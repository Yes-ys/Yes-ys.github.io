


<!DOCTYPE html>
<html lang="ch">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
	<title>深度优先搜索整理 [ 代码和诗 ]</title>
	
	
	<!-- stylesheets list from _config.yml -->
	
	<link rel="stylesheet" href="/css/PreciousJoy.css">
	
	<link rel="stylesheet" href="/css/top-bar.css">
	
	<link rel="stylesheet" href="/css/menu-outer.css">
	
	<link rel="stylesheet" href="/css/content-outer.css">
	
	<link rel="stylesheet" href="/css/bottom-outer.css">
	
	<link rel="stylesheet" href="/css/atom-one-dark.css">
	
	<link rel="stylesheet" href="/css/recent-posts-item.css">
	
	<link rel="stylesheet" href="/css/article-sidebar-toc.css">
	
	<link rel="stylesheet" href="/css/jquery.fancybox.min.css">
	
	<link rel="stylesheet" href="/css/search.css">
	
	<link rel="stylesheet" href="/css/toc.css">
	
	<link rel="stylesheet" href="/css/sidebar.css">
	
	<link rel="stylesheet" href="/css/archive.css">
	
	<link rel="stylesheet" href="/css/jquery.mCustomScrollbar.min.css">
	
	<link rel="stylesheet" href="/css/Z-last-cover-others.css">
	
	
	
<meta name="generator" content="Hexo 7.3.0"></head>




<body id="wrapper">

	<div id="">
		
		<div id="top-bar">
			
			<div id="avatar-box">
				<img 
				class="avatar"
				src="/images/my-avatar.jpg" //网站头像
				alt="avatar">
			</div>

			<div id="top-bar-text">
				<div id="top-bar-title">
					阳生。
				</div>
				<div id="top-bar-slogan">
					风毛丛劲节，只上尽头竿。
				</div>
			</div>

		</div>

		<div id="menu-outer">
			<div id="menu-inner">
				
				
				<div class="menu-item">
					<a href="/">Home</a>
				</div>
				
				<div class="menu-item">
					<a href="/about">About</a>
				</div>
				
				<div class="menu-item">
					<a href="/archives">Archives</a>
				</div>
				

				<div class="menu-item menu-item-search">
					
  <span class="local-search local-search-google local-search-plugin">
      <input type="search" placeholder="站内搜索" id="local-search-input" class="local-search-input-cls" style="">
      <div id="local-search-result" class="local-search-result-cls"></div>
  </span>
	
				</div>

			</div>
		</div>

		<div id="content-outer">
			<div id="content-inner">

				
<div id="details">
	
	<article id="details-post">
		<div id=details-post-item>
			<h1>深度优先搜索整理</h1>
			<p><code>这篇blog用来整理一些常见的可以使用深度优先搜索的问题模板</code></p>
<h2 id="写在最前面"><a href="#写在最前面" class="headerlink" title="写在最前面"></a>写在最前面</h2><p>在这篇blog中会高频地出现三个词汇，<strong>DFS、递归、回溯</strong>，实际上DFS与后二者的关联是十分密切的。</p>
<p>狭义上来说，DFS是在图上面做搜索的一种算法，它使用深度优先，依次处理各个结点。可以用<strong>递归函数的形式</strong>实现，也可以用<strong>循环+栈</strong>的形式实现。</p>
<p>但是从广义上来说，对于可以枚举状态的问题，问题的状态转移的过程本就可以<strong>抽象成一棵树</strong>，而树本质上就是一个特殊的图。当我们使用递归函数，搜索问题的各个状态的时候，就可以看作，我们是在一张“特殊的”图上，做DFS。</p>
<p><em>关于回溯与它们的联系，后面再进行补充</em>。</p>
<h2 id="基本范式"><a href="#基本范式" class="headerlink" title="基本范式"></a>基本范式</h2><p>DFS的模板框架如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function <span class="title function_">dfs</span><span class="params">(now_state)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(now_state == target_state)</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> ...;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(... enumerate new_state)&#123;</span><br><span class="line">        <span class="keyword">if</span>(new_state is valid)&#123;</span><br><span class="line">            vis[new_state] = ...;<span class="comment">//标记新状态被访问</span></span><br><span class="line">            dfs(new_state);</span><br><span class="line">            ? vis[new_state] = ...;<span class="comment">//是否需要恢复现场</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(have considered all condition)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来的部分分几个主要的大类型，每个题目里都会附上对应的练习与解答，结合题目进行总结。</p>
<h2 id="DFS无需回溯"><a href="#DFS无需回溯" class="headerlink" title="DFS无需回溯"></a>DFS无需回溯</h2><p>DFS无需回溯的情况是少</p>
<h3 id="红与黑-AcWing-1113"><a href="#红与黑-AcWing-1113" class="headerlink" title="红与黑 AcWing 1113"></a>红与黑 AcWing 1113</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> h,w;</span><br><span class="line"><span class="type">char</span> mp[<span class="number">21</span>][<span class="number">21</span>];</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> vis[<span class="number">21</span>][<span class="number">21</span>],<span class="type">int</span> posx,<span class="type">int</span> posy)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">4</span>;i++)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="keyword">switch</span>(i)&#123;</span><br><span class="line">   <span class="keyword">case</span> <span class="number">1</span>:&#123;</span><br><span class="line">    <span class="type">int</span> x = posx,y = posy<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(y &gt;= <span class="number">0</span> &amp;&amp; !vis[x][y] &amp;&amp; mp[x][y] == <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">     vis[x][y] = <span class="number">1</span>;</span><br><span class="line">     cnt++;</span><br><span class="line">     <span class="built_in">dfs</span>(vis,x,y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">case</span> <span class="number">2</span>:&#123;</span><br><span class="line">    <span class="type">int</span> x = posx,y = posy<span class="number">+1</span>;</span><br><span class="line">    <span class="keyword">if</span>(y &lt; w &amp;&amp; !vis[x][y] &amp;&amp; mp[x][y] == <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">     vis[x][y] = <span class="number">1</span>;</span><br><span class="line">     cnt++;</span><br><span class="line">     <span class="built_in">dfs</span>(vis,x,y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">case</span> <span class="number">3</span>:&#123;</span><br><span class="line">    <span class="type">int</span> x = posx<span class="number">-1</span>,y = posy;</span><br><span class="line">    <span class="keyword">if</span>(x &gt;= <span class="number">0</span> &amp;&amp; !vis[x][y] &amp;&amp; mp[x][y] == <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">     vis[x][y] = <span class="number">1</span>;</span><br><span class="line">     cnt++;</span><br><span class="line">     <span class="built_in">dfs</span>(vis,x,y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">case</span> <span class="number">4</span>:&#123;</span><br><span class="line">    <span class="type">int</span> x = posx<span class="number">+1</span>,y = posy;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; h &amp;&amp; !vis[x][y] &amp;&amp; mp[x][y] == <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">     vis[x][y] = <span class="number">1</span>;</span><br><span class="line">     cnt++;</span><br><span class="line">     <span class="built_in">dfs</span>(vis,x,y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="type">int</span> vis[<span class="number">21</span>][<span class="number">21</span>];</span><br><span class="line"> <span class="type">int</span> posx = <span class="number">0</span>,posy = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; h;i++)</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; w;j++)</span><br><span class="line">  &#123;</span><br><span class="line">   vis[i][j] = <span class="number">0</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//寻找起点</span></span><br><span class="line">   <span class="comment">//cout&lt;&lt;&quot;mp[i][j]:&quot;&lt;&lt;mp[i][j]&lt;&lt;endl;</span></span><br><span class="line">   <span class="keyword">if</span>(mp[i][j] == <span class="string">&#x27;@&#x27;</span>)posx = i,posy = j; </span><br><span class="line">  &#125;</span><br><span class="line"> vis[posx][posy] = <span class="number">1</span>;</span><br><span class="line"> cnt = <span class="number">1</span>;</span><br><span class="line"> <span class="built_in">dfs</span>(vis,posx,posy);</span><br><span class="line"> cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> string str;</span><br><span class="line"> <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">  cin&gt;&gt;w&gt;&gt;h;</span><br><span class="line">  <span class="keyword">if</span>(w == <span class="number">0</span> &amp;&amp; h == <span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; h;i++)</span><br><span class="line">   &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; w;j++)</span><br><span class="line">     cin&gt;&gt;mp[i][j];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//输入完成 </span></span><br><span class="line">   <span class="built_in">solve</span>();</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意点：</p>
<ol>
<li>关于不需要回溯，<strong>我的一个理解</strong>：由于在每次搜索到的状态，更改的全局变量只有vis数组，而这个更改正是必须的（我们需要一个DFS分支更改的vis影响另一个DFS分支，来确定当前点是否已经到达过了），所以不需要进行回溯。<em>需要回溯的一种情况是，一个分支修改的全局变量对另一个分支没有作用，另一个分支不能直接使用，要自己修改，那么在一个分支结束的时候就应该还原自己修改的全局变量</em></li>
<li>关于不需要回溯，<strong>另一种理解</strong>：在一个分支下到达的每一个点，在这个分支结束过后就可以抛弃了，因为我们只是统计点的数量不需要再回到这个点；但是需要回溯的情况，例如走迷宫，你在尝试一种路径的时候走过一系列点，这些点不能被抛弃，你在尝试其它路径的时候可能还会来到这些点，所以在每一条路径结束的时候，要将标记访问的vis数组进行还原（具体如何还原见后面的笔记）。</li>
<li>注意io上的细节实现，由于有多轮数据，所以每轮开始要注意相关变量的初始化</li>
</ol>
<h2 id="DFS与回溯"><a href="#DFS与回溯" class="headerlink" title="DFS与回溯"></a>DFS与回溯</h2><h3 id="ACW分成互质组"><a href="#ACW分成互质组" class="headerlink" title="ACW分成互质组"></a>ACW分成互质组</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; g[<span class="number">11</span>];</span><br><span class="line"><span class="type">int</span> num[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(x%y == <span class="number">0</span>)<span class="keyword">return</span> y;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">return</span> gcd(y,x%y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line"> <span class="comment">//检查是否可以把数字i放在第j组</span></span><br><span class="line"> <span class="keyword">if</span>(g[j].empty())<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> <span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>;k &lt; g[j].size();k++)&#123;</span><br><span class="line">   <span class="keyword">if</span>(gcd(num[i],g[j][k]) != <span class="number">1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> num_g,<span class="type">int</span> now)</span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(now == n)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="type">int</span> i = now;</span><br><span class="line"> <span class="comment">//i对应当前正在处理数字的索引 </span></span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; num_g;j++)<span class="comment">//把它尝试放入各组中</span></span><br><span class="line"> &#123;</span><br><span class="line">  <span class="keyword">if</span>(check(i,j))&#123;<span class="comment">//如果可以放入第j组 </span></span><br><span class="line">   g[j].push_back(num[now]);</span><br><span class="line">   <span class="keyword">if</span>(dfs(num_g, now+<span class="number">1</span>))<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   <span class="keyword">else</span> g[j].pop_back();<span class="comment">//尝试放入失败 </span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">  <span class="built_in">cin</span>&gt;&gt;num[i];</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> num_g = <span class="number">1</span>;num_g &lt;= n;num_g++)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="keyword">if</span>(dfs(num_g,<span class="number">0</span>))&#123;</span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;num_g&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125; </span><br><span class="line">  </span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现的思路是从小到大枚举可能的组数，用DFS暴力搜索，把每个数字依次放入每个组的情况。</p>
<p>本题总结：</p>
<ol>
<li>DFS的主线是依次处理每个数字，每处理一个数字就进入到下一个状态，当n个数字处理完毕就可以结束了，当前使用的组数就是最小的组数</li>
<li>一个反思，在写DFS的时候要想清楚，每层深入的时候，对应的实际意义是什么。这里就是处理过的数字的数量增加。我开始的时候没有想清楚在dfs的for循环外面还套了一层遍历所有数字的循环，不明所以…</li>
<li>这里就要注意<strong>恢复现场</strong>，即g[j].pop_back()，也是回溯的体现，当一条分支尝试失败了要还原状态。否则当前分支存入第j组的数字，在其它分支总也会存在，显然就会有问题…</li>
</ol>
<h3 id="子集模板-子集-leetcode78"><a href="#子集模板-子集-leetcode78" class="headerlink" title="子集模板 子集 leetcode78"></a>子集模板 子集 leetcode78</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; &gt;ans;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; cmb, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == len)&#123;</span><br><span class="line">            ans.push_back(cmb);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cmb.push_back(nums[i]);</span><br><span class="line">        dfs(cmb,i+<span class="number">1</span>);</span><br><span class="line">        cmb.pop_back();</span><br><span class="line"></span><br><span class="line">        dfs(cmb,i+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; subsets(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        len = nums.size();</span><br><span class="line">        this-&gt;nums = nums;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; t;</span><br><span class="line">        dfs(t,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这道题可以完美地体现写在blog开头的那段话，问题的状态就是一棵二叉树，递归就是在其上做深搜。同样，回溯体现在还原现场。</p>
<p>上面代码的此题思路是，从<strong>每个数字</strong>的角度出发，依次考虑选与不选，当所有的数字都被考虑过一遍，我们就可以得到一种答案的组合。</p>
<p><strong>另一种思路</strong>是从<strong>答案的角度</strong>出发，依次考虑选择哪些数字，每做出一次选择本身就得到了一种答案。</p>
<p>而对于这种思路，当我们考虑过下标为i的数字选择后会从当前层向下递归产生分支；而在当前层，我们还会考虑下标大于i的数字，例如i+1对应的数字，选择它后又从当前层向下递归产生分支（记作分支1）；要避免后一条分支（记作分支2）与分支1重复。</p>
<p>即对于(1,2)的原始数组，第一层选择1后，产生分支1向下递归选择2，形成(1,2)；我们要避免第一层选择2后产生分支2向下递归形成(2,1)（这是重复的）</p>
<p><strong>规避重复</strong>的一种思路是，每层向下递归的时候 只能选择 下标 大于当前层已选数字下标 的数字 从而形成下面图片的效果：</p>
<p><img src="/../_images/Algorithm1/DFS1.png" alt="MyAlgorithm"></p>
<p><a href="!https://www.bilibili.com/video/BV1mG4y1A7Gu?spm_id_from=333.788.videopod.sections&vd_source=80df09f481ef5f0671e5e0e35d02e33e">参考视频教程</a></p>
<p>我们也可以将这两种思路概括为：</p>
<ol>
<li>选或者不选的思路</li>
<li>选哪个的思路<br>（这是常用的dfs思路，后续的组合、排列都会用到）</li>
</ol>
<h3 id="子集模板应用-分割回文串-leetcode-131"><a href="#子集模板应用-分割回文串-leetcode-131" class="headerlink" title="子集模板应用 分割回文串 leetcode 131"></a>子集模板应用 分割回文串 leetcode 131</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="title function_">check</span><span class="params">(<span class="built_in">string</span> s)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>,j = s.length()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(;i &lt; s.length() &amp;&amp; j &gt;= <span class="number">0</span>;i++,j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] != s[j])<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; ans;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; cmb, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == len<span class="number">-1</span>)&#123;<span class="comment">//当执行到应该判断最后一个位置是否要切割的时候</span></span><br><span class="line">            <span class="built_in">string</span> s = str.substr(j+<span class="number">1</span>,i-j);</span><br><span class="line">            <span class="keyword">if</span>(check(s))&#123;</span><br><span class="line">                cmb.push_back(s);</span><br><span class="line">                ans.push_back(cmb);</span><br><span class="line">                cmb.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> s = str.substr(j+<span class="number">1</span>,i-j);</span><br><span class="line">        <span class="keyword">if</span>(check(s))&#123;</span><br><span class="line">            cmb.push_back(s);</span><br><span class="line">            dfs(cmb, i+<span class="number">1</span>,i);</span><br><span class="line">            <span class="comment">//回溯</span></span><br><span class="line">            cmb.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dfs(cmb,i+<span class="number">1</span>,j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//切割是把当前位置的字符串和上一次切割位置后的字符串切出来</span></span><br><span class="line"><span class="comment">//i是当前考虑是否要切割的位置</span></span><br><span class="line"><span class="comment">//j是上一次进行切割的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; partition(<span class="built_in">string</span> s) &#123;</span><br><span class="line">        this-&gt;len = s.length();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; t;</span><br><span class="line">        this-&gt;str = s;</span><br><span class="line">        dfs(t, <span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这道题的思路是考虑所有可以切割子串的位置的状态，每个位置有两种状态，切或者不切；问题的状态就变成了一棵二叉树，DFS在树上做搜索，但是将一个位置设置为“切”的状态，需要判断得到的新子串是否是回文串，如果是才能切；最后一个位置必须切。</p>
<h3 id="组合模板-组合-leetcode-78"><a href="#组合模板-组合-leetcode-78" class="headerlink" title="组合模板 组合 leetcode 78"></a>组合模板 组合 leetcode 78</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="type">int</span> k,n;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> cnt,<span class="type">int</span> i,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; cmb)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt == k)&#123;</span><br><span class="line">            ans.push_back(cmb);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i+<span class="number">1</span>;j &lt;= n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cmb.push_back(j);</span><br><span class="line">            dfs(cnt+<span class="number">1</span>,j,cmb);</span><br><span class="line">            cmb.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; combine(<span class="type">int</span> n, <span class="type">int</span> k) &#123;</span><br><span class="line">        this-&gt;k = k;</span><br><span class="line">        this-&gt;n = n;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; t;</span><br><span class="line">        dfs(<span class="number">0</span>,<span class="number">0</span>,t);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面代码的实现思路是，在子集模板的第二种思路（站在答案的视角，考虑每个数字的选择）下加入一个已选择数字数量的判定，当选择的数字数量达到k个的时候就将答案记录下来，并停止向下递归。</p>
<h4 id="关于组合问题的剪枝"><a href="#关于组合问题的剪枝" class="headerlink" title="关于组合问题的剪枝"></a>关于组合问题的剪枝</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span>(n-i+cnt &lt; k)<span class="keyword">return</span>;<span class="comment">//剩下可选的数字+已经选择的数字 &lt; 需要选择的数字，可以直接return，因为最后必定没有结果（剪枝）</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在dfs的for循环之前加入这个判断，如果满足条件，最后一定无法选出指定数量的数字，也就没有继续递归的必要了，可以提前结束当前分支。</p>
<h3 id="组合模板应用-组合总和Ⅲ-leetcode-216"><a href="#组合模板应用-组合总和Ⅲ-leetcode-216" class="headerlink" title="组合模板应用 组合总和Ⅲ leetcode 216"></a>组合模板应用 组合总和Ⅲ leetcode 216</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> k,n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> cnt,<span class="type">int</span> i,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; cmb)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt == k &amp;&amp; accumulate(cmb.begin(),cmb.end(),<span class="number">0</span>) == n)&#123;</span><br><span class="line">            ans.push_back(cmb);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">9</span>-i+cnt &lt; k)<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i+<span class="number">1</span>;j &lt;= <span class="number">9</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cmb.push_back(j);</span><br><span class="line">            dfs(cnt+<span class="number">1</span>,j,cmb);</span><br><span class="line">            cmb.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; combinationSum3(<span class="type">int</span> k, <span class="type">int</span> n) &#123;</span><br><span class="line">        this-&gt;k = k;</span><br><span class="line">        this-&gt;n = n;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; t;</span><br><span class="line">        dfs(<span class="number">0</span>,<span class="number">0</span>,t);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="关于剪枝"><a href="#关于剪枝" class="headerlink" title="关于剪枝"></a>关于剪枝</h4><p>这道题除了和组合模板一样的剪枝，还有根据n进行的剪枝。主要是两种情况</p>
<ol>
<li>当前已经选择的数字数量不足k，但是其和已经大于n，最后递归下去其和必定大于n，剪枝</li>
<li>剩下的所有数字加上当前选择的所有数字 之和 小于n，最后递归下去其和必定小于n，剪枝</li>
</ol>
<p>为了方便剪枝的实现，可以选择维护一个当前已选数字之和的变量now_sum，具体实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> k,n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> cnt,<span class="type">int</span> i,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; cmb,<span class="type">int</span> now_sum)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt == k &amp;&amp; now_sum == n)&#123;</span><br><span class="line">            ans.push_back(cmb);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">9</span>-i+cnt &lt; k)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(now_sum &gt; n)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(now_sum+(i+<span class="number">10</span>)*(<span class="number">9</span>-i)/<span class="number">2</span> &lt; n)<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i+<span class="number">1</span>;j &lt;= <span class="number">9</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cmb.push_back(j);</span><br><span class="line">            dfs(cnt+<span class="number">1</span>,j,cmb,now_sum+j);</span><br><span class="line">            cmb.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; combinationSum3(<span class="type">int</span> k, <span class="type">int</span> n) &#123;</span><br><span class="line">        this-&gt;k = k;</span><br><span class="line">        this-&gt;n = n;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; t;</span><br><span class="line">        dfs(<span class="number">0</span>,<span class="number">0</span>,t,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>一个总结：组合模板上的剪枝是围绕要选择k个数字进行的，这一题又有了新的要求即k个数字的和要为n。这些要求都可以看作问题的约束，也就是说我们这两道题的剪枝都是围绕问题的约束展开的。所以以后在思考递归的剪枝的时候，可以考虑<strong>问题状态树上，从当前递归层的状态出发，判断之后的状态是否可以满足最终问题的各个约束，如果不能满足，那么就停止向下递归。</strong></p>
<p>而我们之所以能做出这样判断的原因，是因为问题状态具有的一些性质在转移的过程中如何发展是可以推知的。<em>就像这道题，一共9个数，你每次只选比上一次选择的数字更大的数字，当你选择了i，接下来你可以选择的数字个数一定是9-i</em>，这就是可以推知的状态。</p>
<h3 id="组合模板应用-括号生成-leetcode-22"><a href="#组合模板应用-括号生成-leetcode-22" class="headerlink" title="组合模板应用 括号生成 leetcode 22"></a>组合模板应用 括号生成 leetcode 22</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> nl,<span class="type">int</span> nr,<span class="built_in">string</span>&amp; str)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nl + nr == (n&lt;&lt;<span class="number">1</span>))&#123;</span><br><span class="line">            ans.push_back(str);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nl &lt; nr)<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nl &lt; n)&#123;</span><br><span class="line">            str += <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">            dfs(nl+<span class="number">1</span>,nr,str);</span><br><span class="line">            str.erase(str.end()<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nr &lt; n)&#123;</span><br><span class="line">            str += <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">            dfs(nl,nr+<span class="number">1</span>,str);</span><br><span class="line">            str.erase(str.end()<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title function_">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        this-&gt;n = n;</span><br><span class="line">        <span class="built_in">string</span> str;</span><br><span class="line">        dfs(<span class="number">0</span>,<span class="number">0</span>,str);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我解决这道题的思考过程：</p>
<ol>
<li>基本方法是套用子集模板，我们一共有n个左括号、n个右括号可以用，需要选择2n个括号，根据选择的顺序形成str，直接dfs到底，然后判断括号是否有效</li>
<li>考虑剪枝，约束是括号有效，考虑是否存在一些选择情况对应的状态已经无效，并且之后的状态也一定无效。存在这样的选择情况，那就是右括号比左括号先选择。只要有这种情况出现就可以剪枝</li>
</ol>
<p>关于实现</p>
<ol>
<li>剪枝的实现是可以维护nl、nr来记录已经选择的左右括号的数量，一旦nl小于nr就剪枝。</li>
<li>并且我注意到，递归的结束条件可以用nl+nr &#x3D;&#x3D; 2*n来实现；且只要nl始终大于等于nr，左括号一定可以被右括号抵消，最终的情况一定有效，也就不需要递归结束时的有效判断了</li>
<li>结合1、2两点，套用dfs的模板就可以解决问题</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> nl,<span class="type">int</span> nr,<span class="built_in">string</span>&amp; str)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nl + nr == (n&lt;&lt;<span class="number">1</span>))&#123;</span><br><span class="line">            ans.push_back(str);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nl &lt; nr)<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nl &lt; n)&#123;</span><br><span class="line">            str += <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">            dfs(nl+<span class="number">1</span>,nr,str);</span><br><span class="line">            str.erase(str.end()<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nr &lt; n)&#123;</span><br><span class="line">            str += <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">            dfs(nl,nr+<span class="number">1</span>,str);</span><br><span class="line">            str.erase(str.end()<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title function_">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        this-&gt;n = n;</span><br><span class="line">        <span class="built_in">string</span> str;</span><br><span class="line">        dfs(<span class="number">0</span>,<span class="number">0</span>,str);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="全排列模板-全排列-leetcode-46"><a href="#全排列模板-全排列-leetcode-46" class="headerlink" title="全排列模板 全排列 leetcode 46"></a>全排列模板 全排列 leetcode 46</h3><p>模板的思路基础是<strong>子集模板的第二种思路</strong>，在子集模板中，我们为了避免重复的选择，规定在选择第i个数字之后 产生的递归分支上，只能选择第i+1及以后的数字；而全排列不需要避免这种重复的选择，或者说<strong>这种重复的选择对全排列而言正是必要的</strong>，因为对于排列而言，选择的顺序不同 但 含有的元素相同 的子集是不同的。</p>
<p>于是问题的关键在于，每个分支如何知道自己当前可以选择哪些数字。</p>
<p>我的思路是用一个vis数组来记录当前分支的<strong>父状态</strong>选择过的数字，这些数字是不能选的。而其它分支选择过的数字，自己的父状态没有选择过的数字，这些分支是可以选择的。</p>
<p>按照这个思路实现的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; vis;</span><br><span class="line">    </span><br><span class="line">    <span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; cmb)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == len)&#123;</span><br><span class="line">            ans.push_back(cmb);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                cmb.push_back(nums[i]); vis[i] = <span class="number">1</span>;</span><br><span class="line">                dfs(n+<span class="number">1</span>,cmb);</span><br><span class="line">                cmb.pop_back(); vis[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; permute(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        this-&gt;len = nums.size();</span><br><span class="line">        this-&gt;nums = nums;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; len;i++)</span><br><span class="line">            vis.push_back(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; cmb;</span><br><span class="line">        dfs(<span class="number">0</span>,cmb);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>参考教程的思路是<strong>维护一个可选数字</strong>的集合，这个集合可以起到取代我上面的vis数组的作用。并且这样显然好一些，因为使用vis数组，状态树上的每一个结点都会检查初始nums中的所有数组，虽然当不满足条件的时候，不会向下产生分支，但是在当前层的循环中枚举了很多不必要的情况。</p>
<p>我按照这个思路写的代码如下，但是使用到了vector的插入和删除操作，频繁的这样操作，或许增加的时间复杂度不会比我开始使用的vis好到哪里去？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; cmb,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty())&#123;</span><br><span class="line">            ans.push_back(cmb);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> t = nums[i];</span><br><span class="line">            cmb.push_back(t); nums.erase(nums.begin()+i);</span><br><span class="line">            dfs(cmb,nums);</span><br><span class="line">            cmb.pop_back(); nums.insert(nums.begin()+i,t);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; permute(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; cmb;</span><br><span class="line">        dfs(cmb,nums);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>实际上两种思路都是常见的做法，我的第一种思路在参考的教程中后面也提到了。</p>
<p><a href="!https://www.bilibili.com/video/BV1mY411D7f6?spm_id_from=333.788.videopod.sections&vd_source=80df09f481ef5f0671e5e0e35d02e33e">参考教程</a></p>
<h3 id="DFS与回溯综合练习-n皇后"><a href="#DFS与回溯综合练习-n皇后" class="headerlink" title="DFS与回溯综合练习 n皇后"></a>DFS与回溯综合练习 n皇后</h3><p>我的基本思路是用dfs枚举每个位置放置皇后的情况，每个位置可以放、可以不放；当一个位置放置后，该位置对应的行、列、两个对角线 不能再放置；维护一个vis二维数组来判断各个位置是否可以放置皇后。</p>
<p>实现代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; vis;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; ans;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> num,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; cmb,<span class="type">int</span> posx,<span class="type">int</span> posy,<span class="type">int</span> cnt)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num == n)&#123;</span><br><span class="line">            ans.push_back(cmb);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(cnt &lt; n-num)<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = posx;i &lt; n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = posy;j &lt; n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(vis[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">                    cmb[i][j] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//ban</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>;k &lt; n;k++)</span><br><span class="line">                        vis[i][k]++,vis[k][j]++;</span><br><span class="line">                    vis[i][j]--;<span class="comment">//重复ban了一次</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> ki = i+<span class="number">1</span>,kj = j+<span class="number">1</span>;ki &lt; n&amp;&amp;kj &lt; n;ki++,kj++)</span><br><span class="line">                        vis[ki][kj]++;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> ki = i<span class="number">-1</span>,kj = j<span class="number">-1</span>;ki &gt;= <span class="number">0</span>&amp;&amp;kj &gt;= <span class="number">0</span>;ki--,kj--)</span><br><span class="line">                        vis[ki][kj]++;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> ki = i+<span class="number">1</span>,kj = j<span class="number">-1</span>;ki &lt; n&amp;&amp;kj &gt;= <span class="number">0</span>;ki++,kj--)</span><br><span class="line">                        vis[ki][kj]++;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> ki = i<span class="number">-1</span>,kj = j+<span class="number">1</span>;ki &gt;= <span class="number">0</span>&amp;&amp;kj &lt; n;ki--,kj++)</span><br><span class="line">                        vis[ki][kj]++;</span><br><span class="line">                    </span><br><span class="line">                    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> ki = <span class="number">0</span>;ki &lt; n;ki++)</span><br><span class="line">                        <span class="keyword">for</span>(<span class="type">int</span> kj = <span class="number">0</span>;kj &lt; n;kj++)</span><br><span class="line">                            <span class="keyword">if</span>(vis[ki][kj] == <span class="number">0</span>)sum++;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>(posy &lt; n)</span><br><span class="line">                        dfs(num+<span class="number">1</span>,cmb,posx,posy+<span class="number">1</span>,sum);</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(posy == n<span class="number">-1</span>)</span><br><span class="line">                        dfs(num+<span class="number">1</span>,cmb,posx+<span class="number">1</span>,<span class="number">0</span>,sum);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//recover，这样写可能会错误的恢复已经被其它皇后ban掉的位置，将修改为1改做++</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>;k &lt; n;k++)</span><br><span class="line">                        vis[i][k]--,vis[k][j]--;</span><br><span class="line">                    vis[i][j]++;<span class="comment">//重复recover了一次</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> ki = i+<span class="number">1</span>,kj = j+<span class="number">1</span>;ki &lt; n&amp;&amp;kj &lt; n;ki++,kj++)</span><br><span class="line">                        vis[ki][kj]--;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> ki = i<span class="number">-1</span>,kj = j<span class="number">-1</span>;ki &gt;= <span class="number">0</span>&amp;&amp;kj &gt;= <span class="number">0</span>;ki--,kj--)</span><br><span class="line">                        vis[ki][kj]--;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> ki = i+<span class="number">1</span>,kj = j<span class="number">-1</span>;ki &lt; n&amp;&amp;kj &gt;= <span class="number">0</span>;ki++,kj--)</span><br><span class="line">                        vis[ki][kj]--;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> ki = i<span class="number">-1</span>,kj = j+<span class="number">1</span>;ki &gt;= <span class="number">0</span>&amp;&amp;kj &lt; n;ki--,kj++)</span><br><span class="line">                        vis[ki][kj]--;</span><br><span class="line">                    cmb[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">                </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; solveNQueens(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; t;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; n;j++)</span><br><span class="line">                t.push_back(<span class="number">0</span>);</span><br><span class="line">            vis.push_back(t);</span><br><span class="line">        &#125;   </span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; cmb;</span><br><span class="line">        <span class="built_in">string</span> str;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">            str+=<span class="string">&quot;.&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">            cmb.push_back(str);</span><br><span class="line">        this-&gt;n = n;</span><br><span class="line">        dfs(<span class="number">0</span>,cmb,<span class="number">0</span>,<span class="number">0</span>,n*n);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>记录几个出现的问题：</p>
<ol>
<li>开始的时候我标记位置是否能放，能放是将vis[i][j]置为1，能放是将这个元素置为0。这样做的问题在于：一个皇后恢复现场的时候，可能把其它皇后置为不能放置的位置给恢复成能放了； <strong>解决的方法</strong>是，可以放置设置为0，每放一个皇后对应不能放置的位置+1，恢复的时候-1即可，这样每个皇后对现场的操作都被保存了下来作为是否能放的参照</li>
<li>开始的时候我写dfs中的for循环，每一层都是从i&#x3D;0，j&#x3D;0开始枚举的，这样的话每一层都会重复考虑之前已经考虑过的位置，这是错误的。<strong>解决的方法</strong>是记录好当前位置的下标，进入下一层递归的时候设置下一次开始遍历的初始位置是当前位置的下一个位置</li>
<li>解决1、2两个问题之后，代码的正确性已经得到保证了，但是现在的问题是时间复杂度太高了…，当n&#x3D;&#x3D;9的时候会TLE</li>
</ol>
<h3 id="全排列模板-n皇后"><a href="#全排列模板-n皇后" class="headerlink" title="全排列模板 n皇后"></a>全排列模板 n皇后</h3><p>对于上述dfs枚举每个格子的<strong>改进的方法</strong>，涉及n皇后的一个性质，那就是<strong>每一行、每一列一定有一个皇后</strong>。</p>
<p>这个性质不难证明，假设有一行没有皇后，那么剩下n-1行要放n个皇后，肯定有一行有两个皇后，与条件矛盾；列是同理的</p>
<p>于是我们可以考虑使用一个数组col[i]来表示第i行在哪一列放置了Q，即在第col[i]列放置了Q，<strong>理解这个数组很关键！</strong></p>
<p>于是，我们最终放置好的棋盘就可以单纯用col数组来表示。并且满足条件的情况下，其中一定有4个元素。</p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">col[<span class="number">4</span>] = &#123;<span class="number">1</span>，<span class="number">3</span>，<span class="number">0</span>，<span class="number">2</span>&#125;<span class="comment">//n==4的一种放置方案</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们现在可以把问题变成：我们要在数字0<del>n-1中，选出一种k&#x3D;n个数字的排列。由于一共就0</del>n-1个数字，所以得到排列还原回棋盘上的情况，意味着<strong>列一定不会冲突</strong>；而我们按照行来进行枚举，那么<strong>行也一定不会冲突</strong>；再者，在dfs的时候我们是从行0，枚举到行n-1，那么<strong>左下、右下的对角线一定不会冲突</strong></p>
<p>于是问题就变成了全排列模板上的变式，改变了的点是：</p>
<ol>
<li>在完成排列，退出递归的时候，我们要把得到的col数组还原回字符串向量（题意中用于表示棋盘），这是一个简单的模拟问题</li>
<li>在挑选加入排列的数字的时候，我们要进行check，考虑当前选择的数字，对应放置到棋盘上的Q，其左上、右上是否已经有Q了，如果有了就不能放置，也就是不能选择这个数字；否则可以选择</li>
</ol>
<p>具体的代码实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; ans;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//x是当前处理的行号，y是当前选择的数字，即x行希望放置Q的列号</span></span><br><span class="line">    <span class="type">bool</span> <span class="title function_">check</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp;col, <span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">        <span class="comment">//只需要检查左上和右上有没有皇后，因为按行递归，下面的行必定还没放置Q</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = x<span class="number">-1</span>,j1 = y<span class="number">-1</span>,j2 = y+<span class="number">1</span>;i &gt;= <span class="number">0</span>;i--,j1--,j2++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(col[i] == j1 || col[i] == j2)<span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; col, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(col.size() == n)&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; cmb;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">                <span class="built_in">string</span> str;</span><br><span class="line">                str.clear();</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; n;j++)</span><br><span class="line">                    <span class="keyword">if</span>(j == col[i])str+=<span class="string">&quot;Q&quot;</span>;</span><br><span class="line">                    <span class="keyword">else</span> str+=<span class="string">&quot;.&quot;</span>;</span><br><span class="line">                cmb.push_back(str);</span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(cmb);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; nums.size();j++)<span class="comment">//全排列的模板，nums中存有待选数字</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(check(col, col.size(), nums[j]))&#123;</span><br><span class="line">                <span class="type">int</span> t = nums[j];</span><br><span class="line">                col.push_back(nums[j]); nums.erase(nums.begin()+j);</span><br><span class="line">                dfs(col, nums);</span><br><span class="line">                col.pop_back(); nums.insert(nums.begin()+j,t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; solveNQueens(<span class="type">int</span> n) &#123;</span><br><span class="line">        this-&gt;n = n;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)nums.push_back(i);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; col;</span><br><span class="line">        dfs(col,nums);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>实际上check函数可以再利用棋盘上的一个性质，那就是从(i,j)出发，对于任意右上的位置(k,l)，i+j &#x3D;&#x3D; k+l恒成立；对于任意左上的位置(k,l)，i-j &#x3D;&#x3D; k-l恒成立。</p>
<p>于是可以这样写</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">check</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; col, <span class="type">int</span> x,<span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = x<span class="number">-1</span>;i &gt;= <span class="number">0</span>;i--)</span><br><span class="line">        <span class="keyword">if</span>(x+y == i+col[i] || x-y == i-col[i])<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>进一步优化对角线是否合法的检查，如果可以用i+j以及i-j来判断，那么我们不如直接使用两个bool数组，分别对应左上、右上；对于左上要使用i-j+n-1（避免索引出现负数），右上的索引可以直接使用i+j</p>
<p>这样check的O(n)就变成了O(1)，这是一种常见的哈希表优化的思想。</p>
<p>优化后的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; ans;</span><br><span class="line">    <span class="type">bool</span> diag1[<span class="number">20</span>];</span><br><span class="line">    <span class="type">bool</span> diag2[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// //x是当前处理的行号，y是当前选择的数字，即x行希望放置Q的列号</span></span><br><span class="line">    <span class="comment">// bool check(vector&lt;int&gt;&amp;col, int x,int y)&#123;</span></span><br><span class="line">    <span class="comment">//     //只需要检查左上和右上有没有皇后，因为按行递归，下面的行必定还没放置Q</span></span><br><span class="line">    <span class="comment">//     for(int i = x-1,j1 = y-1,j2 = y+1;i &gt;= 0;i--,j1--,j2++)&#123;</span></span><br><span class="line">    <span class="comment">//        if(col[i] == j1 || col[i] == j2)return false; </span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     return true;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; col, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(col.size() == n)&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; cmb;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">                <span class="built_in">string</span> str;</span><br><span class="line">                str.clear();</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; n;j++)</span><br><span class="line">                    <span class="keyword">if</span>(j == col[i])str+=<span class="string">&quot;Q&quot;</span>;</span><br><span class="line">                    <span class="keyword">else</span> str+=<span class="string">&quot;.&quot;</span>;</span><br><span class="line">                cmb.push_back(str);</span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(cmb);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; nums.size();j++)<span class="comment">//全排列的模板，nums中存有待选数字</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(diag1[nums[j]+col.size()] &amp;&amp; diag2[nums[j]-col.size()+n<span class="number">-1</span>])&#123;</span><br><span class="line">                <span class="type">int</span> t = nums[j];</span><br><span class="line">                diag1[nums[j]+col.size()] = <span class="literal">false</span>;diag2[nums[j]-col.size()+n<span class="number">-1</span>] = <span class="literal">false</span>;</span><br><span class="line">                col.push_back(nums[j]); nums.erase(nums.begin()+j);</span><br><span class="line">                dfs(col, nums);</span><br><span class="line">                col.pop_back(); nums.insert(nums.begin()+j,t);</span><br><span class="line">                diag1[nums[j]+col.size()] = <span class="literal">true</span>;diag2[nums[j]-col.size()+n<span class="number">-1</span>] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; solveNQueens(<span class="type">int</span> n) &#123;</span><br><span class="line">        this-&gt;n = n;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)nums.push_back(i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">20</span>;i++)diag1[i] = <span class="literal">true</span>,diag2[i] = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; col;</span><br><span class="line">        dfs(col,nums);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="DFS与记忆化"><a href="#DFS与记忆化" class="headerlink" title="DFS与记忆化"></a>DFS与记忆化</h2><h3 id="打家劫舍-leetcode-198"><a href="#打家劫舍-leetcode-198" class="headerlink" title="打家劫舍 leetcode 198"></a>打家劫舍 leetcode 198</h3><h4 id="打家劫舍-基础递归"><a href="#打家劫舍-基础递归" class="headerlink" title="打家劫舍 基础递归"></a>打家劫舍 基础递归</h4><p>这道题可以使用选或不选的递归思路，从后向前考虑。如果第i个房间选择了，那么第i-1个就不能选，紧接着从第i-2个继续考虑；如果第i个房间不选，紧接着从第i-1个继续考虑；于是很自然的就可以画出问题的状态树是怎样的，在此之上进行递归。</p>
<p>而我们的目标是最终的结果最大，所以考虑的时候应该是dfs(i) &#x3D; max(dfs(i-1),dfs(i-2)+nums[i])</p>
<p>在上面的思路上有了第一版代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> num)</span>&#123;<span class="comment">//从后向前考虑，i表示当前考虑的房间</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span>) <span class="keyword">return</span> num;</span><br><span class="line">        <span class="keyword">return</span> max(dfs(i<span class="number">-1</span>,num),dfs(i<span class="number">-2</span>,num+nums[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums)</span> &#123;</span><br><span class="line">        this-&gt;nums = nums;</span><br><span class="line">        <span class="keyword">return</span> dfs(nums.size()<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="打家劫舍-递归-记忆化-记忆化搜索"><a href="#打家劫舍-递归-记忆化-记忆化搜索" class="headerlink" title="打家劫舍 递归+记忆化&#x3D;记忆化搜索"></a>打家劫舍 递归+记忆化&#x3D;记忆化搜索</h4><p>遗憾的是，每层递归几乎都会展开两层，时间复杂度为$O(2^n)$，会TLE</p>
<p>我们可以注意到，在问题的状态树中，存在这样的结构：</p>
<p><img src="/../_images/Algorithm1/DFS2.png" alt="状态树"></p>
<p><a href="!https://www.bilibili.com/video/BV1Xj411K7oF?spm_id_from=333.788.videopod.sections&vd_source=80df09f481ef5f0671e5e0e35d02e33e">参考资料</a></p>
<p>这意味着我们进行了重复计算（<strong>通过观察状态树的分支情况，是我们判断是否可以进行记忆化处理的一种标注</strong>）</p>
<p>优化后的状态树是这样的，每层递归的小分支可以忽略不记，时间复杂度直接变成了O(n)<br><img src="/../_images/Algorithm1/DFS3.png" alt="优化后的状态树"></p>
<p>具体的优化方法是，我们可以使用一个数组或者一个哈希表，来保存在某分支上第一次计算dfs(i)的结果，然后在其它分支要计算dfs(i)的时候，先检查是否已经计算过了，如果计算过了可以直接调用。</p>
<p>我写的初版记忆化代码是这样的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cnt[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> num)</span>&#123;<span class="comment">//从后向前考虑，i表示当前考虑的房间</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span>) <span class="keyword">return</span> num;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(cnt[i] != <span class="number">-1</span>)<span class="keyword">return</span> cnt[i];</span><br><span class="line">        <span class="type">int</span> res = max(dfs(i<span class="number">-1</span>,num),dfs(i<span class="number">-2</span>,num+nums[i]));</span><br><span class="line">        cnt[i] = res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums)</span> &#123;</span><br><span class="line">        this-&gt;nums = nums;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">100</span>;i++)cnt[i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> dfs(nums.size()<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但是得出的结果是错误的。一个重要的原因是<strong>记忆化的依据是问题的状态</strong>，我们要把一个状态的结果保存下来，就像我们开始说的，要把dfs(i)的计算结果保存下来，这里的i就可以看作一个<strong>状态变量</strong>，来对一层递归进行唯一的标定。</p>
<p>而我代码中将累加变量num，当作参数来处理，num也变成了一个状态变量，而且它的值通常是难以估计的（随着测试输入的值有着巨大的变化），如果硬要考虑num也是一个状态，可以使用二维数组来存储记忆的结果，但是这会让空间开销变得很大（甚至超范围）。</p>
<p><strong>累加变量本身是可以作返回值处理的</strong>，不用当作参数跟着传递，修改的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cnt[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i)</span>&#123;<span class="comment">//从后向前考虑，i表示当前考虑的房间</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(cnt[i] != <span class="number">-1</span>)<span class="keyword">return</span> cnt[i];</span><br><span class="line">        <span class="type">int</span> res = max(dfs(i<span class="number">-1</span>),dfs(i<span class="number">-2</span>)+nums[i]);</span><br><span class="line">        cnt[i] = res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums)</span> &#123;</span><br><span class="line">        this-&gt;nums = nums;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">100</span>;i++)cnt[i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> dfs(nums.size()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>简单总结一下，一般情况下我习惯将dfs的累加变量当作参数处理，尤其是在退出的时候，使用最后累积的参数来更新我的答案；但是如果要实现记忆化，通常这种累积的参数应该通过返回值来进行处理，即存在明显的递归中“归”这一操作；而当累加变量当作参数处理的时候，实际上我的dfs返回通常是void，没有下层向上层的反馈，只有递归到边界的时候对全局变量的操作，所以没有“归”这一操作</p>
<h4 id="打家劫舍-自顶向下的记忆化搜索-自下向上-DP"><a href="#打家劫舍-自顶向下的记忆化搜索-自下向上-DP" class="headerlink" title="打家劫舍 自顶向下的记忆化搜索-&gt;自下向上 &#x3D; DP"></a>打家劫舍 自顶向下的记忆化搜索-&gt;自下向上 &#x3D; DP</h4><p>我们可以进一步观察状态树</p>
<p><img src="/../_images/Algorithm1/DFS4.png" alt="优化后的状态树"></p>
<p>从状态树来看，自上向下计算的过程中，我们总是在较上层提前计算了dfs(i)的结果 并存储起来 留给下层又遇到dfs(i)的时候使用的。</p>
<p>例如，在上面的状态树中，2、1、0这些右侧的分支点，是第一次调用dfs(2),dfs(1),dfs(0)的点，然后再左侧又遇到dfs(2),dfs(1),dfs(0)的时候是直接使用 较上层的 右侧分支点 第一次计算时保存的结果。</p>
<p>现在我们希望不保存这些结果，将空间复杂度从O(n)优化到O(1)，该如何做？</p>
<p>答案很显然了，我们可以自下向上计算状态结点上的值，只使用临时变量存储必要的值，并不断更新这些临时变量。站在记忆化的角度理解就是，我们是有保存dfs(i)的结果，但是没有保存全部结果，我们只存储了O(1)个对之后计算有需要的结果，并抛弃了不需要的结果；从临时变量来看，我们就是不断地用之后的计算需要的结果存入临时变量，覆盖掉了不再需要的结果。</p>
<p>从状态树上来看，我们计算dfs(2)的时候需要dfs(1),dfs(0)，计算dfs(3)的时候需要dfs(2),dfs(1)但不再需要dfs(0)，计算dfs(4)的时候需要dfs(3),dfs(2)，但不再需要dfs(1),dfs(0)。由此可以看出，计算dfs(i)的时候，实际需要的是dfs(i-1),dfs(i-2)</p>
<p>于是我们将dfs改记作dp，于是我们有了递推公式dp(i) &#x3D; max(dp(i-1),dp(i-2)+nums[i])；再结合边界条件dp(0) &#x3D; nums[0]，dp(1) &#x3D; max(nums[0],nums[1])，就可以开始递推填表了，这就是动态规划。</p>
<p>当然仅仅这样的自下向上，我们还没有完成空间复杂度的优化，因为我们使用了O(n)的递推数组。完全的优化是只使用O(1)的临时变量递推，这类似于我们在1维的dp数组上滚动处理，同样也类似于背包问题中，把二维的表格优化为一维的滚动数组（$O(n^2)$到O(n)的空间复杂度优化）。</p>
<p>在一维数组上的滚动处理，我们只需要3个临时变量f1、f2、f3。</p>
<ol>
<li>f1 &#x3D; nums[0], f2 &#x3D; max(nums[1], nums[0]) 状态0、状态1</li>
<li>f3 &#x3D; max(f2,f1+nums[2]) 状态2 &#x3D; max(状态1,状态0+nums[2])</li>
<li>f1 &#x3D; max(f3,f2+nums[3]) 状态3 &#x3D; max(状态2,状态1+nums[3])</li>
<li>f2 &#x3D; max(f1,f3+nums[4])</li>
</ol>
<p>最终结果就在f2中，上面的f1、f2、f3再反复使用的时候被赋予了不同状态的值，要注意区别。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() == <span class="number">1</span>)<span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums.size() == <span class="number">2</span>)<span class="keyword">return</span> max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> f[<span class="number">3</span>] = &#123;nums[<span class="number">0</span>],max(nums[<span class="number">1</span>],nums[<span class="number">0</span>]),<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt; nums.size();i++)</span><br><span class="line">            f[i%<span class="number">3</span>] = max(f[(i<span class="number">-1</span>)%<span class="number">3</span>],f[(i<span class="number">-2</span>)%<span class="number">3</span>]+nums[i]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> f[(nums.size()<span class="number">-1</span>)%<span class="number">3</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li>f是用来存储dfs的结果的，初始化要存储dfs(0)和dfs(1)，而dfs(1)并不是nums[1]，而是max(nums[1],nums[0])，我开始犯了这个错误</li>
<li>通过取模来实现三个临时变量不断互换位置更新的操作的这种实现方法需要留意，多多测试，想清楚怎么变化的，也是一种套路</li>
</ol>
<p>关于注意的第二点，也可以枚举nums中的数字，然后使用一种易读性更强的写法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> new_f,f0 = nums[<span class="number">0</span>],f1 = max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt; nums.size();i++)</span><br><span class="line">&#123;</span><br><span class="line">    new_f = max(f1,f0+nums[i]);</span><br><span class="line">    f0 = f1;</span><br><span class="line">    f1 = new_f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

		</div>

		<!-- 来必力City版安装代码 -->
<div id="lv-container" data-id="city" data-uid="MTAyMC80NjIyNC8yMjczNQ==">
	<script type="text/javascript">
   (function(d, s) {
       var j, e = d.getElementsByTagName(s)[0];

       if (typeof LivereTower === 'function') { return; }

       j = d.createElement(s);
       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
       j.async = true;

       e.parentNode.insertBefore(j, e);
   })(document, 'script');
	</script>
<noscript> 为正常使用来必力评论功能请激活JavaScript</noscript>
</div>
<!-- City版安装代码已完成 -->
		
	</article>

	<div id="toc">
		
	</div>

</div>

<!-- <div id="paginator"> -->
<!-- 	 -->
<!-- </div> -->


			</div>
		</div>

		<div id="bottom-outer">
			<div id="bottom-inner">
				Site by 阳生 | 
				Powered by <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a> |
				theme <a target="_blank" rel="noopener" href="https://github.com/fireworks99/hexo-theme-PreciousJoy">PreciousJoy</a>
			</div>
		</div>

		
	</div>





	
	<!-- scripts list from theme config.yml -->
	
	<script src="/js/jquery-3.5.1.min.js"></script>
	
	<script src="/js/PreciousJoy.js"></script>
	
	<script src="/js/highlight.pack.js"></script>
	
	<script src="/js/jquery.fancybox.min.js"></script>
	
	<script src="/js/search.js"></script>
	
	<script src="/js/load.js"></script>
	
	<script src="/js/jquery.mCustomScrollbar.concat.min.js"></script>
	
	<script src="/js/clipboard.min.js"></script>
	
	

	<script>hljs.initHighlightingOnLoad();</script>

</body>
</html>
