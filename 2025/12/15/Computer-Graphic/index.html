


<!DOCTYPE html>
<html lang="ch">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
	<title>Computer Graphic [ 代码和诗 ]</title>

	<link rel="shortcut icon" href="/myicon.ico">
	
	
	<!-- stylesheets list from _config.yml -->
	
	<link rel="stylesheet" href="/css/PreciousJoy.css">
	
	<link rel="stylesheet" href="/css/top-bar.css">
	
	<link rel="stylesheet" href="/css/menu-outer.css">
	
	<link rel="stylesheet" href="/css/content-outer.css">
	
	<link rel="stylesheet" href="/css/bottom-outer.css">
	
	<link rel="stylesheet" href="/css/atom-one-dark.css">
	
	<link rel="stylesheet" href="/css/recent-posts-item.css">
	
	<link rel="stylesheet" href="/css/article-sidebar-toc.css">
	
	<link rel="stylesheet" href="/css/jquery.fancybox.min.css">
	
	<link rel="stylesheet" href="/css/search.css">
	
	<link rel="stylesheet" href="/css/toc.css">
	
	<link rel="stylesheet" href="/css/sidebar.css">
	
	<link rel="stylesheet" href="/css/archive.css">
	
	<link rel="stylesheet" href="/css/jquery.mCustomScrollbar.min.css">
	
	<link rel="stylesheet" href="/css/Z-last-cover-others.css">
	
	
	
<meta name="generator" content="Hexo 7.3.0"></head>




<body id="wrapper">

	<div id="">
		
		<div id="top-bar">
			
			<div id="avatar-box">
				<img 
				class="avatar"
				src="/images/my-avatar.jpg" //网站头像
				alt="avatar">
			</div>

			<div id="top-bar-text">
				<div id="top-bar-title">
					阳生。
				</div>
				<div id="top-bar-slogan">
					风毛丛劲节，只上尽头竿。
				</div>
			</div>

		</div>

		<div id="menu-outer">
			<div id="menu-inner">
				
				
				<div class="menu-item">
					<a href="/">Home</a>
				</div>
				
				<div class="menu-item">
					<a href="/about">About</a>
				</div>
				
				<div class="menu-item">
					<a href="/archives">Archives</a>
				</div>
				

				<div class="menu-item menu-item-search">
					
  <span class="local-search local-search-google local-search-plugin">
      <input type="search" placeholder="站内搜索" id="local-search-input" class="local-search-input-cls" style="">
      <div id="local-search-result" class="local-search-result-cls"></div>
  </span>
	
				</div>

			</div>
		</div>

		<div id="content-outer">
			<div id="content-inner">

				
<div id="details">
	
	<article id="details-post">
		<div id=details-post-item>
			<h1>Computer Graphic</h1>
			<p><code>这篇blog用来记录我在大学三年级的秋季学期，选修计算机图形学时学到的专业知识，以备增强自己的专业素养以及应对后续考核</code></p>
<h2 id="光栅化"><a href="#光栅化" class="headerlink" title="光栅化"></a>光栅化</h2><p>引入：<br>    到目前为止我们完成了：<br>        1）模型变换-放置好了物品；<br>        2）视图变换-放置好了相机；<br>        3）投影变换-得到了标准空间下的图像信息；<br>    下一步我们需要考虑：<br>        如何将图像显示在屏幕上？<br>        视口变换；</p>
<p>一些基础概念<br>    <em>屏幕</em>：<br>        1）由<em>像素</em>构成，计算机将其抽象为数组进行管理；<br>        2）数组的大小对应<em>分辨率</em>；<br>        3）屏幕是典型的<em>光栅化显示</em>；<br>    光栅：Raster，即德语中的屏幕；<br>    光栅化：Rasterize，画在屏幕上；<br>    像素：Pixel，具有颜色的小正方形，可以用RGB形式来描述颜色；</p>
<p>视口变换：Viewport Transformation<br>    屏幕空间：<br>        连续坐标系下：屏幕覆盖的区域上(0,0)-&gt;(width,height)；<br>        将屏幕离散为像素进行考虑：<br>            1）<strong>分辨率，像素的个数</strong>：$width \times height$；<br>            2）<strong>每个像素对应的范围是</strong>(x,y)-&gt;(x+1,y+1)；<br>            （简单地将一个像素的长宽考虑为单位1）<br>            3）其中x、y是像素的索引，都是整数；<br>            4）当然x、y也可以对应到连续空间中的坐标；<br>            5）<strong>x、y的取值范围分别是0～width-1的整数、0～height-1的整数</strong>；<br>            （相当于连续空间坐标的离散化，根据2）中每个像素的范围，这些索引范围的像素实际上就覆盖了原始的屏幕空间）<br>        注意：<br>            1）虽然像素被离散化处理了，但是我们在进行图形学上的处理时，经常会将其放在连续空间下讨论对其如何处理；<br>            2）<strong>例如(x,y)索引的像素的中心坐标被认为是(x+0.5,y+0.5)</strong><br>        一句话总结：<br>            屏幕坐标是一定范围中的连续空间，其按照每个小单位将坐标离散化作为像素，对用的索引是，离散化后的坐标，其既可以在连续空间中仍旧保持原来的坐标意义，又可以作为计算机管理像素的基本索引<br>    视口变换：<br>        1）是将投影变化后的标准空间里的相关图像信息（空间中的点与对应的位置信息），变换到屏幕空间中；<br>        2）与Z轴无关，eg：将$[-1,1]^2 \rightarrow [0,width]\times [0,height]$<br>    使用到的变换矩阵如下图所示：<br>    <img src="https://raw.githubusercontent.com/Yes-ys/blog-images/main/Computer-Graphic/p1.png" alt="视口转换矩阵"></p>
<p>计算机中<strong>图像的表示方式</strong>：<br>    多边形网格：<br>        1）<strong>三角形网格</strong>：<br>            最<strong>简单</strong>的多边形；<br>            其他多边形可以<strong>拆分</strong>成三角形；<br>            具有良好的性质：<br>                1）一定是<strong>平面</strong>；<br>                2）<strong>内外</strong>定义清晰；<br>                3）对内部任意点方便做<strong>插值</strong>；（重心坐标插值）</p>
<p>如何使用像素近似三角形：<br>    前置条件：<br>        三角形的图形信息已经经过一系列变换，到了屏幕空间中，三角形图像的相关坐标信息可以与像素的坐标信息一概而论；<br>    最简单的光栅化方法：<br>        采样：<br>            <strong>基本定义</strong>：给定一个连续的函数，计算某些点上的函数值；<br>            （本质上将连续的函数给离散化的过程）<br>            样本的作用：<br>                1）我们可以利用它得到原始连续物体的信息；<br>                2）对所有的样本进行一系列处理，得到一些结果；<br>        图形学中的常见采样：<br>            1）一维：对时间采样；<br>            2）二维：对面积采样、对方向采样；<br>            3）三维：对体积采样；<br>    使用二维采样进行光栅化：<br>        1）定义二值函数<strong>inside(t,x,y)<strong>，为1则(x,y)在三角形t内，为0则在三角形外部；<br>        （使用判断点是否在三角形内部的方法，常见的如：重心坐标、向量叉乘等）<br>        2）遍历每一个</strong>像素的中心坐标(x+0.5,y+0.5)，判断是否在三角形内部</strong>，即inside(t,x+0.5,y+0.5)等于1与否；<br>        3）对于中心在三角形内部的像素，则像素的颜色使用该三角形t，属性中的颜色；<br>        4）将每一个像素均处理之后，就可以得到一个光栅化的三角形表示；<br>        如下图所示：<img src="https://raw.githubusercontent.com/Yes-ys/blog-images/main/Computer-Graphic/p2.png" alt="光栅化后的三角形"></p>
<p>采样中存在的问题：<br>    遍历所有的像素点时间消耗太多：<br>        1）使用<strong>包围盒</strong>：<br>            构造方法是取三角形包含坐标的：<br>                x轴方向上最小值-包围盒左下、左上的x坐标；<br>                x轴方向上最大值-包围盒右下、右上的x坐标；<br>                y轴方向上最小值-包围盒左下、右下的y坐标；<br>                y轴方向上最大值-包围盒左上、右上的y坐标；<br>        2）<strong>扫描</strong>的方法：<br>            从下至上、从左至右，逐行或逐列扫描三角形内部像素中心坐标的情况，找到相对应的像素；<br>    光栅化的结果存在采样伪迹：<br>        常见的<strong>采样伪迹</strong>：<br>            1）锯齿；<br>            2）摩尔纹；<br>            3）车轮错觉；<br>        出现<strong>采样伪迹的原因</strong>：<br>            <strong>走样</strong>：<br>                本质原因：<strong>信号变换太快（高频），而采样频率太慢</strong>，导致面向结果估计出的原始信号频率是错误的（与原始信号相差甚远）；<br>                具体的例子：<br>                    锯齿：<strong>空间采样</strong>，频率太低；<br>                    摩尔纹：<strong>图像欠采样</strong>；<br>                    （<em>欠采样 是一个 过程 或 技术性错误。它描述的是 采样频率（即“拍照”或“测量”的频率）低于被采样信号最高频率的两倍 这一情况。</em>）<br>                    车轮错觉：<strong>时间采样</strong>，频率太低；<br>        如何<strong>改善走样</strong>问题：<br>            1）提高采样率（需要考虑代价，提高多少才能才能改善走样）；<br>            2）反走样；</p>
<p>反走样：<br>    本质：<strong>采样前过滤掉高频信号</strong>；<br>    光栅化三角形反走样：<br>        平均像素值：<br>            1）一般采样的过程，光栅化三角形出现锯齿的地方是因为边界像素值为纯红或纯白；<br>            2）考虑将边界的像素值取中间值，使用平均像素值：<br>                三角形覆盖像素的面积，来计算平均像素值；<br>            （可是三角形覆盖了像素的多少，这在计算上比较复杂，而且需要对每个边界像素进行操作）<br>        <strong>点采样</strong>：<br>            将<strong>一个像素</strong>作为<strong>一个采样点</strong>；<br>        <strong>超级采样</strong>：<br>            在<strong>一个像素中进行多次采样</strong>，计算他们的<strong>平均值</strong>作为像素值；<br>            例如：<br>                1）将一个像素分为$2\times 2$对四个子像素<br>                2）对每一个子像素中心点考察是否在三角形中，如果是则子像素在理论上是纯红，不是则是纯白；<br>                3）实际是最后考虑有几个子像素在三角形中，有几个不在，对他们的像素值做平均，得到一个像素的值；</p>
<p>概念辨析<em>采样、采样伪迹、走样、采样频率、欠采样、提高采样频率、反采样</em></p>
<p><em>为什么超级采样算在反采样中？</em></p>
<p>遮挡与可见性问题：<br>    背景：<br>        1）前面描述视口变换的时候提到，是将x、y方向上的图像信息变换到屏幕空间下，但是z轴上对应的信息是不变的；<br>        2）于是根据<strong>z坐标的大小，显示在屏幕上的图像信息实际上是有远有近的</strong>；<br>        3）我们需要考虑对于相同x、y坐标，但z坐标不同的图像信息，近处的图像会遮挡远处的图像；（于是有了下面几个算法）<br>    <strong>画家算法</strong>：<br>        1）对场景中的多边形按照<strong>深度进行排序</strong>（时间复杂度O(nlogn)）<br>        2）由近远及近的光栅化物体信息，近处物体会遮挡远处物体，在帧缓冲器中重写即可<br>    <strong>画家算法的缺点</strong>：<br>        （但是画家算法存在问题，考虑z轴对应空间，所属同一个图像的信息，可以<strong>部分的z坐标较大、部分的z坐标较小，例如存在如下图所示无法排序</strong>的情况）<br>        <img src="https://raw.githubusercontent.com/Yes-ys/blog-images/main/Computer-Graphic/p3.png" alt="画家算法的问题"><br>    <strong>Z-buffer算法</strong>：<strong>思想</strong>，在每个采样点（像素）记录当前最小的Z值，如果新的样本点点深度更小再采纳对应的信息；<br>        1）假设z永远是正值，离相机越近z越小；离相机越远z越大；<br>        （要在实际情况下满足这种条件，可能需要在代码上进行一些变换处理）<br>        2）维护一个<strong>z-buffer，深度缓冲器</strong>，用来缓冲对应<strong>像素记录的图形信息对应深度值z</strong>；<br>        3）逐个光栅化物体，当需要使用当前图像信息设置对应像素的属性值时，先使用<strong>当前图像信息对应的深度值z，与z-buffer中缓存的该像素当前保存图像信息的深度值z，谁更小</strong>；<br>        4）若z-buffer中缓存的z值更小，则跳过该图像信息；<br>        5）若当前图像信息z值更小，则使用当前的图像信息设置相应像素的属性值，其间对使用到的像素，对应在z-buffer中记录该像素当前的深度值；<br>    Z-buffer算法形象的图像表示如下：<br>    <img src="https://raw.githubusercontent.com/Yes-ys/blog-images/main/Computer-Graphic/p4.png" alt="Z-buffer算法"><br>    <strong>Z-buffer算法的优点</strong>：<br>        1）如果三角形的像素个数是常数个，n个三角形处理的<strong>时间复杂度</strong>是O(n)；<br>        2）属于可见性算法，<strong>硬件容易实现</strong>；<br>        3）<strong>不</strong>需要对三角形<strong>全局排序</strong>；<br>    <strong>Z-buffer算法注意</strong>：<br>        一般情况下处理三角形的顺序不会对结果有影响，如果有特殊的情况例如两个三角形的采样点点深度值相同，会对结果有影响；</p>
<p>Z-buffer算法的伪代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(each Traingle t)</span><br><span class="line">    <span class="keyword">for</span>(each sample(x,y,z) in t)</span><br><span class="line">        <span class="keyword">if</span>(z&lt;Zbuffer[x,y])</span><br><span class="line">            framebuffer[x,y] = rgb;</span><br><span class="line">            zbuffer[x,y]=z;</span><br><span class="line">        <span class="keyword">else</span> ;<span class="comment">//do nothing</span></span><br></pre></td></tr></table></figure>

<h2 id="着色"><a href="#着色" class="headerlink" title="着色"></a>着色</h2><p>引入：<br>    到目前为止：<br>        1）我们已经可以使用一系列变换将世界坐标系下的图像信息变换到屏幕坐标下，并且使用光栅化来在屏幕上显示图像来；<br>        2）但是正如我们上一节中对三角形的讨论，我们在设置像素值的时候是直接取纯红或纯白；<br>        3）这种方式显然不会应用在真正的图形显示上面，对像素值的操作太粗暴了<br>    下一步：<br>        1）这一节中我们要结合一些光学知识，更加细粒度地讨论如何设置像素值；<br>        2）目的是在屏幕上显示出有光照效果的图形；如下图所示：<br>        <img src="https://raw.githubusercontent.com/Yes-ys/blog-images/main/Computer-Graphic/p5.png" alt="纯红色的茶壶考虑光照影响后的光栅化效果"></p>
<p>一些基本的概念：<br>    着色：shading；<br>        严格来说在计算机图形学中，着色是指将材质应用到物体上的过程；<br>        （这里的物体大概是指光栅化后表示在屏幕上的物体）；<br>        （所以着色并非仅限于考虑光照的影响，还要考虑具体的材质，这在后续章节中会进行探讨）；<br>    着色器：shader；<br>    光照：<br>        高光：Specular highlights；光源直接照射；<br>        漫反射：Diffuse relection；光源照射后粗糙表面的反射；<br>        环境光：Ambient lighting；其他物体反射光源形成的间接光；<br>    注意：<br>        shading不是shadow，对于阴影shadow，我们后续章节也会进行讨论；</p>
<p>考虑光照的着色：<br>    着色点：shading point<br>        1）我们需要就一个着色点考虑光照的情况；<br>        2）可以将着色点对应到物体图像信息中的一个局部点；<br>        3）对这些局部点考虑光照后，计算出着色信息存储在对应的图像信息中，光栅化设置像素属性值的时候使用；<br>        4）最终光栅化的整体图形可以呈现出光照的效果；<br>    常用的信息：<br>        1）观察方向v；<br>        2）表面法向n；<br>        3）光线方向l；<br>        4）表面参数；<br>    （<img src="https://raw.githubusercontent.com/Yes-ys/blog-images/main/Computer-Graphic/p28.png" alt="相关向量方向">）<br>    Blinn-Phong反射模型：<br>        用来基于常用信息计算着色点的光照情况；</p>
<p>Blinn-Phong反射模型：<br>    前置知识：<br>        1）兰伯特余弦定理：<br>            1）作用：描述有多少光被表面接收到；<br>            2）公式：每个着色点接收到的光，是照射向该着色点点原始光的：<br>            $\cos\theta &#x3D; l \cdot n$；<br>        2）光的衰减：<br>            1）作用：描述光在扩散过程中的衰减；<br>            2）公式：光源发出的光在单位距离1处的Intensity为I，在距离光源距离为r处，对应的Intensity为$I&#x2F;r^2$<br>            （<em>从后面辐射度量学的角度来看，这里应该是Irradiance，而非Radiant Intensity，但是后续的Blinn-Phong模型均用了I的描述，这是为什么呢？</em>）<br>    <strong>漫反射</strong>：<br>        1）<strong>公式</strong>：<br>            $L_d &#x3D; k_d(I&#x2F;r^2)max(0,n\cdot l)$；<br>            说明：<br>                1）$L_d$对应漫反射光；<br>                2）$k_d$是漫反射系数；<br>                3）$I&#x2F;r^2$对应的就是光的衰减；<br>                4）$n\cdot l$对应的是兰伯特余弦定理，与0取max是考虑一面受光；<br>        2）特点：<br>            1）光向各个方向均匀散射；<br>            2）<strong>所有观察方向看到的表面颜色是一致</strong>的；<br>            3）因此$L_d$与$v$无关，但是与$l$有关；<br>    <strong>镜面高光</strong>：<br>        1）<strong>公式</strong>：<br>            $L_s &#x3D; k_s(I&#x2F;r^2)max(0,h\cdot n)^p$；<br>            说明：<br>                1）$k_s$是高光反射系数；<br>                2）$h &#x3D; \frac{l+v}{||l+v||}$，是半程向量；<br>                (这里的半程向量对应就是l、v夹角的角平分线，因为l、v是单位向量)<br>                3）$p$用来控制高光范围，参考余弦幂图进行理解；<br>                <img src="https://raw.githubusercontent.com/Yes-ys/blog-images/main/Computer-Graphic/p6.png" alt="余弦幂图"><br>        2）特点：<br>            1）<strong>强度取决于观察方向</strong>，靠近镜面的反射方向更加明亮；<br>            2）观察向量v接近镜面反射方向，等价于半程向量h接近法线向量n;<br>            3）所以这里使用h与n的点乘；<br>    <strong>环境光</strong>：<br>        1）<strong>公式</strong>：<br>            $L_a &#x3D; k_a I_a$<br>            说明：<br>                1）$k_a$是环境光系数；<br>        2）特点：<br>            1）Blinn-Phong模型对环境光的处理是一种<strong>常量颜色</strong>；<br>            2）这是一种近似，并不真实；<br>    最终的Blinn-Phong模型：<br>        $L &#x3D; k_d(I&#x2F;r^2)max(0,n\cdot l) + k_s(I&#x2F;r^2)max(0,n\cdot h)^p + k_a I_a$</p>
<p>影响着色效果的因素：<br>    1）物体本身的面数（几何处理）：<br>        这与将现实世界中的物体通过几何处理，转换为多边形网格表示有关；<br>        网格的大小、网格的数量等本身就会影响着色处理等细粒度；<br>    2）<strong>着色频率</strong>（光栅化表示）：<br>        在已有物体的图像信息不改变的前提下，在着色过程中可以考虑：<br>            1）对每一个<strong>多边形着色</strong>，eg：三角形；<br>                1）多边形通常是平面<br>                2）不适合光滑的表面；<br>            2）对多边形的每一个<strong>顶点着色</strong>；<br>                1）三角形的各个顶点携带了颜色信息；<br>                2）但是三角形作为平面只有一个平面的法向信息，顶点的法向信息需要插值计算；<br>            3）对每一个<strong>像素着色</strong>；<br>                1）法向信息同样需要插值计算；<br>                2）在每一个像素上计算着色模型<br>        注意：<br>            上面三种频率的着色对应的专有名词为：<br>                1）<strong>Flat Shading</strong>；<br>                2）<strong>Gourand Shading</strong>；<br>                3）<strong>Phong Shading</strong>；<br>            （Phong Shading要与Blinn-Phong模型区别开，前者对应的是一种着色频率，后者对应的是在该着色频率下采取的具体的着色模型）；<br>    3）三种着色频率随物体面数变化的效果对比：<br>        <img src="https://raw.githubusercontent.com/Yes-ys/blog-images/main/Computer-Graphic/p7.png" alt="着色效果">；</p>
<p><strong>法向量的插值计算</strong>：<br>    1）<strong>面法向</strong>；<br>    2）<strong>顶点法向</strong>：<br>        公式：$N_v &#x3D; \frac{\sum_i N_i}{||\sum_i N_i||}$<br>        其中：<br>            1）$N_v$对应顶点的法向量；<br>            2）$N_i$对应与该顶点相邻的所有面的法向量；<br>            3）所以顶点法向的插值就是相邻面法向量的平均；<br>    3）<strong>像素法向量</strong>：<br>        需要使用重心插值，我们后续会进一步学习；</p>
<p>一种典型的图形管线：<br>    Application输入；<br>    1）Vertex Processing；顶点处理；<br>        1）应用输入的是3D世界空间中的一系列离散点，表示连续图形离散化后的信息；<br>        2）相关操作eg：MVP变换、着色器处理颜色信息（光照、纹理）保存到对应的顶点；<br>    2）Triangle Processing；三角形化；<br>        1）要显示完整的图像，我们要先用离散的点构建多边形网格；<br>        2）相关操作eg：几何处理；（后面会讨论）；<br>    3）Rasterization；光栅化；<br>        1）有了多边形网格之后，对于每一个多边形，例如三角形，我们可以做光栅化处理就像我们之前讨论的一样；<br>        2）相关操作eg：光栅化；<br>    4）Fragment Processing；片元处理；<br>        1）进一步对相关的像素构成的片元，使用着色器处理颜色信息（光照、纹理）；<br>        2）相关操作eg：MVP变换、着色（光照、纹理）；<br>    5）Framebuffer Operations；帧缓冲区处理；<br>        1）将处理完成后的各个像素的信息存入帧缓冲区，等待下一帧改变相应像素的信息为缓冲区中的对应值，显示图像；<br>        2）相关操作eg：画家算法、Z-buffer算法；<br>    输出显示；</p>
<p>纹理映射（Texture Mapping）<br>    含义：三维空间中的一点可以对应二维图像（纹理）上的一点，将二维图像（纹理）上的属性值应用到三维空间对应的点，即纹理映射；<br>    基本概念：<br>        纹理（Texture Mapping）；<br>        <strong>纹理坐标</strong>：<br>            为三维空间中的每个点计算一个纹理坐标(u,v)，对应的是纹理图像上的坐标值，可以确定纹理图像上的一点以获取对应的属性；<br>            三维空间中的点通常是网格化处理后的三维图形，的各个多边形网格中的点；<br>            eg：三角形的每个顶点、三角形内部的任意点；<br>        <strong>纹素&#x2F;纹理元素</strong>：<br>            纹理上的一个像素；<br>            （最终计算机应用的时候纹理图片也是以图形保存的，对应其实就是落实到屏幕空间下各个像素的属性是什么，理解纹素对于理解纹理的应用以及后续纹理贴图存在的问题很重要）<br>    纹理坐标映射的建立：<br>        三角形的顶点：<br>            按照纹理的使用方法，为三角形的每个顶点直接分配纹理坐标；<br>        三角形内部的任意点：<br>            问题：<br>                1）三角形的顶点是离散的、有限的，我们可以也应该为其直接分配相应的纹理坐标；<br>                2）三角形内部的任意点是连续的，不可能手动分配；<br>            解决方法：<br>                进行插值；<br>                    根据顶点的纹理坐标按照一定的方法，计算出合理的三角形内部的纹理坐标<br>                可以插值的对象：<br>                    1）纹理坐标（这也是我们这里引入插值的核心目的）；<br>                    2）颜色；<br>                    3）法向量；<br>                    4）深度；<br>                    5）材质属性；<br>            <strong>重心坐标插值法</strong>：<br>                重心坐标：<br>                1）使用三角形顶点表示空间中一点：<br>                    考虑三角形的三个顶点$A,B,C$，对应空间中的任意点可以在这三个顶点的基础上，使用一组坐标$\alpha,\beta,\gamma$进行表示，即任意点$P$：<br>                    $P &#x3D; \alpha A + \beta B + \gamma C,s.t.\alpha+\beta+\gamma&#x3D;1$；<br>                2）重心坐标的求法：<br>                    $\alpha &#x3D; \frac{S_A}{S_A+S_B+S_C}$；<br>                    $\beta &#x3D; \frac{S_B}{S_A+S_B+S_C}$；<br>                    $\gamma &#x3D; \frac{S_B}{S_A+S_B+S_C}$；<br>                    1）其中$S_A,S_B,S_C$分别对应顶点$A,B,C$对应的三角形面积；即由$K$与三个顶点相连形成的三个三角形，其中不与某顶点相邻的三角形，就是该顶点对应的三角形；<br>                    2）该面积为有向面积，有正负之分；（了解）；<br>                3）重心坐标的性质：<br>                    1）三角形内部顶点的重心坐标是非负的；<br>                    2）可以用任意点对应三角形的重心坐标来判断点在三角形的内部还是外部；<br>                    3）三角形重心的重心坐标是：$(1&#x2F;3,1&#x2F;3,1&#x2F;3)$；重心总是在三角形的内部；<br>                    4）在投影变换下，重心坐标无法保持不变，需要特殊的处理；</p>
<p>纹理简单应用的例子：漫反射颜色；<br><img src="https://raw.githubusercontent.com/Yes-ys/blog-images/main/Computer-Graphic/p8.png" alt="伪代码"><br>    因此：<br>        实际上纹理映射不只是管线流程中最开始的3D模型可以将三维空间中一点映射到纹理空间；屏幕空间中的一点，或者是一个像素（它们都在屏幕空间中具有坐标）都能够被映射到纹理空间中的一点；</p>
<p>纹理使用中存在的问题<br>    <strong>纹理分辨率不足</strong>：<br>        <strong>纹理空间过小导致</strong>，映射后纹理坐标并不存在（没有对应的纹素）；<br>            eg：$1024\times 720$的光栅化图像使用$720\times 560$的纹理空间；假设使用1对1对映射，例如(1023,719)对应的像素点，在纹理空间中没有对应(1023,719)的纹理坐标，我们不知道该对这个像素点设置何种属性。这就是纹理分辨率不足带来的问题；<br>        <strong>直接的问题</strong>：<br>            <strong>放大了看可能感觉存在马赛克</strong>；<br>        解决方法：<br>            <strong>纹理放大</strong>：<br>                思想：通过一些操作，将像素点映射到一个或多个合理的纹理坐标，并基于对应的纹理属性给出像素点的属性；<br>                具体操作：<br>                    预处理：<br>                        将<strong>纹理空间放大，纹素保持均匀分布</strong>；只是改变纹素的空间分布情况，不会增加额外的纹理属性信息；<br>                        （试设想将$720\times 560$个像素点，分布情况拉伸到均匀分布与$1024\times 720$的平面空间；）<br>                    （实际上这一步就是纹理放大）<br>                    预处理基础上可选的几种操作：<br>                        1）<strong>最邻近方法(Nearest)<strong>：<br>                            1）针对映射后的纹理坐标(u,v)，对应到最近的纹素(x,y)；<br>                            2）将该纹素(x,y)的属性值作为纹理坐标(u,v)的属性值；<br>                        2）</strong>双线性插值(Bilinear)<em><em>：<br>                            1）针对映射后的纹理坐标(u,v)，对应到最近的四个纹素(x,y)&#x2F;(x,y+dy)&#x2F;(x+dx,y)&#x2F;(x+dx,y+dy)；<br>                            2）将四个纹素的属性分别记做：<br>                                u00,u01,u10,u11；<br>                            3）考虑映射后的纹理坐标(u,v) &#x3D; (x,y)+(s,t)<br>                            4）使用双线性插值计算纹理坐标(u,v)对应的属性：<br>                                u0 &#x3D; lerp(t,u00,u01) &#x3D; u00 + t</em>(u01-u00);<br>                                u1 &#x3D; lerp(t,u10,u11) &#x3D; u10 + t</em>(u11-u01);<br>                                f(u,v) &#x3D; lerp(s,u0,u1) &#x3D; u0 + s*(u1-u0);<br>                                其中，u0、u1对应的是纹理属性值，中间变量；f(u,v)是纹理坐标(u,v)对应的纹理属性值；<br>                            注意：t的取值范围为0到1，对应边界取得两个插值项的值；<br>                            为了便于理解放置如下图像<img src="https://raw.githubusercontent.com/Yes-ys/blog-images/main/Computer-Graphic/p9.png" alt="双线性插值"><em>图像中的符号记法与上述笔记描述不同，起因是老师的ppt缺少规范的描述，初看很模糊，所以我在自己理解的基础上写了上述笔记。能够将图像中的记法与上述笔记的记法对应起来也是一种很好的思辨</em>；<br>                        关键点：<br>                            <strong>区分</strong>：纹理坐标、纹素、纹理的属性；<br>                            上述引用纹素的时候，更多的是引用其作为纹理图像上的坐标性质（所以上述描述用纹素坐标更贴切），实际上纹素应该包含了纹理的属性；<br>                注意：<br>                    1）实际情况下，纹理空间与光栅化图像空间或者说3维图像的分布空间，究竟是什么关系，我们是不知道的，但也没有必要知道，这并非此处的讨论重点；<br>                    2）重点在于，当我们对光栅化图像的像素 or 3维图像，进行一个映射来到纹理空间之后，得到的纹理坐标(u,v)，可能无法对应到一个存在的纹素；<br>                    3）整个这一部分我们要讨论的都是这种问题；<br>    纹理分辨率过大：<br>        一个像素&#x2F;3维模型的点等，映射后的纹理坐标涉及范围内，包含多个纹素，此时应该如何设置纹理坐标的属性值。<br>            eg：<img src="https://raw.githubusercontent.com/Yes-ys/blog-images/main/Computer-Graphic/p10.png" alt="纹理过大"><br>        <strong>直接的问题</strong>：<br>            <strong>出现采样伪迹（摩尔纹、锯齿）</strong>，因为本质是发生了走样（样本频率变化高，采样频率低）；<br>        解决方法：</strong>纹理缩小**<br>            <strong>超级采样</strong>：<br>                将一个像素划分为子像素，对子像素计算对应纹素的属性值，让一个像素捕获更多的纹理信息；<br>                （缺点在于开销较大）；<br>            <strong>Mipmap</strong>：<br>                <strong>Mipmap level</strong>：<br>                    预处理：<br>                        1）对<strong>原始的纹理图像</strong>按照<strong>层级进行处理</strong>；<br>                        2）<strong>层级的数量</strong> Level Num &#x3D; log2(原始图像<strong>分辨率的宽或高</strong>)<br>                        eg:对于<strong>128*128的纹理图像，会有7层</strong>；<br>                        3）<strong>level0</strong>对应原始纹理图像；<br>                        4）<strong>level(n+1)<strong>对应纹理图像的分辨率是leveln的图像分辨率除以2；<br>                        5）具体的处理方式这里不展开，大致是将多个纹素的属性信息汇聚到周围的一个纹素属性信息上，形成分辨率更小的纹理图像；<br>                        （可以参照如下图像进行理解<img src="https://raw.githubusercontent.com/Yes-ys/blog-images/main/Computer-Graphic/p11.png" alt="Mipmap">）<br>                    实际操作（针对屏幕空间-纹理空间的映射进行说明）：<br>                        1）对于每一个像素(x,y)，考虑其相邻两个像素(x,y+1)和(x+1,y)，将三个像素映射到纹理空间，得到(u,v)以及(u1,v1),(u2,v2)；<br>                        （考虑这三个像素是为了确定像素(x,y)在纹理空间的覆盖范围）；<br>                        2）考虑(u,v)到(u1,v1)的距离是L1，(u,v)到(u2,v2)的距离是L2；<br>                        3）取</strong>L &#x3D; max(L1,L2)<strong>计算层级</strong>D &#x3D; round(log2(L))<strong>；<br>                        4）像素(x,y)对应的纹理坐标(u,v)应该在D层级，使用双线性插值，得到纹理属性f；<br>                    或者在2）之后的基础上</strong>三线性插值</strong>：<br>                        1）对于<strong>纹理坐标(u,v)在down(log2(L))层级</strong>使用双线性插值得到<strong>纹理属性f1</strong>；<br>                        2）对于<strong>纹理坐标在upper(log2(L))层级</strong>使用双线性插值得到<strong>纹理属性f2</strong>；<br>                        3）对于<strong>f1和f2进行单线性插值：f &#x3D; f1 + (L - down(L))(f2 - f1)<strong>；<br>                注意：<br>                    1）Mipmap的</strong>额外存储空间</strong>：<br>                        1）假设<strong>原始纹理图像所用空间为1</strong>；<br>                        2）每次分辨率减半（长、宽），所用空间变为<strong>上一层的1&#x2F;4</strong>；<br>                        3）对应的所用空间：<br>                            $1 + (\frac{1}{4})^1 + (\frac{1}{4})^2 + \dots &#x3D; \frac{4}{3}[1 - (\frac{1}{4})^n] \rightarrow \frac{4}{3}, when:n \rightarrow inf$<br>                        4）<strong>即变为原来的4&#x2F;3，所以多用了1&#x2F;3的空间</strong>；<br>                    2）为什么使用D &#x3D; round(log(L))的方式来取层级；<br>                    3）由于我们是泛泛而学，里面仍然有一些细节不清晰：<br>                        1）层级数量计算的时候实际应该选择宽还是高；<br>                        2）对于三线性插值，如果D已经是最大层级了应该如何特殊处理；<br>                        3）<em>在三线性插值的最后一步f1和f2如何进行插值不太清楚；（已经问了老师了，并补充在上面了）</em></p>
<p>纹理的应用：<br>    1）环境光照；<br>    2）环境贴图；<br>    3）球形环境贴图；<br>    4）立方体贴图；</p>
<p>纹理对着色的影响：<br>    纹理本身中存储了颜色信息，通过纹理为模型上色让模型看起来更逼真；<br>    （但是不止如此）<br>        <strong>凹凸&#x2F;法线贴图</strong>：<br>            作用：用于伪造凹凸不平的几何纹理；<br>            <strong>优点</strong>：添加<strong>表面细节</strong>但<strong>不改变任何几何信息</strong>，<strong>不会增加三角形的数目</strong>；<br>            （不改变模型的几何形状（顶点位置），而是通过一张纹理贴图来“欺骗”光照计算，改变每个像素点（片段）的<strong>表面法线方向</strong>。因为光照效果（漫反射、高光）极度依赖于法线，改变法线就能<strong>制造出凹凸不平</strong>的视觉假象。）<br>        <strong>2D方法</strong>：<br>            1）定义高度偏移（在每个纹素上定义）：<br>                对模型上的一点$p$，利用纹理定义每个<strong>纹素</strong>上的<strong>高度函数h(p)<strong>（表示在位置p处的表面凹凸高度）；<br>            2）计算扰动后的法向量：<br>                1）原始</strong>表面法线</strong> $n(p) &#x3D; (0,1)$；（<strong>代表平坦</strong>,是从p点出发的二维上的(0,1)向量（法向量）；）<br>                2）p点处的<strong>导数</strong> $dp &#x3D; c*(h(p+1)-h(p))$；<br>                3）<strong>扰动后的法线</strong> $n(p) &#x3D; (-dp,1).normalized$；<br>                其中：<br>                    1）n(p)对应的是原始法向量；<br>                    2）dp对应的是p点处的导数；<br>                    3）h是高度函数，对应的导数计算方法是一种近似的方法；<br>                    4）c是一个常数参数；<br>        <strong>3D方法</strong>：<br>            扰动后的法向量：<br>                1）<strong>原始表面法线</strong>：$n(p) &#x3D; (0,0,1)$；<br>                2）<strong>p点处的偏导数</strong>：<br>                    $dp&#x2F;du&#x3D;c1*(h(u+1,v)-h(u,v))$；<br>                    $dp&#x2F;dv&#x3D;c2*(h(u,v+1)-h(u,v))$；<br>                    （这里类似h(u+1)的含义应该是在p点的u坐标上+1，然后对应到一个新的点？）<br>                3）<strong>扰动后的法线</strong>：<br>                    $n(p) &#x3D; (-\frac{dp}{dv},-\frac{dp}{du},1).normalized$；<br>                注意：<br>                    <em>似乎3D下的符号表示与2D下的符号表示有一些矛盾？前者采用了分量的形式，后者直接使用点p，来表示函数值，形成函数曲线；(我自己手动修正了一下)</em><br>    <strong>凹凸&#x2F;法线贴图的问题</strong>：<br>        1）在模型<strong>边缘处不能</strong>很好地<strong>模拟凹凸效果</strong>；<br>        2）<strong>阴影效果</strong>是由真实的几何信息计算出的，导致阴影与物体相<strong>矛盾</strong>；<br>    更好的选择：<br>        <strong>位移贴图</strong>：<br>            优点：可以解决凹凸&#x2F;法线贴图的两个问题；<br>            <strong>原理</strong>：在于位移贴图<strong>真正地移动了三角形的顶点</strong>；<br>            <strong>缺点</strong>：<br>                1）<strong>对三角形数目有要求</strong>；<br>            改进：<br>                1）动态细分曲面；</p>
<h2 id="几何"><a href="#几何" class="headerlink" title="几何"></a>几何</h2><p>几何的表示方法：<br>    <strong>隐式表示</strong>：<br>        1）<strong>代数曲面</strong>：<br>            将表面表示成x、y、z多项式的零集；<br>            <img src="https://raw.githubusercontent.com/Yes-ys/blog-images/main/Computer-Graphic/p12.png" alt="代数曲面">；<br>            （<strong>缺点</strong>是不能表示复杂的几何体）；<br>        2）<strong>构造实体几何</strong>：<br>            通过布尔运算组合隐式几何；<br>            <img src="https://raw.githubusercontent.com/Yes-ys/blog-images/main/Computer-Graphic/p13.png" alt="构造实体几何">；<br>        3）<strong>距离函数</strong>：<br>            给出从任何地方到物体的最小距离，然后距离函数逐渐将曲面融合在一起；<br>            <img src="https://raw.githubusercontent.com/Yes-ys/blog-images/main/Computer-Graphic/p14.png" alt="距离函数">；<br>            eg：利用距离函数混合（线性插值）移动边界；<br>        4）<strong>水平集</strong>：<br>            对于复杂形状，将逼近函数的值存储在格子中，通过插值得到曲面；<br>            <img src="https://raw.githubusercontent.com/Yes-ys/blog-images/main/Computer-Graphic/p15.png" alt="水平集">；<br>            eg：利用水平集编码医疗数据、气液距离<br>        5）<strong>分形</strong>：<br>            在所有尺度上展现自相似性；<br>            <img src="https://raw.githubusercontent.com/Yes-ys/blog-images/main/Computer-Graphic/p16.png" alt="分形">；<br>    显示表示：<br>        1）<strong>参数方程</strong>：<br>            通过参数映射给出几何体上的所有点；<br>            <img src="https://raw.githubusercontent.com/Yes-ys/blog-images/main/Computer-Graphic/p17.png" alt="参数方程">；<br>        2）<strong>点云</strong>；<br>            最简单的表示形式，就是点(x,y,z)点列表；<br>            <strong>优点</strong>：<br>                1）方便的表示各种几何类型；<br>                2）适用于大数据集合；<br>            <strong>缺点</strong>：<br>                1）通常需要转换为多边形网格；<br>                2）在欠采样区域难以绘制；<br>        3）<strong>多边形网格</strong>：<br>            存储顶点和多边形（常用三角形、四边形），这是图形学中最常用的表示方式；<br>            <strong>优点</strong>：<br>                1）易于进行处理&#x2F;模拟、自适应采样；<br>            <strong>缺点</strong>：<br>                1）相较于点云需要更加复杂的数据结构；<br>        4）其他：<br>            Bezier曲面（线）、<strong>细分</strong>曲面、<strong>NURBS</strong>；</p>
<p><strong>代数曲面与参数方程的对比</strong>：<br>    1）代数曲面本质上是描述了，空间中坐标点的限制关系，满足这些限制关系的点就在多项式零集对应的几何体上；<br>    2）参数方程本质上是用给定范围的参数，直接查询对应的空间中对应的坐标点；<br>    反映隐式表示与显示表示的优缺点：<br>        <strong>隐式表示</strong>：<br>            <strong>优点</strong>：<strong>内外测试容易</strong>，因为有代数曲面的多项式零集，只需要将相应的坐标点带入多项式中；<br>                1）如果为正，则在曲面外；<br>                2）如果为负，则在曲面内；<br>                3）如果为0，则在曲面上；<br>            <strong>缺点</strong>：<strong>采样困难</strong>，不容易找到哪些点在曲面上（因为本质上就是要解方程，这并不简单）；<br>        <strong>显示表示</strong>：<br>            <strong>优点</strong>：<strong>采样简单</strong>，因为只要给出一组参数就可以计算出空间中曲面上对应的坐标点（并且参数的范围是知道的）；<br>            <strong>缺点</strong>：<strong>内外测试困难</strong>；</p>
<p>曲线：<br>    曲线的应用：<br>        1）相机路径；<br>        2）动画曲线；<br>        3）定义字体；<br>        4）贝塞尔曲线；<br>    <strong>贝塞尔曲线</strong>：<br>        <strong>de Casteljau算法（贝塞尔曲线的定义）</strong><br>            1）考虑一系列控制点$b_0,b_1,\dots,b_n$；<br>            2）相邻控制点之间进行线性插值，使用参数t插入一个新的点；<br>            3）用相邻控制点，构成新的控制点，相邻之间又使用线性插值（仍然用参数t），插入新的点；<br>            4）重复过程3），持续插值，递归，直到最后只插入了一个点（这个过程中持续使用参数t）；<br>            （于是最终我们得到了一个使用参数t控制的，移动的点，即最后一个插入的点，其移动的轨迹就是贝塞尔曲线）<br>            算法过程：<br>                <img src="https://raw.githubusercontent.com/Yes-ys/blog-images/main/Computer-Graphic/p20.png" alt="递归地进行新点插入"><br>            注意：<br>                由于线性插值前面已有，所以这里没有过多赘述，线性插值点参数t点取值范围仍然是0到1；<br>        eg：<br>            三个控制点的贝塞尔曲线：<br>            <img src="https://raw.githubusercontent.com/Yes-ys/blog-images/main/Computer-Graphic/p18.png" alt="贝塞尔曲线"><br>        <strong>贝塞尔曲线的名称</strong>：<br>            最初有n个控制点的曲线对应称为n-1次贝塞尔曲线；<br>        <strong>控制点的命名规范</strong>：<br>            1）最初的控制点命名为：$b_{0}、b_{1}、…、b_{n-1}$；<br>            2）递归的确定所有控制点的变化范围之后，可以采用“倒推法”命名；（自己发现的规律，还不太确定原理，简单来说就是从最初控制点序列中的最后一个控制点开始，倒推，每倒推一次就对应到当前控制点所在序列，构造的下一个序列，并将下标减1，上标加1，直到下标为0；参考该图：<img src="https://raw.githubusercontent.com/Yes-ys/blog-images/main/Computer-Graphic/p19.png" alt="倒推法">）；<br>        <strong>贝塞尔曲线的代数公式</strong>：<br>            $b^n_0(t) &#x3D; \sum_{j&#x3D;0}^n B_j^n(t)b_j$；<br>            其中：<br>                1）$b^n_0$ 就是定义中递归到最后一个插值点，即贝塞尔曲线上的点，其位置由t控制；（可以简写为：$b^n$）；<br>                2）$B_j^n(t)$ 为贝塞尔曲线基函数：<br>                    $B_j^n(t) &#x3D; C_n^j t^j (1-t)^{(n-j)}$；<br>                3）$b_j$ 是最初的第控制点j；（从0开始）；<br>        <strong>贝塞尔曲线的性质</strong>：<br>            1）端点位置：<br>                1）<strong>当t&#x3D;0的时候</strong>，为曲线端点，在第一个控制点p0处；（<strong>起始点计算</strong>）<br>                2）当t&#x3D;1的时候，为曲线另一个端点，在最后一个控制点pn处（n+1次贝塞尔曲线）；<br>            2）<strong>端点切向量</strong>：<br>                1）在<strong>p0处</strong>，切向量可以对应是$n(p_1-p_0)$<br>                2）在<strong>p1处</strong>，切向量可以对应是$n(p_n - p_{n-1})$<br>                其中：<strong>n对应归一化</strong>；<br>            3）<strong>仿射变换性质</strong>：<br>                通过变换点控制点达到变换曲线的目的；<br>            4）<strong>凸包性质</strong>：<br>                得到的贝塞尔曲线一定在控制点的凸包内部；<br>        高阶贝塞尔曲线存在的问题：<br>            不直观、难以控制，并不常用！<br>        <strong>分段贝塞尔曲线</strong>：<br>            思想：通过连接多段低阶贝塞尔曲线来实现；<br>            eg：分段三次贝塞尔曲线；<br>            <img src="https://raw.githubusercontent.com/Yes-ys/blog-images/main/Computer-Graphic/p21.png" alt="分段三次贝塞尔曲线"><br>            连续性：<br>                <strong>有几种连续性级别</strong>：<br>                    1）<strong>C0连续</strong>：$a_n &#x3D; b_0$；<br>                    <strong>前一段的终点与后一段的起点相同</strong><br>                    <img src="https://raw.githubusercontent.com/Yes-ys/blog-images/main/Computer-Graphic/p22.png" alt="C0连续"><br>                    2）<strong>C1连续</strong>：$a_n &#x3D; b_0 &#x3D; \frac{1}{2}(a_{n-1}+b_1)$；<br>                    前一段终点与后一段<strong>起点相同</strong>，且交点处，在<strong>前一段的切向量与后一段的切向量共线、等长</strong>（相等）<br>                    <img src="https://raw.githubusercontent.com/Yes-ys/blog-images/main/Computer-Graphic/p23.png" alt="C1连续"><br>        贝塞尔曲线的<strong>缺点</strong>：<br>            1）控制点较多时，<strong>控制能力减弱</strong><br>            2）控制点较多时，生成<strong>曲线阶数</strong>增大；<br>            3）<strong>局部控制能力较差</strong>；<br>            4）连接需要<strong>附加条件</strong>，<strong>不太灵活</strong>；<br>        贝塞尔曲线的<strong>优点</strong>：<br>            形状控制直观，设计灵活，应用广泛；</p>
<p>样条：<br>    优于贝塞尔曲线之处：<br>        1）局部修改能力强；<br>        2）易于拼接；<br>    eg：<br>        B样条、NURBS；</p>
<p>贝塞尔曲面：<br>    双三次贝塞尔曲面：实际上就是在空间中的一个平面内先通过递归插值得到贝塞尔曲线的控制点（不同曲面、不同曲线，相同的控制参数u），然后在各个贝塞尔曲线的控制点之间引入另一个控制参数v，进行递归插值；最终两个控制参数对应一个曲面；<br>    <img src="https://raw.githubusercontent.com/Yes-ys/blog-images/main/Computer-Graphic/p24.png" alt="双三次贝塞尔曲面"></p>
<p>几何处理：<br>    含义：对传统数字信号处理的扩展，用于对几何信号进行处理；<br>    常见的集合处理：<br>        1）重建：<br>            给定几何样本，重建表面；<br>            eg：给定点、法线，基于轮廓重建；<br>        2）上采样：<br>            通过插值提高分辨率；<br>            eg：双线性插值、三线性插值、网格细分；<br>        3）下采样：<br>            降低分辨率同时保持几何体形状外观；<br>            eg：最临近、双线性插值、双三线性插值；<br>            （虽然2、3都有插值，但是2可以类比用在纹理放大、3类比用在纹理缩小）<br>        4）重采样：<br>            修改样本分布，但保持多边形数目不变，以提高质量；<br>        5）过滤：<br>            消除噪声或强调重要特征；<br>        6）形状分析：<br>            识别&#x2F;理解图形中的语义；<br>    挑战：<br>        1）几何信息的欠采样破坏图形特征；<br>        2）几何信息的过采样会影响性能；<br>        3）重复重采样（先下采样再上采样）会导致信号质量变差；<br>    <strong>Loop细分</strong>：<br>        场景：针对三角形网格的常用细分方法；<br>        思想：增加三角形的顶点，然后调整顶点的位置，从而将一个三角形网格划分为更多的三角形网格；<br>        方法：<br>            1）插入边点：对于一个三角形网格，在其每条边的中点插入一个新的点，称为边点；<br>            2）连接插入点三个边点，将一个三角形一分为四；<br>            3）更新顶点的位置，新、旧顶点都要更新：<br>                1）新顶点（边点）：<br>                    $position &#x3D; \frac{3}{8}(x_0+x_1) + \frac{1}{8}(x_2+x_3)$<br>                    其中：<br>                        1）0、1对应该边点所在边点两个端点；<br>                        2）2、3对应与边点所在边相对的两个端点；<br>                    eg：<br>                        <img src="https://raw.githubusercontent.com/Yes-ys/blog-images/main/Computer-Graphic/p25.png" alt="新顶点位置修改"><br>                2）旧顶点：<br>                    $position &#x3D; (1-n\beta)OriginalPosition + \beta \sum NeighborPosition$<br>                    其中：<br>                        1）n是顶点的度，即相邻边&#x2F;点数量；<br>                        2）beta是一个参数，可以由n确定，通常使用近似公式：<br>                            $\beta &#x3D; \frac{3}{16} if n&#x3D;3,otherwise:\beta &#x3D; \frac{3}{8n}$<br>                    eg：6个相邻点情况<br>                        <img src="https://raw.githubusercontent.com/Yes-ys/blog-images/main/Computer-Graphic/p26.png" alt="旧顶点位置修改"><br>        另一种实现方式：<em>或许这就是具体的实现方式，直接连接三个新的边点在实际中无法完成？？？</em><br>            1）以任意顺序分割原始网格点边；<br>            2）翻转接触新旧顶点的新边<br>                eg：在四边形ABCD中，一条四边形内的边连接AD，翻转后就连接BC了，即从一条对角线变成另一条对角线；<br>            （上面两步实际上就对应了插入新点、分割三角形）<br>            3）更新顶点的位置，参照上面的更新方法；<br>            结合图示理解<img src="https://raw.githubusercontent.com/Yes-ys/blog-images/main/Computer-Graphic/p27.png" alt="通过分割、翻转边完成loop细分">；<br>    <strong>CatMull-Clark细分</strong>：<br>        场景：针对多边形网格，多用于四边形网格；<br>        方法：<br>            1）<strong>计算面点</strong>：<br>                为该面所有顶点位置的算数平均；<br>            2）<strong>计算边点</strong>：<br>                为该边的两个端点位置和相邻两个面的面面点，这四个点的算数平均；<br>            3）连接面点与相邻的边点，让<strong>一个四边形被划分为四个四边形</strong>；<br>            4）计算旧顶点的新位置：<br>                $v &#x3D; \frac{Q+2R+(n-3)S}{n}$；<br>                其中：<br>                    1）v为原始v点的新位置；<br>                    2）Q为原始点相邻面点的算数平均；<br>                    3）R为原始点相邻边点的算数平均；<br>                    4）S为原始点的坐标；<br>            注意：<br>                1）计算旧顶点的新位置的时候，本轮产生的面点和边点仅管已经通过连接变成顶点了，但是它们的位置不会再次更新；<br>                2）在下一轮中这些新的边点、面点会作为旧的顶点使用；<br>        一些讨论：<strong>CatMull-Clark细分与非四边形面、奇异点</strong><br>            1）一轮CatMull-Clark细分之后所有的非四边形面都会变成四边形面；<br>            2）但是奇异点始终保持不变（并且第一轮细分可能产生新的奇异点，例如初始三角形面的面点，细分后度数为3）；<br>            3）随着细分的不断进行，奇异点会被越来越多的四边形面隔离，最终曲面收敛到光滑曲面；<br>    网格简化：<br>        边塌陷：<br>            将边缩拢，两个端点变成一个，原来与两个端点相邻的边均与这一个点相邻；<br>        贪心算法：<br>            1）给每条边一个成本；<br>            2）每次对成本最小的边进行塌陷；<br>            3）重复知道简化到指定的元素（点&#x2F;边&#x2F;面）数目；</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">初始网格（包含三角形、四边形、五边形等）</span><br><span class="line">     ↓ 第一次细分</span><br><span class="line">所有面变为四边形，但产生奇异顶点</span><br><span class="line">     ↓ 第二次细分</span><br><span class="line">奇异顶点保持不变，但被更多规则四边形包围</span><br><span class="line">     ↓ 后续细分</span><br><span class="line">奇异顶点越来越被隔离，大部分区域变成规则四边形网格</span><br></pre></td></tr></table></figure>

<h2 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h2><p>阴影贴图：<br>    思想：不在阴影中的点必须同时被光源和相机看到；<br>    方法：<br>        第一步：从光源的“眼睛”看世界 - 生成深度快照（阴影贴图）<br>            1）将虚拟摄像机放在光源的位置，对准需要投射阴影的场景。像普通渲染一样，计算从光源到场景中每个可见点的距离（即深度值）。<br>            2）我们不关心这个点是什么颜色、什么材质，只关心它的深度。我们将这个深度值渲染到一张纹理（即阴影贴图）上。<br>            3）结果：这张阴影贴图本质上就是一张深度照片，记录了从光源视角看，离它最近的物体表面的深度信息。可以把它想象成光源的“记忆”——“我记得在这个方向上，最近的物体离我有多远”。<br>        第二步：从摄像机的眼睛看世界 - 进行深度比较<br>            1）现在回到我们正常的观察视角（摄像机视角）。对于屏幕上要渲染的每一个像素点P（对应世界空间中的一个点），我们需要判断它是否在阴影中。<br>            2）坐标变换：将点P的3D世界坐标，变换到第一步中光源的摄像机空间中。这样我们就得到了点P在光源视角下的坐标 (x_light, y_light, z_light)。<br>            3）投影与采样：将 (x_light, y_light) 归一化到纹理坐标，用它去采样第一步生成的阴影贴图，得到光源记忆中该方向上的最近深度值 d_map。<br>            4）深度比较：比较点P自己的深度 z_light 和阴影贴图记录的深度 d_map。<br>            如果 z_light &gt; d_map：说明点P比光源“记住”的最近表面还要远。这意味着在点P和光源之间有一个更近的物体挡住了光。点P在阴影中。<br>            5）如果 z_light ≈ d_map （在考虑一个微小偏差bias后）：说明点P就是光源“看见”的那个最近表面。点P被照亮。<br>    缺点：<br>        1）生成的是硬阴影，仅限于点光源；<br>        2）质量取决于阴影贴图的分辨率；<br>        3）涉及浮点深度的相等比较；<br>    优点：<br>        1）不需要知道场景的几何信息；</p>
<h2 id="光线追踪"><a href="#光线追踪" class="headerlink" title="光线追踪"></a>光线追踪</h2><p><code>光线、包围盒、求交，可能会出大题</code></p>
<p>使用光线追踪的原因：<br>    光栅化不能很好的处理全局信息，尤其是在光线在场景中多次弹射的时候：<br>        1）没有软阴影，是硬阴影；<br>        2）虽然效率高但是质量较差；</p>
<p>计算机图形学中对光线传播的假设：<br>    1）光线沿直线传播；<br>    2）光线交叉不会相互碰撞；<br>    3）光线从光源光源传播到眼睛；<br>    注意：<br>        前面两条在物理上实际上是错误的，最后一条在物理上是正确的（路径可逆）</p>
<p><strong>光线投射算法Ray Casting算法</strong>：<br>    1）从<strong>视点或者像素出发</strong>，仅<strong>对穿过像素的光线反向追踪</strong>；<br>    2）当光线路径到达一个 离视点<strong>最近</strong>的 <strong>可见</strong>的 <strong>不透明</strong>物体的表面，则找到了屏幕上该像素对应的可见面；<br>    3）<strong>停止追踪</strong>；<br>    （缺点是没有考虑光线的反射和折射，阴影的判别实际上就和阴影贴图类似）<br>    <img src="https://raw.githubusercontent.com/Yes-ys/blog-images/main/Computer-Graphic/p30.png" alt="光线投射算法">；</p>
<p><strong>递归的光线追踪算法Whitted-Style光线</strong>追踪：<br>    基本思想：作为<strong>光线投射算法的延伸</strong>，通过<strong>追踪多条光线</strong>在场景中的路径，得<strong>到多个表面所产生的反射和折射</strong>的影响；<br>    基本过程：<br>        1）沿着<strong>到达视点的光线的相反方向</strong>追踪；<br>        2）经过屏幕上一像素点找到与视线所<strong>相交的物体表面点P0</strong>；<br>        3）<strong>继续追踪</strong>，找到影响P0处光强度所有光源；<br>        4）算出<strong>P0处精确的光线强度</strong>；<br>        5）<strong>结束条件</strong>：<br>            1）光线与<strong>光源相交</strong>；<br>            2）光线与<strong>漫反射表面相交</strong>；<br>            3）被追踪光线对第一个表面交点的<strong>光强贡献度趋近于0</strong>；<br>        <img src="https://raw.githubusercontent.com/Yes-ys/blog-images/main/Computer-Graphic/p31.png" alt="递归的光线追踪算法">；</p>
<p>上述光线追踪算法的一个关键点：光线与物体求交；<br>    注意：<br>        一般的求交过程，是将光线与场景中所有物体尝试求交之后，对所有得到的交点排序，才能确定可见点；<br>        （传统的做法中，大部分工作量用在了求交上，因此求交的方法是我们优化的关键）；</p>
<p>光线求交：<br>    光线的定义：<br>        1）原点o；<br>        2）方向向量d；<br>        得到定义：光线上任意一点的计算公式 $r(t) &#x3D; o+td,0 \le t \l ∞$;<br>    光线与球面求交：<br>        将光线上一点带入球面方程求解；<br>        <img src="https://raw.githubusercontent.com/Yes-ys/blog-images/main/Computer-Graphic/p29.png" alt="光线与球面求交"><br>    光线与隐式曲面求交：<br>        和与球面求交类似；<br>    <strong>光线与三角形网格求交</strong>：<br>        基本思路：考虑光线与每一个三角形求交；<br>        <strong>方法一</strong>：<br>            1）光线与三角形所在平面求交点；（平面也有自己的方程，和与球面求交类似）；<br>            2）判断交点是否在三角形内部（参考前面有很多方法）；<br>        <strong>方法二</strong>：<br>            直接利用重心坐标建立方程：<br>                $o + td &#x3D; (1-b_1-b_2)P_0+b_1 P_1 + b_2 P_2$<br>            如果：$0 &lt; b_1,b_2,1-b_1-b_2&lt;1$ 则光线与三角形相交；<br>        注意：<br>            方法二刚快，但是本质上两个方法是一样的，只是在重心坐标建立的方程中三角形的三个点又同时表征了平面；<br>    问题：<br>        1）光线与三角形网格求交是图形渲染管线中的常态；<br>        2）简单的光线求交方法，判断一条光线与哪个三角形网格相交，需要将这条光线与所有三角形求交，然后排序判断；<br>        3）问题的规模是：$像素数量 \times 三角形数量 \times 弹射数量(若有)$<br>            （对于一条光线就已经到这个规模了，很慢，需要加速！）；</p>
<p>光线追踪的加速技术<br>    本质：就是提升光线与场景中物体求交的效率；<br>    包围盒：<br>        思想：<br>            1）包围盒是包围物体的简单形体，与该简单形体求交比较容易，并且如果光线不与包围盒相交那么光线一定不与物体相交；<br>            2）所以可以先与包围盒求交，如果测试相交的话再进一步检查是否与物体相交；<br>            （之前在光栅化的时候也用过包围盒，检查像素是否在三角形内，不用检查所有像素，只用检查包围盒内的）；<br>        <strong>二维情况下</strong>：<br>            1）物体的包围盒是一个矩形；<br>            2）分别写出两组对边所在的四条直线的参数方程；<br>            3）将光线上一点的参数方程r(t)代入 “宽对边” 求解方程得到$t_{min}^1$和$t_{max}^1$，代入 “长对边” 求解得到 $t_{min}^2$和$t_{max}^2$；<br>            4）计算<strong>射入参数</strong> $t_{enter} &#x3D; max{t_{min}^i}$ 和<strong>射出参数</strong> $t_{exit} &#x3D; min{t_{max}^i}$<br>            根据<strong>射入参数和射出参数判断是否有交点</strong>：<br>                1）如果 $t_{exit} \ge 0$ 并且 $t_{exit} &gt; t_{enter}$ 说明有交点；<br>                2）在满足上述条件基础上，如果：<br>                    1）$t_{enter} \le 0$，则<strong>光源在物体内部</strong>；<br>                    2）$t_{exit},t_{enter} \g 0$，则<strong>物体在光源前方</strong>；<br>                3）如果 $t_{exit} \l 0$，则<strong>物体在光源后面，没有交点</strong>；<br>                （注意光线是一条射线）；<br>        三维情况下：<br>            与二维情况方法完全一致，只是有两对边所在四条直线的参数方程，换成了三对平板所在的六个平面的参数方程；<br>        <img src="https://raw.githubusercontent.com/Yes-ys/blog-images/main/Computer-Graphic/p32.png" alt="包围盒求交">；</p>
<p>利用AABB加速光线追踪<br>    空间划分层次包围盒：<br>        <strong>均匀格子Grid</strong>：<br>            <strong>构建</strong><br>            1）确定包围盒，使用一个大包围盒包围所有物体；<br>            2）构建均匀网络；<br>            3）将物体存储在与物体重叠的相应网格中；<br>                （注意这里只考虑<strong>物体表面</strong>）；<br>            4）光线与场景<strong>求交</strong>，按照光线穿过方向逐步遍历网格，对于每一个网格测试光线与存储在网格中的所有对象是否相交；<br>            问题：<br>                加速情况取决于分辨率的设置：<br>                    1）一个网格不存在加速；<br>                    2）过多的网格会由于无关网格的遍历导致效率低下；<br>                    3）只有恰当的网格分辨率才能加速；<br>                        启发式规则：网格数 &#x3D; C<em>物体数；（三维空间中C通常取27）；<br>                不适用于空间比较空旷，物体对象比较少的情况；<br>            适用：<br>                场景中存在大量物体，并且它们的大小和空间分布都比较均匀；<br>        <strong>KD-tree</strong>：<br>            <strong>构建</strong><br>            1）确定包围盒；<br>            2）按照二叉树的方式不断划分包围盒：（<em>下面是上课图例的参考</em>）<br>                一个节点代表一个空间；<br>                从初始开始按照分左右、分上下的顺序交替进行；<br>                当前节点如果是分左右，则左孩子分到左边的空间，右孩子分到右边的空间；<br>                当前节点如果是分上下，则左孩子分到上面的空间，右孩子分到下面的空间；<br>            3）划分完成后的空间中存储被空间覆盖到的物体对象；<br>            4）<strong>光线求交</strong>：<br>                遍历二叉树：<br>                    1）对于中间节点对应的包围盒，求交；<br>                    2）如果相交的话，则向下遍历其左孩子、右孩子；<br>                    3）直到：<br>                        1）发现不与当前中间节点的包围盒相交，结束这一分支的遍历；<br>                        2）发现遍历到了叶节点，则与其中所有的对象做相交测试；<br>            <strong>使用的数据结构</strong>：<br>                1）中间节点<br>                    ➢ 按照<strong>沿x轴、y轴、z轴的划分平面来划分</strong><br>                    ➢ 指向孩子节点的指针<br>                    ➢ 不存储空间中的物体<br>                2）叶子节点<br>                    ➢ 存储空间中的物体<br>        空间划分中存在问题：<br>            1）一个物体可能出现在多个叶子节点中（被划分到多个空间中）；<br>            2）</em>不好与三角形求交吗？*<br>    物体划分：<br>        <strong>层次包围盒</strong>：<br>            <strong>构建</strong><br>            1）确定一个大的包围盒；<br>            2）递归地将物体划分为两部分并重新计算包围盒；<br>                划分节点：<br>                    1）选择一个维度做划分；<br>                        通常可以选择最长轴方向做划分，选择中间物体位置做划分；<br>                        这时要用到排序，时间复杂度O(nlogn)，或者求第k小的元素，时间复杂度O(n)；<br>            3）停止后将物体存储在每一个叶子节点中；<br>                停止条件：当节点包含足够少的物体的时候，这一支就停止；<br>            4）光线<strong>求交</strong><br>                1）递归的遍历层次包围盒；<br>                2）如果是中间节点则求交，不相交则退出；<br>                3）如果相交进一步遍历在其基础上划分的层次包围盒；<br>                4）直到与叶子节点的包围盒相交，然后对其中所有物体做相交测试；<br>                5）最终返回的是一个最近的交点；<br>            <strong>数据结构</strong>：<br>                中间节点<br>                    ➢ 存储包围盒<br>                    ➢ 指向孩子节点的指针<br>                • 叶子节点<br>                    ➢ 存储包围盒<br>                    ➢ 存储空间中的物体<br>    <strong>两种方法对比</strong>：<br>        <strong>空间划分</strong>：<br>            1）空间划分的<strong>区域是不重叠</strong>的；<br>            2）同一<strong>物体可能在不同的空间</strong>中；<br>        <strong>层次包围盒</strong>：<br>            1）划分的区域是<strong>有重叠</strong>的；<br>            2）同一<strong>物体不会出现在不同空间</strong>中，因为划分结果的叶子节点包含的物体集合对应是原始集合的不相交的子集；     </p>
<p>计算机动画基本技术<br>    关节骨骼：运动学使用的对象<br>        关节骨骼：<br>            1）拓扑（连接关系）<br>            2）关节的几何关系；<br>            3）树形结构（没有环）；<br>        关节类型：<br>            1）Pin（1维旋转）；<br>            2）Ball（2维旋转）；<br>            3）Prismatic joint（平移）；<br>    <strong>正向运动学</strong>：基于关节骨骼进行的<br>        方法：<br>            1）动<strong>画师</strong>提供<strong>角度</strong>，<strong>计算机</strong>计算关节<strong>末端的位置</strong>；<br>            2）动画被描述为<strong>关于时间的角度参数值的函数</strong>；<br>        优点：<br>            1）<strong>直接控制</strong>，非常方便；<br>            2）很直观，<strong>容易实现</strong>；<br>        缺点：<br>            1）动画可能与<strong>物理规律不一致</strong>；<br>            2）艺术家需要花费<strong>大量时间</strong>；<br>    <strong>逆向运动学</strong>：基于关节骨骼进行的；<br>        方法：<br>            1）动画师提供关节<strong>末端位置</strong>；<br>            2）计算机给出<strong>满足约束条件的关节角度</strong>；<br>        缺点：实现比较困难<br>            1）可能存在<strong>多个解</strong>，满足末端位置，但是关节状态完全不同；<br>            2）可能<strong>无解</strong>；<br>    动画绑定：<br>        动画绑定是一组更高级别的<strong>对动画角色的控制操作</strong>，允许更快速和直观的修改姿势、变形、表情等；<br>        缺点：应用代价较高<br>            1）<strong>人力成本高</strong>；<br>            2）对艺术造诣和技术能力都有较高要求；<br>    动作捕捉：<br>        <strong>动画捕捉</strong>是利用<strong>数据驱动</strong>的方式来创建动画序列：<br>            1）记录<strong>真实世界中人的行为</strong>；<br>            2）从<strong>收集到的数据中提取姿态</strong>，生成关于<strong>时间的函数</strong>；<br>        优点：<br>            1）能够快速收集到<strong>大量真实数据</strong>；<br>            2）生成的动画<strong>真实程度高</strong>；<br>        缺点：<br>            1）需要<strong>复杂和昂贵的前期配置</strong>；<br>            2）捕获的动画可能不满足艺术要求，还需要<strong>后期修改</strong>；<br>        常见的动作捕捉设备：<br>            1）基于光学；<br>            2）基于感应磁场；<br>            3）直接测量关节角度；</p>

		</div>

		<!-- Comments removed -->
		
	</article>

	<div id="toc">
		
	</div>

</div>

<!-- <div id="paginator"> -->
<!-- 	 -->
<!-- </div> -->
<!-- page.mathjax == true修改为true，默认开启-->

    
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
          tex2jax: {
            inlineMath: [ ['$','$'], ["\\(","\\)"] ],
            processEscapes: true
          }
        });
      </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
            tex2jax: {
              skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
            }
          });
      </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
              var all = MathJax.Hub.getAllJax(), i;
              for(i=0; i < all.length; i += 1) {
                  all[i].SourceElement().parentNode.className += ' has-jax';
              }
          });
    </script>

    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>



			</div>
		</div>

		<div id="bottom-outer">
			<div id="bottom-inner">
				Site by 阳生 | 
				Powered by <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a> |
				theme <a target="_blank" rel="noopener" href="https://github.com/fireworks99/hexo-theme-PreciousJoy">PreciousJoy</a>
			</div>
		</div>

		
	</div>





	
	<!-- scripts list from theme config.yml -->
	
	<script src="/js/jquery-3.5.1.min.js"></script>
	
	<script src="/js/PreciousJoy.js"></script>
	
	<script src="/js/highlight.pack.js"></script>
	
	<script src="/js/jquery.fancybox.min.js"></script>
	
	<script src="/js/search.js"></script>
	
	<script src="/js/load.js"></script>
	
	<script src="/js/jquery.mCustomScrollbar.concat.min.js"></script>
	
	<script src="/js/clipboard.min.js"></script>
	
	

	<script>hljs.initHighlightingOnLoad();</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>
