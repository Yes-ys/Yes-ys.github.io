


<!DOCTYPE html>
<html lang="ch">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
	<title>分布式计算框架MapReduce [ 代码和诗 ]</title>
	
	
	<!-- stylesheets list from _config.yml -->
	
	<link rel="stylesheet" href="/css/PreciousJoy.css">
	
	<link rel="stylesheet" href="/css/top-bar.css">
	
	<link rel="stylesheet" href="/css/menu-outer.css">
	
	<link rel="stylesheet" href="/css/content-outer.css">
	
	<link rel="stylesheet" href="/css/bottom-outer.css">
	
	<link rel="stylesheet" href="/css/atom-one-dark.css">
	
	<link rel="stylesheet" href="/css/recent-posts-item.css">
	
	<link rel="stylesheet" href="/css/article-sidebar-toc.css">
	
	<link rel="stylesheet" href="/css/jquery.fancybox.min.css">
	
	<link rel="stylesheet" href="/css/search.css">
	
	<link rel="stylesheet" href="/css/toc.css">
	
	<link rel="stylesheet" href="/css/sidebar.css">
	
	<link rel="stylesheet" href="/css/archive.css">
	
	<link rel="stylesheet" href="/css/jquery.mCustomScrollbar.min.css">
	
	<link rel="stylesheet" href="/css/Z-last-cover-others.css">
	
	
	
<meta name="generator" content="Hexo 7.3.0"></head>




<body id="wrapper">

	<div id="">
		
		<div id="top-bar">
			
			<div id="avatar-box">
				<img 
				class="avatar"
				src="/images/my-avatar.jpg" //网站头像
				alt="avatar">
			</div>

			<div id="top-bar-text">
				<div id="top-bar-title">
					阳生。
				</div>
				<div id="top-bar-slogan">
					风毛丛劲节，只上尽头竿。
				</div>
			</div>

		</div>

		<div id="menu-outer">
			<div id="menu-inner">
				
				
				<div class="menu-item">
					<a href="/">Home</a>
				</div>
				
				<div class="menu-item">
					<a href="/about">About</a>
				</div>
				
				<div class="menu-item">
					<a href="/archives">Archives</a>
				</div>
				

				<div class="menu-item menu-item-search">
					
  <span class="local-search local-search-google local-search-plugin">
      <input type="search" placeholder="站内搜索" id="local-search-input" class="local-search-input-cls" style="">
      <div id="local-search-result" class="local-search-result-cls"></div>
  </span>
	
				</div>

			</div>
		</div>

		<div id="content-outer">
			<div id="content-inner">

				
<div id="details">
	
	<article id="details-post">
		<div id=details-post-item>
			<h1>分布式计算框架MapReduce</h1>
			<p><code>这篇blog用于记录我在学习计算机系统工程导论时所做的一次实验。我阅读了一篇论文，其介绍了一种名为MapReduce的模型，它通过键值对来拆解任务同时并行地处理子任务，达到了提高数据吞吐率从而降低时延提高性能的效果。</code></p>
<h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><p>主要实验目的如下：</p>
<ol>
<li>通过实验，理解MapReduce框架的基本原理，掌握MapReduce框架的Map阶段和Reduce阶段的执行流程，以及数据的划分、传输和聚合过程，具备使用MapReduce进行简单的分布式数据处理，并能通过进一步自学进行更为复杂的分布式数据处理，从而掌握使用MapReduce进行大数据处理的基本系统设计能力。</li>
<li>通过程序验证，理解性能优化中的并发技术对时延和吞吐率的影响，掌握用并发技术提升系统性能的设计思想。</li>
<li>通过观察分析，理解系统的可并行性与不可并行性的差异，理解工程实践中的并行不完备问题，通过思考该问题，训练理解和处理工程实践冲突和设计实现差异的思维能力。</li>
<li>通过实验准备和作业提交过程中的论文查阅（MapReduce2004），<br>逐步掌握外文专业文献的检索、学习和应用能力。</li>
</ol>
<h2 id="实验过程与习题"><a href="#实验过程与习题" class="headerlink" title="实验过程与习题"></a>实验过程与习题</h2><h3 id="2-1-WordCount"><a href="#2-1-WordCount" class="headerlink" title="2.1 WordCount"></a>2.1 WordCount</h3><h4 id="问题1：WordCount的-init-方法的参数是maptask和reducetask，简单地解释一下这两个变量都控制了什么？"><a href="#问题1：WordCount的-init-方法的参数是maptask和reducetask，简单地解释一下这两个变量都控制了什么？" class="headerlink" title="问题1：WordCount的__init__方法的参数是maptask和reducetask，简单地解释一下这两个变量都控制了什么？"></a>问题1：WordCount的__init__方法的参数是maptask和reducetask，简单地解释一下这两个变量都控制了什么？</h4><p>maptask指定了Map阶段的并行任务数（原始数据分块数），在MapReduce模型中会将数据先进行分块处理，然后在每一块上运行一个Map任务，所以这个参数也间接决定了每一个Map任务需要处理的数据量大小。</p>
<p>reducetask指定了Reduce阶段的并行任务数（中间数据分区数），在模型中会先对Map任务处理完成的中间键值对数据进行分区，在每一个区上运行一个Reduce任务，这个参数也间接决定了每个Reduce任务需要处理的数据量大小。</p>
<p>由run方法中线程池使用了这两个参数来启动线程可知，如下图所示。</p>
<p>如图1所示</p>
<h4 id="问题2：简要解释调用run如何触发对WordCount实例的map和reduce方法的调用"><a href="#问题2：简要解释调用run如何触发对WordCount实例的map和reduce方法的调用" class="headerlink" title="问题2：简要解释调用run如何触发对WordCount实例的map和reduce方法的调用"></a>问题2：简要解释调用run如何触发对WordCount实例的map和reduce方法的调用</h4><p>WordCount类继承了MapReduce类，使用<code>wc.run()</code>调用了run方法；</p>
<p>在run方法中使用<code>Pool</code>创建了进程池，并添加了相应的进程数量；</p>
<p>根据maptask、reducetask启动了相应数量的Map和Reduce任务，对应为<code>doMap()</code>和<code>doReduce()</code>函数；（这两个函数相当于MapReduce模型中map和reduce工作结点在调用用户的Map、Reduce函数前所进行的预处理操作）</p>
<p>在doMap函数中调用了<code>Map()</code>，在doReduce函数中调用了<code>Reduce()</code>即WordCount实例的map和reduce方法；</p>
<p>综上，通过run触发了WordCount实例的map和reduce方法的调用。</p>
<p>doMap、doReduce调用Map、Reduce的位置如下图所示。</p>
<p>如图2所示</p>
<h3 id="Map和Reduce"><a href="#Map和Reduce" class="headerlink" title="Map和Reduce"></a>Map和Reduce</h3><h4 id="问题3：WordCount中map方法的参数keyvalue和value代表什么？"><a href="#问题3：WordCount中map方法的参数keyvalue和value代表什么？" class="headerlink" title="问题3：WordCount中map方法的参数keyvalue和value代表什么？"></a>问题3：WordCount中map方法的参数keyvalue和value代表什么？</h4><p>keyvalue代表了当前处理的数据块对应的文本起始位置在整个文本文件中的偏移量。</p>
<p>因为<code>keyvalue = f.readline()</code>，而前面进行Split处理的时候，将整个文本文件按块分割为了多个中间文件，中间文件的起始行由<code>f.write(str(i) + &quot;\n&quot;)</code>记录了当前的偏移<code>i</code>。</p>
<p>value代表了当前处理数据块对应的文本数据。</p>
<p>因为<code>value = f.read()</code>，读取了相应的文本数据赋值给value。</p>
<p>keyvalue、value的赋值情况如下图所示</p>
<p>如图3所示</p>
<h4 id="问题4：WordCount中reduce方法的参数key和keyvalues代表什么？"><a href="#问题4：WordCount中reduce方法的参数key和keyvalues代表什么？" class="headerlink" title="问题4：WordCount中reduce方法的参数key和keyvalues代表什么？"></a>问题4：WordCount中reduce方法的参数key和keyvalues代表什么？</h4><p>每个reduce任务会将自己处理的数据区的键值对按照键聚集起来形成集合，并进行排序。</p>
<p>key代表了当前处理的是第几个键值对集合，keyvalues代表了当前处理的键值对集合中的各个键值对。</p>
<p>注：这里使用“集合”只是形象的表述，由于单词计数的任务特征，实际上同一键值对集合中的各个“元素”都是完全相同的键值对，<code>(str,1)</code>，所以这里的“集合”并不具有“互异性”</p>
<p>key、keyvalues的赋值情况如下图所示。</p>
<p>如图4所示</p>
<h3 id="Map和Reduce的并行"><a href="#Map和Reduce的并行" class="headerlink" title="Map和Reduce的并行"></a>Map和Reduce的并行</h3><h4 id="问题5：doMap有多少调用，doReduce有多少调用？为什么？"><a href="#问题5：doMap有多少调用，doReduce有多少调用？为什么？" class="headerlink" title="问题5：doMap有多少调用，doReduce有多少调用？为什么？"></a>问题5：doMap有多少调用，doReduce有多少调用？为什么？</h4><p>doMap有maptask次调用，doReduce有reducetask次调用。</p>
<p>因为在run方法中，通过线程池的map函数分别按照<code>range(0,self.maptask)</code>和<code>range(0,self.reducetask)</code>分发了maptask个doMap调用、reducetask个doReduce调用。</p>
<h4 id="问题6：假设有足够的内核，哪些调用是并行运行的？"><a href="#问题6：假设有足够的内核，哪些调用是并行运行的？" class="headerlink" title="问题6：假设有足够的内核，哪些调用是并行运行的？"></a>问题6：假设有足够的内核，哪些调用是并行运行的？</h4><p>假设内核是足够的，所有的doMap调用是并行的、所有的doReduce调用是并行的；doMap与doReduce两种调用之间是串行的。</p>
<p>因为doMap由线程池管理的线程一一调用，doReduce同理；而在所有doMap完成之后才开始由线程池管理调用。</p>
<h4 id="问题7：对于maptask和reducetask参数的值，哪一个影响到了程序的运行时间？为什么有的参数不会对程序的运行时间产生影响？（可以通过在代码中创建开始时间和结束时间来计算程序运行时间）"><a href="#问题7：对于maptask和reducetask参数的值，哪一个影响到了程序的运行时间？为什么有的参数不会对程序的运行时间产生影响？（可以通过在代码中创建开始时间和结束时间来计算程序运行时间）" class="headerlink" title="问题7：对于maptask和reducetask参数的值，哪一个影响到了程序的运行时间？为什么有的参数不会对程序的运行时间产生影响？（可以通过在代码中创建开始时间和结束时间来计算程序运行时间）"></a>问题7：对于maptask和reducetask参数的值，哪一个影响到了程序的运行时间？为什么有的参数不会对程序的运行时间产生影响？（可以通过在代码中创建开始时间和结束时间来计算程序运行时间）</h4><p>maptask和reducetask的值理论上都会影响到程序运行的时间。如果有其中之一不会对程序的运行时间产生影响，我认为原因是当前这个参数并非程序运行时间的瓶颈所在。例如当reducetask决定Reduce阶段才是任务执行的瓶颈的时候，增加maptask的数量并不会显著加快程序运行的时间，例如下图中的<strong>2个maptask，2个reducetask和4个maptask，2个reducetask</strong>情况下的对照，可以说明这个问题。</p>
<p>图5（2个maptask，2个reducetask运行情况）</p>
<p>图6（4个maptask，2个reducetask运行情况）</p>
<p>图7（2个maptask，4个reducetask运行情况）</p>
<p>图8（4个maptask，4个reducetask运行情况）</p>
<p>图9（8个maptask，8个reducetask运行情况）</p>
<h2 id="遇到的问题及解决办法"><a href="#遇到的问题及解决办法" class="headerlink" title="遇到的问题及解决办法"></a>遇到的问题及解决办法</h2><p>在进行本次实验的过程中，我主要遇到了以下几个问题：</p>
<ol>
<li><p>在探究WordCount中Map方法的参数keyvalue的时候，我不太理解这个参数存在的意义。虽然通过Split分割文本时，记录了相应的偏移，再在doMap阶段将偏移读入了keyvalue，最终在调用用户的Map的时候将keyvalue传递给了Map方法，但是Map方法并没有使用到keyvalue。所以起初，我认为这个参数没必要存在。后来，我与同学进行了一些讨论，我们发现在MapReduce的文献中，描述该模型的工作规范时，有类似这样的陈述“被分配 map 任务的工作节点读取对应输入分片的内容。它从输入数据中解析出键&#x2F;值对，并将每个对传递给用户定义的 Map 函数。Map 函数产生的中间键&#x2F;值对被缓存在内存中。”于是，我们认为，此处的keyvalue、value对应的正是map任务工作结点解析产生的键值对，后续Map函数将在value中进一步解析产生中间键值对。于是，我们认为此处虽然没有用到keyvalue，但是这是<strong>模型的思想所在</strong>，应当予以规范地保留。</p>
</li>
<li><p>在探究问题7的时候，对于maptask、reducetask的大小和任务执行的快慢，似乎有一些合不上，因为起初我认为应该两个任务分配得越多，并行越多，执行越快。但是可以看到在8个maptask，8个reducetask的情况下，执行时间却是最慢的。于是我查阅相关资料，了解到，这可能有以下几种原因：1）与我的内核数有关，如果系统内核数小于进程数，则会带来频繁地上下文切换，进一步增大时延（这或许就是为什么分配任务数最多的时候，反而最慢的原因）2）Map阶段的输出需要传递给Reduce阶段，如果并行的任务数增加，可能带来更加频繁地数据交换，从而造成I&#x2F;O瓶颈，增大时延（这可能是我单独增大reducetask时，运行变慢的原因）3）最后这个原因比较有趣，我开始完全没有考虑过，即任务之间的负载均衡问题，如果分配数量过多，可能导致有的任务几乎没有数据处理，但是仍然占用了相关的计算机资源，在资源有限的情况下，实际工作的任务分配到的资源减少，同样也会造成执行时间变慢。</p>
</li>
</ol>
<h2 id="课后实验与思考（选做）"><a href="#课后实验与思考（选做）" class="headerlink" title="课后实验与思考（选做）"></a>课后实验与思考（选做）</h2><p>我在原始代码的基础上，新增了一个ReverseIndex类用于替代原来的WordCount类，并在其中添加了类似于先前的Map、Reduce方法。Map方法的主要更改是形成的键值对是(word,offset)，而不再是用于计数的(word,1)，在Reduce中会对中间键值对进行处理，返回的是一个(word,sorted(list))，list中是同一word的各个offset，并且按照从小到大进行了排序。最后再简单处理一下结果，按照word的字典序（a~z），输出前二十组(word,sorted(list))。得到如下图所示的结果。</p>
<p>结果如图10所示</p>
<h2 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h2><p>通过本次实验，在阅读MapReduce文献的基础上，我进一步地理解了这个模型的工作方式，其通过Map、Reduce来便捷地实现任务的并行是模型思想的核心所在，尤其是理解了先前阅读文献时不太理解的map工作阶段、reduce工作阶段和用户的Map、Reduce函数之间的关系以及具体是怎样工作的。此外我还学习到了一些有关Python的知识，例如线程池管理下的简单的多线程编程，还有有关Python类之间继承关系与函数复用的知识。最后我通过课后实验与思考，增强了自己的Python编码能力，同时进一步熟悉了MapReduce的工作方式，收获颇丰。</p>

		</div>

		<!-- 来必力City版安装代码 -->
<div id="lv-container" data-id="city" data-uid="MTAyMC80NjIyNC8yMjczNQ==">
	<script type="text/javascript">
   (function(d, s) {
       var j, e = d.getElementsByTagName(s)[0];

       if (typeof LivereTower === 'function') { return; }

       j = d.createElement(s);
       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
       j.async = true;

       e.parentNode.insertBefore(j, e);
   })(document, 'script');
	</script>
<noscript> 为正常使用来必力评论功能请激活JavaScript</noscript>
</div>
<!-- City版安装代码已完成 -->
		
	</article>

	<div id="toc">
		
	</div>

</div>

<!-- <div id="paginator"> -->
<!-- 	 -->
<!-- </div> -->


			</div>
		</div>

		<div id="bottom-outer">
			<div id="bottom-inner">
				Site by 阳生 | 
				Powered by <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a> |
				theme <a target="_blank" rel="noopener" href="https://github.com/fireworks99/hexo-theme-PreciousJoy">PreciousJoy</a>
			</div>
		</div>

		
	</div>





	
	<!-- scripts list from theme config.yml -->
	
	<script src="/js/jquery-3.5.1.min.js"></script>
	
	<script src="/js/PreciousJoy.js"></script>
	
	<script src="/js/highlight.pack.js"></script>
	
	<script src="/js/jquery.fancybox.min.js"></script>
	
	<script src="/js/search.js"></script>
	
	<script src="/js/load.js"></script>
	
	<script src="/js/jquery.mCustomScrollbar.concat.min.js"></script>
	
	<script src="/js/clipboard.min.js"></script>
	
	

	<script>hljs.initHighlightingOnLoad();</script>

</body>
</html>
