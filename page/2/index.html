


<!DOCTYPE html>
<html lang="ch">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
	<title> [ 代码和诗 ]</title>
	
	
	<!-- stylesheets list from _config.yml -->
	
	<link rel="stylesheet" href="/css/PreciousJoy.css">
	
	<link rel="stylesheet" href="/css/top-bar.css">
	
	<link rel="stylesheet" href="/css/menu-outer.css">
	
	<link rel="stylesheet" href="/css/content-outer.css">
	
	<link rel="stylesheet" href="/css/bottom-outer.css">
	
	<link rel="stylesheet" href="/css/atom-one-dark.css">
	
	<link rel="stylesheet" href="/css/recent-posts-item.css">
	
	<link rel="stylesheet" href="/css/article-sidebar-toc.css">
	
	<link rel="stylesheet" href="/css/jquery.fancybox.min.css">
	
	<link rel="stylesheet" href="/css/search.css">
	
	<link rel="stylesheet" href="/css/toc.css">
	
	<link rel="stylesheet" href="/css/sidebar.css">
	
	<link rel="stylesheet" href="/css/archive.css">
	
	<link rel="stylesheet" href="/css/jquery.mCustomScrollbar.min.css">
	
	<link rel="stylesheet" href="/css/Z-last-cover-others.css">
	
	
	
<meta name="generator" content="Hexo 7.3.0"></head>




<body id="wrapper">

	<div id="">
		
		<div id="top-bar">
			
			<div id="avatar-box">
				<img 
				class="avatar"
				src="/images/my-avatar.jpg" //网站头像
				alt="avatar">
			</div>

			<div id="top-bar-text">
				<div id="top-bar-title">
					阳生。
				</div>
				<div id="top-bar-slogan">
					风毛丛劲节，只上尽头竿。
				</div>
			</div>

		</div>

		<div id="menu-outer">
			<div id="menu-inner">
				
				
				<div class="menu-item">
					<a href="/">Home</a>
				</div>
				
				<div class="menu-item">
					<a href="/about">About</a>
				</div>
				
				<div class="menu-item">
					<a href="/archives">Archives</a>
				</div>
				

				<div class="menu-item menu-item-search">
					
  <span class="local-search local-search-google local-search-plugin">
      <input type="search" placeholder="站内搜索" id="local-search-input" class="local-search-input-cls" style="">
      <div id="local-search-result" class="local-search-result-cls"></div>
  </span>
	
				</div>

			</div>
		</div>

		<div id="content-outer">
			<div id="content-inner">

				

<div id="recent-posts-box">

  
  <div id="recent-posts">
    <!-- <h1>Recent Posts</h1> -->
    
    
    <div class="recent-post-item">

      <a href="/2025/09/01/DFS-DP%E5%88%B7%E9%A2%98%E7%BB%83%E4%B9%A0/" class="item-title">DFS&amp;DP刷题练习</a>
      
      <time datetime="2025-09-01T07:52:59.000Z">
        2025-09-01
      </time>
      
      <!-- <div class="article-digest"> -->
        <!-- 在通过网上一些资料稍微系统学习了一下DFS相关的内容，还有初步接触了一些DP的基础知识之后，我开这篇blog用来记录我刷相关的练习题的思路
打家劫舍 Ⅱ leetcode213第一版代码是错误的。
我的思路是，现在房屋形成了一个环，我可以任意枚举一个位置入手，把环剪开，此时还原成房屋是一排的情况，然后套用Ⅰ的dp模板就可以了。
这样做的问题在于，dp模板在新的一排房屋上，相当于状态树是从i+1的位置开始的，但是dp模板是套用在从0开始的。也就是说状态树结点上前后结点的值有严格的依赖，任意剪切环，形成的数组，从前往后的dp并不对应原始数据的状态树。
以下是第一版代码：
123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution &#123;public:    int ans = 0;    int rob(vector&lt;int&gt;&amp; nums) &#123;        if(nums.size() == 1)return  -->
        <!-- </div> -->

        
        <p><code>在通过网上一些资料稍微系统学习了一下DFS相关的内容，还有初步接触了一些DP的基础知识之后，我开这篇blog用来记录我刷相关的练习题的思路</code></p>
<h2 id="打家劫舍-Ⅱ-leetcode213"><a href="#打家劫舍-Ⅱ-leetcode213" class="headerlink" title="打家劫舍 Ⅱ leetcode213"></a>打家劫舍 Ⅱ leetcode213</h2><p>第一版代码是错误的。</p>
<p>我的思路是，现在房屋形成了一个环，我可以任意枚举一个位置入手，把环剪开，此时还原成房屋是一排的情况，然后套用Ⅰ的dp模板就可以了。</p>
<p>这样做的问题在于，dp模板在新的一排房屋上，相当于状态树是从i+1的位置开始的，但是dp模板是套用在从0开始的。也就是说状态树结点上前后结点的值有严格的依赖，任意剪切环，形成的数组，从前往后的dp并不对应原始数据的状态树。</p>
<p>以下是第一版代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() == <span class="number">1</span>)<span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums.size() == <span class="number">2</span>)<span class="keyword">return</span> max(nums[<span class="number">1</span>],nums[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums.size() == <span class="number">3</span>)<span class="keyword">return</span> max(nums[<span class="number">2</span>],max(nums[<span class="number">1</span>],nums[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; nums.size();i++)&#123;</span><br><span class="line">            <span class="type">int</span> cnt = nums[i];</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> b1 = i,b2 = (i<span class="number">-1</span>+nums.size())%nums.size(),b3 = (i+<span class="number">1</span>)%nums.size();</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; t;</span><br><span class="line">            t.clear();</span><br><span class="line">            <span class="comment">// for(int j = 0;j &lt; nums.size();j++)</span></span><br><span class="line">            <span class="comment">//     if(j != b1&amp;&amp;j != b2&amp;&amp;j != b3)t.push_back(nums[j]); 这样简单粗暴的构造t没有考虑到环断开之后，首位相接的情况</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i+<span class="number">2</span>;j &lt; nums.size();j++)</span><br><span class="line">                t.push_back(nums[j]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; i<span class="number">-1</span>;j++)</span><br><span class="line">                t.push_back(nums[j]);</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(t.size() == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(ans &lt; t[<span class="number">0</span>]+cnt)ans = t[<span class="number">0</span>]+cnt;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(t.size() == <span class="number">2</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(ans &lt; max(t[<span class="number">0</span>],t[<span class="number">1</span>])+cnt) ans = max(t[<span class="number">0</span>],t[<span class="number">1</span>])+cnt;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> new_f,f0 = t[<span class="number">0</span>],f1 = t[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">2</span>;j &lt; t.size();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                new_f = max(f1,f0+t[j]);</span><br><span class="line">                f0 = f1;</span><br><span class="line">                f1 = new_f;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(new_f + cnt &gt; ans)ans = new_f + cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>正确的思路是只从第一个位置把环剪开，枚举偷第一个位置，不偷第一个位置；</p>
<p>我最开始想到从任意位置剪开环，其实是相当于在选不选的子集模板中，不从第一个数开始考虑，从任意的数字开始考虑。看似是为了“考虑所有情况”，实际上打乱了状态树的状态，按照从前往后依次考虑选不选本就能够把所有状态考虑进去。而这道题只是在此基础上多了一个，第一个位置要特殊考虑，它会衍生出两种情况，就第一个位置的特殊考虑而言已经完备，分别在两种情况中直接使用“从前往后选或不选”的思想，也是完备的，综合来看可以考虑所有情况，而不会打乱状态树，可以套用dp模板。否则只会像我的第一版思路，打乱了状态树，还套用dp模板，只会造成错误（这样的错误在某种程度上来说，就是我改变了某些房屋的位置，改变了它们的相邻关系。）</p>
<p>修改后的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() == <span class="number">1</span>)<span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums.size() == <span class="number">2</span>)<span class="keyword">return</span> max(nums[<span class="number">1</span>],nums[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums.size() == <span class="number">3</span>)<span class="keyword">return</span> max(nums[<span class="number">2</span>],max(nums[<span class="number">1</span>],nums[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> new_f = <span class="number">0</span>, f1 = <span class="number">0</span>, f0 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//选第一个房屋</span></span><br><span class="line">        <span class="comment">// f0 = nums[2+0], f1 = max(nums[2+0],nums[2+1]);</span></span><br><span class="line">        <span class="comment">// if(4 == nums.size() &amp;&amp; nums[0]+f0 &gt; ans)ans = nums[0]+f0;</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// for(int j = 2+2;j &lt; nums.size() - 1;j++)</span></span><br><span class="line">        <span class="comment">// &#123;</span></span><br><span class="line">        <span class="comment">//     new_f = max(f1,f0+nums[j]);</span></span><br><span class="line">        <span class="comment">//     f0 = f1;</span></span><br><span class="line">        <span class="comment">//     f1 = new_f;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// if(new_f+nums[0] &gt; ans) ans = new_f+nums[0]; 注意选第一个房屋不一定要偷第一个房屋，我的代码就错在了这里！</span></span><br><span class="line"></span><br><span class="line">        f0 = nums[<span class="number">0</span>],f1 = max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">2</span>;j &lt; nums.size()<span class="number">-1</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            new_f = max(f1,f0+nums[j]);</span><br><span class="line">            f0 = f1;</span><br><span class="line">            f1 = new_f;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(new_f &gt; ans) ans = new_f;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//不选第一个房屋</span></span><br><span class="line">        f0 = nums[<span class="number">1</span>+<span class="number">0</span>], f1 = max(nums[<span class="number">1</span>+<span class="number">0</span>],nums[<span class="number">1</span>+<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>+<span class="number">2</span>;j &lt; nums.size();j++)</span><br><span class="line">        &#123;</span><br><span class="line">            new_f = max(f1,f0+nums[j]);</span><br><span class="line">            f0 = f1;</span><br><span class="line">            f1 = new_f;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(new_f &gt; ans) ans = new_f;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我在写这版代码开始的时候又犯了一个错误，选第一间房屋的意思是要考虑第一间，而不是一定会偷第一间；实际上选第一间与否代表着参与递推计算的索引范围不同，也是考虑的房屋范围不同。但是确定了范围之后使用递推计算的过程，对应的才是考虑实际要不要偷的问题。</p>
<h2 id="删除并获得点数"><a href="#删除并获得点数" class="headerlink" title="删除并获得点数"></a>删除并获得点数</h2><p>题干：</p>
<p>给你一个整数数组 nums ，你可以对它进行一些操作。</p>
<p>每次操作中，选择任意一个 nums[i] ，删除它并获得 nums[i] 的点数。之后，你必须删除 所有 等于 nums[i] - 1 和 nums[i] + 1 的元素。</p>
<p>开始你拥有 0 个点数。返回你能通过这些操作获得的最大点数。</p>
<p>我的思路：</p>
<p>这道题和打家劫舍有一点像，不过其取走i处的元素后不能再取的并不直接是i-1，i+1处的元素，而是元素值等于nums[i]+1和nums[i]-1处的元素。</p>
<p>首先，我想尽量还原回打家劫舍的场景，看是否能套用模板。于是我想到了<strong>排序</strong>，排完序之后，对于ban掉的位置而言，根据元素值的+1、-1会比较接近直接根据下标值的+1、-1。</p>
<p>于是我考虑直接使用dfs的模板，回溯三问：</p>
<ol>
<li>当前问题考虑能从0~i位置获取到的最大值，当前操作，是否选择位置i的元素</li>
<li>子问题，如果选择了位置i的元素，那么考虑0<del>j位置获取到的最大值，其中j是从i-1开始，第一个不满足nums[j]+1 &#x3D;&#x3D; nums[i]的元素的下标；如果没有选择位置i的元素，那么考虑0</del>i-1位置能获取到的最大元素</li>
<li>子问题的操作，如果…，是否选择位置j的元素；如果…是否选择位置i-1处的元素</li>
</ol>
<p>然而上面存在一个问题，即第2步的时候：“对于j是，第一个不满足nums[j]+1 &#x3D;&#x3D; nums[i]的元素的下标”，如果nums[i] !&#x3D; nums[i-1]的话这是正确的，换言之，如果存在相同元素，那么索引范围的缩减会出现错误，误以为已经缩减成剔除了nums[j]+1 &#x3D;&#x3D; nums[i]对应的元素nums[j]，但实际上没有剔除。</p>
<p>所以为了回溯三问对应的思路是正确的，我们要确保没有相同元素的存在；又因为我们要取得最大值，所以你如果选择了一个nums[i]，那么剩下的相同值的元素你都应该选；于是我想到了用一个哈希表，以nums[i]为key，value存储所有值为nums[i]的元素的和；然后将nums更新，使得重复的元素只保留一个，再排序；最后套用回溯三问的思路即可。</p>
<p>代码实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; mp;</span><br><span class="line">    <span class="type">int</span> cnt[<span class="number">20000</span>];</span><br><span class="line">    <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">0</span>)<span class="keyword">return</span> mp[nums[<span class="number">0</span>]];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i<span class="number">-1</span>]+<span class="number">1</span> == nums[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(cnt[i] != <span class="number">-1</span>)<span class="keyword">return</span> cnt[i];</span><br><span class="line">                cnt[i] = max(dfs(i<span class="number">-1</span>,nums),dfs(i<span class="number">-2</span>,nums)+mp[nums[i]]);</span><br><span class="line">                <span class="keyword">return</span> cnt[i];</span><br><span class="line">            &#125;   </span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(cnt[i] != <span class="number">-1</span>)<span class="keyword">return</span> cnt[i];</span><br><span class="line">                cnt[i] = dfs(i<span class="number">-1</span>,nums)+mp[nums[i]];</span><br><span class="line">                <span class="keyword">return</span> cnt[i];</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">deleteAndEarn</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; nums.size();i++)</span><br><span class="line">            mp[nums[i]]+=nums[i];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; t;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it = mp.begin();it != mp.end();it++)</span><br><span class="line">            t.push_back(it-&gt;first);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; t.size();i++)cnt[i] = <span class="number">-1</span>;</span><br><span class="line">        sort(t.begin(),t.end());</span><br><span class="line">        <span class="keyword">return</span> dfs(t.size()<span class="number">-1</span>,t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="统计构造好字符串的方案数-leetcode-2466"><a href="#统计构造好字符串的方案数-leetcode-2466" class="headerlink" title="统计构造好字符串的方案数 leetcode 2466"></a>统计构造好字符串的方案数 leetcode 2466</h2><p>题干：</p>
<p>给你整数 zero ，one ，low 和 high ，我们从空字符串开始构造一个字符串，每一步执行下面操作中的一种：</p>
<ol>
<li>将 ‘0’ 在字符串末尾添加 zero  次。</li>
<li>将 ‘1’ 在字符串末尾添加 one 次。<br>以上操作可以执行任意次。</li>
</ol>
<p>如果通过以上过程得到一个 长度 在 low 和 high 之间（包含上下边界）的字符串，那么这个字符串我们称为 好 字符串。</p>
<p>请你返回满足以上要求的 不同 好字符串数目。由于答案可能很大，请将结果对 109 + 7 取余 后返回。</p>
<p>我的第一种思路，试一试dfs，枚举每次选zero还是选one即可，时间复杂度显然是$O(2^n)$，不出所料超时了…但是正确性是有保证的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans;</span><br><span class="line">    <span class="type">int</span> low,high,zero,one;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> M = <span class="number">1000000007</span>;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> len)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(len &gt; high)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(len &gt;= low)ans = (ans+<span class="number">1</span>)%M;</span><br><span class="line"></span><br><span class="line">        dfs(len+zero);</span><br><span class="line">        dfs(len+one);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">countGoodStrings</span><span class="params">(<span class="type">int</span> low, <span class="type">int</span> high, <span class="type">int</span> zero, <span class="type">int</span> one)</span> &#123;</span><br><span class="line">        this-&gt;low = low, this-&gt;high = high, this-&gt;zero = zero, this-&gt;one = one;</span><br><span class="line">        dfs(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>改进的思路是添加记忆化。换一个视角，其实这就是爬楼梯的翻版，每次可以选择爬zero或one阶，爬到x in [low,high]，的方案总和有多少。于是可以写出如下记忆化递归：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> M = <span class="number">1000000007</span>;</span><br><span class="line">    <span class="type">int</span> zero,one;</span><br><span class="line">    <span class="type">int</span> cnt[<span class="number">100001</span>];</span><br><span class="line">    <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> len)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//得到空串的方案数是1</span></span><br><span class="line">        <span class="keyword">if</span>(len &lt; <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(cnt[len] != <span class="number">-1</span>)<span class="keyword">return</span> cnt[len];</span><br><span class="line">        <span class="keyword">else</span> cnt[len] = (dfs(len-zero)+dfs(len-one))%M;</span><br><span class="line">        <span class="keyword">return</span> cnt[len];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">countGoodStrings</span><span class="params">(<span class="type">int</span> low, <span class="type">int</span> high, <span class="type">int</span> zero, <span class="type">int</span> one)</span> &#123;</span><br><span class="line">        this-&gt;zero = zero,this-&gt;one = one;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= high;i++)cnt[i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = low;i &lt;= high;i++)</span><br><span class="line">            ans = (ans + dfs(i))%M;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>有两个关键点</p>
<ol>
<li>递归的边界条件，dfs(i)代表爬i阶的方案数，所以dfs(0) &#x3D;&#x3D; 1，可以理解成爬0阶就是一种方案，或者理解为递归从i到0的时候，0是整个下台阶尝试成功的一条分支，所以返回1；而i&lt;0的情况就是尝试失败的分支，所以返回0</li>
<li>最后的ans累加的是dfs(i)，low&lt;&#x3D; i &lt;&#x3D;high，虽然我们的dfs(i)本身代表的是爬上i阶的方案，并且在cnt中进行了记忆化，但是对于i的不同初态，能够递归到的情况是不同的；所以不能直接dfs(high)，然后ans累加cnt[i]，i in [low, high]（例如low &#x3D; 4，high &#x3D; 5，zero &#x3D; 2，one &#x3D; 2，如果从high开始，dfs(4)并不会被递归到）</li>
</ol>
<p><strong>第二个关键点是我第一次遇见</strong>，这算是一种在递归中初态会影响后续分支选择的情况，值得着重注意。</p>
<h2 id="组合总和"><a href="#组合总和" class="headerlink" title="组合总和"></a>组合总和</h2><p>题干：</p>
<p>给你一个由 不同 整数组成的数组 nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数。（元素可以重复选取）</p>
<p>题目数据保证答案符合 32 位整数范围。</p>
<p>我的思路：仍然可以看成爬楼梯的变式，这次要爬的楼梯数是固定的，但是每次的选择有nums.size()种。dfs枚举每一次每一种选，然后加一个记忆化即可。基本上就是直接套板子了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cnt[<span class="number">1001</span>];</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i &lt; <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(cnt[i] != <span class="number">-1</span>)<span class="keyword">return</span> cnt[i];</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; nums.size();j++)</span><br><span class="line">                res += dfs(i - nums[j]);</span><br><span class="line">            cnt[i] = res;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">combinationSum4</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt;= target;i++)cnt[i] = <span class="number">-1</span>;</span><br><span class="line">        this-&gt;nums = nums;</span><br><span class="line">        <span class="keyword">return</span> dfs(target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="统计打字方案数"><a href="#统计打字方案数" class="headerlink" title="统计打字方案数"></a>统计打字方案数</h2><p>爬楼梯的变式，可以看成楼梯是由数字标定的不同种类，有这样几个关键的条件限制</p>
<ol>
<li>一次只能爬一种台阶</li>
<li>对于7、9标定的台阶，一次最多爬4阶；其它数字对应的台阶一次最多爬3阶</li>
</ol>
<p>在此基础上，从dfs(-1)开始，代表还没有爬任何一阶（因为string从0开始索引就代表第一阶了）；然后开始爬楼梯，使用check()检查当前位置可以爬几阶，例如可以爬3阶的时候就是dfs(i) &#x3D; dfs(i+1)+dfs(i+2)+dfs(i+3)，向下递归即可；边界条件是i &#x3D;&#x3D; str.length()-1，即i已经索引到了最后一个字符，也就是爬上了最高的台阶。</p>
<p>最后再引入一个记忆化即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="type">int</span> cnt[<span class="number">100001</span>];</span><br><span class="line">    <span class="type">int</span> tlen[<span class="number">100001</span>];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> i)</span>&#123;<span class="comment">//确定可以上几个台阶</span></span><br><span class="line">        <span class="type">int</span> len = <span class="number">1</span>;<span class="comment">//至少上一阶，不会有上0阶的情况，因为在dfs中以到最后一阶（i == str.length()-1）为边界条件</span></span><br><span class="line">        <span class="keyword">if</span>(len + i == str.length() - <span class="number">1</span>)<span class="keyword">return</span> len;<span class="comment">//上一阶就到最后一阶了</span></span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> t = str[i + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(t == <span class="string">&#x27;7&#x27;</span> || t == <span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(;(len + i != str.length())&amp;&amp;(str[len + i] == str[i + <span class="number">1</span>]);len++);</span><br><span class="line">            <span class="keyword">return</span> min(len<span class="number">-1</span>,<span class="number">4</span>);<span class="comment">//最多上4阶</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(;(len + i != str.length())&amp;&amp;(str[len + i] == str[i + <span class="number">1</span>]);len++);</span><br><span class="line">            <span class="keyword">return</span> min(len<span class="number">-1</span>,<span class="number">3</span>);<span class="comment">//最多上3阶</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == str.length()<span class="number">-1</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i &gt;= <span class="number">0</span> &amp;&amp; cnt[i] != <span class="number">-1</span>)<span class="keyword">return</span> cnt[i];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">-1</span>)len = check(i);</span><br><span class="line">        <span class="keyword">else</span> len = tlen[i];</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= len;j++)</span><br><span class="line">            res = (res + dfs(i+j))%<span class="number">1000000007</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(i &gt;= <span class="number">0</span>)cnt[i] = res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">countTexts</span><span class="params">(<span class="built_in">string</span> pressedKeys)</span> &#123;</span><br><span class="line">        this-&gt;str = pressedKeys;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; str.length();i++)cnt[i] = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; str.length()<span class="number">-1</span>;i++)</span><br><span class="line">            tlen[i] = check(i);</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但是这样记忆化搜索会被最后几个非常庞大的样例卡住，时间大概是擦边不能过的样子…</p>
<p>参考了题解之后，这道题应该直接用dp，虽然dp和记忆化搜索在一般情况下认为时间大差不差，但是这种时间擦边不能过的情况，记忆化搜索稍微比dp多出来的一点时间就成为掣肘的关键了。</p>
<p>改dp的思路：</p>
<ol>
<li>打标计算只有一类台阶的情况，爬到第i阶的时候有多少种方案</li>
<li>再中间台阶类型变换的时候使用乘法原理处理</li>
</ol>
<p>转移方程参考爬楼梯的模板dp[i] &#x3D; dp[i-1] + dp[i-2]，不难理解。 </p>
<p>代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> dp1[<span class="number">100001</span>];<span class="comment">//dp1[i]代表在全是一类台阶的情况下，爬到i的方案数</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> dp2[<span class="number">100001</span>];<span class="comment">//dp2[i]代表在全是二类台阶的情况下，爬到i的方案数</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> M = <span class="number">1000000007</span>;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">ini</span><span class="params">()</span>&#123;</span><br><span class="line">        dp1[<span class="number">0</span>] = <span class="number">1</span>,dp1[<span class="number">1</span>] = <span class="number">1</span>,dp1[<span class="number">2</span>] = <span class="number">2</span>,dp1[<span class="number">3</span>] = <span class="number">4</span>;<span class="comment">//不爬；1；11、2；3、12、21、111；</span></span><br><span class="line">        dp2[<span class="number">0</span>] = <span class="number">1</span>,dp2[<span class="number">1</span>] = <span class="number">1</span>,dp2[<span class="number">2</span>] = <span class="number">2</span>,dp2[<span class="number">3</span>] = <span class="number">4</span>;<span class="comment">//同上</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//提前打好dp表，后续直接用</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">4</span>;i &lt; <span class="number">100001</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp1[i] = (dp1[i<span class="number">-1</span>] + dp1[i<span class="number">-2</span>] + dp1[i<span class="number">-3</span>])%M;</span><br><span class="line">            dp2[i] = (dp2[i<span class="number">-1</span>] + dp2[i<span class="number">-2</span>] + dp2[i<span class="number">-3</span>] + dp2[i<span class="number">-4</span>])%M;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">countTexts</span><span class="params">(<span class="built_in">string</span> pressedKeys)</span> &#123;</span><br><span class="line">        ini();</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">1</span>;<span class="comment">//最后的答案爬完这种楼梯的方案数，中间要用乘法处理，因为楼梯的类型会变化，乘的就是一种类型的楼梯爬了几个台阶</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; pressedKeys.length();)&#123;</span><br><span class="line">            <span class="type">int</span> j;</span><br><span class="line">            <span class="keyword">for</span>(j = i+<span class="number">1</span>;j &lt; pressedKeys.length() &amp;&amp; pressedKeys[j] == pressedKeys[i];j++);<span class="comment">//注意边界情况，最后爬到最高的台阶应该是第pressedKeys.length()阶，而不是按照索引去减1；可以想想里面具体有多少字符</span></span><br><span class="line">            <span class="keyword">if</span>(pressedKeys[i] == <span class="string">&#x27;7&#x27;</span> || pressedKeys[i] == <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">                ans = (ans * dp2[j - i])%M;</span><br><span class="line">            <span class="keyword">else</span> ans = (ans * dp1[j - i])%M;</span><br><span class="line">            i = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这道题给我最大的感受是，对于边界条件的设置，以及不同索引下dp数组的含义 or dfs递归的状态 要有清楚的认识，这样才不会乱。我被索引绕得有点晕写了好久…</p>
<h2 id="统计各位数字都不同的数字个数"><a href="#统计各位数字都不同的数字个数" class="headerlink" title="统计各位数字都不同的数字个数"></a>统计各位数字都不同的数字个数</h2><p>题干：</p>
<p>给你一个整数 n ，统计并返回各位数字都不同的数字 x 的个数，其中 0 &lt;&#x3D; x &lt; 10n 。</p>
<p>示例 1：</p>
<p>输入：n &#x3D; 2<br>输出：91<br>解释：答案应为除去 11、22、33、44、55、66、77、88、99 外，在 0 ≤ x &lt; 100 范围内的所有数字。</p>
<p>这道题换一个视角来看，就是有0<del>9，十张卡片，按照要求抽1</del>n张卡，求对应所有的排列情况之和（即抽1张卡时的排列情况+2张卡时的排列情况+…）。可以直接使用全排列；由于抽卡的数量是1~n，所以问题状态树上的每一个结点都对应增加一种情况，而不是完成抽卡之后才统计为一种情况。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">1</span>;<span class="comment">//一位的情况下可以有一个单独的0</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> r)</span>&#123;<span class="comment">//i是当前抽的第几个数字，r是当前剩余的数字数量</span></span><br><span class="line">        <span class="keyword">if</span>(i == n)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt; r;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                ans++;</span><br><span class="line">                dfs(<span class="number">1</span>,r<span class="number">-1</span>);<span class="comment">//第一个数字不能是0</span></span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; r;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                ans++;</span><br><span class="line">                dfs(i+<span class="number">1</span>,r<span class="number">-1</span>);</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">countNumbersWithUniqueDigits</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        this-&gt;n = n;</span><br><span class="line">        dfs(<span class="number">0</span>,<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意点是</p>
<ol>
<li>上面写的dfs递归不涵盖n &#x3D;&#x3D; 0的情况，所以ans初始时置为1；</li>
<li>然后n &#x3D;&#x3D; 1的时候由于n &#x3D;&#x3D; 0抽掉了1，所以只剩9张卡；而当n &gt; 1的时候，高位数字不能为0，所以第一次抽也只有9张卡，于是统一在dfs中有一个特殊处理，即i &#x3D;&#x3D; 0的情况</li>
</ol>
<h2 id="最小路径和"><a href="#最小路径和" class="headerlink" title="最小路径和"></a>最小路径和</h2><p>题干：</p>
<p>给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<p>说明：每次只能向下或者向右移动一步。</p>
<p>我的基本思路是这样的：</p>
<p>回溯三问：</p>
<ol>
<li>当前操作，是否选择要向右移动</li>
<li>当前子问题，要做k次选择，其中只能且必须选择i次向右，要求获得收益最少</li>
<li>子问题的下一个问题，情况1：如果选择了向右，那么还要做k-1次选择，只能且必须选择i-1次向右；如果没有选择向右，那么还要做k-1次选择，只能且必须选择i次向右</li>
</ol>
<p>关于边界条件：</p>
<ol>
<li>当i &#x3D;&#x3D; k的时候，剩余k次全部选择向右</li>
<li>当i &#x3D;&#x3D; 0的时候，剩余k此全部选择向下</li>
</ol>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; cnt;<span class="comment">//记录每一次的选择，1向右，0向下</span></span><br><span class="line">    <span class="type">int</span> memo[<span class="number">200</span>][<span class="number">400</span>];</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; grid;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">compute</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="number">0</span>,y = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> t = grid[x][y];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; cnt.size();i++)</span><br><span class="line">            <span class="keyword">if</span>(cnt[i] == <span class="number">1</span>)t += grid[x][++y];</span><br><span class="line">            <span class="keyword">else</span> t += grid[++x][y];</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == k)&#123;<span class="comment">//只能向右走了</span></span><br><span class="line">            <span class="keyword">if</span>(memo[i][k] != <span class="number">-1</span>)<span class="keyword">return</span> memo[i][k];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; k;j++)</span><br><span class="line">                cnt.push_back(<span class="number">1</span>);</span><br><span class="line">            <span class="type">int</span> res = compute();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; k;j++)</span><br><span class="line">                cnt.pop_back();</span><br><span class="line">            memo[i][k] = res;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;<span class="comment">//只能向下走了</span></span><br><span class="line">            <span class="keyword">if</span>(memo[i][k] != <span class="number">-1</span>)<span class="keyword">return</span> memo[i][k];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; k;j++)</span><br><span class="line">                cnt.push_back(<span class="number">0</span>);</span><br><span class="line">            <span class="type">int</span> res = compute();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; k;j++)</span><br><span class="line">                cnt.pop_back();</span><br><span class="line">            memo[i][k] = res;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(memo[i][k] != <span class="number">-1</span>)<span class="keyword">return</span> memo[i][k];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//选择向右走</span></span><br><span class="line">        cnt.push_back(<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> t1 = dfs(i<span class="number">-1</span>,k<span class="number">-1</span>);</span><br><span class="line">        cnt.pop_back();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//选择向下走</span></span><br><span class="line">        cnt.push_back(<span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> t2 = dfs(i,k<span class="number">-1</span>);</span><br><span class="line">        cnt.pop_back();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = min(t1,t2);</span><br><span class="line">        memo[i][k] = res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">minPathSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">200</span>;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; <span class="number">400</span>;j++)</span><br><span class="line">                memo[i][j] = <span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        this-&gt;grid = grid;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dfs(grid[<span class="number">0</span>].size()<span class="number">-1</span>,grid.size()+grid[<span class="number">0</span>].size()<span class="number">-2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但是这份代码出现了问题。</p>
<p>其实回溯三问的考量下的状态转移，以及递归的边界条件都没有问题，而状态是出现在记忆化上。</p>
<p><strong>来自deepseek的总结</strong>非常鞭辟入里</p>
<p>你的代码的基本思路是使用记忆化搜索（DFS + memoization），通过记录路径选择（<code>cnt</code> 向量）并在边界条件下计算完整路径和（<code>compute</code> 函数）。然而，错误的核心在于 <strong>记忆化设计不完整</strong>，导致在某些情况下错误地重用了记忆化值。具体原因如下：<br>记忆化键（memo[i][k]）不足以唯一标识状态</p>
<p>你的记忆化数组 memo[i][k] 使用两个参数：</p>
<ol>
<li>i：表示剩余需要向右走的步数。</li>
<li>k：表示总剩余步数（剩余向右步数 + 剩余向下步数）。</li>
</ol>
<p>在状态 (i, k) 下，理论上剩余路径是确定的（需要走 i 步向右和 k - i 步向下），但 (i, k) 没有捕获当前位置 (x, y) 或前缀路径的累积和。<br>问题在于，compute 函数计算的是 从起点 (0, 0) 开始的完整路径和，而不是从当前状态开始的剩余路径和。compute 使用全局 cnt 向量重建整个路径，但 cnt 包含了所有历史选择（从起点到当前点的路径）。因此：<br>相同的 (i, k) 状态可能从不同的位置 (x, y) 到达（例如，通过不同的路径前缀）。<br>由于起点到当前位置的前缀路径不同，compute 计算的完整路径和也会不同。<br>然而，你的记忆化只基于 (i, k) 存储结果，忽略了当前位置或前缀路径的影响。这会导致错误的重用：当从不同路径到达相同的 (i, k) 状态时，memo[i][k] 可能返回一个错误的完整路径和（该值依赖于之前计算时的前缀路径，而非当前路径）。</p>
<p>其实这本质上就是犯了我常犯的一个错误——<strong>将累积变量作为了参数传递</strong>，如果使用累积变量作为参数传递，通常是不能使用记忆化的；（看似我这里没有把它当作参数传递，但是本质上累积变量是到达边界的时候才进行计算的。）</p>
<p>进一步思考，我对于这个问题的考虑太过复杂了，其实没必要考虑“选择序列”是怎样的，直接将位置作为状态即可。</p>
<p>重新考虑回溯三问</p>
<ol>
<li>当前操作，在位置(x,y)，去到位置(x+1,y)还是位置(x,y+1)</li>
<li>当前子问题，在位置(x,y)，如何移动到终点，使得收益最小</li>
<li>当前子问题的下一个问题，1）在(x+1,y)如何移动到终点使得收益最小；2）在(x,y+1)如何移动到终点使得收益最小</li>
</ol>
<p>边界条件：</p>
<p>x &#x3D;&#x3D; g.size()-1 || y &#x3D;&#x3D; g.size()-1</p>
<p>状态转移：</p>
<p>dfs(x,y) &#x3D; min(dfs(x+1,y)+g[x+1][y],dfs(x,y+1)+g[x][y+1]) s.t. x !&#x3D; g.size()-1 &amp;&amp; y !&#x3D; g[0].size()-1<br>… s.t. x &#x3D;&#x3D; g.size()-1<br>… s.t. y &#x3D;&#x3D; g[0].size()-1</p>
<p>g[0][0]可以直接作为初始值，累加在答案上。</p>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> memo[<span class="number">200</span>][<span class="number">200</span>];</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; g;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == g.size() - <span class="number">1</span> &amp;&amp; y == g[<span class="number">0</span>].size() - <span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(memo[x][y] != <span class="number">-1</span>)<span class="keyword">return</span> memo[x][y];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(x == g.size() - <span class="number">1</span>)&#123;</span><br><span class="line">            memo[x][y] = dfs(x,y+<span class="number">1</span>) + g[x][y+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">return</span> memo[x][y];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(y == g[<span class="number">0</span>].size() - <span class="number">1</span>)&#123;</span><br><span class="line">            memo[x][y] = dfs(x+<span class="number">1</span>,y) + g[x+<span class="number">1</span>][y];</span><br><span class="line">            <span class="keyword">return</span> memo[x][y];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            memo[x][y] = min(dfs(x+<span class="number">1</span>,y) + g[x+<span class="number">1</span>][y],dfs(x,y+<span class="number">1</span>) + g[x][y+<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">return</span> memo[x][y];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">minPathSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">200</span>;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; <span class="number">200</span>;j++)</span><br><span class="line">                memo[i][j] = <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">        this-&gt;g =grid;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> g[<span class="number">0</span>][<span class="number">0</span>] + dfs(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样才能明显的看见，累积变量是在递归状态转移的过程中累加的，而没有作为参数处理。‘</p>
<h2 id="将石头分散到网格图的最少移动次数"><a href="#将石头分散到网格图的最少移动次数" class="headerlink" title="将石头分散到网格图的最少移动次数"></a>将石头分散到网格图的最少移动次数</h2><p>题干：</p>
<p>给你一个大小为 3 * 3 ，下标从 0 开始的二维整数矩阵 grid ，分别表示每一个格子里石头的数目。网格图中总共恰好有 9 个石头，一个格子里可能会有 多个 石头。</p>
<p>每一次操作中，你可以将一个石头从它当前所在格子移动到一个至少有一条公共边的相邻格子。</p>
<p>请你返回每个格子恰好有一个石头的 最少移动次数 。</p>
<p>我的思路：</p>
<ol>
<li>预处理，统计重叠石头的存在位置（注意是统计重叠了的石头，例如一个位置有3个石头要统计两次）；统计没有石头的位置</li>
<li>对存在石头的位置进行全排列，与没有石头的位置一一匹配，计算每一种情况的移动次数</li>
<li>保留最少的移动次数</li>
</ol>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Pos</span>&#123;</span></span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="type">int</span> y;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Pos&gt; a;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Pos&gt; b;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">100000000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;Pos&gt;&amp; cmb)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cmb.size() == b.size())&#123;</span><br><span class="line">            <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; cmb.size();i++)&#123;</span><br><span class="line">                cnt += (<span class="built_in">abs</span>(cmb[i].x - b[i].x) + <span class="built_in">abs</span>(cmb[i].y - b[i].y));</span><br><span class="line">            &#125;</span><br><span class="line">            ans = min(ans, cnt);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; a.size();i++)&#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">Pos</span> <span class="title">t</span> =</span> a[i];</span><br><span class="line">            cmb.push_back(t);</span><br><span class="line">            a.erase(a.begin()+i);</span><br><span class="line">            dfs(cmb);</span><br><span class="line">            a.insert(a.begin()+i,t);</span><br><span class="line">            cmb.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">minimumMoves</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; <span class="number">3</span>;j++)</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="class"><span class="keyword">struct</span> <span class="title">Pos</span> <span class="title">t</span>;</span></span><br><span class="line">                    t.x = i,t.y = j;</span><br><span class="line">                    b.push_back(t);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(grid[i][j] &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> k = grid[i][j]<span class="number">-1</span>;k &gt; <span class="number">0</span>;k--)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">struct</span> Pos t;</span><br><span class="line">                        t.x = i,t.y = j;</span><br><span class="line">                        a.push_back(t);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;Pos&gt; t;</span><br><span class="line">        dfs(t);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

        


        <span>
          <a class="article-read" href="/2025/09/01/DFS-DP刷题练习/"> Read more -->
          </span>
        </div>

        
    
    <div class="recent-post-item">

      <a href="/2025/08/30/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E6%95%B4%E7%90%86/" class="item-title">深度优先搜索整理</a>
      
      <time datetime="2025-08-30T03:28:38.000Z">
        2025-08-30
      </time>
      
      <!-- <div class="article-digest"> -->
        <!-- 这篇blog用来整理一些常见的可以使用深度优先搜索的问题模板
写在最前面在这篇blog中会高频地出现三个词汇，DFS、递归、回溯，实际上DFS与后二者的关联是十分密切的。
狭义上来说，DFS是在图上面做搜索的一种算法，它使用深度优先，依次处理各个结点。可以用递归函数的形式实现，也可以用循环+栈的形式实现。
但是从广义上来说，对于可以枚举状态的问题，问题的状态转移的过程本就可以抽象成一棵树，而树本质上就是一个特殊的图。当我们使用递归函数，搜索问题的各个状态的时候，就可以看作，我们是在一张“特殊的”图上，做DFS。
关于回溯与它们的联系，后面再进行补充。
基本范式DFS的模板框架如下：
1234567891011121314151617181920function dfs(now_state)&#123;    if(now_state == target_state)    &#123;        ...        return ...;    &#125;    for(... enumerate new_state)&#123;        if(new_state is  -->
        <!-- </div> -->

        
        <p><code>这篇blog用来整理一些常见的可以使用深度优先搜索的问题模板</code></p>
<h2 id="写在最前面"><a href="#写在最前面" class="headerlink" title="写在最前面"></a>写在最前面</h2><p>在这篇blog中会高频地出现三个词汇，<strong>DFS、递归、回溯</strong>，实际上DFS与后二者的关联是十分密切的。</p>
<p>狭义上来说，DFS是在图上面做搜索的一种算法，它使用深度优先，依次处理各个结点。可以用<strong>递归函数的形式</strong>实现，也可以用<strong>循环+栈</strong>的形式实现。</p>
<p>但是从广义上来说，对于可以枚举状态的问题，问题的状态转移的过程本就可以<strong>抽象成一棵树</strong>，而树本质上就是一个特殊的图。当我们使用递归函数，搜索问题的各个状态的时候，就可以看作，我们是在一张“特殊的”图上，做DFS。</p>
<p><em>关于回溯与它们的联系，后面再进行补充</em>。</p>
<h2 id="基本范式"><a href="#基本范式" class="headerlink" title="基本范式"></a>基本范式</h2><p>DFS的模板框架如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function <span class="title function_">dfs</span><span class="params">(now_state)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(now_state == target_state)</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> ...;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(... enumerate new_state)&#123;</span><br><span class="line">        <span class="keyword">if</span>(new_state is valid)&#123;</span><br><span class="line">            vis[new_state] = ...;<span class="comment">//标记新状态被访问</span></span><br><span class="line">            dfs(new_state);</span><br><span class="line">            ? vis[new_state] = ...;<span class="comment">//是否需要恢复现场</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(have considered all condition)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来的部分分几个主要的大类型，每个题目里都会附上对应的练习与解答，结合题目进行总结。</p>
<h2 id="DFS无需回溯"><a href="#DFS无需回溯" class="headerlink" title="DFS无需回溯"></a>DFS无需回溯</h2><p>DFS无需回溯的情况是少</p>
<h3 id="红与黑-AcWing-1113"><a href="#红与黑-AcWing-1113" class="headerlink" title="红与黑 AcWing 1113"></a>红与黑 AcWing 1113</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> h,w;</span><br><span class="line"><span class="type">char</span> mp[<span class="number">21</span>][<span class="number">21</span>];</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> vis[<span class="number">21</span>][<span class="number">21</span>],<span class="type">int</span> posx,<span class="type">int</span> posy)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">4</span>;i++)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="keyword">switch</span>(i)&#123;</span><br><span class="line">   <span class="keyword">case</span> <span class="number">1</span>:&#123;</span><br><span class="line">    <span class="type">int</span> x = posx,y = posy<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(y &gt;= <span class="number">0</span> &amp;&amp; !vis[x][y] &amp;&amp; mp[x][y] == <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">     vis[x][y] = <span class="number">1</span>;</span><br><span class="line">     cnt++;</span><br><span class="line">     <span class="built_in">dfs</span>(vis,x,y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">case</span> <span class="number">2</span>:&#123;</span><br><span class="line">    <span class="type">int</span> x = posx,y = posy<span class="number">+1</span>;</span><br><span class="line">    <span class="keyword">if</span>(y &lt; w &amp;&amp; !vis[x][y] &amp;&amp; mp[x][y] == <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">     vis[x][y] = <span class="number">1</span>;</span><br><span class="line">     cnt++;</span><br><span class="line">     <span class="built_in">dfs</span>(vis,x,y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">case</span> <span class="number">3</span>:&#123;</span><br><span class="line">    <span class="type">int</span> x = posx<span class="number">-1</span>,y = posy;</span><br><span class="line">    <span class="keyword">if</span>(x &gt;= <span class="number">0</span> &amp;&amp; !vis[x][y] &amp;&amp; mp[x][y] == <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">     vis[x][y] = <span class="number">1</span>;</span><br><span class="line">     cnt++;</span><br><span class="line">     <span class="built_in">dfs</span>(vis,x,y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">case</span> <span class="number">4</span>:&#123;</span><br><span class="line">    <span class="type">int</span> x = posx<span class="number">+1</span>,y = posy;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; h &amp;&amp; !vis[x][y] &amp;&amp; mp[x][y] == <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">     vis[x][y] = <span class="number">1</span>;</span><br><span class="line">     cnt++;</span><br><span class="line">     <span class="built_in">dfs</span>(vis,x,y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="type">int</span> vis[<span class="number">21</span>][<span class="number">21</span>];</span><br><span class="line"> <span class="type">int</span> posx = <span class="number">0</span>,posy = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; h;i++)</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; w;j++)</span><br><span class="line">  &#123;</span><br><span class="line">   vis[i][j] = <span class="number">0</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//寻找起点</span></span><br><span class="line">   <span class="comment">//cout&lt;&lt;&quot;mp[i][j]:&quot;&lt;&lt;mp[i][j]&lt;&lt;endl;</span></span><br><span class="line">   <span class="keyword">if</span>(mp[i][j] == <span class="string">&#x27;@&#x27;</span>)posx = i,posy = j; </span><br><span class="line">  &#125;</span><br><span class="line"> vis[posx][posy] = <span class="number">1</span>;</span><br><span class="line"> cnt = <span class="number">1</span>;</span><br><span class="line"> <span class="built_in">dfs</span>(vis,posx,posy);</span><br><span class="line"> cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> string str;</span><br><span class="line"> <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">  cin&gt;&gt;w&gt;&gt;h;</span><br><span class="line">  <span class="keyword">if</span>(w == <span class="number">0</span> &amp;&amp; h == <span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; h;i++)</span><br><span class="line">   &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; w;j++)</span><br><span class="line">     cin&gt;&gt;mp[i][j];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//输入完成 </span></span><br><span class="line">   <span class="built_in">solve</span>();</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意点：</p>
<ol>
<li>关于不需要回溯，<strong>我的一个理解</strong>：由于在每次搜索到的状态，更改的全局变量只有vis数组，而这个更改正是必须的（我们需要一个DFS分支更改的vis影响另一个DFS分支，来确定当前点是否已经到达过了），所以不需要进行回溯。<em>需要回溯的一种情况是，一个分支修改的全局变量对另一个分支没有作用，另一个分支不能直接使用，要自己修改，那么在一个分支结束的时候就应该还原自己修改的全局变量</em></li>
<li>关于不需要回溯，<strong>另一种理解</strong>：在一个分支下到达的每一个点，在这个分支结束过后就可以抛弃了，因为我们只是统计点的数量不需要再回到这个点；但是需要回溯的情况，例如走迷宫，你在尝试一种路径的时候走过一系列点，这些点不能被抛弃，你在尝试其它路径的时候可能还会来到这些点，所以在每一条路径结束的时候，要将标记访问的vis数组进行还原（具体如何还原见后面的笔记）。</li>
<li>注意io上的细节实现，由于有多轮数据，所以每轮开始要注意相关变量的初始化</li>
</ol>
<h2 id="DFS与回溯"><a href="#DFS与回溯" class="headerlink" title="DFS与回溯"></a>DFS与回溯</h2><h3 id="ACW分成互质组"><a href="#ACW分成互质组" class="headerlink" title="ACW分成互质组"></a>ACW分成互质组</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; g[<span class="number">11</span>];</span><br><span class="line"><span class="type">int</span> num[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(x%y == <span class="number">0</span>)<span class="keyword">return</span> y;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">return</span> gcd(y,x%y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line"> <span class="comment">//检查是否可以把数字i放在第j组</span></span><br><span class="line"> <span class="keyword">if</span>(g[j].empty())<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> <span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>;k &lt; g[j].size();k++)&#123;</span><br><span class="line">   <span class="keyword">if</span>(gcd(num[i],g[j][k]) != <span class="number">1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> num_g,<span class="type">int</span> now)</span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(now == n)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="type">int</span> i = now;</span><br><span class="line"> <span class="comment">//i对应当前正在处理数字的索引 </span></span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; num_g;j++)<span class="comment">//把它尝试放入各组中</span></span><br><span class="line"> &#123;</span><br><span class="line">  <span class="keyword">if</span>(check(i,j))&#123;<span class="comment">//如果可以放入第j组 </span></span><br><span class="line">   g[j].push_back(num[now]);</span><br><span class="line">   <span class="keyword">if</span>(dfs(num_g, now+<span class="number">1</span>))<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   <span class="keyword">else</span> g[j].pop_back();<span class="comment">//尝试放入失败 </span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">  <span class="built_in">cin</span>&gt;&gt;num[i];</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> num_g = <span class="number">1</span>;num_g &lt;= n;num_g++)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="keyword">if</span>(dfs(num_g,<span class="number">0</span>))&#123;</span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;num_g&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125; </span><br><span class="line">  </span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现的思路是从小到大枚举可能的组数，用DFS暴力搜索，把每个数字依次放入每个组的情况。</p>
<p>本题总结：</p>
<ol>
<li>DFS的主线是依次处理每个数字，每处理一个数字就进入到下一个状态，当n个数字处理完毕就可以结束了，当前使用的组数就是最小的组数</li>
<li>一个反思，在写DFS的时候要想清楚，每层深入的时候，对应的实际意义是什么。这里就是处理过的数字的数量增加。我开始的时候没有想清楚在dfs的for循环外面还套了一层遍历所有数字的循环，不明所以…</li>
<li>这里就要注意<strong>恢复现场</strong>，即g[j].pop_back()，也是回溯的体现，当一条分支尝试失败了要还原状态。否则当前分支存入第j组的数字，在其它分支总也会存在，显然就会有问题…</li>
</ol>
<h3 id="子集模板-子集-leetcode78"><a href="#子集模板-子集-leetcode78" class="headerlink" title="子集模板 子集 leetcode78"></a>子集模板 子集 leetcode78</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; &gt;ans;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; cmb, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == len)&#123;</span><br><span class="line">            ans.push_back(cmb);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cmb.push_back(nums[i]);</span><br><span class="line">        dfs(cmb,i+<span class="number">1</span>);</span><br><span class="line">        cmb.pop_back();</span><br><span class="line"></span><br><span class="line">        dfs(cmb,i+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; subsets(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        len = nums.size();</span><br><span class="line">        this-&gt;nums = nums;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; t;</span><br><span class="line">        dfs(t,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这道题可以完美地体现写在blog开头的那段话，问题的状态就是一棵二叉树，递归就是在其上做深搜。同样，回溯体现在还原现场。</p>
<p>上面代码的此题思路是，从<strong>每个数字</strong>的角度出发，依次考虑选与不选，当所有的数字都被考虑过一遍，我们就可以得到一种答案的组合。</p>
<p><strong>另一种思路</strong>是从<strong>答案的角度</strong>出发，依次考虑选择哪些数字，每做出一次选择本身就得到了一种答案。</p>
<p>而对于这种思路，当我们考虑过下标为i的数字选择后会从当前层向下递归产生分支；而在当前层，我们还会考虑下标大于i的数字，例如i+1对应的数字，选择它后又从当前层向下递归产生分支（记作分支1）；要避免后一条分支（记作分支2）与分支1重复。</p>
<p>即对于(1,2)的原始数组，第一层选择1后，产生分支1向下递归选择2，形成(1,2)；我们要避免第一层选择2后产生分支2向下递归形成(2,1)（这是重复的）</p>
<p><strong>规避重复</strong>的一种思路是，每层向下递归的时候 只能选择 下标 大于当前层已选数字下标 的数字 从而形成下面图片的效果：</p>
<p><img src="/../_images/Algorithm1/DFS1.png" alt="MyAlgorithm"></p>
<p><a href="!https://www.bilibili.com/video/BV1mG4y1A7Gu?spm_id_from=333.788.videopod.sections&vd_source=80df09f481ef5f0671e5e0e35d02e33e">参考视频教程</a></p>
<p>我们也可以将这两种思路概括为：</p>
<ol>
<li>选或者不选的思路</li>
<li>选哪个的思路<br>（这是常用的dfs思路，后续的组合、排列都会用到）</li>
</ol>
<h3 id="子集模板应用-分割回文串-leetcode-131"><a href="#子集模板应用-分割回文串-leetcode-131" class="headerlink" title="子集模板应用 分割回文串 leetcode 131"></a>子集模板应用 分割回文串 leetcode 131</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="title function_">check</span><span class="params">(<span class="built_in">string</span> s)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>,j = s.length()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(;i &lt; s.length() &amp;&amp; j &gt;= <span class="number">0</span>;i++,j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] != s[j])<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; ans;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; cmb, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == len<span class="number">-1</span>)&#123;<span class="comment">//当执行到应该判断最后一个位置是否要切割的时候</span></span><br><span class="line">            <span class="built_in">string</span> s = str.substr(j+<span class="number">1</span>,i-j);</span><br><span class="line">            <span class="keyword">if</span>(check(s))&#123;</span><br><span class="line">                cmb.push_back(s);</span><br><span class="line">                ans.push_back(cmb);</span><br><span class="line">                cmb.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> s = str.substr(j+<span class="number">1</span>,i-j);</span><br><span class="line">        <span class="keyword">if</span>(check(s))&#123;</span><br><span class="line">            cmb.push_back(s);</span><br><span class="line">            dfs(cmb, i+<span class="number">1</span>,i);</span><br><span class="line">            <span class="comment">//回溯</span></span><br><span class="line">            cmb.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dfs(cmb,i+<span class="number">1</span>,j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//切割是把当前位置的字符串和上一次切割位置后的字符串切出来</span></span><br><span class="line"><span class="comment">//i是当前考虑是否要切割的位置</span></span><br><span class="line"><span class="comment">//j是上一次进行切割的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; partition(<span class="built_in">string</span> s) &#123;</span><br><span class="line">        this-&gt;len = s.length();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; t;</span><br><span class="line">        this-&gt;str = s;</span><br><span class="line">        dfs(t, <span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这道题的思路是考虑所有可以切割子串的位置的状态，每个位置有两种状态，切或者不切；问题的状态就变成了一棵二叉树，DFS在树上做搜索，但是将一个位置设置为“切”的状态，需要判断得到的新子串是否是回文串，如果是才能切；最后一个位置必须切。</p>
<h3 id="组合模板-组合-leetcode-78"><a href="#组合模板-组合-leetcode-78" class="headerlink" title="组合模板 组合 leetcode 78"></a>组合模板 组合 leetcode 78</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="type">int</span> k,n;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> cnt,<span class="type">int</span> i,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; cmb)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt == k)&#123;</span><br><span class="line">            ans.push_back(cmb);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i+<span class="number">1</span>;j &lt;= n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cmb.push_back(j);</span><br><span class="line">            dfs(cnt+<span class="number">1</span>,j,cmb);</span><br><span class="line">            cmb.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; combine(<span class="type">int</span> n, <span class="type">int</span> k) &#123;</span><br><span class="line">        this-&gt;k = k;</span><br><span class="line">        this-&gt;n = n;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; t;</span><br><span class="line">        dfs(<span class="number">0</span>,<span class="number">0</span>,t);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面代码的实现思路是，在子集模板的第二种思路（站在答案的视角，考虑每个数字的选择）下加入一个已选择数字数量的判定，当选择的数字数量达到k个的时候就将答案记录下来，并停止向下递归。</p>
<h4 id="关于组合问题的剪枝"><a href="#关于组合问题的剪枝" class="headerlink" title="关于组合问题的剪枝"></a>关于组合问题的剪枝</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span>(n-i+cnt &lt; k)<span class="keyword">return</span>;<span class="comment">//剩下可选的数字+已经选择的数字 &lt; 需要选择的数字，可以直接return，因为最后必定没有结果（剪枝）</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在dfs的for循环之前加入这个判断，如果满足条件，最后一定无法选出指定数量的数字，也就没有继续递归的必要了，可以提前结束当前分支。</p>
<h3 id="组合模板应用-组合总和Ⅲ-leetcode-216"><a href="#组合模板应用-组合总和Ⅲ-leetcode-216" class="headerlink" title="组合模板应用 组合总和Ⅲ leetcode 216"></a>组合模板应用 组合总和Ⅲ leetcode 216</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> k,n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> cnt,<span class="type">int</span> i,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; cmb)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt == k &amp;&amp; accumulate(cmb.begin(),cmb.end(),<span class="number">0</span>) == n)&#123;</span><br><span class="line">            ans.push_back(cmb);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">9</span>-i+cnt &lt; k)<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i+<span class="number">1</span>;j &lt;= <span class="number">9</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cmb.push_back(j);</span><br><span class="line">            dfs(cnt+<span class="number">1</span>,j,cmb);</span><br><span class="line">            cmb.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; combinationSum3(<span class="type">int</span> k, <span class="type">int</span> n) &#123;</span><br><span class="line">        this-&gt;k = k;</span><br><span class="line">        this-&gt;n = n;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; t;</span><br><span class="line">        dfs(<span class="number">0</span>,<span class="number">0</span>,t);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="关于剪枝"><a href="#关于剪枝" class="headerlink" title="关于剪枝"></a>关于剪枝</h4><p>这道题除了和组合模板一样的剪枝，还有根据n进行的剪枝。主要是两种情况</p>
<ol>
<li>当前已经选择的数字数量不足k，但是其和已经大于n，最后递归下去其和必定大于n，剪枝</li>
<li>剩下的所有数字加上当前选择的所有数字 之和 小于n，最后递归下去其和必定小于n，剪枝</li>
</ol>
<p>为了方便剪枝的实现，可以选择维护一个当前已选数字之和的变量now_sum，具体实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> k,n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> cnt,<span class="type">int</span> i,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; cmb,<span class="type">int</span> now_sum)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt == k &amp;&amp; now_sum == n)&#123;</span><br><span class="line">            ans.push_back(cmb);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">9</span>-i+cnt &lt; k)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(now_sum &gt; n)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(now_sum+(i+<span class="number">10</span>)*(<span class="number">9</span>-i)/<span class="number">2</span> &lt; n)<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i+<span class="number">1</span>;j &lt;= <span class="number">9</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cmb.push_back(j);</span><br><span class="line">            dfs(cnt+<span class="number">1</span>,j,cmb,now_sum+j);</span><br><span class="line">            cmb.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; combinationSum3(<span class="type">int</span> k, <span class="type">int</span> n) &#123;</span><br><span class="line">        this-&gt;k = k;</span><br><span class="line">        this-&gt;n = n;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; t;</span><br><span class="line">        dfs(<span class="number">0</span>,<span class="number">0</span>,t,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>一个总结：组合模板上的剪枝是围绕要选择k个数字进行的，这一题又有了新的要求即k个数字的和要为n。这些要求都可以看作问题的约束，也就是说我们这两道题的剪枝都是围绕问题的约束展开的。所以以后在思考递归的剪枝的时候，可以考虑<strong>问题状态树上，从当前递归层的状态出发，判断之后的状态是否可以满足最终问题的各个约束，如果不能满足，那么就停止向下递归。</strong></p>
<p>而我们之所以能做出这样判断的原因，是因为问题状态具有的一些性质在转移的过程中如何发展是可以推知的。<em>就像这道题，一共9个数，你每次只选比上一次选择的数字更大的数字，当你选择了i，接下来你可以选择的数字个数一定是9-i</em>，这就是可以推知的状态。</p>
<h3 id="组合模板应用-括号生成-leetcode-22"><a href="#组合模板应用-括号生成-leetcode-22" class="headerlink" title="组合模板应用 括号生成 leetcode 22"></a>组合模板应用 括号生成 leetcode 22</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> nl,<span class="type">int</span> nr,<span class="built_in">string</span>&amp; str)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nl + nr == (n&lt;&lt;<span class="number">1</span>))&#123;</span><br><span class="line">            ans.push_back(str);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nl &lt; nr)<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nl &lt; n)&#123;</span><br><span class="line">            str += <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">            dfs(nl+<span class="number">1</span>,nr,str);</span><br><span class="line">            str.erase(str.end()<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nr &lt; n)&#123;</span><br><span class="line">            str += <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">            dfs(nl,nr+<span class="number">1</span>,str);</span><br><span class="line">            str.erase(str.end()<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title function_">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        this-&gt;n = n;</span><br><span class="line">        <span class="built_in">string</span> str;</span><br><span class="line">        dfs(<span class="number">0</span>,<span class="number">0</span>,str);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我解决这道题的思考过程：</p>
<ol>
<li>基本方法是套用子集模板，我们一共有n个左括号、n个右括号可以用，需要选择2n个括号，根据选择的顺序形成str，直接dfs到底，然后判断括号是否有效</li>
<li>考虑剪枝，约束是括号有效，考虑是否存在一些选择情况对应的状态已经无效，并且之后的状态也一定无效。存在这样的选择情况，那就是右括号比左括号先选择。只要有这种情况出现就可以剪枝</li>
</ol>
<p>关于实现</p>
<ol>
<li>剪枝的实现是可以维护nl、nr来记录已经选择的左右括号的数量，一旦nl小于nr就剪枝。</li>
<li>并且我注意到，递归的结束条件可以用nl+nr &#x3D;&#x3D; 2*n来实现；且只要nl始终大于等于nr，左括号一定可以被右括号抵消，最终的情况一定有效，也就不需要递归结束时的有效判断了</li>
<li>结合1、2两点，套用dfs的模板就可以解决问题</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> nl,<span class="type">int</span> nr,<span class="built_in">string</span>&amp; str)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nl + nr == (n&lt;&lt;<span class="number">1</span>))&#123;</span><br><span class="line">            ans.push_back(str);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nl &lt; nr)<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nl &lt; n)&#123;</span><br><span class="line">            str += <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">            dfs(nl+<span class="number">1</span>,nr,str);</span><br><span class="line">            str.erase(str.end()<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nr &lt; n)&#123;</span><br><span class="line">            str += <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">            dfs(nl,nr+<span class="number">1</span>,str);</span><br><span class="line">            str.erase(str.end()<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title function_">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        this-&gt;n = n;</span><br><span class="line">        <span class="built_in">string</span> str;</span><br><span class="line">        dfs(<span class="number">0</span>,<span class="number">0</span>,str);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="全排列模板-全排列-leetcode-46"><a href="#全排列模板-全排列-leetcode-46" class="headerlink" title="全排列模板 全排列 leetcode 46"></a>全排列模板 全排列 leetcode 46</h3><p>模板的思路基础是<strong>子集模板的第二种思路</strong>，在子集模板中，我们为了避免重复的选择，规定在选择第i个数字之后 产生的递归分支上，只能选择第i+1及以后的数字；而全排列不需要避免这种重复的选择，或者说<strong>这种重复的选择对全排列而言正是必要的</strong>，因为对于排列而言，选择的顺序不同 但 含有的元素相同 的子集是不同的。</p>
<p>于是问题的关键在于，每个分支如何知道自己当前可以选择哪些数字。</p>
<p>我的思路是用一个vis数组来记录当前分支的<strong>父状态</strong>选择过的数字，这些数字是不能选的。而其它分支选择过的数字，自己的父状态没有选择过的数字，这些分支是可以选择的。</p>
<p>按照这个思路实现的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; vis;</span><br><span class="line">    </span><br><span class="line">    <span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; cmb)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == len)&#123;</span><br><span class="line">            ans.push_back(cmb);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                cmb.push_back(nums[i]); vis[i] = <span class="number">1</span>;</span><br><span class="line">                dfs(n+<span class="number">1</span>,cmb);</span><br><span class="line">                cmb.pop_back(); vis[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; permute(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        this-&gt;len = nums.size();</span><br><span class="line">        this-&gt;nums = nums;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; len;i++)</span><br><span class="line">            vis.push_back(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; cmb;</span><br><span class="line">        dfs(<span class="number">0</span>,cmb);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>参考教程的思路是<strong>维护一个可选数字</strong>的集合，这个集合可以起到取代我上面的vis数组的作用。并且这样显然好一些，因为使用vis数组，状态树上的每一个结点都会检查初始nums中的所有数组，虽然当不满足条件的时候，不会向下产生分支，但是在当前层的循环中枚举了很多不必要的情况。</p>
<p>我按照这个思路写的代码如下，但是使用到了vector的插入和删除操作，频繁的这样操作，或许增加的时间复杂度不会比我开始使用的vis好到哪里去？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; cmb,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty())&#123;</span><br><span class="line">            ans.push_back(cmb);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> t = nums[i];</span><br><span class="line">            cmb.push_back(t); nums.erase(nums.begin()+i);</span><br><span class="line">            dfs(cmb,nums);</span><br><span class="line">            cmb.pop_back(); nums.insert(nums.begin()+i,t);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; permute(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; cmb;</span><br><span class="line">        dfs(cmb,nums);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>实际上两种思路都是常见的做法，我的第一种思路在参考的教程中后面也提到了。</p>
<p><a href="!https://www.bilibili.com/video/BV1mY411D7f6?spm_id_from=333.788.videopod.sections&vd_source=80df09f481ef5f0671e5e0e35d02e33e">参考教程</a></p>
<h3 id="DFS与回溯综合练习-n皇后"><a href="#DFS与回溯综合练习-n皇后" class="headerlink" title="DFS与回溯综合练习 n皇后"></a>DFS与回溯综合练习 n皇后</h3><p>我的基本思路是用dfs枚举每个位置放置皇后的情况，每个位置可以放、可以不放；当一个位置放置后，该位置对应的行、列、两个对角线 不能再放置；维护一个vis二维数组来判断各个位置是否可以放置皇后。</p>
<p>实现代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; vis;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; ans;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> num,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; cmb,<span class="type">int</span> posx,<span class="type">int</span> posy,<span class="type">int</span> cnt)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num == n)&#123;</span><br><span class="line">            ans.push_back(cmb);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(cnt &lt; n-num)<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = posx;i &lt; n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = posy;j &lt; n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(vis[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">                    cmb[i][j] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//ban</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>;k &lt; n;k++)</span><br><span class="line">                        vis[i][k]++,vis[k][j]++;</span><br><span class="line">                    vis[i][j]--;<span class="comment">//重复ban了一次</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> ki = i+<span class="number">1</span>,kj = j+<span class="number">1</span>;ki &lt; n&amp;&amp;kj &lt; n;ki++,kj++)</span><br><span class="line">                        vis[ki][kj]++;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> ki = i<span class="number">-1</span>,kj = j<span class="number">-1</span>;ki &gt;= <span class="number">0</span>&amp;&amp;kj &gt;= <span class="number">0</span>;ki--,kj--)</span><br><span class="line">                        vis[ki][kj]++;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> ki = i+<span class="number">1</span>,kj = j<span class="number">-1</span>;ki &lt; n&amp;&amp;kj &gt;= <span class="number">0</span>;ki++,kj--)</span><br><span class="line">                        vis[ki][kj]++;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> ki = i<span class="number">-1</span>,kj = j+<span class="number">1</span>;ki &gt;= <span class="number">0</span>&amp;&amp;kj &lt; n;ki--,kj++)</span><br><span class="line">                        vis[ki][kj]++;</span><br><span class="line">                    </span><br><span class="line">                    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> ki = <span class="number">0</span>;ki &lt; n;ki++)</span><br><span class="line">                        <span class="keyword">for</span>(<span class="type">int</span> kj = <span class="number">0</span>;kj &lt; n;kj++)</span><br><span class="line">                            <span class="keyword">if</span>(vis[ki][kj] == <span class="number">0</span>)sum++;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>(posy &lt; n)</span><br><span class="line">                        dfs(num+<span class="number">1</span>,cmb,posx,posy+<span class="number">1</span>,sum);</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(posy == n<span class="number">-1</span>)</span><br><span class="line">                        dfs(num+<span class="number">1</span>,cmb,posx+<span class="number">1</span>,<span class="number">0</span>,sum);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//recover，这样写可能会错误的恢复已经被其它皇后ban掉的位置，将修改为1改做++</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>;k &lt; n;k++)</span><br><span class="line">                        vis[i][k]--,vis[k][j]--;</span><br><span class="line">                    vis[i][j]++;<span class="comment">//重复recover了一次</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> ki = i+<span class="number">1</span>,kj = j+<span class="number">1</span>;ki &lt; n&amp;&amp;kj &lt; n;ki++,kj++)</span><br><span class="line">                        vis[ki][kj]--;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> ki = i<span class="number">-1</span>,kj = j<span class="number">-1</span>;ki &gt;= <span class="number">0</span>&amp;&amp;kj &gt;= <span class="number">0</span>;ki--,kj--)</span><br><span class="line">                        vis[ki][kj]--;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> ki = i+<span class="number">1</span>,kj = j<span class="number">-1</span>;ki &lt; n&amp;&amp;kj &gt;= <span class="number">0</span>;ki++,kj--)</span><br><span class="line">                        vis[ki][kj]--;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> ki = i<span class="number">-1</span>,kj = j+<span class="number">1</span>;ki &gt;= <span class="number">0</span>&amp;&amp;kj &lt; n;ki--,kj++)</span><br><span class="line">                        vis[ki][kj]--;</span><br><span class="line">                    cmb[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">                </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; solveNQueens(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; t;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; n;j++)</span><br><span class="line">                t.push_back(<span class="number">0</span>);</span><br><span class="line">            vis.push_back(t);</span><br><span class="line">        &#125;   </span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; cmb;</span><br><span class="line">        <span class="built_in">string</span> str;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">            str+=<span class="string">&quot;.&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">            cmb.push_back(str);</span><br><span class="line">        this-&gt;n = n;</span><br><span class="line">        dfs(<span class="number">0</span>,cmb,<span class="number">0</span>,<span class="number">0</span>,n*n);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>记录几个出现的问题：</p>
<ol>
<li>开始的时候我标记位置是否能放，能放是将vis[i][j]置为1，能放是将这个元素置为0。这样做的问题在于：一个皇后恢复现场的时候，可能把其它皇后置为不能放置的位置给恢复成能放了； <strong>解决的方法</strong>是，可以放置设置为0，每放一个皇后对应不能放置的位置+1，恢复的时候-1即可，这样每个皇后对现场的操作都被保存了下来作为是否能放的参照</li>
<li>开始的时候我写dfs中的for循环，每一层都是从i&#x3D;0，j&#x3D;0开始枚举的，这样的话每一层都会重复考虑之前已经考虑过的位置，这是错误的。<strong>解决的方法</strong>是记录好当前位置的下标，进入下一层递归的时候设置下一次开始遍历的初始位置是当前位置的下一个位置</li>
<li>解决1、2两个问题之后，代码的正确性已经得到保证了，但是现在的问题是时间复杂度太高了…，当n&#x3D;&#x3D;9的时候会TLE</li>
</ol>
<h3 id="全排列模板-n皇后"><a href="#全排列模板-n皇后" class="headerlink" title="全排列模板 n皇后"></a>全排列模板 n皇后</h3><p>对于上述dfs枚举每个格子的<strong>改进的方法</strong>，涉及n皇后的一个性质，那就是<strong>每一行、每一列一定有一个皇后</strong>。</p>
<p>这个性质不难证明，假设有一行没有皇后，那么剩下n-1行要放n个皇后，肯定有一行有两个皇后，与条件矛盾；列是同理的</p>
<p>于是我们可以考虑使用一个数组col[i]来表示第i行在哪一列放置了Q，即在第col[i]列放置了Q，<strong>理解这个数组很关键！</strong></p>
<p>于是，我们最终放置好的棋盘就可以单纯用col数组来表示。并且满足条件的情况下，其中一定有4个元素。</p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">col[<span class="number">4</span>] = &#123;<span class="number">1</span>，<span class="number">3</span>，<span class="number">0</span>，<span class="number">2</span>&#125;<span class="comment">//n==4的一种放置方案</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们现在可以把问题变成：我们要在数字0<del>n-1中，选出一种k&#x3D;n个数字的排列。由于一共就0</del>n-1个数字，所以得到排列还原回棋盘上的情况，意味着<strong>列一定不会冲突</strong>；而我们按照行来进行枚举，那么<strong>行也一定不会冲突</strong>；再者，在dfs的时候我们是从行0，枚举到行n-1，那么<strong>左下、右下的对角线一定不会冲突</strong></p>
<p>于是问题就变成了全排列模板上的变式，改变了的点是：</p>
<ol>
<li>在完成排列，退出递归的时候，我们要把得到的col数组还原回字符串向量（题意中用于表示棋盘），这是一个简单的模拟问题</li>
<li>在挑选加入排列的数字的时候，我们要进行check，考虑当前选择的数字，对应放置到棋盘上的Q，其左上、右上是否已经有Q了，如果有了就不能放置，也就是不能选择这个数字；否则可以选择</li>
</ol>
<p>具体的代码实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; ans;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//x是当前处理的行号，y是当前选择的数字，即x行希望放置Q的列号</span></span><br><span class="line">    <span class="type">bool</span> <span class="title function_">check</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp;col, <span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">        <span class="comment">//只需要检查左上和右上有没有皇后，因为按行递归，下面的行必定还没放置Q</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = x<span class="number">-1</span>,j1 = y<span class="number">-1</span>,j2 = y+<span class="number">1</span>;i &gt;= <span class="number">0</span>;i--,j1--,j2++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(col[i] == j1 || col[i] == j2)<span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; col, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(col.size() == n)&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; cmb;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">                <span class="built_in">string</span> str;</span><br><span class="line">                str.clear();</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; n;j++)</span><br><span class="line">                    <span class="keyword">if</span>(j == col[i])str+=<span class="string">&quot;Q&quot;</span>;</span><br><span class="line">                    <span class="keyword">else</span> str+=<span class="string">&quot;.&quot;</span>;</span><br><span class="line">                cmb.push_back(str);</span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(cmb);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; nums.size();j++)<span class="comment">//全排列的模板，nums中存有待选数字</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(check(col, col.size(), nums[j]))&#123;</span><br><span class="line">                <span class="type">int</span> t = nums[j];</span><br><span class="line">                col.push_back(nums[j]); nums.erase(nums.begin()+j);</span><br><span class="line">                dfs(col, nums);</span><br><span class="line">                col.pop_back(); nums.insert(nums.begin()+j,t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; solveNQueens(<span class="type">int</span> n) &#123;</span><br><span class="line">        this-&gt;n = n;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)nums.push_back(i);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; col;</span><br><span class="line">        dfs(col,nums);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>实际上check函数可以再利用棋盘上的一个性质，那就是从(i,j)出发，对于任意右上的位置(k,l)，i+j &#x3D;&#x3D; k+l恒成立；对于任意左上的位置(k,l)，i-j &#x3D;&#x3D; k-l恒成立。</p>
<p>于是可以这样写</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">check</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; col, <span class="type">int</span> x,<span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = x<span class="number">-1</span>;i &gt;= <span class="number">0</span>;i--)</span><br><span class="line">        <span class="keyword">if</span>(x+y == i+col[i] || x-y == i-col[i])<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>进一步优化对角线是否合法的检查，如果可以用i+j以及i-j来判断，那么我们不如直接使用两个bool数组，分别对应左上、右上；对于左上要使用i-j+n-1（避免索引出现负数），右上的索引可以直接使用i+j</p>
<p>这样check的O(n)就变成了O(1)，这是一种常见的哈希表优化的思想。</p>
<p>优化后的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; ans;</span><br><span class="line">    <span class="type">bool</span> diag1[<span class="number">20</span>];</span><br><span class="line">    <span class="type">bool</span> diag2[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// //x是当前处理的行号，y是当前选择的数字，即x行希望放置Q的列号</span></span><br><span class="line">    <span class="comment">// bool check(vector&lt;int&gt;&amp;col, int x,int y)&#123;</span></span><br><span class="line">    <span class="comment">//     //只需要检查左上和右上有没有皇后，因为按行递归，下面的行必定还没放置Q</span></span><br><span class="line">    <span class="comment">//     for(int i = x-1,j1 = y-1,j2 = y+1;i &gt;= 0;i--,j1--,j2++)&#123;</span></span><br><span class="line">    <span class="comment">//        if(col[i] == j1 || col[i] == j2)return false; </span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     return true;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; col, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(col.size() == n)&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; cmb;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">                <span class="built_in">string</span> str;</span><br><span class="line">                str.clear();</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; n;j++)</span><br><span class="line">                    <span class="keyword">if</span>(j == col[i])str+=<span class="string">&quot;Q&quot;</span>;</span><br><span class="line">                    <span class="keyword">else</span> str+=<span class="string">&quot;.&quot;</span>;</span><br><span class="line">                cmb.push_back(str);</span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(cmb);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; nums.size();j++)<span class="comment">//全排列的模板，nums中存有待选数字</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(diag1[nums[j]+col.size()] &amp;&amp; diag2[nums[j]-col.size()+n<span class="number">-1</span>])&#123;</span><br><span class="line">                <span class="type">int</span> t = nums[j];</span><br><span class="line">                diag1[nums[j]+col.size()] = <span class="literal">false</span>;diag2[nums[j]-col.size()+n<span class="number">-1</span>] = <span class="literal">false</span>;</span><br><span class="line">                col.push_back(nums[j]); nums.erase(nums.begin()+j);</span><br><span class="line">                dfs(col, nums);</span><br><span class="line">                col.pop_back(); nums.insert(nums.begin()+j,t);</span><br><span class="line">                diag1[nums[j]+col.size()] = <span class="literal">true</span>;diag2[nums[j]-col.size()+n<span class="number">-1</span>] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; solveNQueens(<span class="type">int</span> n) &#123;</span><br><span class="line">        this-&gt;n = n;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)nums.push_back(i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">20</span>;i++)diag1[i] = <span class="literal">true</span>,diag2[i] = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; col;</span><br><span class="line">        dfs(col,nums);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="DFS与记忆化"><a href="#DFS与记忆化" class="headerlink" title="DFS与记忆化"></a>DFS与记忆化</h2><h3 id="打家劫舍-leetcode-198"><a href="#打家劫舍-leetcode-198" class="headerlink" title="打家劫舍 leetcode 198"></a>打家劫舍 leetcode 198</h3><h4 id="打家劫舍-基础递归"><a href="#打家劫舍-基础递归" class="headerlink" title="打家劫舍 基础递归"></a>打家劫舍 基础递归</h4><p>这道题可以使用选或不选的递归思路，从后向前考虑。如果第i个房间选择了，那么第i-1个就不能选，紧接着从第i-2个继续考虑；如果第i个房间不选，紧接着从第i-1个继续考虑；于是很自然的就可以画出问题的状态树是怎样的，在此之上进行递归。</p>
<p>而我们的目标是最终的结果最大，所以考虑的时候应该是dfs(i) &#x3D; max(dfs(i-1),dfs(i-2)+nums[i])</p>
<p>在上面的思路上有了第一版代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> num)</span>&#123;<span class="comment">//从后向前考虑，i表示当前考虑的房间</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span>) <span class="keyword">return</span> num;</span><br><span class="line">        <span class="keyword">return</span> max(dfs(i<span class="number">-1</span>,num),dfs(i<span class="number">-2</span>,num+nums[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums)</span> &#123;</span><br><span class="line">        this-&gt;nums = nums;</span><br><span class="line">        <span class="keyword">return</span> dfs(nums.size()<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="打家劫舍-递归-记忆化-记忆化搜索"><a href="#打家劫舍-递归-记忆化-记忆化搜索" class="headerlink" title="打家劫舍 递归+记忆化&#x3D;记忆化搜索"></a>打家劫舍 递归+记忆化&#x3D;记忆化搜索</h4><p>遗憾的是，每层递归几乎都会展开两层，时间复杂度为$O(2^n)$，会TLE</p>
<p>我们可以注意到，在问题的状态树中，存在这样的结构：</p>
<p><img src="/../_images/Algorithm1/DFS2.png" alt="状态树"></p>
<p><a href="!https://www.bilibili.com/video/BV1Xj411K7oF?spm_id_from=333.788.videopod.sections&vd_source=80df09f481ef5f0671e5e0e35d02e33e">参考资料</a></p>
<p>这意味着我们进行了重复计算（<strong>通过观察状态树的分支情况，是我们判断是否可以进行记忆化处理的一种标注</strong>）</p>
<p>优化后的状态树是这样的，每层递归的小分支可以忽略不记，时间复杂度直接变成了O(n)<br><img src="/../_images/Algorithm1/DFS3.png" alt="优化后的状态树"></p>
<p>具体的优化方法是，我们可以使用一个数组或者一个哈希表，来保存在某分支上第一次计算dfs(i)的结果，然后在其它分支要计算dfs(i)的时候，先检查是否已经计算过了，如果计算过了可以直接调用。</p>
<p>我写的初版记忆化代码是这样的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cnt[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> num)</span>&#123;<span class="comment">//从后向前考虑，i表示当前考虑的房间</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span>) <span class="keyword">return</span> num;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(cnt[i] != <span class="number">-1</span>)<span class="keyword">return</span> cnt[i];</span><br><span class="line">        <span class="type">int</span> res = max(dfs(i<span class="number">-1</span>,num),dfs(i<span class="number">-2</span>,num+nums[i]));</span><br><span class="line">        cnt[i] = res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums)</span> &#123;</span><br><span class="line">        this-&gt;nums = nums;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">100</span>;i++)cnt[i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> dfs(nums.size()<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但是得出的结果是错误的。一个重要的原因是<strong>记忆化的依据是问题的状态</strong>，我们要把一个状态的结果保存下来，就像我们开始说的，要把dfs(i)的计算结果保存下来，这里的i就可以看作一个<strong>状态变量</strong>，来对一层递归进行唯一的标定。</p>
<p>而我代码中将累加变量num，当作参数来处理，num也变成了一个状态变量，而且它的值通常是难以估计的（随着测试输入的值有着巨大的变化），如果硬要考虑num也是一个状态，可以使用二维数组来存储记忆的结果，但是这会让空间开销变得很大（甚至超范围）。</p>
<p><strong>累加变量本身是可以作返回值处理的</strong>，不用当作参数跟着传递，修改的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cnt[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i)</span>&#123;<span class="comment">//从后向前考虑，i表示当前考虑的房间</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(cnt[i] != <span class="number">-1</span>)<span class="keyword">return</span> cnt[i];</span><br><span class="line">        <span class="type">int</span> res = max(dfs(i<span class="number">-1</span>),dfs(i<span class="number">-2</span>)+nums[i]);</span><br><span class="line">        cnt[i] = res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums)</span> &#123;</span><br><span class="line">        this-&gt;nums = nums;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">100</span>;i++)cnt[i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> dfs(nums.size()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>简单总结一下，一般情况下我习惯将dfs的累加变量当作参数处理，尤其是在退出的时候，使用最后累积的参数来更新我的答案；但是如果要实现记忆化，通常这种累积的参数应该通过返回值来进行处理，即存在明显的递归中“归”这一操作；而当累加变量当作参数处理的时候，实际上我的dfs返回通常是void，没有下层向上层的反馈，只有递归到边界的时候对全局变量的操作，所以没有“归”这一操作</p>
<h4 id="打家劫舍-自顶向下的记忆化搜索-自下向上-DP"><a href="#打家劫舍-自顶向下的记忆化搜索-自下向上-DP" class="headerlink" title="打家劫舍 自顶向下的记忆化搜索-&gt;自下向上 &#x3D; DP"></a>打家劫舍 自顶向下的记忆化搜索-&gt;自下向上 &#x3D; DP</h4><p>我们可以进一步观察状态树</p>
<p><img src="/../_images/Algorithm1/DFS4.png" alt="优化后的状态树"></p>
<p>从状态树来看，自上向下计算的过程中，我们总是在较上层提前计算了dfs(i)的结果 并存储起来 留给下层又遇到dfs(i)的时候使用的。</p>
<p>例如，在上面的状态树中，2、1、0这些右侧的分支点，是第一次调用dfs(2),dfs(1),dfs(0)的点，然后再左侧又遇到dfs(2),dfs(1),dfs(0)的时候是直接使用 较上层的 右侧分支点 第一次计算时保存的结果。</p>
<p>现在我们希望不保存这些结果，将空间复杂度从O(n)优化到O(1)，该如何做？</p>
<p>答案很显然了，我们可以自下向上计算状态结点上的值，只使用临时变量存储必要的值，并不断更新这些临时变量。站在记忆化的角度理解就是，我们是有保存dfs(i)的结果，但是没有保存全部结果，我们只存储了O(1)个对之后计算有需要的结果，并抛弃了不需要的结果；从临时变量来看，我们就是不断地用之后的计算需要的结果存入临时变量，覆盖掉了不再需要的结果。</p>
<p>从状态树上来看，我们计算dfs(2)的时候需要dfs(1),dfs(0)，计算dfs(3)的时候需要dfs(2),dfs(1)但不再需要dfs(0)，计算dfs(4)的时候需要dfs(3),dfs(2)，但不再需要dfs(1),dfs(0)。由此可以看出，计算dfs(i)的时候，实际需要的是dfs(i-1),dfs(i-2)</p>
<p>于是我们将dfs改记作dp，于是我们有了递推公式dp(i) &#x3D; max(dp(i-1),dp(i-2)+nums[i])；再结合边界条件dp(0) &#x3D; nums[0]，dp(1) &#x3D; max(nums[0],nums[1])，就可以开始递推填表了，这就是动态规划。</p>
<p>当然仅仅这样的自下向上，我们还没有完成空间复杂度的优化，因为我们使用了O(n)的递推数组。完全的优化是只使用O(1)的临时变量递推，这类似于我们在1维的dp数组上滚动处理，同样也类似于背包问题中，把二维的表格优化为一维的滚动数组（$O(n^2)$到O(n)的空间复杂度优化）。</p>
<p>在一维数组上的滚动处理，我们只需要3个临时变量f1、f2、f3。</p>
<ol>
<li>f1 &#x3D; nums[0], f2 &#x3D; max(nums[1], nums[0]) 状态0、状态1</li>
<li>f3 &#x3D; max(f2,f1+nums[2]) 状态2 &#x3D; max(状态1,状态0+nums[2])</li>
<li>f1 &#x3D; max(f3,f2+nums[3]) 状态3 &#x3D; max(状态2,状态1+nums[3])</li>
<li>f2 &#x3D; max(f1,f3+nums[4])</li>
</ol>
<p>最终结果就在f2中，上面的f1、f2、f3再反复使用的时候被赋予了不同状态的值，要注意区别。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() == <span class="number">1</span>)<span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums.size() == <span class="number">2</span>)<span class="keyword">return</span> max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> f[<span class="number">3</span>] = &#123;nums[<span class="number">0</span>],max(nums[<span class="number">1</span>],nums[<span class="number">0</span>]),<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt; nums.size();i++)</span><br><span class="line">            f[i%<span class="number">3</span>] = max(f[(i<span class="number">-1</span>)%<span class="number">3</span>],f[(i<span class="number">-2</span>)%<span class="number">3</span>]+nums[i]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> f[(nums.size()<span class="number">-1</span>)%<span class="number">3</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li>f是用来存储dfs的结果的，初始化要存储dfs(0)和dfs(1)，而dfs(1)并不是nums[1]，而是max(nums[1],nums[0])，我开始犯了这个错误</li>
<li>通过取模来实现三个临时变量不断互换位置更新的操作的这种实现方法需要留意，多多测试，想清楚怎么变化的，也是一种套路</li>
</ol>
<p>关于注意的第二点，也可以枚举nums中的数字，然后使用一种易读性更强的写法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> new_f,f0 = nums[<span class="number">0</span>],f1 = max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt; nums.size();i++)</span><br><span class="line">&#123;</span><br><span class="line">    new_f = max(f1,f0+nums[i]);</span><br><span class="line">    f0 = f1;</span><br><span class="line">    f1 = new_f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

        


        <span>
          <a class="article-read" href="/2025/08/30/深度优先搜索整理/"> Read more -->
          </span>
        </div>

        
    
    <div class="recent-post-item">

      <a href="/2025/08/30/%E5%9B%BE%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" class="item-title">图的数据结构与算法</a>
      
      <time datetime="2025-08-30T02:29:59.000Z">
        2025-08-30
      </time>
      
      <!-- <div class="article-digest"> -->
        <!-- 这篇blog用来整理图有关的数据结构与算法的知识
图的存储结构邻接矩阵邻接矩阵本质上就是一个二维数组，分为两种情况

无权图，m[i][j] &#x3D;&#x3D; 1代表vi有到vj的边；否则为0，代表不存在这样的边
有权图，元素为inf代表两点间不存在边，否则存在，且对应元素值为权重

从数据结构上来说，有向无向图没有区别，都是二维数组，且均适用于上面描述的两种情况。只是无向图有m[i][j] &#x3D;&#x3D; m[j][i]恒成立的性质
链式前向星本质上是数组实现的静态邻接表
掌握的关键在于记住三个点

使用到的数据结构即其含义
初始化的方式
加边的方式

下面分别进行描述：
数据结构：
12345678int head[]//一维数组，head[i]代表 vi 的最后一条边在edge中的索引 起一个指针的作用struct Edge&#123;    int to;//当前边指向的结点编号 对应可以用作head的索引 兼具标识结点编号和类似指针的两重作用    int next;//同一结点 当前边的 上一条边在edge中的索引 起一个指针的作用    int w;// -->
        <!-- </div> -->

        
        <p><code>这篇blog用来整理图有关的数据结构与算法的知识</code></p>
<h2 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h2><h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><p>邻接矩阵本质上就是一个二维数组，分为两种情况</p>
<ol>
<li>无权图，m[i][j] &#x3D;&#x3D; 1代表vi有到vj的边；否则为0，代表不存在这样的边</li>
<li>有权图，元素为inf代表两点间不存在边，否则存在，且对应元素值为权重</li>
</ol>
<p>从数据结构上来说，有向无向图没有区别，都是二维数组，且均适用于上面描述的两种情况。只是无向图有m[i][j] &#x3D;&#x3D; m[j][i]恒成立的性质</p>
<h3 id="链式前向星"><a href="#链式前向星" class="headerlink" title="链式前向星"></a>链式前向星</h3><p>本质上是数组实现的静态邻接表</p>
<p>掌握的关键在于记住三个点</p>
<ol>
<li>使用到的数据结构即其含义</li>
<li>初始化的方式</li>
<li>加边的方式</li>
</ol>
<p><em>下面分别进行描述</em>：</p>
<p>数据结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> head[]<span class="comment">//一维数组，head[i]代表 vi 的最后一条边在edge中的索引 起一个指针的作用</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> to;<span class="comment">//当前边指向的结点编号 对应可以用作head的索引 兼具标识结点编号和类似指针的两重作用</span></span><br><span class="line">    <span class="type">int</span> next;<span class="comment">//同一结点 当前边的 上一条边在edge中的索引 起一个指针的作用</span></span><br><span class="line">    <span class="type">int</span> w;<span class="comment">//当前边的权重</span></span><br><span class="line">&#125;edge[]<span class="comment">//一维数组，表示一条边</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这种数据结构的特点是，边本身是没有编号的；也不像邻接矩阵那样，可以直观的知道某条边介于哪两点之间。但是通过遍历点来遍历边，是能够得到这些信息的。</p>
<p>初始化与加边的方式</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> maxmn;</span><br><span class="line"><span class="type">int</span> m,n,cnt;</span><br><span class="line"><span class="type">int</span> head[maxmn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> to,next,w;</span><br><span class="line">&#125;edge[maxmn];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ini</span><span class="params">()</span>&#123;</span><br><span class="line">    cnt = <span class="number">0</span>;<span class="comment">//注意cnt用于全局管理边的索引，初始化为0</span></span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)head[i] = <span class="number">-1</span>;<span class="comment">//结点初始时都没有指向任何边 代表边索引的值初始化为-1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> from,to,w;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;from&gt;&gt;to&gt;&gt;w;</span><br><span class="line">        add_edge(from,to,w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">add_edge</span><span class="params">(<span class="type">int</span> from,<span class="type">int</span> to,<span class="type">int</span> w)</span>&#123;</span><br><span class="line">    edge[cnt].to = to;</span><br><span class="line">    edge[cnt].w = w;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这三行是理解加边操作的关键</span></span><br><span class="line">    edge[cnt].next = head[from];<span class="comment">//让新加的边指向 结点的上一条边</span></span><br><span class="line">    head[from] = cnt;<span class="comment">//让结点指向 新加的边</span></span><br><span class="line">    cnt++;<span class="comment">//全局管理边的索引</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="链式前向星的遍历"><a href="#链式前向星的遍历" class="headerlink" title="链式前向星的遍历"></a>链式前向星的遍历</h4><p>前面提到了这种存图方法在以点为基础，进行遍历的时候，是可以遍历所有的边，并得到边的完整信息（起点、终点、权重）的。下面进行展示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    ini();<span class="comment">//参考前面的代码，假设我们初始化好了一个链式前向星存储的图</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = head[i];j != <span class="number">-1</span>;j = edge[j].next)<span class="comment">//当j==-1成立时，对应遍历完了点v的所有边 前面初始化为-1的作为边界条件的作用 就是类似使用的</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;当前边在edge中的索引：&quot;</span>:j&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;from:&quot;</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;to:&quot;</span>&lt;&lt;edge[j].to&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;w:&quot;</span>&lt;&lt;edge[j].w&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//注意j的更新操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，我认为<strong>数据结构的含义是记忆的重点，记住之后其它操作根据理解是可以写出的</strong>。</p>
<h2 id="图上的DFS（判断两个点是否连通）"><a href="#图上的DFS（判断两个点是否连通）" class="headerlink" title="图上的DFS（判断两个点是否连通）"></a>图上的DFS（判断两个点是否连通）</h2><p>这里使用链式前向星实现，目的是对于输入的两个点u、v，判断是否连通（从一个点可以到达令一个点）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> maxmn = <span class="number">10000</span>;</span><br><span class="line"><span class="type">int</span> n,m,cnt = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> head[maxmn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> to,next,w;</span><br><span class="line">&#125;edge[maxmn];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ini_graph</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">        head[i] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        add_edge(u,v,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">add_edge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span>&#123;</span><br><span class="line">    edge[cnt].to = v;</span><br><span class="line">    edge[cnt].w = <span class="number">1</span>;</span><br><span class="line">    edge[cnt].next = head[u];</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> u,v;<span class="comment">//需要判断是否连通的两点</span></span><br><span class="line"><span class="type">bool</span> flag = <span class="literal">false</span>;<span class="comment">//结果标志</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>* vis, <span class="type">int</span> now_pos)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(flag) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历当前点的边，对每一条可行的边进行递归，实现dfs</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = head[now_pos];i != <span class="number">-1</span>;i = edge[i].next)&#123;</span><br><span class="line">        <span class="comment">//判断是否到达目标结点</span></span><br><span class="line">        <span class="keyword">if</span>(edge[i].to == v)&#123;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(vis[edge[i].to] == <span class="number">0</span>)&#123;</span><br><span class="line">            vis[edge[i].to] = <span class="number">1</span>;</span><br><span class="line">            dfs(vis, edge[i].to);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">solve</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> vis[maxmn];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)vis[i] = <span class="number">0</span>;<span class="comment">//初始化一个标记访问的数组</span></span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v;</span><br><span class="line">    vis[u] = <span class="number">1</span>;<span class="comment">//注意标记初始点已经被访问（来自chatgpt的纠错）</span></span><br><span class="line">    dfs(vis, u);</span><br><span class="line">    <span class="keyword">if</span>(flag)<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;u可达于v&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;不可达！&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    ini_graph();</span><br><span class="line">    solve();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h2><h2 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h2>
        


        <span>
          <a class="article-read" href="/2025/08/30/图的数据结构与算法/"> Read more -->
          </span>
        </div>

        
    
    <div class="recent-post-item">

      <a href="/2025/08/29/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E7%9A%84%E5%B0%8F%E7%AE%97%E6%B3%95/" class="item-title">杂七杂八的小算法</a>
      
      <time datetime="2025-08-29T14:08:53.000Z">
        2025-08-29
      </time>
      
      <!-- <div class="article-digest"> -->
        <!-- 在平常练习算法题的过程中，有的题目常常涉及到使用一些基本的小算法作为整个解决方案中的一部分，例如gcd、进制转换，乃至KMP等等，我用这篇blog对这些小算法。我在这篇blog中对它们做一个综合的整理。
gcd1234int gcd(int x,int y)&#123; if(x%y == 0)return y; else return gcd(y,x%y);&#125;

辗转相除法求最大公约数
进制转换lcm1234int lcm(int x,int y)&#123;    return x*y/gcd(x,y);&#125;

利用最大公约数求最小公倍数
Fibonacci这一部分从Fibonacci数列的计算出发，使用递归&amp;递归+记忆化的方式实现。
目的是展示递归改记忆化递归的基本思想。
string数字转换为int数字 -->
        <!-- </div> -->

        
        <p><code>在平常练习算法题的过程中，有的题目常常涉及到使用一些基本的小算法作为整个解决方案中的一部分，例如gcd、进制转换，乃至KMP等等，我用这篇blog对这些小算法。我在这篇blog中对它们做一个综合的整理。</code></p>
<h2 id="gcd"><a href="#gcd" class="headerlink" title="gcd"></a>gcd</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(x%y == <span class="number">0</span>)<span class="keyword">return</span> y;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">return</span> gcd(y,x%y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>辗转相除法求最大公约数</p>
<h2 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h2><h2 id="lcm"><a href="#lcm" class="headerlink" title="lcm"></a>lcm</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">lcm</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> x*y/gcd(x,y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用最大公约数求最小公倍数</p>
<h2 id="Fibonacci"><a href="#Fibonacci" class="headerlink" title="Fibonacci"></a>Fibonacci</h2><p>这一部分从Fibonacci数列的计算出发，使用递归&amp;递归+记忆化的方式实现。</p>
<p>目的是展示递归改记忆化递归的基本思想。</p>
<h2 id="string数字转换为int数字"><a href="#string数字转换为int数字" class="headerlink" title="string数字转换为int数字"></a>string数字转换为int数字</h2>
        


        <span>
          <a class="article-read" href="/2025/08/29/杂七杂八的小算法/"> Read more -->
          </span>
        </div>

        
    
    <div class="recent-post-item">

      <a href="/2025/08/29/%E7%AE%97%E6%B3%95%E9%A2%98%E5%B8%B8%E7%94%A8%E5%BA%93%E4%B8%AD%E7%9A%84%E5%B7%A5%E5%85%B7/" class="item-title">算法题常用库中的工具</a>
      
      <time datetime="2025-08-29T12:19:32.000Z">
        2025-08-29
      </time>
      
      <!-- <div class="article-digest"> -->
        <!-- 在过去的算法竞赛中，我常常接触到一些库中的工具，例如函数、容器、类等等，但是总是零零散散的，记忆也不是很牢，每次都是用到了现查。于是我用这篇blog做一个简单的整理
头文件algorithmmax()函数在 C++ 中，max 函数是一个非常实用的函数，用于比较两个或更多数值并返回其中的最大值。这个函数定义在 algorithm 头文件中。
1234567891011#include &lt;iostream&gt;#include &lt;algorithm&gt; // 引入algorithm头文件以使用max函数int main() &#123;int a = 10;int b = 20;int max_value = std::max(a, b); // 使用max函数比较a和b，并将结果存储在max_value中std::cout &lt;&lt; &quot;Max value is: &quot; &lt;&lt; max_value &lt;&lt; std::endl;return 0;&#125;

在这个例子中，std::max(a, b) 将返回 a 和 b 中 -->
        <!-- </div> -->

        
        <p><code>在过去的算法竞赛中，我常常接触到一些库中的工具，例如函数、容器、类等等，但是总是零零散散的，记忆也不是很牢，每次都是用到了现查。于是我用这篇blog做一个简单的整理</code></p>
<h2 id="头文件algorithm"><a href="#头文件algorithm" class="headerlink" title="头文件algorithm"></a>头文件algorithm</h2><h3 id="max-函数"><a href="#max-函数" class="headerlink" title="max()函数"></a>max()函数</h3><p>在 C++ 中，max 函数是一个非常实用的函数，用于比较两个或更多数值并返回其中的最大值。这个函数定义在 algorithm 头文件中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span> <span class="comment">// 引入algorithm头文件以使用max函数</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> max_value = <span class="built_in">std</span>::max(a, b); <span class="comment">// 使用max函数比较a和b，并将结果存储在max_value中</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Max value is: &quot;</span> &lt;&lt; max_value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，std::max(a, b) 将返回 a 和 b 中的较大值，并将结果存储在 max_value 中。</p>
<h3 id="sort-函数"><a href="#sort-函数" class="headerlink" title="sort()函数"></a>sort()函数</h3><h2 id="头文件cmath"><a href="#头文件cmath" class="headerlink" title="头文件cmath"></a>头文件cmath</h2><h3 id="取整函数"><a href="#取整函数" class="headerlink" title="取整函数"></a>取整函数</h3><p>round()</p>
<p>ceil()</p>
<p>floor()</p>
<h2 id="字符串相关"><a href="#字符串相关" class="headerlink" title="字符串相关"></a>字符串相关</h2><h3 id="strcpy"><a href="#strcpy" class="headerlink" title="strcpy"></a>strcpy</h3><h3 id="substr"><a href="#substr" class="headerlink" title="substr"></a>substr</h3><h3 id="getline"><a href="#getline" class="headerlink" title="getline"></a>getline</h3><p>通常的使用方式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a;</span><br><span class="line"><span class="built_in">cin</span>.ignore();<span class="comment">//处理回车</span></span><br><span class="line">getline(<span class="built_in">cin</span>,str);</span><br></pre></td></tr></table></figure>

<p>注意在使用getline读取一行信息之前，如果输入有回车，要使用cin.ignore()来处理回车</p>
<h3 id="erase"><a href="#erase" class="headerlink" title="erase"></a>erase</h3><ol>
<li>basic_string &amp; erase(size_type pos&#x3D;0, size_type n&#x3D;npos);即erase（pos，n）;从给定起始位置pos处开始删除, 删除n个字符, 返回值修改后的string对象引用。比如erase(0,1)就是删除第一个字符。</li>
<li>iterator erase(const_iterator position)即erase（positon），删除迭代器位置处的单个字符(position是个string类型的迭代器), 并返回下个元素的迭代器。<br>如果position 不是迭代器位置，则删除该位置及之后的所有字符。</li>
<li>iterator erase(const_iterator first, const_iterator last)即erase（first，last）；删除迭代器（first, last)区间的所有字符（first和last都是迭代器）,返回一个指向被删除的最后一个元素的下一个字符的迭代器.</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="built_in">string</span> str = <span class="string">&quot;hello the world!&quot;</span>;</span><br><span class="line"> <span class="built_in">string</span> str1 = <span class="string">&quot;hello the world!&quot;</span>;</span><br><span class="line"> <span class="built_in">string</span> str2 = <span class="string">&quot;hello the world!&quot;</span>;</span><br><span class="line"> <span class="built_in">string</span> str3 = <span class="string">&quot;hello the world!&quot;</span>;</span><br><span class="line"> <span class="built_in">string</span> str4 = <span class="string">&quot;hello the world!&quot;</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/****************第1种用法:earse(pos,n)**************************/</span></span><br><span class="line"> str.erase(<span class="number">6</span>, <span class="number">2</span>);   </span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;&lt;&quot;</span> &lt;&lt; str &lt;&lt; <span class="string">&quot;&gt;&quot;</span> &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// &lt;hello e world!&gt;    </span></span><br><span class="line"> <span class="comment">/****************第2种用法:earse(position)***********************/</span></span><br><span class="line"> str1.erase(<span class="number">8</span>);  <span class="comment">//如果pos不是迭代器位置，则删除该位置及之后的所有字符</span></span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;&lt;&quot;</span> &lt;&lt; str1 &lt;&lt; <span class="string">&quot;&gt;&quot;</span> &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">//  &lt;hello th&gt;</span></span><br><span class="line"> </span><br><span class="line"> str2.erase(str2.begin()); <span class="comment">//如果pos是迭代器，则</span></span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;&lt;&quot;</span> &lt;&lt; str2 &lt;&lt; <span class="string">&quot;&gt;&quot;</span> &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">//  &lt;ello the world!&gt;</span></span><br><span class="line"> <span class="comment">/****************第3种用法:earse(fist,last)**********************/</span></span><br><span class="line"> str3.erase(str3.begin() + <span class="number">3</span>, str3.end()<span class="number">-3</span>);</span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;&lt;&quot;</span> &lt;&lt; str3 &lt;&lt; <span class="string">&quot;&gt;&quot;</span> &lt;&lt; <span class="built_in">endl</span>;     <span class="comment">// &lt;helld!&gt;</span></span><br><span class="line"> str4.erase(str4.begin() + <span class="number">3</span>, str4.end());</span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;&lt;&quot;</span> &lt;&lt; str4 &lt;&lt; <span class="string">&quot;&gt;&quot;</span> &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">//  &lt;hel&gt;</span></span><br><span class="line"> system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>资料来自于：<br><a href="!https://blog.csdn.net/weixin_42258743/article/details/120751188">CSDN</a></p>
<h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><h3 id="vector在指定位置插入元素"><a href="#vector在指定位置插入元素" class="headerlink" title="vector在指定位置插入元素"></a>vector在指定位置插入元素</h3><p>使用vector类的内置方法，insert</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> it = numbers.begin() + <span class="number">3</span>; <span class="comment">// 指定插入位置</span></span><br><span class="line">    numbers.insert(it, <span class="number">4</span>); <span class="comment">// 在位置 3 插入元素 4</span></span><br><span class="line">    numbers.insert(it, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;); <span class="comment">// 在位置 3 插入多个元素 4, 5, 6</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After insertion: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> num : numbers) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="vector在指定位置删除元素"><a href="#vector在指定位置删除元素" class="headerlink" title="vector在指定位置删除元素"></a>vector在指定位置删除元素</h3><p>使用vector类的内置方法，erase</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> it = numbers.begin() + <span class="number">2</span>; <span class="comment">// 指定删除位置</span></span><br><span class="line">    numbers.erase(it); <span class="comment">// 删除位置 2 的元素</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> start = numbers.begin() + <span class="number">2</span>; <span class="comment">// 指定起始删除位置</span></span><br><span class="line">    <span class="keyword">auto</span> end = numbers.begin() + <span class="number">5</span>;   <span class="comment">// 指定结束删除位置</span></span><br><span class="line">    numbers.erase(start, end); <span class="comment">// 删除从位置 2 到位置 5 的元素</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After deletion: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> num : numbers) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>关于vector插入与删除的总结，相同点是都可以使用迭代器进行，并且在操作一个元素的时候都是使用一个迭代器来指定操作元素的位置；在操作多个元素的时候插入还是使用一个迭代器，删除使用两个迭代器来指定区间。</p>
<p>插入，是插入于指定迭代器的位置，原本位置及之后的元素，均向后挪动（挪动多少取决于你插入元素的多少）<br>删除，删除指定位置的元素，或指定区间的元素</p>
<p>注意begin()获取的迭代器对应位置是首元素，end()迭代器对应位置是尾元素的下一位</p>
<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><h2 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h2><h2 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h2><h2 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h2><p>双端队列，支持队列的基本操作。但是是用push_front, pop_back</p>
<p>另外还有push_back, pop_front</p>
<p>还支持从任意位置删除元素，与vector类似，使用erase()即可</p>
<p>并且可以使用at()方法便捷地访问元素值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 使用 at() 方法访问元素</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\n使用 at() 方法访问元素:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; dq.size(); ++i) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;dq.at(&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;) = &quot;</span> &lt;&lt; dq.at(i) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样的方法便捷地访问deque的值</p>
<h2 id="accumulate"><a href="#accumulate" class="headerlink" title="accumulate"></a>accumulate</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;numeric&gt;</span><span class="comment">//accumulate函数在numeric库中</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; b = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> sum_a = accumulate(a,a+<span class="number">10</span>,<span class="number">0</span>);</span><br><span class="line"><span class="type">int</span> sum_b = accumulate(b.begin(),b.end(),<span class="number">0</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意accumulate最后一个参数是必要的，含义是在累加指定迭代器范围的容器中的元素后，加上第三个元素，并且按照第三个元素的数据类型返回求和结果。</p>
<p>所以即使不用额外的累加，也需要使用第三个元素，int型的时候，第三个元素通常置0即可。</p>
<h2 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h2><p>元组的使用：设置值&amp;获取值</p>

        


        <span>
          <a class="article-read" href="/2025/08/29/算法题常用库中的工具/"> Read more -->
          </span>
        </div>

        
    
    <div class="recent-post-item">

      <a href="/2025/08/29/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%9F%BA%E7%A1%80/" class="item-title">动态规划基础</a>
      
      <time datetime="2025-08-29T11:24:22.000Z">
        2025-08-29
      </time>
      
      <!-- <div class="article-digest"> -->
        <!-- 之前零零散散地接触过一些动态规划的问题，用这篇blog来稍微系统性的记录一下
动态规划的基本步骤
定义数组的基本含义（模板或是灵感）
找到数组元素间的关系（dp的递推式，模板或是灵感）
找到边界的初始值（基本含义定义好了这个通常不难）
递推填表得到需要的元素（结合初始值以及递推式，考虑应该如何进行递推填表，确保新填一个元素需要用到其它元素的时候，其它元素的值已经被填过了）

背包问题01背包（二维解法）问题描述：有n种物品，每种物品只有一个。每个物品有自己的重量和价值。有一个给定容量的背包，问这个背包最多能装的最大价值是多少。
step1定义数组元素的含义
1dp[i][j]//背包容量为j时，考虑1~i种物品，所能承载的最大价值

step2于是我们可以有如下递推式
1dp[i][j] = max(dp[i-1][j], dp[i-1][j-weight[i]] + val[i])

因为从前i-1种物品考虑到第i种物品，只有两种情况：

拿第i种物品，那么前i-1种物品还剩下的可用容量是j-weight[i]，根据数组元素的意义，有dp[i][j] &#x3D; max(dp[i- -->
        <!-- </div> -->

        
        <p><code>之前零零散散地接触过一些动态规划的问题，用这篇blog来稍微系统性的记录一下</code></p>
<h2 id="动态规划的基本步骤"><a href="#动态规划的基本步骤" class="headerlink" title="动态规划的基本步骤"></a>动态规划的基本步骤</h2><ol>
<li>定义数组的基本含义（模板或是灵感）</li>
<li>找到数组元素间的关系（dp的递推式，模板或是灵感）</li>
<li>找到边界的初始值（基本含义定义好了这个通常不难）</li>
<li>递推填表得到需要的元素（结合初始值以及递推式，考虑应该如何进行递推填表，确保新填一个元素需要用到其它元素的时候，其它元素的值已经被填过了）</li>
</ol>
<h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><h3 id="01背包（二维解法）"><a href="#01背包（二维解法）" class="headerlink" title="01背包（二维解法）"></a>01背包（二维解法）</h3><p>问题描述：有n种物品，每种物品只有一个。每个物品有自己的重量和价值。有一个给定容量的背包，问这个背包最多能装的最大价值是多少。</p>
<h4 id="step1"><a href="#step1" class="headerlink" title="step1"></a>step1</h4><p>定义数组元素的含义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j]<span class="comment">//背包容量为j时，考虑1~i种物品，所能承载的最大价值</span></span><br></pre></td></tr></table></figure>

<h4 id="step2"><a href="#step2" class="headerlink" title="step2"></a>step2</h4><p>于是我们可以有如下递推式</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i<span class="number">-1</span>][j-weight[i]] + val[i])</span><br></pre></td></tr></table></figure>

<p>因为从前i-1种物品考虑到第i种物品，只有两种情况：</p>
<ol>
<li>拿第i种物品，那么前i-1种物品还剩下的可用容量是j-weight[i]，根据数组元素的意义，有dp[i][j] &#x3D; max(dp[i-1][j-weight[i]] + val[i])</li>
<li>不拿第i种物品，前i-1种物品剩下的可用容量是j，根据数组元素的意义，有dp[i][j] &#x3D; dp[i-1][j]</li>
</ol>
<p>所以取两种情况中较大的一者，就是dp[i][j]的结果。<strong>注意，第一种情况应该满足条件j&gt;&#x3D;weight[i]，这是显然成立的，于变成而言不满足这个条件数组会发生越界，于实际意义而言，你要装下物品i，意味着你的背包容量至少要大于等于w[i]</strong></p>
<h4 id="step3"><a href="#step3" class="headerlink" title="step3"></a>step3</h4><p>不难发现边界条件的初始值是</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="number">0</span>][any_j] == <span class="number">0</span> &amp;&amp; dp[any_i][j] == <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h4 id="step4"><a href="#step4" class="headerlink" title="step4"></a>step4</h4><p>根据递推关系式，我们发现在填元素dp[i][j]的时候，使用到的元素的1、2维索引一定分别小于i、j，于是按照最简单的从左往右，从上往下填表即可。</p>
<h4 id="例题与代码实现-01背包（二维解法）"><a href="#例题与代码实现-01背包（二维解法）" class="headerlink" title="例题与代码实现 01背包（二维解法）"></a>例题与代码实现 01背包（二维解法）</h4><p>洛谷：P1060 [NOIP 2006 普及组] 开心的金明</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">ll m,n;</span><br><span class="line">ll v[<span class="number">26</span>],w[<span class="number">26</span>];</span><br><span class="line">ll dp[<span class="number">26</span>][<span class="number">30001</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i++)</span><br><span class="line"> &#123;</span><br><span class="line">  ll t;</span><br><span class="line">  <span class="built_in">cin</span>&gt;&gt;v[i]&gt;&gt;t;</span><br><span class="line">  w[i] = v[i];</span><br><span class="line">  v[i]*=t;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i++)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= n;j++)</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="keyword">if</span>(j &gt;= w[i])dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i<span class="number">-1</span>][j-w[i]]+v[i]);</span><br><span class="line">   <span class="keyword">else</span> dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">cout</span>&lt;&lt;dp[m][n];</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="01背包（一维解法）"><a href="#01背包（一维解法）" class="headerlink" title="01背包（一维解法）"></a>01背包（一维解法）</h3><p>根据上面的状态转移式，我们可以发现在填表的过程中，<strong>每新的一行，仅仅依赖于上一行的数据</strong>，所以我们可以考虑使用1维表格。</p>
<p>即数组dp[j]，在二维表格的意义基础上描述对应元素的意义是：当前你正在更新行的元素数据，例如更新到第i行后，那么dp[j]对应就是dp[i][j]。当然这只是粗略的描述。</p>
<p>实际上，假设你当前正在更新第i行，并考虑更新dp[j]，在其更新之前，其对应的应该是dp[i-1][j]，更新完成后才是dp[i][j]。<strong>理解这一点很关键</strong>，有如下两点原因。</p>
<ol>
<li>dp[i][j]更新只依赖于i-1行的数据，而根据这个更新过程，i-1行的数据是可以同时被保存于这个一维表格的，那么只使用这个一维表格是可能的；</li>
<li>由于dp[i][j]的更新，从列上来看，其依赖的有1）dp[i][j-1]，在dp[j]于第i行更新中没有完成时，其代表的就是第i-1行的元素，所以dp[i-1][j]可以在需要时从表格中获取；2）dp[i-1][j-w[i]]，这就要求在dp[j]于第i行更新时，任何小于j的列k（0&lt;&#x3D; k &lt; j）没有完成更新，即dp[k]还保存的i-1行的元素，<strong>所以我们要从后往前更新表格</strong></li>
</ol>
<p>在第2点的基础上，只要我们从后往前更新1维表格，就可以确保<strong>表格中每个数据更新的时候，其需要的数据都存在于表格中（关键点）</strong>，于是使用一维数组替换二维数组是可行的。</p>
<p><em>这也是一般的dp需要考虑填表的方式的原因，你知道了递推式，你需要考虑如何递推才能满足，在求解一个元素的时候其它需要的元素一定是已经求解过了。</em></p>
<h4 id="例题与代码实现-01背包（一维解法）"><a href="#例题与代码实现-01背包（一维解法）" class="headerlink" title="例题与代码实现 01背包（一维解法）"></a>例题与代码实现 01背包（一维解法）</h4><p>洛谷：P1060 [NOIP 2006 普及组] 开心的金明</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line">ll m,n;</span><br><span class="line">ll v[<span class="number">26</span>],w[<span class="number">26</span>];</span><br><span class="line">ll dp[<span class="number">30001</span>];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i++)</span><br><span class="line"> &#123;</span><br><span class="line">  ll t;</span><br><span class="line">  <span class="built_in">cin</span>&gt;&gt;v[i]&gt;&gt;t;</span><br><span class="line">  w[i] = v[i];</span><br><span class="line">  v[i]*=t;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i++)</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> j = n;j &gt;= <span class="number">0</span>;j--)<span class="comment">//注意从后往前递推</span></span><br><span class="line">   <span class="keyword">if</span>(j &gt;= w[i])dp[j] = max(dp[j],dp[j-w[i]]+v[i]);</span><br><span class="line">   <span class="comment">//else dp[j] = dp[j]，对应的就是dp[j] = dp[j-1]，当然没有写的必要 </span></span><br><span class="line"> <span class="built_in">cout</span>&lt;&lt;dp[n];</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h3><p>01背包之所以叫01背包，是因为对于每种物品只有1个，或选或不选；而完全背包唯一区别于01背包的一点就是，每一种可以选择的物品都是无限的。</p>
<p>采用与01背包相同的dp数组定义，可以想到以下递推式</p>
<p>即考虑前i种物品时对于第i种物品，考虑选择其数量为0到正无穷的情况，对此进行枚举</p>
<p>$dp[i][j] &#x3D; max^∞_{k&#x3D;0}(dp[i - 1][j - k<em>w[i]]+ k</em>v[i])$</p>
<p>当然对于每一次枚举，我们有终止条件</p>
<p>$j&#x2F;k &gt; w[i]$</p>
<p>但是这样的算法复杂度是$n^3$，通常会TLE</p>
<p>可以考虑优化</p>
<p>$dp[i][j] &#x3D; max(dp[i-1][j],dp[i][j-w[i]]+v[i])$</p>
<p>这里涉及两个情况</p>
<ol>
<li>不拿第i种物品的时候$dp[i][j] &#x3D; dp[i-1][j]$显然成立</li>
<li>拿第i种物品的时候，拿1件物品i时的值，已经由$dp[i][j-2*w[i]]$更新过了，依次类推，拿任意件物品i（至于边界情况，拿尽可能多）对应的情况都被考虑在其中了。而$dp[i][j-w[i]]$的更新一定在$dp[i][j]$之前（直接考虑顺序递推），所以可行。</li>
</ol>
<p>上面的第二点，从朴素一点的角度，可以从你定义好数组的含义之后，填表更新的过程来理解，填$dp[i][j-w[i]]$的时候，根据状态转移方程的情况2，就需要考虑$dp[i][j-2*w[i]]$，而后者一定是比前者先填好的。</p>
<h4 id="例题与代码实现"><a href="#例题与代码实现" class="headerlink" title="例题与代码实现"></a>例题与代码实现</h4><p>第37次CCF CSP认证 Task2 机器人饲养指南</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line">ll n,m;</span><br><span class="line">ll v[<span class="number">101</span>];</span><br><span class="line">ll w[<span class="number">101</span>];</span><br><span class="line">ll dp[<span class="number">101</span>][<span class="number">100001</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i++)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="built_in">cin</span>&gt;&gt;v[i];</span><br><span class="line">  w[i] = i;</span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i++)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= n;j++)</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="keyword">if</span>(j &gt;= w[i])dp[i][j] = max(dp[i<span class="number">-1</span>][j],dp[i][j-w[i]]+v[i]);<span class="comment">//记住转移方程，其它按部就班即可</span></span><br><span class="line">   <span class="keyword">else</span> dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="built_in">cout</span>&lt;&lt;dp[m][n];</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这道题就是一个完全背包的模板，理解题意还原到完全背包，苹果的数量就是容量，投喂的数量就是物品的重量，投喂数量对应的受益就是物品的价值。</p>

        


        <span>
          <a class="article-read" href="/2025/08/29/动态规划基础/"> Read more -->
          </span>
        </div>

        
    
    <div class="recent-post-item">

      <a href="/2025/08/25/%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" class="item-title">联邦学习基础知识</a>
      
      <time datetime="2025-08-25T08:55:39.000Z">
        2025-08-25
      </time>
      
      <!-- <div class="article-digest"> -->
        <!-- 我正在学习一个用来跑PFL算法的代码框架，读代码的同时用这篇blog记录一些有关联邦学习的基础知识；以及一些python、pytorch的知识
数据集划分的平衡与不平衡含义在联邦学习中，平衡和不平衡主要指数据量上的分布情况：
平衡数据（Balanced Data）：每个客户端拥有的数据量大致相同。例如，如果有10个客户端和1000个数据样本，那么每个客户端分配到的数据约为100条。
不平衡数据（Unbalanced Data）：不同客户端拥有的数据量差别很大。例如，10个客户端中，某些客户端可能分配到300条数据，而另一些可能只有10条。这种情况在实际场景中很常见，比如边缘设备中，每台设备的用户数量或活跃度可能不同，导致本地数据量差异。
影响平衡与不平衡的影响：
平衡的数据划分更容易训练，且模型收敛更快。
不平衡的数据划分会导致联邦学习中的“客户端漂移”问题，即全局模型更倾向于数据量大的客户端，而忽略数据量较小的客户端。
人为划分IID or Non-IID的数据集IID划分方法将整个数据集随机打乱后，均匀划分到每个客户端。
例如，MNIST 数据集有 60000 张图片，可以随机将它 -->
        <!-- </div> -->

        
        <p><code>我正在学习一个用来跑PFL算法的代码框架，读代码的同时用这篇blog记录一些有关联邦学习的基础知识；以及一些python、pytorch的知识</code></p>
<h2 id="数据集划分的平衡与不平衡"><a href="#数据集划分的平衡与不平衡" class="headerlink" title="数据集划分的平衡与不平衡"></a>数据集划分的平衡与不平衡</h2><h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h3><p>在联邦学习中，平衡和不平衡主要指数据量上的分布情况：</p>
<p>平衡数据（Balanced Data）：每个客户端拥有的数据量大致相同。例如，如果有10个客户端和1000个数据样本，那么每个客户端分配到的数据约为100条。</p>
<p>不平衡数据（Unbalanced Data）：不同客户端拥有的数据量差别很大。例如，10个客户端中，某些客户端可能分配到300条数据，而另一些可能只有10条。这种情况在实际场景中很常见，比如边缘设备中，每台设备的用户数量或活跃度可能不同，导致本地数据量差异。</p>
<h3 id="影响"><a href="#影响" class="headerlink" title="影响"></a>影响</h3><p>平衡与不平衡的影响：</p>
<p>平衡的数据划分更容易训练，且模型收敛更快。</p>
<p>不平衡的数据划分会导致联邦学习中的“客户端漂移”问题，即全局模型更倾向于数据量大的客户端，而忽略数据量较小的客户端。</p>
<h2 id="人为划分IID-or-Non-IID的数据集"><a href="#人为划分IID-or-Non-IID的数据集" class="headerlink" title="人为划分IID or Non-IID的数据集"></a>人为划分IID or Non-IID的数据集</h2><h3 id="IID划分方法"><a href="#IID划分方法" class="headerlink" title="IID划分方法"></a>IID划分方法</h3><p>将整个数据集随机打乱后，均匀划分到每个客户端。</p>
<p>例如，MNIST 数据集有 60000 张图片，可以随机将它们分成 10 份，每份 6000 张，分配给 10 个客户端。</p>
<h3 id="Non-IID划分方法"><a href="#Non-IID划分方法" class="headerlink" title="Non-IID划分方法"></a>Non-IID划分方法</h3><p>常见的方法：</p>
<ol>
<li>按类别划分：MNIST 有 10 个类别，可以让每个客户端只拥有 1-2 个类别的数据。例如，客户端 A 拥有类别 0 和 1 的数据，客户端 B 拥有类别 2 和 3 的数据。</li>
<li>狄利克雷分布（Dirichlet Distribution）：通过狄利克雷分布生成权重，控制每个客户端拥有的类别比例</li>
<li>数量不平衡：对每个客户端分配不同数量的数据，进一步增加数据分布的不均衡性。</li>
</ol>
<h3 id="狄利克雷划分法（Non-IID）"><a href="#狄利克雷划分法（Non-IID）" class="headerlink" title="狄利克雷划分法（Non-IID）"></a>狄利克雷划分法（Non-IID）</h3><h4 id="关于狄利克雷分布"><a href="#关于狄利克雷分布" class="headerlink" title="关于狄利克雷分布"></a>关于狄利克雷分布</h4><p>狄利克雷分布是一种概率分布，用于生成一组非负数，使它们的和为 1。它常用于 Non-IID 数据划分中，控制每个客户端拥有数据类别的比例。</p>
<p>狄利克雷分布是一种“分布的分布” (a distribution on probability distribution) ，由两个参$\mathcal{G}_0,\alpha$ 确定，即$\mathcal{G} \sim DP(\alpha,\mathcal{G}_0)$，$\alpha$是分布参数(concentration or scaling parameter)，其值越大，分布越接近于均匀分布，其值越小，分布越concentrated。$\mathcal{G}_0$是基分布(base distribution)。</p>
<p>具体步骤：</p>
<ol>
<li>假设有 $K$ 个类别，客户端数为 $N$，狄利克雷分布的超参数为 $\alpha$。</li>
<li>对于每个客户端 $i$，从狄利克雷分布中采样一个向量 $p_i$，表示该客户端对 $K$ 个类别的偏好。</li>
<li>根据 $p_i$分配数据样本。例如，如果某个客户端 $i$ 的 $p_i &#x3D; [0.7, 0.2, 0.1]$，则它的样本中 70% 来自类别 1，20% 来自类别 2，10% 来自类别 3。</li>
<li>调整 $\alpha$ 值，可以控制 Non-IID 的程度：$\alpha$ 越小，每个客户端的类别分布差异越大（更偏向 Non-IID）。$\alpha$ 越大，类别分布差异越小（更接近 IID）。</li>
</ol>
<h3 id="其它一些划分方式（Non-IID）"><a href="#其它一些划分方式（Non-IID）" class="headerlink" title="其它一些划分方式（Non-IID）"></a>其它一些划分方式（Non-IID）</h3><ol>
<li>固定类别划分：每个客户端只分配特定的类别。例如，客户端 A 只分到类别 0，客户端 B 只分到类别 1。适用于模拟极端 Non-IID 分布。</li>
<li>聚类划分：对数据集进行聚类，将每个聚类的数据分配给一个客户端。这种方法可以模拟数据具有某种特定模式的情况。</li>
<li>概率抽样：给每个客户端分配不同的类别概率分布，然后根据概率分布抽样数据。比如，客户端 A 的类别分布是 [0.9, 0.1, 0.0]，客户端 B 的类别分布是 [0.3, 0.3, 0.4]。</li>
<li>基于地理或时间划分：按照数据生成的时间或地理位置来划分数据。例如，某些客户端的数据来自特定地区，模拟真实场景下的数据分布。</li>
</ol>
<h3 id="数据的异质性-Heterogeneity"><a href="#数据的异质性-Heterogeneity" class="headerlink" title="数据的异质性(Heterogeneity)"></a>数据的异质性(Heterogeneity)</h3><p>指的是Non-IID and unbalanced</p>
<h3 id="客户端漂移"><a href="#客户端漂移" class="headerlink" title="客户端漂移"></a>客户端漂移</h3><p>由于数据分布的差异，每个客户端的本地模型更新（梯度）可能会在方向和大小上有所不同。当这些更新被聚合时，可能会导致全局模型更新的方向和大小并不是所有客户端所需要的最佳方向。这种现象称为客户端漂移。</p>
<h3 id="CUDA"><a href="#CUDA" class="headerlink" title="CUDA"></a>CUDA</h3><p>CUDA（Compute Unified Device Architecture）是由 NVIDIA 开发的并行计算平台和编程模型。它允许开发者使用 NVIDIA 显卡（GPU）进行通用计算，即不仅仅用于图形处理，还可以用于科学计算、机器学习、深度学习等大量需要并行计算的任务。</p>
<p>通常cuda设备就是指GPU</p>
<h2 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h2><h3 id="Py的for循环"><a href="#Py的for循环" class="headerlink" title="Py的for循环"></a>Py的for循环</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, train_data <span class="keyword">in</span> <span class="built_in">enumerate</span>(trainloader, <span class="number">0</span>):</span><br><span class="line">    trainset.data, trainset.targets = train_data</span><br></pre></td></tr></table></figure>

<p>enumerate函数返回一个(索引，值)的元组，_是常用的占位符（我们知道这里有值，但是我们不使用），这里_存储的是索引值；train_data是由Dataloader将原始的数据集对象分批后得到的新的“数据集对象列表”trainloader中的元素，作为enumerate元组的值，其是一个数据集对象。</p>
<p>上面的赋值语句是将一个数据集对象train_data（本身是一个元组）中的两个元素，分别赋值给数据集对象trainset的两个属性元素。</p>
<h3 id="Py，range函数"><a href="#Py，range函数" class="headerlink" title="Py，range函数"></a>Py，range函数</h3><p>range(n)，生成一个迭代器，依次返回0，1，2，3，…，n-1</p>
<h3 id="Py，np-array函数"><a href="#Py，np-array函数" class="headerlink" title="Py，np.array函数"></a>Py，np.array函数</h3><p>numpy库中的array函数用于将输入的数据转换为一个NumPy数组，该数组是一种高效的多维数组对象，提供了许多用于数学和科学计算的功能。</p>
<h3 id="Py迭代器"><a href="#Py迭代器" class="headerlink" title="Py迭代器"></a>Py迭代器</h3><p>在Python中，迭代器是一种遵循迭代协议的对象，具有 iter() 和 next() 方法。迭代器允许程序员遍历一个集合，如列表或字符串，一次访问一个元素。生成器是一种特殊的迭代器，它使用 yield 关键字在每次迭代时返回值，而不是一次性返回所有值。</p>
<h4 id="一种迭代器的实现方式"><a href="#一种迭代器的实现方式" class="headerlink" title="一种迭代器的实现方式"></a>一种迭代器的实现方式</h4><p>把一个类作为一个迭代器使用需要在类中实现两个方法 __iter__() 与 __next__() 。</p>
<p>如果你已经了解的面向对象编程，就知道类都有一个构造函数，Python 的构造函数为__init__(), 它会在对象初始化的时候执行。</p>
<p>__iter__() 方法返回一个特殊的迭代器对象， 这个迭代器对象实现了 __next__() 方法并通过 StopIteration 异常标识迭代的完成。</p>
<p>__next__() 方法（Python 2 里是 next()）会返回下一个迭代器对象。</p>
<p><em>一个具体的例子：</em></p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyNumbers</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="variable language_">self</span>.a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">self</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">    x = <span class="variable language_">self</span>.a</span><br><span class="line">    <span class="variable language_">self</span>.a += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"> </span><br><span class="line">myclass = MyNumbers()</span><br><span class="line">myiter = <span class="built_in">iter</span>(myclass)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(myiter))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(myiter))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(myiter))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(myiter))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(myiter))</span><br></pre></td></tr></table></figure>

<p><em>输出结果是：</em></p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>

<h3 id="Py使用布尔数组索引元素"><a href="#Py使用布尔数组索引元素" class="headerlink" title="Py使用布尔数组索引元素"></a>Py使用布尔数组索引元素</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">idxs = np.array(<span class="built_in">range</span>(<span class="built_in">len</span>(dataset_label)))</span><br><span class="line">idx_for_each_class = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_classes):</span><br><span class="line">    idx_for_each_class.append(idxs[dataset_label == i])</span><br></pre></td></tr></table></figure>

<p>其中idxs是一个索引数组。</p>
<p>dataset_label &#x3D;&#x3D; i会生成一个布尔数组，对于dataset_label中的元素等于i的，该元素的位置对应布尔数组中True元素的位置，布尔数组中其它位置元素是False。例如，dataset_label &#x3D; [1, 2, 1, 2, 1]，i &#x3D; 1；那么对应布尔数组为[True, False, True, False, True]</p>
<p>idxs[dataset_label &#x3D;&#x3D; i]使用布尔数组进行索引，将布尔数组中为True的元素的位置对应到idxs中元素的位置。例如，idxs &#x3D; [1, 2, 3, 4, 5]，根据前面的布尔数组，返回[1, 3, 5]</p>
<h3 id="Py列表生成式"><a href="#Py列表生成式" class="headerlink" title="Py列表生成式"></a>Py列表生成式</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class_num_per_client = [class_per_client <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(num_clients)]</span><br></pre></td></tr></table></figure>

<p>其中[class_per_client for _ in range(num_clients)]是一个列表生成式；</p>
<p>用range迭代num_clients次，每次迭代的过程中添加一个元素为class_per_client；</p>
<p>最终得到一个长度为num_clients，每个元素都是class_per_client的列表；</p>
<p>实际意义是创建一个列表，其中每个元素代表每个客户端拥有的类别数量</p>
<h3 id="Py列表截取"><a href="#Py列表截取" class="headerlink" title="Py列表截取"></a>Py列表截取</h3><p>常见的列表截取操作如下：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a[start:stop] <span class="comment"># 从索引start开始到索引stop-1结束</span></span><br><span class="line">a[start:] <span class="comment"># 从索引start开始到列表末尾</span></span><br><span class="line">a[:stop] <span class="comment"># 从列表开头到索引stop-1结束</span></span><br><span class="line">a[:] <span class="comment"># 获取整个列表</span></span><br></pre></td></tr></table></figure>

<p>又如</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">selected_clients = selected_clients[:<span class="built_in">int</span>(np.ceil((num_clients/num_classes)*class_per_client))]</span><br></pre></td></tr></table></figure>

<p>np.ceil的作用告诉向上取整，再用int()转换为整数，又从0截取到stop-1</p>
<h3 id="Py，利用enumerate的for循环"><a href="#Py，利用enumerate的for循环" class="headerlink" title="Py，利用enumerate的for循环"></a>Py，利用enumerate的for循环</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> idx, train_dict <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_data):  <span class="comment"># 这种循环的作用是idx是train_data的索引，train_dict是train_data的元素（即存有训练数据的字典）</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(train_path + <span class="built_in">str</span>(idx) + <span class="string">&#x27;.npz&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        np.savez_compressed(f, data=train_dict)</span><br></pre></td></tr></table></figure>

<p>enumerate返回一个元组(index, element)的迭代器，常用于for index, element in enumerate(list)的循环中</p>
<h3 id="Py，argparse模块"><a href="#Py，argparse模块" class="headerlink" title="Py，argparse模块"></a>Py，argparse模块</h3><p>argparse 模块是 Python 标准库中的一个模块，它用于解析命令行参数。通过 argparse，我们可以方便地从命令行中获取参数并将其传递给程序。</p>
<h4 id="argparse的用法"><a href="#argparse的用法" class="headerlink" title="argparse的用法"></a>argparse的用法</h4><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parser = argparse.ArgumentParser()  <span class="comment"># 这是创建一个新的 ArgumentParser 对象，用于处理命令行参数。</span></span><br><span class="line">parser.add_argument(<span class="string">&#x27;-go&#x27;</span>, <span class="string">&quot;--goal&quot;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="string">&quot;test&quot;</span>, </span><br><span class="line">                    <span class="built_in">help</span>=<span class="string">&quot;The goal for this experiment&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>add_argument 方法用于定义程序可以接受的命令行参数，在上面的例子中：</p>
<ol>
<li>-go 和 –goal 是参数的名称（短名称和长名称）。</li>
<li>type&#x3D;str 指定参数的类型为字符串。</li>
<li>default&#x3D;”test” 指定参数的默认值。</li>
<li>help 提供该参数的帮助信息，会在使用 –help 时显示。</li>
</ol>
<p>类似的参数定义方法：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">parser.add_argument(<span class="string">&#x27;-dev&#x27;</span>, <span class="string">&quot;--device&quot;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="string">&quot;cuda&quot;</span>,</span><br><span class="line">                    choices=[<span class="string">&quot;cpu&quot;</span>, <span class="string">&quot;cuda&quot;</span>])</span><br><span class="line">parser.add_argument(<span class="string">&#x27;-did&#x27;</span>, <span class="string">&quot;--device_id&quot;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="string">&quot;0&quot;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;-data&#x27;</span>, <span class="string">&quot;--dataset&quot;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="string">&quot;MNIST&quot;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;-itk&#x27;</span>, <span class="string">&quot;--itk&quot;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">4000</span>,</span><br><span class="line">                    <span class="built_in">help</span>=<span class="string">&quot;The iterations for solving quadratic subproblems&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>最后解析参数，得到一个Namespace对象，用来访问各个参数</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">args = parser.parse_args()</span><br></pre></td></tr></table></figure>

<p>parse_args 方法会解析命令行参数，并返回一个包含参数值的 Namespace 对象。可以通过 args 对象来访问这些参数，例如 args.goal、args.device 等。</p>
<p>综合来看，argparse的主要用法就是<strong>创建对象，定义参数，解析参数</strong></p>
<h3 id="Py张量"><a href="#Py张量" class="headerlink" title="Py张量"></a>Py张量</h3><p>一般是指用于数值计算的高效多维数组，可能是一个比较抽象的概念。</p>
<p>具体而言Py内置的list、Numpy库的Numpy数组或者Pytorch中的tensor，在某种程度上都可以被称为张量；但是在一些特定的情况下，张量或许特指后面两者</p>
<h3 id="Py，Dataloader"><a href="#Py，Dataloader" class="headerlink" title="Py，Dataloader"></a>Py，Dataloader</h3><p>在 PyTorch 中，DataLoader 是一个非常常用的类，用于包装数据集，提供批量加载数据的功能。</p>
<p>主要作用：</p>
<ol>
<li>批量加载数据: 根据指定的 batch_size 从数据集中加载数据。</li>
<li>打乱数据: 如果 shuffle&#x3D;True，在每个 epoch 开始时打乱数据。</li>
<li>多线程加载: 通过 num_workers 参数（未在此代码段中指定），可以并行加载数据，提高数据加载速度。</li>
<li>迭代接口: DataLoader 实现了 Python 迭代器协议，可以在训练循环中方便地使用 for batch in dataloader 这样的语法。</li>
</ol>
<p>例子：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset, DataLoader</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleDataset</span>(<span class="title class_ inherited__">Dataset</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, data</span>):</span><br><span class="line">        <span class="variable language_">self</span>.data = data</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(<span class="variable language_">self</span>.data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, idx</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.data[idx]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设 read_client_data 返回一个 SimpleDataset 对象</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_client_data</span>(<span class="params">dataset, client_id, is_train, few_shot</span>):</span><br><span class="line">    <span class="keyword">return</span> SimpleDataset([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, batch_size=<span class="number">3</span></span>):</span><br><span class="line">        <span class="variable language_">self</span>.batch_size = batch_size</span><br><span class="line">        <span class="variable language_">self</span>.dataset = <span class="literal">None</span></span><br><span class="line">        <span class="variable language_">self</span>.<span class="built_in">id</span> = <span class="literal">None</span></span><br><span class="line">        <span class="variable language_">self</span>.few_shot = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">load_test_data</span>(<span class="params">self, batch_size=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="keyword">if</span> batch_size == <span class="literal">None</span>:</span><br><span class="line">            batch_size = <span class="variable language_">self</span>.batch_size</span><br><span class="line">        test_data = read_client_data(<span class="variable language_">self</span>.dataset, <span class="variable language_">self</span>.<span class="built_in">id</span>, is_train=<span class="literal">False</span>, few_shot=<span class="variable language_">self</span>.few_shot)</span><br><span class="line">        <span class="keyword">return</span> DataLoader(test_data, batch_size, drop_last=<span class="literal">False</span>, shuffle=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 MyClass 加载数据</span></span><br><span class="line">my_class = MyClass()</span><br><span class="line">dataloader = my_class.load_test_data()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> batch <span class="keyword">in</span> dataloader:</span><br><span class="line">    <span class="built_in">print</span>(batch)</span><br></pre></td></tr></table></figure>

<p>例子将会输出</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tensor([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">tensor([<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line">tensor([<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line">tensor([<span class="number">10</span>])</span><br></pre></td></tr></table></figure>
        


        <span>
          <a class="article-read" href="/2025/08/25/联邦学习基础知识/"> Read more -->
          </span>
        </div>

        
    
    <div class="recent-post-item">

      <a href="/2025/08/17/PFL-SRDP/" class="item-title">PFL-SRDP</a>
      
      <time datetime="2025-08-17T09:38:41.000Z">
        2025-08-17
      </time>
      
      <!-- <div class="article-digest"> -->
        <!-- nothing to see…
 -->
        <!-- </div> -->

        
        <p>nothing to see…</p>

        


        <span>
          <a class="article-read" href="/2025/08/17/PFL-SRDP/"> Read more -->
          </span>
        </div>

        
    
    <div class="recent-post-item">

      <a href="/2025/08/06/PFL2/" class="item-title">PFL2</a>
      
      <time datetime="2025-08-06T07:17:24.000Z">
        2025-08-06
      </time>
      
      <!-- <div class="article-digest"> -->
        <!-- 这篇blog用来记录我读的第二篇有关联邦学习的文献，其中也使用了nash bargaining game
基本概念Representation Collapse Entanglement表示崩塌纠缠：这是指在联邦无监督学习（FUSL）过程中，由于某个本地模型的表示崩塌（即该模型的特征表示不再具有区分度），会影响到全局模型和其他本地模型的表示能力。这种崩塌会导致整个系统的表示能力下降，使得模型在处理非独立同分布（non-IID）数据时效果不佳。
Flexible Uniform RegularizerFUR：灵活均匀正则化器，这是FedU2方法中的一个组件，旨在每个客户端上避免表示崩塌。通过均匀分散样本，使得模型的表示不集中在特定区域，从而保持特征空间的多样性。通过强制模型学习到更加均匀分布的特征，FUR可以防止表示崩塌，提高模型的泛化能力。
Efficient Unified AggregatorEUA：高效统一聚合器，这是FedU2方法中的另一个组件，部署在服务器端，用于在聚合客户端模型时促进统一的表示空间。该聚合器通过约束客户端模型的更新，确保各客户端模型在特征空间上的一致性。
I -->
        <!-- </div> -->

        
        <p><code>这篇blog用来记录我读的第二篇有关联邦学习的文献，其中也使用了nash bargaining game</code></p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="Representation-Collapse-Entanglement"><a href="#Representation-Collapse-Entanglement" class="headerlink" title="Representation Collapse Entanglement"></a>Representation Collapse Entanglement</h3><p>表示崩塌纠缠：这是指在联邦无监督学习（FUSL）过程中，由于某个本地模型的表示崩塌（即该模型的特征表示不再具有区分度），会影响到全局模型和其他本地模型的表示能力。这种崩塌会导致整个系统的表示能力下降，使得模型在处理非独立同分布（non-IID）数据时效果不佳。</p>
<h3 id="Flexible-Uniform-Regularizer"><a href="#Flexible-Uniform-Regularizer" class="headerlink" title="Flexible Uniform Regularizer"></a>Flexible Uniform Regularizer</h3><p>FUR：灵活均匀正则化器，这是FedU2方法中的一个组件，旨在每个客户端上避免表示崩塌。通过均匀分散样本，使得模型的表示不集中在特定区域，从而保持特征空间的多样性。通过强制模型学习到更加均匀分布的特征，FUR可以防止表示崩塌，提高模型的泛化能力。</p>
<h3 id="Efficient-Unified-Aggregator"><a href="#Efficient-Unified-Aggregator" class="headerlink" title="Efficient Unified Aggregator"></a>Efficient Unified Aggregator</h3><p>EUA：高效统一聚合器，这是FedU2方法中的另一个组件，部署在服务器端，用于在聚合客户端模型时促进统一的表示空间。该聚合器通过约束客户端模型的更新，确保各客户端模型在特征空间上的一致性。</p>
<h3 id="Inactivated-neurons"><a href="#Inactivated-neurons" class="headerlink" title="Inactivated neurons"></a>Inactivated neurons</h3><p>非活化神经元：：在人工神经网络（如深度学习模型）中，某些神经元可能在特定输入或训练阶段不被激活。激活函数（如ReLU、Sigmoid等）会根据输入值决定某个神经元是否被激活。</p>
<h3 id="Unbalanced-Optimal-Transport-Divergence"><a href="#Unbalanced-Optimal-Transport-Divergence" class="headerlink" title="Unbalanced Optimal Transport Divergence"></a>Unbalanced Optimal Transport Divergence</h3><p>非平衡最优传输散度：是一种测量分布之间差异的方法，特别适用于处理具有不同质量或总质量不守恒的分布。它是传统最优传输（Optimal Transport, OT）理论的扩展，传统最优传输通常假设两个分布具有相同的总质量，这样可以通过寻找最优运输计划来最小化从一个分布到另一个分布的“运输成本”。非平衡最优传输散度放宽了传统最优传输的总质量守恒假设，允许处理不同质量或存在质量损失的分布。它引入了一个正则项来惩罚质量的创建和销毁，从而可以在更广泛的应用场景中使用。</p>
<p>在FUR中的应用：最小化客户端数据与均匀随机样本（如来自同一球形高斯分布的样本）之间的非平衡最优传输散度。FUR强制每个客户端的数据分布更接近一个统一的参考分布，从而避免了表示崩塌并促进更均匀的特征表示。</p>
<p>注意：在最小化非平衡最优传输散度的过程中，通常并不会直接删除客户端的数据点，而是通过调整模型的训练过程来使数据的特征表示与统一的参考分布对齐。这是通过优化目标函数和引入正则化项来实现的，而不是通过直接修改原始数据。</p>
<p>具体实现方法：在训练过程中，优化目标函数时会加入非平衡最优传输散度作为正则化项。这一项会惩罚客户端数据分布与参考分布之间的差异。</p>
<p>公式：假设 $\mathcal{L}$ 是原始损失函数，$\text{UOT}(P, Q)$ 是非平衡最优传输散度项，那么新的优化目标可以表示为：<br>$\mathcal{L}_{\text{total}} &#x3D; \mathcal{L} + \lambda \cdot \text{UOT}(P, Q)$</p>
<h2 id="翻译"><a href="#翻译" class="headerlink" title="翻译"></a>翻译</h2><p>divergent 不同的，分歧的；（级数）发散的</p>
<p>suppress 抑制；封锁；压制</p>
<p>decorrelate 去相关</p>
<p>discrepant 有差异的；矛盾的</p>
<p>threshold 阈；门槛</p>
<p>deviation 偏离</p>
<p>dual 双重的</p>

        


        <span>
          <a class="article-read" href="/2025/08/06/PFL2/"> Read more -->
          </span>
        </div>

        
    
    <div class="recent-post-item">

      <a href="/2025/07/29/PFL/" class="item-title">PFL</a>
      
      <time datetime="2025-07-29T07:33:06.000Z">
        2025-07-29
      </time>
      
      <!-- <div class="article-digest"> -->
        <!-- 这篇blog用于记录我阅读论文《 Improve global generalization for personalized federated learning within a Stackelberg game》过程中学习到的一些基础知识。
基本概念PFL个性化联邦学习：在联邦学习(FL)的基础上， PFL的目标是为每个客户端训练一个个性化模型，适应每个客户端的特定数据分布和需求。PFL适用于各客户端数据分布差异较大，且每个客户端需要一个定制化模型的场景。不同于FL训练一个全局共享的模型，希望是该模型在所有客户端上表现良好。
PFL分类“Towards Personalized Federated Learning”一文将个性化联邦学习（PFL）分为两类：

全局模型个性化（Global Model Personalization）：第一阶段，训练一个共享的全局FL模型；第二阶段，在本地的数据上进行额外的训练，达到适应个性化的目的。在这一类模型中，关注与第一阶段全局FL模型在non-IID数据上的训练能力。
学习个性化模型（Learning Personalized Model） -->
        <!-- </div> -->

        
        <p><code>这篇blog用于记录我阅读论文《 Improve global generalization for personalized federated learning within a Stackelberg game》过程中学习到的一些基础知识。</code></p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="PFL"><a href="#PFL" class="headerlink" title="PFL"></a>PFL</h3><p>个性化联邦学习：在联邦学习(FL)的基础上， PFL的目标是为每个客户端训练一个个性化模型，适应每个客户端的特定数据分布和需求。PFL适用于各客户端数据分布差异较大，且每个客户端需要一个定制化模型的场景。<strong>不同于FL训练一个全局共享的模型，希望是该模型在所有客户端上表现良好。</strong></p>
<h4 id="PFL分类"><a href="#PFL分类" class="headerlink" title="PFL分类"></a>PFL分类</h4><p>“Towards Personalized Federated Learning”一文将个性化联邦学习（PFL）分为两类：</p>
<ol>
<li>全局模型个性化（Global Model Personalization）：第一阶段，训练一个共享的全局FL模型；第二阶段，在本地的数据上进行额外的训练，达到适应个性化的目的。在这一类模型中，关注与第一阶段全局FL模型在non-IID数据上的训练能力。</li>
<li>学习个性化模型（Learning Personalized Model）：在训练阶段，就达到模型个性化的效果。个人理解：区别于上种二阶段的PFL，这一类方法在一阶段就实现了PFL（但这样理解的话似乎把Regularization based的方法归入architecture更合理）。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/497934969">参考资料</a></p>
<h2 id="词汇"><a href="#词汇" class="headerlink" title="词汇"></a>词汇</h2>
        


        <span>
          <a class="article-read" href="/2025/07/29/PFL/"> Read more -->
          </span>
        </div>

        
      </div>
      


      <div id="recent-posts-paginator">
        <a class="extend prev" rel="prev" href="/"> </a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/3/"> </a>
      </div>

    </div>

<aside id="sidebar">
  
  <div class="widget-box">
  	  <div class="widget-box">
    <h3 class="widget-title-friends">friends</h3>
    <div class="widget">
      
    </div>
  </div>

  </div>
  
  <div class="widget-box">
  	

  </div>
  
  <div class="widget-box">
  	
  <div class="widget-box">
    <h3 class="widget-title-tag">tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/" rel="tag">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/unity/" rel="tag">unity</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" rel="tag">分布式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/" rel="tag">图形学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%A7%E5%AD%A6/" rel="tag">大学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" rel="tag">数据结构与算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88MTL%EF%BC%89/" rel="tag">机器学习（MTL）</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%83%E5%AD%A6%E4%B9%A0%EF%BC%89/" rel="tag">机器学习（元学习）</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%89/" rel="tag">机器学习（强化学习）</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0%EF%BC%89/" rel="tag">机器学习（联邦学习）</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E8%81%9A%E7%B1%BB%EF%BC%89/" rel="tag">机器学习（聚类）</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9D%82%E9%A1%B9/" rel="tag">杂项</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C/" rel="tag">网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" rel="tag">计算机基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%97%E6%AD%8C/" rel="tag">诗歌</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/" rel="tag">软件工程</a></li></ul>
    </div>
  </div>


  </div>
  
  <div class="widget-box">
  	
  <div class="widget-box">
    <h3 class="widget-title-archive">archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2026/01/">January 2026</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/12/">December 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/11/">November 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/10/">October 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/09/">September 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/08/">August 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/07/">July 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/05/">May 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/04/">April 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/02/">February 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/10/">October 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li></ul>
    </div>
  </div>

  </div>
  
  <div class="widget-box">
  	
  <div class="widget-box">
    <h3 class="widget-title-post">recent_posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a class="recent_posts-list-link" href="/2026/01/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/">软件工程导论</a>
          </li>
        
          <li>
            <a class="recent_posts-list-link" href="/2026/01/02/Connect6%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/">Connect6框架学习</a>
          </li>
        
          <li>
            <a class="recent_posts-list-link" href="/2025/12/15/Computer-Graphic/">Computer Graphic</a>
          </li>
        
          <li>
            <a class="recent_posts-list-link" href="/2025/12/05/Double-Cross/">Double Cross</a>
          </li>
        
          <li>
            <a class="recent_posts-list-link" href="/2025/12/01/Computer%20Network/">Computer Network</a>
          </li>
        
      </ul>
    </div>
  </div>

  </div>
  
</aside>

<!-- <div id="paginator"> -->
<!--   <a class="extend prev" rel="prev" href="/"> </a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/3/"> </a> -->
<!-- </div> -->

    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
          tex2jax: {
            inlineMath: [ ['$','$'], ["\\(","\\)"] ],
            processEscapes: true
          }
        });
      </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
            tex2jax: {
              skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
            }
          });
      </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
              var all = MathJax.Hub.getAllJax(), i;
              for(i=0; i < all.length; i += 1) {
                  all[i].SourceElement().parentNode.className += ' has-jax';
              }
          });
    </script>

    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>



			</div>
		</div>

		<div id="bottom-outer">
			<div id="bottom-inner">
				Site by 阳生 | 
				Powered by <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a> |
				theme <a target="_blank" rel="noopener" href="https://github.com/fireworks99/hexo-theme-PreciousJoy">PreciousJoy</a>
			</div>
		</div>

		
	</div>





	
	<!-- scripts list from theme config.yml -->
	
	<script src="/js/jquery-3.5.1.min.js"></script>
	
	<script src="/js/PreciousJoy.js"></script>
	
	<script src="/js/highlight.pack.js"></script>
	
	<script src="/js/jquery.fancybox.min.js"></script>
	
	<script src="/js/search.js"></script>
	
	<script src="/js/load.js"></script>
	
	<script src="/js/jquery.mCustomScrollbar.concat.min.js"></script>
	
	<script src="/js/clipboard.min.js"></script>
	
	

	<script>hljs.initHighlightingOnLoad();</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>
