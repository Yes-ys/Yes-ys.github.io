<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CN-Exercise</title>
      <link href="/2026/01/17/CN-Exercise/"/>
      <url>/2026/01/17/CN-Exercise/</url>
      
        <content type="html"><![CDATA[<h2 id="期末重点"><a href="#期末重点" class="headerlink" title="期末重点"></a>期末重点</h2><p><code>挖空练习</code></p><h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><p>物理层的功能：<br>    ()，为链路层提供服务；</p><p>不同信道复用技术的区别：<br>    信道复用技术：<br>        频分复用、时分复用、统计时分复用、波分复用、码分复用；<br>        1）()的各路信号在()占用()（频率带宽而非发送速率）；<br>        2）()的所有用户是在()占用()；<br>        3）()：在频分复用的基础上()，其中要包含()；<br>        4）()：在时分复用的基础上()，其中要包含()；<br>        5）()：使用STDM帧来传送数据，STDM帧()，按需()，其中要()；<br>        （基本原理是一个STDM帧中有多个时隙，但小于总用户数量，用户有想发的数据就往集中器中发，集中器按顺序扫描输入缓冲，放入STDM帧的各个时隙中，当一个STDM帧的数据放满了就发送出去）<br>        6）()就是()，但是由于光的频率很高，所以()而不用频率这一概念，所以描述为波分复用；</p><p>FDM、TDM、FDMA、TDMA、STDM哪种效率高：<br>    统计时分复用()，因为其对于每个用户()，总是()，保证()，避免存在时隙有空便发送信号的情况，所以这种效率高；</p><h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><p>数据链路层的功能：<br>    ()传输()；</p><p>为了实现正确传输数据帧需要解决的<strong>三个基本问题</strong>：<br>    ()、()、()；</p><p><strong>封装成帧的含义</strong>：<br>    封装成帧就是在()的前后分别添加()，()，使得接收方能够在收到物理层上交的比特流之后()，()出帧的开始和结束；<br>    （首部、尾部的主要作用是()）；<br>    （帧的数据部分有长度上限()，eg：以太网是()）；</p><p><strong>透明传输的含义</strong>：<br>    无论什么样比特组合的数据，都能够按照原样没有差错地通过数据链路层进行正确地传输，不会因为数据中出现了与()相同的比特组合而导致传输的()；</p><p><strong>透明传输的方法</strong>：<br>    使用转义字符”()”，十六进制是()；<br>    如果数据中有比特组合呈现出：()或()，则前面加上转义字符；<br>    如果数据中出现了ESC，也在前面加上ESC；</p><p><strong>差错检测的含义</strong>：<br>    由于实际通信的链路并非是理想的，存在误码率，为了保证数据传输的()，在计算机网络传输数据时，必须采用的手段，用于检测是否存在差错；</p><p>差错检测的方法：<br>    ()；<br>    发送方：<br>        1）原始k位01串数据；<br>        2）()，事先商量好n位；<br>        3）k位原数据+(n-1)个0作为()；<br>        4）被除数对除数进行()；<br>        5）最终得到的()，就是()（帧检验序列）<br>        6）k位原始数据+n-1位FCS，构成()；<br>    接收放：<br>        1）使用()；<br>        2）如果()则没有差错；<br>        3）否则存在差错；<br>    注意：<br>        1）n位除数可以用多项式生成，对应()（因为有个常数）；<br>        2）eg：$p(X) &#x3D; X^3 + X^2$，对应：1100</p><p><strong>传输差错：</strong><br>    1）()，()可以避免；<br>    2）帧丢失、帧重复、帧失序；<br>        解决它们意味着：<br>            实现了()：数据链路层发送端发送什么，接收端就接收什么；<br>    注意：<br>        ()可以解决比特差错，但是这并()；</p><p>PPP协议的组成：<br>    1）一个将IP数据包封装到串行链路的()；<br>    （既支持()（一连串比特连续传送），又支持()（逐个字符的传输，8bit一字符，没有奇偶校验）<br>    2）用来()的()；<br>    3）一套()<br>    （其中的每个协议支持不同的网络层协议，例如IP、OSI的网络层）</p><p>PPP协议的<strong>数据帧</strong>：<br>    首部字段从前往后：<br>        1）标志字段F：()（对应的就是首尾()）；<br>        2）地址字段A：0xFF，固定；<br>        3）控制字段C：0x03，固定；<br>        4）<strong>协议字段：</strong><br>            1）紧接着控制字段；<br>            2）2个字节；<br>            3）表征当前信息字段的含义：<br>                ()，对应()；<br>                ()，对应链路控制协议()；<br>                ()，对应网络层的控制数据（()协议）；<br>    尾部字段从前往后：<br>        1）()，两个字节，使用CRC；<br>        2）标志字段F：0x7E</p><p>PPP协议如何完成<strong>透明传输</strong>：<br>    对应的是组成的第一部分的作用（透明传输）；<br>    方法：<br>        <strong>字节填充</strong>：转义字符0x7D；<br>            1）若有()，则修改为：()；<br>            2）若有()，则修改为：()；<br>            3）若有()的字符，则修改为：()；<br>        <strong>零比特填充</strong>：<br>            1）尤其适用于同步传输的场景，传输一连串比特串；<br>            2）对于信息字段，只要发现有()，则填入一个()（填在连续的1后面）<br>    通过这些方法：<br>        在所传送的数据比特流中可以传送任意组合的比特流，而不会引起对帧边界的错误判断；</p><p><strong>LCP</strong>链路配置协议的作用：<br>    用来()；</p><p><strong>NCP</strong>网络控制协议的作用：<br>    为新接入的用户个人电脑()；</p><p>PPP协议的工作状态：<br>    <strong>链路静止</strong>：<br>        1）PPP协议的()，这时用户个人电脑和ISP路由器()；<br>    <strong>链路静止-&gt;链路建立</strong>：<br>        ()通过调制解调器()，路由器检测对应的载波信号，建立()；<br>    <strong>链路建立-&gt;鉴别：</strong><br>        进行()：<br>            链路的()，信息字段携带有特定的()；<br>                eg：<br>                    1）最大帧长；<br>                    2）所使用的鉴别协议；<br>                    3）不使用PPP协议的地址和控制字段；<br>            链路的另一端发送：<br>                1）配置()：所有选项都()；<br>                2）配置()：所有选项都理解但()；<br>                3）配置()：选项有的不能识别或无法接受，需要()；<br>        注意：<br>            如果配置协商失败，<strong>链路建立-&gt;链路静止</strong>；<br>    <strong>鉴别：</strong><br>        该状态只允许()，()的分组以及()质量的分组；<br>        eg：<br>            使用PAP口令鉴别协议：<br>                要求发起通信方，发送身份标识符和口令，系统允许用户重试多次；<br>    <strong>鉴别-&gt;网络层协议：</strong><br>        如果鉴别成功 or 不需要鉴别；<br>        注意：<br>            如果鉴别失败，<strong>鉴别-&gt;链路终止</strong>；<br>    <strong>网络层协议：</strong><br>        PPP协议的()根据网络层不同的协议，()；<br>        （重要的一步，是()的关键，从而让PPP协议两端端网络层在使用不同网络层协议的基础上，仍然使用同一个PPP协议进行通信）；<br>        eg：<br>            如果使用IP协议，则使用NCP中支持IP协议的IPCP（IP控制协议），将其封装成PPP帧，在链路上传送；<br>    <strong>网络层协议-&gt;链路打开：</strong><br>        NCP配置协商完成；<br>    <strong>链路打开：</strong><br>        1）链路的()；<br>        2）也可以发送给回送请求、回送回答对应的()；<br>    <strong>链路打开-&gt;链路终止：</strong><br>        终止请求：<br>            1）数据传输结束后，由链路的一方发送()，请求终止链路；<br>            2）接收到终止请求的一方，发送()，确认终止；<br>            3）转到链路终止状态；<br>        链路故障；<br>    <strong>链路终止-&gt;链路静止：</strong><br>        调制解调器的()；</p><p>CSMA&#x2F;CD协议（() 协议）<br>    背景：<br>        计算机之间在数据链路层端到端的通信，是通过总线实现的；<br>            尽力而为：<br>                1）这是无连接的工作方式，适配器对数据帧不编号、不要求确认，仅发送；<br>                2）以太网提供了()（不可靠交付），出现差错是否重传由高层决定；<br>                3）即使()，只是当作新的数据帧传输；<br>            总线传输：<br>                1）共用一个总线，在()只能允许()；<br>                2）()通信；<br>            编码：<br>                使用()，用跳变来代表01<br>                （代表0&#x2F;1的跳变：差分曼彻斯特编码跳变发生在虚线处，有跳变0无跳变1、曼彻斯特编码跳变发生在虚线间，低跳高1，高跳低0）；<br>                （差分曼彻斯特编码实际上会在时钟周期之间用跳变来同步时钟信号）；<br>    CSMA&#x2F;CD协议的作用：<br>        在上述背景下，以太网采用最简单的随机接入，所以需要一个协议来减少冲突发生的概率；<br>        （好像一个没有主持人的会议，大家想发言就发言，但是要找到一个规则，让大家的发言尽可能不同时发生，产生冲突；于是有了CSMA&#x2F;CD协议）；<br>    各部分的含义：<br>        CS：载波监听；<br>            ()，站点不管在发送数据之前，还是在发送数据之中，每个站都必须不停地检测信道；<br>            （在发送之前监听，是为了()）；<br>            （在发送中监听，是为了()）；<br>        MA：多点接入；<br>            说明这是()，许多计算机以多点点方式连接在一根总线上；（这就是一个背景，CS、CD才是协议的实质关键）；<br>        CD：碰撞检测；<br>            ()边发送数据边()信道上的信号()情况；<br>            （当两个站点同时发送数据的时候，总线上信号电压的幅度会变大）<br>    CSMA&#x2F;CD协议的内容：<br>        1）准备发送：网卡从网络层接收数据报，封装成帧；<br>        2）检测信道：<br>            如果网卡监听到()（()，信道上没有信号），则开始传送帧；<br>            如果监听到()，则()信道空闲（从没有信号开始，经过96比特时间）才开始传送帧；<br>            96比特时间称为()；<br>        3）边听边发：<br>            如果在()内一直未检测到碰撞，就认为发送成功（尽管此时可能还没发送完，接着发送完毕即可），回到1）；<br>            （接收方如果发现数据帧有差错就直接丢弃，等待高层来处理）；<br>            如果()内检测到碰撞，就立刻停止发送数据，并按规定发送()，然后适配器执行()，等待r倍争用期之后，回到步骤2）；<br>            如果重传达到()，仍然不能成功，停止重传向上报错；<br>            （在()以太网中，对应的争用期是()，计算如下）；<br>            <img src="/Computer-Network/p1.png" alt="争用期计算"><br>        关键概念：<br>            1）帧间最小间隔，96比特时间；<br>            2）争用期：<br>                1）是对于发送端而言的时间概念；<br>                2）()；<br>                3）这个时间就是发送站发送数据之后，最迟要经过多长的时间才能知道自己发送的数据和其他站发送的数据有没有发生碰撞；<br>            3）截断二进制指数退避算法：<br>                作用：决定冲突后等待，重新开始检测信道的时间；<br>                算法：<br>                    1）从离散集合 $[()]$ 中随机挑选一个数r；<br>                    2）其中 $k &#x3D; min(())$；<br>                    3）推后r倍的争用期（ $r \times RTT$ ），然后开始重新检测信道；<br>                （当重传次数达到16次之后会停止重传，向高层汇报）；<br>            4）强化碰撞：<br>                发送()的人为干扰信号，以便让所有用户都知道现在已经发送了碰撞；<br>            5）最短帧长：<br>                目的：为了确保载波监听可以发现争用期内的冲突；<br>                eg：<br>                    如果某站发送了()，但在发送完毕之前没有检测出碰撞（即载波监听时间内没有发现冲突），但是在向前传播到目的站之前和别的站发生了冲突（目前()以内），因而目的站会接收到有差错的帧，并将它丢弃；但是发送站不知道这个帧发生了碰撞，因而不会重传这个帧；<br>                本质原因：<br>                    1）发送的帧太短了，完全用不了一个争用期的时间；<br>                    2）而载波监听只会在发的时候进行；<br>                    3）如果有冲突发生，理论最迟监听到的时间是一个争用期的时间；<br>                    4）所以至少要让发送时间大于一个争用期；<br>                于是最短帧长：<br>                    () &gt;&#x3D; ()；<br>                注意：<br>                    1）如果发送的数据不足最短帧长，则必须加入一些()；<br>                    2）()的数据都被站点认为是，由于冲突而异常终止的()，收到后会立刻丢弃；<br>                    （()，对应的就是64字节，()）；</p><p>相关设备：<br>    <strong>网桥（()）</strong>：<br>        作用：对收到的帧根据()目的地址进行()；<br>        ()，()；<br>    <strong>转发器、集线器</strong>（()）：<br>        ()；<br>    <strong>以太网交换机</strong>（()）<br>        实质：多端口网桥；<br>        工作方式：()；<br>        作用：让相互通信的主机可以独占传输媒体，无碰撞地传输数据；<br>        原理：<br>            多端口负责接收数据和转发数据，自学习构建转发表；<br>            存储支持暂存再发送，从而隔离冲突域，用户尽管往交换机发；<br>        ()，()；<br>    <strong>路由器</strong>（()）<br>        可以()，()；<br>    （如果可以冲突域，考虑平均带宽，<em>练习题目</em>）；</p><p>以太网交换机的转发原理：<br>    1）以太网交换机具有()；<br>    2）转发原理：<br>        1）交换机中维护一个()，用来指示对于目的地址是某个MAC地址的数据帧应该从哪个端口发出去；<br>        2）若有一个()发来，数据帧中有（()），并且是从一个交换机可以感知的()的；<br>        3）()表项：<br>            检查该数据帧的()是否在表中，如果()；<br>        4）尝试()：<br>            1）如果表中有目的MAC地址对应的端口号则从()；<br>            2）如果表中没有目的地址对应的端口号，则从除了进入端口号以外的所有端口号()；<br>    注意：<br>        1）广播发送可以保证，目的MAC地址方能够接收到；<br>        2）对于不是目的MAC地址方的，会将这个数据帧丢弃，即()；<br>        3）交换机更新表项的能力就称为()；</p><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>网络层的主要功能：<br>    完成不同网络中的()；</p><p>路由器之间传送信息：<br>    1）转发()之间所()（将源主机发送的分组一个一个路由器的转发，直到转发到目的主机）；<br>    2）传送()（根据路由选择协议所使用的路由算法，彼此不断地交换路由信息分组，从而建立路由表）；</p><p>ipv4几个类网络地址：<br>    网络地址+主机地址；开头；<br>    1）A：()；0；<br>    2）B：()；10；<br>    3）C：()；110；<br>    其他：<br>        1）D：1110+多播地址；<br>        2）E：1111+实验开发；<br>    注意：<br>        <strong>如何通过开头的地址判断网络类型</strong>；<br>    特殊号码：<br>        1）A类中00000000网络号码，代表()；<br>        2）A类中01111111网络号码，代表()；<br>        （B类、C类没有这个问题）；<br>        3）网络号不为全0主机号为全0，代表()；<br>        4）网络号为全0主机号不为全0，代表()；<br>        5）网络号和主机号均为0，代表()；<br>        6）网络号不为全1，主机号为全1，()；<br>        7）网络号全为1，主机号全为1，代表()；<br>        （注意6、7都可以指广播地址，要注意具体的应用场景）；<br>        8）()，本地主机测试地址；<br>    按照某类地址给<strong>机构划分子网</strong>：<br>        1）可以使用二叉树划分法；<br>        2）注意划分的时候主机号全0全1不能用；<br>        （对应特殊号码的3、6，<em>练习题目</em>）</p><p>ARP协议<br>    作用：根据机器的()，找到相应的()，使得数据能够通过链路层传输；<br>    背景：<br>        1）IP地址与MAC地址格式不同，()，不存在简单的映射关系；<br>        2）一个网络上可能经常有新的主机加入进来，或撤走一些主机；<br>        3）更换网络适配器也会使主机的MAC地址改变（主机的()实际上就来自其()）；<br>    ARP协议的思想：<br>        在主机中维护一个()，存放一个从IP地址到MAC地址到映射表，这个映射表可以动态更新（新增或超时删除）；<br>    协议具体工作流程：<br>        1）()：<br>            当主机A要向本局域网的某台主机B发送IP数据包时，检查自己的ARP高速缓存，如果其中有B的IP地址对应的MAC地址，则将数据包封装的MAC帧发送到对应的地址，否则进入2）；<br>            （注意，这一步实际上是没有用到ARP协议的）；<br>        2）运行ARP：<br>            1）ARP进程在杂本局域网上()（其中写入了A自己的IP地址、MAC地址，想要请求的MAC地址对应的IP地址）；<br>            2）局域网上所有运行ARP进程的主机都会收到这个分组；<br>            3）收到ARP请求分组的主机，检查其中请求MAC地址对应的IP地址是否与自己的()，如果一致就向A()；<br>            （注意，ARP请求分组虽然是广播发送的，但是ARP响应分组是单播，因为有A确定的MAC地址）；<br>            （注意，为了()，会采取一种()，即让B在收到A的请求分组后，将A的IP地址和对应MAC地址写入ARP高速缓存中，因为后续B很可能会和A通信）；<br>            4）A收到B的响应分组后，将B的IP地址和对应的MAC地址()自己的ARP高速缓存表中；</p><p>ipv4 IP数据包报头：<br>    1）Version（版本号）：<br>        1）()：ipv4；<br>        2）()：ipv6；<br>    2）Header length（首部长度）：<br>        1）标识首部长度，()，ip数据报头()，所以该()；<br>    3）type of service（区分服务）：<br>        1）一般情况下不会使用这个字段；<br>    4）datagram length（数据报）：<br>        1）()，()，该字段是16位，所以ip数据包最长是()；<br>        2）如果ip数据包进行了()，则该字段1是()；<br>    5）identifier（标识）：<br>        1）当ip数据报需要分片的时候，来自于()的分片数据报该()，用来()；<br>        2）实际的赋值机制，是每产生一个数据报计数器就加1（未分片），然后对该数据报进行分片，完成后，将这个字段的值复制到每一个分片；<br>    6）flag（标志）：<br>        1）3位只有()有意义；<br>        2）最低位MF，1代表()，0代表()；<br>        3）中间位DF，1代表()，0代表()；<br>    7）Fragmentation offset（位偏移）：<br>        1）指出分片后，当前()；<br>        2）偏移()，也就是说除了最后一个分片其他分片的长度一定是8的倍数；<br>        3）该字段实际使用的时候，字段值是多少就代表该分片的数据部分，第一个字节，在原始数据中是第()字节；<br>            eg：offset &#x3D; 0，则原来是第一个字节；<br>                offset &#x3D; 1，则原来是第65个字节；<br>        （当然如果直接考虑偏移量，使用第0个字节的表述，并以其作为开头的话，实际上offset<em>8的值就代表，当前分片开始的字节，在原始数据报中是第几个字节）；<br>        4）在分片的时候不能忘记，每个分片都要添加报头，()的时候很重要；<br>        5）但是在计算offset的时候，不能加入报头，()；<br>        6）()；<br>    8）TTL（生存时间）<br>        1）功能是作为()，()不能到达目的地的IP数据报在互联网中()；<br>        2）当数据报到达一个路由器，()，如果等于0则丢弃；<br>        3）如果一个数据报只允许在局域网中转发，那么将TTL设置为1（到达该局域网的路由器的时候，TTL减为0就会被丢弃）；<br>        4）一个数据报能经过（到达）的路由器()；<br>    9）upper-layer protocal（协议）<br>        1）指出当前IP数据报携带的数据来自于什么上层协议；<br>        2）常用的：<br>            ICMP-1；()；()；EGP-8；IGP-9；OSPF-89；<br>    10）check sum（首部检验和）<br>        1）只检验数据报的首部，不包括数据部分；<br>        2）()就要()首部检验和；<br>        3）计算方法是()，相加，()，()；<br>        （接收方检验方法是()，如果()则没有出错，否则认为出错，丢弃；</em>题目练习*）<br>    11）source address（源地址）<br>        1）32位，发送主机的IP地址；<br>        2）32位，接收主机的IP地址；</p><p>最长前缀匹配<br>    1）<strong>原则：</strong><br>        在采用CIDR编址时，如果一个分组在转发表中可以找到()，那么就应当()前缀()的一个作为匹配的前缀。这个原则称为最长前缀匹配；<br>    2）思想：<br>        网络前缀越长，其地址块就越小，因而路由越具体；</p><p><strong>分组转发算法</strong> 路由表项的排列 特定主机路由 默认路由（若有 若无）<br>    分组转发算法：<br>        1）从收到的分组的首部提取()；<br>        2）查找是否有()，对应该IP地址，若有责直接按照下一跳转发；<br>        3）否则，从转发表中()进行检查：<br>            1）将这一行的子网掩码与目的地址AND运算；<br>            2）如果结果和本行()则按下一跳转发（或直接交付本网络上的目的主机，或转发给下一跳路由器）；<br>            3）如果不匹配则继续检查下一行；<br>        4）如果检查结果均不匹配，则来到最后的()，按照指定的接口进行转发；<br>    一些说明：<br>        关于3）：<br>            1）这里查找转发表的逻辑实际上涉及路由表项的排列；<br>            2）路由表项中按照前缀的长度进行排列，由长到短递减；<br>            3）这样的基础上从上到下检查不断“下一行”检查，本身就契合了最长前缀匹配；<br>            4）这样排列也契合了，先检查特定路由，然后进行匹配，最后考虑默认路由；<br>            （因为特定路由等价于前缀长度32，最长；进行匹配就是前缀长度长到短排列；默认路由0.0.0.0是其子网掩码，实际上就等价于前缀长度是0，最短）；<br>        关于1）、4）：<br>            1）特定主机路由和默认主机路由其实都是可选的，不一定存在；<br>            2）尤其是如果默认主机路由不存在，又找不到转发的接口，那么就会报告转发分组错误；</p><p>二叉线索查找转发表：<br>    背景：<br>        1）使用CIDR完成路由聚合后，由于不知道目的网络前缀，让转发表的查找变复杂了；<br>        2）在转发表项目数很大的时候，怎样缩短转发表查找实践是一个非常重要的问题；<br>        3）普通情况，无分类编址的转发表，最简单的查找算法就是对所有前缀进行循环查找，逐行检查网络前缀；<br>    二叉线索查找思想：<br>        1）将无分类编址的转发表存入一种层次数据结构中，然后自上而下地按层次查找；<br>        2）好处就是可以一次排除“一类”前缀，避免不必要的AND运算；<br>    使用方法：<br>        1）用()构造()；<br>        2）是否与()匹配；（对应到叶节点）；<br>        （转发时用目的地址与唯一前缀进行匹配，对目的地址按照高位到低位的顺序，查看0&#x2F;1，选择二叉树上对应的边，从根节点出发持续向下，直到到达叶节点，如果不能到达叶节点则直接丢弃，因为一定没有匹配的前缀）<br>        3）与掩码运算-&gt;是否与()匹配；<br>        （到达叶节点了之后，只是说明唯一前缀匹配上了，还要查看网络是否匹配）；<br>        4）() or 默认转发 or ()；<br>        （如果匹配上了就转发，没有的话看有没有默认转发，没有则丢弃，报错）；</p><p>DHCP协议（应用层 C&#x2F;S模式 UDP协议为其提供服务）<br>    作用：<br>        1）()；<br>        2）为()进入一个网络的主机分配()；<br>    工作原理：<br>        1）DHCP ()：<br>            新到来的主机发送DHCP报文：<br>                1）src: ()；（()，()客户端端口）<br>                2）dest: ()；（()，()服务器端口）<br>                3）<strong>yiaddr</strong>: 0.0.0.0；（等待服务器分配的地址）<br>                4） transaction ID：654；（代表这是获得动态主机IP地址的请求报文）；<br>        2）DHCP ()：<br>            服务器收到discover后回复：<br>                1）src：223.1.2.5，67；<br>                2）dest：255.255.255.255，68；<br>                3）yiaddr：223.1.2.4（()）；<br>                4）transaction ID：654；（代表这是回复动态主机IP地址请求的应答）；<br>                5）()：3600（动态IP使用时间）；<br>        3）DHCP ()：<br>            客户端收到offer后再与服务器()：<br>                1）src：0.0.0.0，68；<br>                2）dest：255.255.255.255，67；<br>                3）yiaddr：223.1.2.4；<br>                4）transaction ID：655；（代表这是核实IP的请求）；<br>                5）Lifetime：3600；<br>        4）DHCP ()：<br>            服务器()：<br>                1）src：223.1.2.5，67；<br>                2）dest：255.255.255.255，68；<br>                3）yiaddr：223.1.2.4；<br>                4）transaction ID：655；<br>                5）Lifetime：3600；</p><p>RIP协议<br>    基本知识：<br>        1）中文名是()；<br>        2）是一种()的选路协议；<br>        3）RIP适用于小型网络，因为不可达距离只有16；<br>    <strong>距离的定义</strong>（跳数、路由器数）：<br>        1）从路由器到直接连接到网络距离为1；<br>        2）从一个主机到非直接连接到网络距离是()；<br>        （+1是因为直接相连定义了距离为1）；<br>        3）不可达距离 ()<br>    交换信息（特点）：和谁交换信息？交换哪些信息？（1、2、3）何时交换信息（1、2）？<br>        协议是通过交换信息工作的，使用RIP协议的路由器有如下特点：<br>            1）仅和()交换信息；<br>            2）交换的信息是本路由器知道的全部信息，即自己的()（到本自治系统中所有网络的最短距离，对应的下一跳路由器）；<br>            3）按固定的时间间隔交换信息：<br>                1）每隔()秒会交换信息；<br>                2）当网络拓扑结构发生变化时，交换信息；<br>        注意：<br>            1）主机也运行RIP协议的话，它智能被动的接收信息，不能发出自己的信息，因为它没有转发功能；<br>            2）刚开始的时候，路由器中路由表是空的，然后可以直接得出与其直接相连的几个网络的距离（定义为1）；     </p><p>距离向量算法：<br>    1）路由器维护的表项目、交换报文（RIP报文）的内容（1、2、3）；<br>        路由器中维护的表项信息，就是交换报文中的主要项目信息；<br>            1）目的网络Neti：代表往这个方向转发的最终目的地；<br>            2）下一跳路由器Ri：要前往目的地下一跳应该向哪个路由器转发；<br>            3）距离d：从当前路由器到达目的地的最终距离；<br>    2）收到报文的操作（项目信息(Neti,Ri,d)）：<br>        1）修改报文项目（1、2）；<br>            1）将Ri改为()；<br>            2）距离d &#x3D; ()；<br>        2）若无目的网络-更新表项目；<br>            如果当前路由器的转发表中没有能够到达Neti的转发表项，则直接将报文项目加入自己的转发表中；<br>        3）若有目的网络-下一跳路由器？<br>            如果当前路由器转发表中有能够到达Neti的表项目：<br>                1）如果对应表项的下一跳是Rj，则直接()；<br>                2）如果对应表项下一跳不是Rj，谁的距离()；<br>    3）3分钟-不可达；<br>        如果3分钟没有收到相邻路由器的更新路由表，则把此相邻路由器，标记为不可达路由器，距离设置为16；<br>    注意：<br>        1）一个RIP报文最多()个路由-()个表项，超过25个报文要再用一个发；<br>        （即实际上上述交换的一个RIP报文，不止有一个表项信息）</p><p>坏消息传得慢-例子（RIP报原始内容）<br>    <em>习题练习</em>；</p><p>OSPF：<br>    基本知识：<br>        1）使用()协议；<br>    交换信息（特点）：<br>        1）向本自治系统中的所有路由器发送信息，使用()；<br>        2）发送的信息：<br>            1）相邻的所有路由器的()；<br>            2）其中包括链路的度量，用来表示代价；<br>            （可以选择费用、距离、时延等等信息来作为这个度量）；<br>            3）每隔一段时间（30分钟） 或者 链路状态发生变化的时候，向所有路由器使用可靠的洪泛法发送链路状态信息<br>            （和谁交换信息（可靠的洪泛法）、交换哪些信息（1、2）、何时交换信息（30分钟））<br>    注意：<br>        1）实际上，所有的路由器最终都能建立一个()，对应的就是全网的拓扑结构图，并且这个结构在全网范围是一致的；<br>        （最直接的结果就是，可以直接看作在一个静态的图上面做Dijkstra算法搜索最短路，或者说对于我们应试来说，在使用OSPF路由的时候，我们可以直接看哪条路最短，来确定下一跳路由器）；<br>        2）OSPF收敛得快；<br>        3）OSPF能够适用于大规模网络；<br>        4）OSPF能够实现()：<br>            <strong>如果到同一个目的网络有多条相同代价的路径，那么可以将通信量分配给这几条路径；</strong></p><p>OSPF使用层次结构区域划分：<br>    好处：在使用洪泛法的时候将链路状态信息的范围局限在一个区域中，而不是整个自治系统，减少整个网络上的通信量；<br>    1）主干区域：<br>        标识符规定()（本自治系统内生效）；<br>    2）其他区域：<br>        主干区域以外的其他各个区域，标识符自定，例如0.0.0.1，0.0.0.2；<br>        （当然都是本自治系统内生效）；<br>    3）相关路由器：<br>        1）主干区域路由器，主干区域内的路由器；<br>        2）区域边界路由器，一个区域的边界路由器，负责将当前区域和其他区域连接起来；<br>        3）自治系统边界路由器，一个自治系统的边界的路由器，负责将当前AS和其他AS连接起来；<br>        注意：<br>            自治系统边界路由器一般在主干区域中，可以同时是主干区域路由器、自治系统边界路由器、区域边界路由器；</p><p>OSPF五种类型的分组：<br>    物种类型分组：<br>        1）()（10s一次，40s没有则不可达）；作用？（初始时）；<br>            作用：用来();<br>        2）()；（交换链路状态摘要信息，用来确认哪些没有）；<br>            作用：向邻站给出自己链路状态数据库中所有链路状态项目的摘要信息；<br>        3）()；（针对没有的请求）；<br>            作用：向对方请求发送某些链路状态的详细信息；<br>        4）();<br>            作用：在洪泛法中使用的分组，用来更新全网链路状态；<br>        5）()；<br>            作用：对链路更新分组的确认，也会在洪泛法中使用；<br>    OSPF的工作过程：<br>        1）使用问候分组判断可达与否：<br>            1）相邻路由器每10s必须交换一次问候分组，从而明确哪些邻站是可达达；<br>            2）如果40s没有收到某个邻站的问候分组，则认为不可达，立即修改链路状态数据库计算新的路由表；<br>            （可达是基本要求，只有可达邻站的链路状态信息才会存入链路状态数据库，路由表是根据链路状态数据库计算出来的）；<br>        2）使用其他分组进行链路状态数据库的同步：<br>            同步的概念：<br>                1）不同路由器的链路状态数据库内容是一样的；<br>                2）两个同步的路由器被称作是完全邻接的；<br>                （不完全邻接的路由器可能只是物理上相邻的）；<br>            过程：<br>                1）每个路由器使用数据库描述分组和相邻路由器交换本数据库中已有的链路状态摘要信息；<br>                2）路由器拿到对方的链路状态描述分组后，根据其中内容检查自己缺少的某些链路状态；<br>                3）向对方发送链路状态请求分组，请求对应自己没有的链路状态信息；<br>                4）收到链路状态请求分组的路由器，按照对方请求的链路状态，用单播的方式，将对应链路状态信息发送给请求方；<br>                5）洪泛法的启用：<br>                    1）当一个路由器的链路状态发生变化的时候，开始使用洪泛法发送信息；<br>                    2）路由器对所有相邻的路由器发送自己的链路状态更新分组；<br>                    3）收到该分组的路由器对链路状态更新分组进行转发（转发到排除上游路由器对所有相邻路由器）；<br>                    4）收到链路状态更新分组的路由器，向给自己发送该分组的路由器发送确认信号；<br>                    （确认是可靠的洪泛法所必要的，而OSPF就是采用可靠的洪泛法）；<br>                    （收到重复的更新分组，只用发送一次确认）；</p><p>可靠的洪泛法：<br>    1）发送；<br>    2）转发（除了上游）；<br>    3）确认（忽略重复）；</p><p>BGP协议：<br>    基本知识：<br>        1）BGP是()；<br>        （RIP、OSPF协议都是内部网关协议）；<br>        2）用于()之间的路由选择；<br>        3）采用的是()路由选择协议；<br>    作用：<br>        选择出一条能够到达目的网络前缀且比较好的路由（不兜圈子），而不是非要计算出一条最佳路由；<br>        为什么不是最佳路由？<br>            1）互联网的规模太大，使得自治系统AS之间的路由选择非常困难；<br>            （例如不同AS中的代价度量不同，比较合理地做法是考虑可达性）；<br>            2）自治系统AS之间的路由选择必须考虑有关策略；<br>            （即考虑多种路由选择策略，包括政治、安全或经济方面；）<br>    相关路由器：<br>        1）AS中有()和()；<br>        2）一个AS至少有一个边界路由器和相邻AS的边界路由器直接相连；<br>        3）正是有了边界路由器，AS之间才能利用协议BGP交换可达性路由信息；<br>    BGP路由的一般格式：<br>        1）这里的路由指的是BGP协议报中有关选路的信息，就类似于RIP报文中的信息；<br>        2）格式：“前缀，BGP信息” &#x3D; “()”；<br>        3）其中：<br>            1）前缀，对应的是BGP路由终点的子网前缀；<br>            2）AS-PATH，是()，通告BGP路由所经过的自治系统；<br>            3）NEXT-HOP，()，对应当前BGP路由的起点；<br>    BGP协议的使用：<br>        1）两个边界路由器建立()连接；<br>        2）边界路由器作为对等端通过()协议互相发送BGP路由；<br>            注意：<br>                1）例如，BGP路由：“X，AS1，R1”，代表可以到达网络前缀位X的网络，经过AS1，下一跳是R1；<br>                2）边界路由器R2就知道下一跳R1，会进入AS1中的，X前缀对应的网络；<br>                3）建立eBGP的两个路由，即不同AS之间的对等端建立了BGP连接；<br>        3）边界路由器收到BGP路由后，更新自己的转发表，然后：<br>            1）与AS内的路由两两之间均建立()连接；<br>                注意：<br>                    1）这种连接是全连通的，即使物理上没有连通；<br>                    2）建立iBGP的两个路由器，即同一AS中的对等端建立了BGP连接；<br>            2）边界路由器通过iBGP将BGP路由发送给AS内的对等端；<br>        3）内部路由器收到BGP路由后，构建转发表：<br>            关键是修改BGP路由中的下一跳信息；<br>            （例如AS2中的R4，不能直接用原始的BGP路由信息中的R1，作为下一跳的转发，因为根本没连接）；<br>            1）通过两次递归查询，找到可用的下一跳路由器；<br>                1）找到非自己所在AS的边界路由器的对等端，即在自己的AS中的边界路由器，且与BGP路由中的边界路由器相连；<br>                （例如R1在AS1中，R4不清楚R1的位置，就找到R1对应的边界路由器R2）；<br>                2）使用IGP（内部网关协议），查询从自己到达边界路由器的最佳路由；<br>                （例如R4要到R2，查看转发表到达R2的最好下一跳发现是R3）；<br>            2）用对应的路由器修改该BGP路由信息，存入自己的转发表中；<br>            （例如，最终BGP路由中有“X，R3”，存放在R4的转发表中）<br>    注意：<br>        1）上面的BGP协议使用，我们主要关注了各个路由器如何使用BGP路由来更新自己的路由表；<br>        2）但是BGP路由的AS信息也是需要维护的，每新到一个自治系统，该AS会被加入BGP路由的AS-PATH中；<br>        （例如上面的例子，最终的”X,R3”，实际上是”X,AS2-AS1,R3”）；</p><p>为什么使用BGP？<br>    1）巨大规模的互联网，自制系统AS之间选路；<br>    2）考虑相关策略（可达性而非代价）</p><p>BGP使用：()选路策略</p><p>BGP报文内容（到达AS1对应的前缀、发送报文的路由器、路由器所在的自治系统AS1）<br>BGP协议路由表（前缀X，下一跳路由器）-含义是下一跳经过路由器，前缀X可达；</p><p>eBGP、iBGP（区别，适用路由器）</p><p>iBGP的全连通</p><p>RIP OSPF BGP区别对比<br>1）RIP不能使用多条路由 OSPF可以()，每一个路由器都知道全网有多少路由器，哪些是相连的，代价是多少；<br>2）RIP、OSPF是工作在()内的 BGP工作在()之间；<br>3）使用的协议不同；<br>4）OSPF在网络层 RIP、BGP在()层（分别由()、()服务）；<br>5）OSPF、RIP属于() 对应BGP；<br>6）OSPF知道全网的拓扑结构，RIP不知道；</p><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>运输层的两个主要协议：<br>    1）()：提供可靠的、面向连接的运输服务；<br>    2）()：无连接，实时、快速高效；</p><p>TCP报文中有一个可选项MSS：<br>    这是()字段，代表的是数据字段的最大长度，这个字段要加上TCP首部的长度才是TCP报文的总的最大长度；<br>    <em>考虑这个字段与拥塞控制的关系</em>；</p><p>TCP流量控制<br>    1）含义：让发送方的速率不要太快，要让接收方来得及接收；<br>    2）实现方式：()；<br>    3）一些细节：<br>        1）发送方的发送窗口大小不能超过接收方给出的接收窗口()；<br>        2）TCP窗口单位是()不是报文段；<br>        3）当rwnd为0时对应()，发送方不允许再发送数据，直到接收方重新发送一个新的窗口值为止；<br>    4）什么时候会发送零窗口通知：<br>        1）接收端将接收到的数据放入缓冲区，如果上层应用不及时读取，缓冲区满了的时候；<br>        2）当接收方检测到可用窗口为0的时候；<br>        3）出现1、2两种情况的时候发送方在对于先前数据的确认报文中会通知rwnd&#x3D;0；<br>    5）零窗口的死锁问题：<br>        描述：<br>            接收方向发送方发送了零窗口报文段之后不久，接收方释放了一些空间，向发送方发送了rwnd&#x3D;400的报文段；但是报文段在传送中丢失了，发送方一直在等待接收方发送非零窗口报文段，接收方一直在等待发送方发送数据，陷入死锁；<br>        解决方法：<br>            TCP为每个链接设立的——()；<br>            机制：<br>                只要TCP连接的一方收到了零窗口报文段，就启动持续计时器，如果计时器时间到了就发送一个()（仅携带1字节数据），对方会在确认探测报文段时给出当前窗口值，如果仍是零，则重置计时器，否则死锁局面解除；</p><p>TCP的拥塞控制<br>    基本概念：<br>        1）拥塞：在某段时间，若对网络中的某一资源的需求超过了该资源所能提供的可用部分，网络的性能就会变坏，这种情况就叫做拥塞。<br>        2）拥塞控制：<br>            1）含义：防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不至于过载。<br>            2）前提：网络能够承载现有的负荷（负载）；<br>            3）特点：这是一个全局性的过程，对比流量控制是点对点的通信量控制（是端到端的过程）；<br>        3）网络负载：提供给网络的负载，也称为输入负载；<br>            （常用于 网络负载-吞吐量 图中）；<br>        4）网络的几种状态（用负载和吞吐量进行判定）：<br>            1）理想情况：吞吐量饱和之前，网络吞吐量&#x3D;网络负载，吞吐量曲线是45度的直线；<br>            2）轻度拥塞状态：网络吞吐量还未到饱和，但是已经有分组被丢弃了，网络吞吐量明显小于理想吞吐量；<br>            3）拥塞状态：网络吞吐量随着负载增减开始减少，而不是理想情况下保持饱和不变；<br>            4）死锁：当网络负载增大到一定数量的时候，吞吐量下降到零；<br>    TCP拥塞控制方法：<br>        假定（理想情况方便讨论算法）：<br>            1）数据是单向发送的，对方只传送确认报文；<br>            2）接收方有足够大的缓存空间，因而发送窗口的大小由网络的拥塞程度来决定；<br>            （实际情况发送方接收窗口的上限 &#x3D; ()，其中rwnd是接收方报文中规定的接收窗口大小）；<br>        基本思想：<br>            1）基于窗口进行拥塞控制，发送方维持一个()，随着网络拥塞程度动态变化，让发送窗口等于拥塞窗口；<br>            2）只要网络没有拥塞，拥塞窗口就可以增大一些以便发送更多的分组，只要出现了拥塞，拥塞窗口就减小一些，以缓解拥塞；<br>        慢开始：<br>            1）设置初始拥塞窗口大小：<br>                1）旧规定：将初始cwnd设置为1～2个SMSS（发送方最大报文长度）；<br>                2）新规定：将初始cwnd设置为2～4个SMSS；<br>                    1）如果SMSS &gt; 2190B，则cwnd &#x3D; 2*SMSS；（不得超过两个报文段）；<br>                    2）如果1095 &lt; SMSS &lt;&#x3D; 2190，则cwnd &#x3D; 3*SMSS；（不得超过三个报文段）；<br>                    3）如果SMSS &lt;&#x3D; 1095，则cwnd &#x3D; 4*SMSS；（不得超过四个报文段）；<br>            2）拥塞窗口增大机制：<br>                1）在每收到一个对新的报文段的确认后，可以把拥塞窗口增加最多一个SMSS的数值；<br>                2）具体来说，拥塞窗口cwnd每次的增加量 &#x3D; ()，其中N是原来未被确认的、但是现在刚收到的确认报文段，所确认的字节数；<br>                3）显然，这种规定下，理想情况cwnd在慢开始阶段是()（每次扩大为原来的两倍）；<br>            3）慢开始阶段的表现：<br>                1）虽然TCP是用字节数作为窗口大小的单位的，但是拥塞控制中为了方便叙述，通常使用报文段个数作为单位；<br>                2）开始时cwnd&#x3D;1；<br>                3）发送方每收到一个对新报文段段确认（对重传的确认不算），cwnd就加1；<br>                4）那么一个RTT后，cwnd&#x3D;2，允许连续发送两个报文段，再一个RTT后收到两个确认，cwnd&#x3D;4，允许连续发送4个报文段，…以此类推；<br>                （注意，显然发送方不是要在所有的确认都收齐了之后才调整其拥塞窗口，而是收到一个确认就调整一下拥塞窗口，这是里面的细节）；<br>            4）慢开始门限()：<br>                1）当cwnd &lt; ssthresh时使用()；<br>                2）当cwnd &gt; ssthresh时停止慢开始算法，启用()；<br>                3）当cwnd &#x3D; ssthresh时，可以选择一个用，决定下一个时刻的行为；<br>        拥塞避免：<br>            1）加法增大：<br>                1）每经过一个RTT的时间，发送方的cwnd大小就()，而不是像慢开始那样成倍增长；<br>                2）这样做可以让cwnd缓慢增大；<br>            2）拥塞避免阶段的表现：<br>                cwnd按()缓慢增长；<br>        超时处理：<br>            1）超时标志：<br>                1）超时重传计时器启动；<br>                2）判断网络出现了拥塞；<br>            2）处理机制：<br>                1）慢开始门限ssthresh设置为()；<br>                2）拥塞窗口置一，cwnd &#x3D; 1；<br>                3）重新开始()；<br>            注意：<br>                1）超时的发生不一定就是网络发生了拥塞，也可能是因为传输出现了差错，而导致分组被丢弃；<br>                2）尽管现代通信线路传输质量都很好，因为传输差错而丢弃分组的概率远小于1%。这也是为什么用超时来判断拥塞，因为超时大概率是拥塞造成的；<br>                3）因此设置了快重传机制；<br>        快重传与快恢复：<br>            1）算法要求：<br>                1）接收方不要等待自己发送数据时才稍带确认，而是在收到报文后立即发送确认；<br>                2）即使收到的失序的报文段也要立即发出对已收到报文段的重复确认；（尽管本来可以什么都不做）；<br>            2）快重传：<br>                1）在接收方一连收到()之后，判断网络没有出现拥塞，但是接收方少了一个报文段M；<br>                2）对方却少的是被重复确认的报文段的下一个报文段，例如重复确认三次M2，那么缺少了M3；<br>                3）发送方立即重新发送接收方缺少的报文段；<br>            3）快恢复：<br>                1）在快重传之后启动快恢复；<br>                2）设置慢启动门限为()；<br>                3）将cwnd减小，通常有两种方法：（这个过程称为()）；<br>                    1）()；（课本上主要阐释的这种）；<br>                    2）()；<br>        <img src="/Computer-Network/p1.jpeg" alt="TCP拥塞控制算法流程图">;</p><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>DNS的作用：<br>    ();</p><p>DNS协议依赖的下层协议：<br>    传输层：()；<br>    网络层：IP协议；<br>    数据链路层（以太网）：CSMA&#x2F;CD协议；</p><p>HTTP协议依赖的下层协议：<br>    传输层：()；<br>    网络层：IP协议；<br>    数据链路层：CSMA&#x2F;CD协议；</p><p>使用一个协议就要封装一个协议的数据包（例如使用DNS协议的时候封装了4层数据包）；</p><h3 id="无线网络"><a href="#无线网络" class="headerlink" title="无线网络"></a>无线网络</h3><p>隐蔽站&#x2F;暴露站</p><p>CSMA&#x2F;CA协议：<br>    背景：<br>        1）无线局域网使用的数据链路比较特殊，对应的是无线信号的信道，但是和物理链路一样也要考虑信道上信号的碰撞问题，同一时刻同一信道上应该只有一种信号；<br>        2）无线局域网的特点：<br>            1）无线局域网的适配器无法实现碰撞检测；<br>            2）检测到信道空闲，起始信道可能并不空闲；<br>            3）即使我们能够在硬件上实现无线局域网的碰撞检测功能，也无法检测出隐蔽站问题带来的碰撞；<br>        3）所以实际上CSMA&#x2F;CA协议不是载波监听多路复用&#x2F;碰撞检测协议，而是()（尽量减少碰撞发生的概率）；<br>    独特的MAC层：<br>        1）802.11标准为CSMA&#x2F;CA协议中设计了独特的MAC层；<br>        2）其中集成了协调功能所必需的字段：<br>            1）()：分布式协调功能，这是为了后面的争用服务必需实现的字段；（重点）；<br>            2）()：点协调功能，无争用服务选用；<br>    CSMA&#x2F;CA协议要点：<br>        1）站点如果要发送数据，必须先监听信道，如果信道在()内均空闲，则发送整个数据帧；<br>        2）否则，<strong>争用信道</strong>；<br>            站点选择随机数，设置退避计时器；<br>            如果信道忙则冻结计时器；<br>            如果信道空闲，且在DIFS内均空闲，则启动计时器；<br>            当计时器减到零，则发送数据帧；<br>        3）如果发送方站点，接收到却认帧，且后续还有帧要发送，再次进入2），但是要在<strong>更大范围</strong>选择随机数；<br>    要点补充：<br>        1）关于DIFS：假设A給B发送数据帧DATA；<br>            1）B接收到数据帧要发送确认ACK；<br>            2）确认发送时间必然滞后于B接收完DATA的时间，因为有CRC校验等；<br>            3）考虑滞后时间统一设置一个标准为()；<br>            4）那么实际上SIFS这段时间内信道是空闲的；<br>            5）为了保证这段空闲时间内其他站点不发送数据，使用更长的()（分布式协调帧间间隔）；<br>            6）空闲时间其他站点想发送数据必须等待DIFS的时间；<br>        2）关于监听（确定信道在忙的具体方法）：<br>            1）802.11标准要求每个站必须同时使用两个方法；<br>            2）第一是，()（软件实现）：<br>                1）源站（发送站）：将自己占用信道的时间（DATA+SIFS+ACK）写入数据帧；<br>                2）广播范围内的各站能够接收到该信息，创建自己的()，指出信道在忙的时间，除了源站和目的站在这一时间内不能使用信道；<br>            3）第二是，()（物理层实现）：<br>                每个站检测接收到的信号强度是否超过一定门限数值，由此判断是否有其他移动站在信道上发送数据；<br>        3）关于争用期的触发：<br>            1）要发送数据时检测到信道在忙；<br>            2）已发送到数据帧未收到确认，要重传数据帧；<br>            3）发送了一个数据帧要接着发送后续的数据帧；（为了防止一个站点长期垄断信道）；<br>            （其他情况，当站点想要发送数据，并检测到信道空闲时间超过DIFS可以直接发送，不用经过争用期）；<br>        4）争用信道的过程（争用期）：<br>            1）使用争用窗口CW，它由许多时隙组成；<br>                （802.11g规定一个时隙为9微秒，SIFS是10微秒，DIFS是28微秒）；<br>            2）退避：<br>                进入争用期（信道空闲）时，在0～CW的时隙中随机生成时隙个数，设置退避计时器；<br>            3）推迟接入：<br>                1）退避计时器先降为0的，开始发送数据帧，信道转为忙；<br>                2）正在退避的站，冻结计时器，保留数值不变，等待下一次争用期接着继续倒计时；<br>        5）关于争用窗口CW的维护：<br>            1）CW需要增大的两种情况：<br>                1）紧接着发送后续帧；<br>                2）每一次重传；<br>            2）具体操作：<br>                1）在每次增大的时候CW会近似翻倍；<br>                2）例如初始时CW &#x3D; 15 &#x3D; 2^4 - 1，那么第i次增大的时候CW &#x3D; 2^(4+i) - 1；<br>                3）通常802.11建议：CW最小取15，最大取1023，当到达1023之后CW不会再增大；<br>    信道预约技术：<br>        目的：更好地避免()；<br>        具体方法：假设A給B发送数据；<br>            1）对于无线局域网，移动站点都会接入一个AP，用来充当站点之间的中介进行信息转发；<br>            2）A在与B通信之前，A向AP发送()；<br>            3）AP收到之后，经过SIFS，恢复()；<br>            4）其他所有能够收到AP的CTS的站点，都会知道在一段时间内信道被A、B的通信占用，并以此设置其NAV；<br>            （实际上这与前面的虚拟载波监听、载波监听，互为一个补充）；</p><h2 id="try-yourself"><a href="#try-yourself" class="headerlink" title="try yourself"></a>try yourself</h2><p><code>if you make sure you&#39;re ready, just try this</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中国哲学简史</title>
      <link href="/2026/01/12/%E4%B8%AD%E5%9B%BD%E5%93%B2%E5%AD%A6%E7%AE%80%E5%8F%B2/"/>
      <url>/2026/01/12/%E4%B8%AD%E5%9B%BD%E5%93%B2%E5%AD%A6%E7%AE%80%E5%8F%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="中国有没有哲学？"><a href="#中国有没有哲学？" class="headerlink" title="中国有没有哲学？"></a>中国有没有哲学？</h2><h3 id="中国哲学具有自身独特的方法论与思维范式"><a href="#中国哲学具有自身独特的方法论与思维范式" class="headerlink" title="中国哲学具有自身独特的方法论与思维范式"></a>中国哲学具有自身独特的方法论与思维范式</h3><p>哲学的核心在于对根本问题的系统性的分析与探究，中国哲学蕴含了独特且成熟的方法论体系；</p><ol><li>象征与隐喻系统：周易象数、庄子寓言；</li><li>辩证综合思维：张载一体两物、王夫之乾坤并建、老子；</li><li>重视体验与实践的认知方法：孟子尽心知性知天、宋明儒者体认天理、朱熹格物致知、王阳明知行合一；</li></ol><h3 id="中国哲学具有宏大且自洽的概念体系"><a href="#中国哲学具有宏大且自洽的概念体系" class="headerlink" title="中国哲学具有宏大且自洽的概念体系"></a>中国哲学具有宏大且自洽的概念体系</h3><p>哲学作为对根本问题的系统性思考，必然凝结为一套核心范畴与概念网络。中国哲学有独特丰富的元概念，并且概念之间相互关联，逻辑严密，层次分明；</p><ol><li>对于宇宙本源与存在根据：道最幽玄、最高范畴（老子）；气构成万物质料与动力基础，张载（太虚即气）、王夫之（理在气中）；理，程朱理学中统摄自然法则、道德律令的本体；</li><li>对于人性道德领域：“性”作为核心枢纽，绵延了两千年的精深辩论（孟子性本善、荀子性本恶、董仲舒性分三品）；仁义礼智信；良知；</li><li>概念不是孤立存在的：本体与现象不可分割“体用一源，显微无间”（程颐）；知行合一（王阳明），统一道德与实践；民胞物与，张载，统一了自然观与价值观；</li></ol><p>“仁”作为儒家伦理的基石，从孔子“爱人”的朴素定义，发展到涵盖“生生之理”（程颢）的宇宙情怀，内涵不断丰富扩充。“礼”规范社会秩序，“义”裁定行为适宜，“智”关乎道德判断，“信”奠定交往根基，共同构成伦理生活的支柱；王阳明提炼出的“良知”概念，更是将道德判断的先天原则与当下呈现的直觉能力完美结合，达到了心性哲学的高峰。</p><h3 id="文明塑造力与普世价值"><a href="#文明塑造力与普世价值" class="headerlink" title="文明塑造力与普世价值"></a>文明塑造力与普世价值</h3><p>哲学的生命力，最终体现在其对社会文明的深刻塑造与对普遍人类问题的有效回应上。</p><ol><li>政治与社会建构：中国哲学提供了根本性的方案。儒家“仁政”、“德治”思想，与“民为贵，社稷次之，君为轻”（孟子）的民本原则，构成了传统政治伦理的基石；道家“无为而治”的理念，则提供了尊重社会自然秩序的治理智慧；法家，以法而治；</li><li>个体安身立命与精神修养：宋儒“主敬”、“慎独”的持守方法；禅宗“明心见性”的顿悟法门，为个体如何提升境界、实现生命超越，提供了切实可行的路径。</li><li>普世性智慧：生态哲学“天人合一、万物一体”；文明观、天下观“和而不同、协和万邦”；处世智慧“己所不欲，勿施于人”；</li></ol><h2 id="对儒家内圣外王对理解"><a href="#对儒家内圣外王对理解" class="headerlink" title="对儒家内圣外王对理解"></a>对儒家内圣外王对理解</h2><h3 id="内圣是外王的根基"><a href="#内圣是外王的根基" class="headerlink" title="内圣是外王的根基"></a>内圣是外王的根基</h3><p>在这个统一中，内圣是外王的根基，道德完善是政治实践的前提</p><p>例子：<br>《大学》“修身、齐家、治国、平天下”的递进逻辑<br>孔子“克己复礼为仁”中对内在德性的要求<br>孟子“穷则独善其身，达则兼济天下”的进退之道<br>王阳明“致良知”学说——心性光明则行事皆正<br>《中庸》“成己成物”的贯通思想<br>朱熹“格物致知”中对内在明理的重视<br>荀子“化性起伪”中通过礼义塑造君子人格<br>文天祥殉国前《正气歌》展现的内圣精神外化为气节<br>范仲淹“先忧后乐”体现的内修推及外任<br>顾炎武“天下兴亡，匹夫有责”中个体道德与天下责任的联结</p><h3 id="外王是内圣的社会延伸"><a href="#外王是内圣的社会延伸" class="headerlink" title="外王是内圣的社会延伸"></a>外王是内圣的社会延伸</h3>]]></content>
      
      
      
        <tags>
            
            <tag> 杂项 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件工程导论</title>
      <link href="/2026/01/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/"/>
      <url>/2026/01/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="ch1-软件工程学概述"><a href="#ch1-软件工程学概述" class="headerlink" title="ch1:软件工程学概述"></a>ch1:软件工程学概述</h2><p>软件的生命周期：<br>    1）问题定义；<br>    2）可行性研究；<br>    3）需求分析；<br>    4）整体设计；<br>    5）详细设计；<br>    6）编码和单元测试；<br>    7）综合测试；<br>    8）软件维护；</p><p>增量模型的优点：<br>    1）可以在较短的时间内，为客户提供一个可以完成部分功能的产品；<br>    2）能够让客户有充裕的时间去熟悉和适应产品，能够减少新的软件为客户组织带来的冲击；</p><p>螺旋模型的优点：<br>    1）适用于内部开发的大规模项目；<br>    2）它是风险驱动的；<br>    3）只有在内部开发时，才能在风险过大时方便地终止；</p><h2 id="ch2-可行性研究"><a href="#ch2-可行性研究" class="headerlink" title="ch2:可行性研究"></a>ch2:可行性研究</h2><p>系统流程图的定义：<br>    系统流程图是概括性地描绘物理系统的传统工具，其基本思想是用图形符号以黑盒子的形式描绘组成系统的各个部件（程序、文档、人工过程、数据库）；</p><p>系统流程图基本符号：<br>    1）处理-矩形；<br>    2）输入输出-平行四边形；<br>    3）数据流-箭头；</p><p>数据流图的基本符号：<br>    1）数据的源点&#x2F;终点-正方形&#x2F;立方体；<br>    2）数据的变换-圆角正方形&#x2F;圆形；<br>    3）数据的存储-缺宽矩形&#x2F;双线；<br>    4）数据流-箭头；</p><p>数据流图注意事项：<br>    1）只用画符号，不用说明含义；<br>    2）只画业务逻辑，不考虑异常、错误处理；</p><p>数据字典的组成：<br>    1）数据流；<br>    2）数据流分量；<br>    3）数据存储；<br>    4）处理；</p><p>数据字典的用途：<br>    数据字典最重要的用途是用作分析节点的工具，在数据字典中建立一套严密、一致的定义，有助于改进分析员和用户之间的通信，可能消除很多误解；</p>]]></content>
      
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Connect6框架学习</title>
      <link href="/2026/01/02/Connect6%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"/>
      <url>/2026/01/02/Connect6%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p><code>在大三学年的秋季学期，人工智能导论课堂上开发了一个AI六子棋的项目，整个开发依托于一个开源的框架，在这里对框架与实现思路做一些简单的记录</code></p><h2 id="基本框架"><a href="#基本框架" class="headerlink" title="基本框架"></a>基本框架</h2><h3 id="比赛如何开始？"><a href="#比赛如何开始？" class="headerlink" title="比赛如何开始？"></a>比赛如何开始？</h3><p>主函数AITester()-&gt;oucLeague()-&gt;GameEvent根据HostID调用函数hostGames()，开始一场比赛；</p><p>关于hostGames:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hostGames</span><span class="params">(<span class="type">int</span> hostId)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">   ArrayList&lt;Game&gt; games = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">   <span class="type">Player</span> <span class="variable">host</span> <span class="operator">=</span> <span class="built_in">this</span>.getHost(hostId);</span><br><span class="line">   <span class="type">Iterator</span> <span class="variable">var4</span> <span class="operator">=</span> <span class="built_in">this</span>.players.iterator();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">while</span>(var4.hasNext()) &#123;</span><br><span class="line">      <span class="type">Player</span> <span class="variable">player</span> <span class="operator">=</span> (Player)var4.next();</span><br><span class="line">      <span class="keyword">if</span> (!player.equals(host)) &#123;</span><br><span class="line">         games.add(<span class="keyword">new</span> <span class="title class_">Game</span>((Player)host.clone(), (Player)player.clone()));</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">this</span>.runGames(games);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>简单来说就是读取properties文件中的hostId，作为host；</li><li>读取Players列表，选择除了host以外的作为自己的对手；</li><li>games.add()创建对应比赛，最终形成一个比死列表，然后在runGames()中依次完成比赛，得到结果列表；</li></ol><p>配置文件中相关项如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#the Ids of each player. corresponding ClassName, for example &quot;stud.g77.AI&quot;</span></span><br><span class="line">Player_Ids = 2,14</span><br><span class="line"><span class="comment">#the group who hosts the games with each other groups.</span></span><br><span class="line"><span class="comment">#at every game, the host plays first, i.e. who uses the white stone.</span></span><br><span class="line">Host = 2</span><br></pre></td></tr></table></figure><ol><li>runGames会遍历当前的games列表，对于其中的每个元素转换为Game对象，使用game.start()开始一次对局；</li><li>上述函数在Game类中，最终的效果是将一局游戏启动为一个Thread，并运行该game.run()；</li></ol><p>Game类中相关函数如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Configuration.GUI) &#123;</span><br><span class="line">       <span class="built_in">this</span>.referee.setUi(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">steps</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    Move move;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">Move</span> <span class="variable">currMove</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="built_in">this</span>.running(); currMove = move) &#123; <span class="comment">//running()布尔值判断游戏是否还在运行</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//处理游戏结束的逻辑，不同的结束原因给出对应的提示；</span></span><br><span class="line">       <span class="keyword">if</span> (<span class="built_in">this</span>.referee.gameOver()) &#123;</span><br><span class="line">          <span class="built_in">this</span>.endingGame(<span class="string">&quot;F&quot;</span>, (Move)<span class="literal">null</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (steps &gt; Configuration.MAX_STEP) &#123;</span><br><span class="line">          <span class="built_in">this</span>.endingGame(<span class="string">&quot;M&quot;</span>, (Move)<span class="literal">null</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//检查当前是谁在下棋，创建对应的Player实例以应用对应的算法</span></span><br><span class="line">       <span class="type">Player</span> <span class="variable">currPlayer</span> <span class="operator">=</span> <span class="built_in">this</span>.referee.whoseMove();</span><br><span class="line">       currPlayer.startTimer();</span><br><span class="line">       move = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">          move = currPlayer.findMove(currMove);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception var6) &#123;</span><br><span class="line">          <span class="comment">//由于Player实例出错导致的游戏结束；</span></span><br><span class="line">          <span class="built_in">this</span>.endingGame(<span class="string">&quot;E&quot;</span>, (Move)<span class="literal">null</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       currPlayer.stopTimer();</span><br><span class="line">       <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//由于当前Player实例犯规导致的游戏结束；</span></span><br><span class="line">       <span class="keyword">if</span> (!<span class="built_in">this</span>.referee.legalMove(move)) &#123;</span><br><span class="line">          <span class="built_in">this</span>.endingGame(<span class="string">&quot;N&quot;</span>, move);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//观战者相关的逻辑，或许与GUI的绘制有关；</span></span><br><span class="line">       <span class="built_in">this</span>.setChanged();</span><br><span class="line">       <span class="built_in">this</span>.notifyObservers(move);</span><br><span class="line">       ++steps;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ol><li>anyway，最核心的方法实际上就是我们的AI要继承Player类，去按照六子棋的合法规则，实现findMove()方法；</li><li>那么首要的，要明确findMove()的返回值，Move类是怎样的；</li></ol><p>作为一个框架，其内容纷繁，我们看它的核心部分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Move</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIDE</span> <span class="operator">=</span> <span class="number">19</span>;<span class="comment">//规定棋盘大小</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">char</span> <span class="variable">MAXCHAR</span> <span class="operator">=</span> <span class="string">&#x27;S&#x27;</span>;<span class="comment">//字符索引最大值，19*19的棋盘，用&#x27;A&#x27;到&#x27;S&#x27;来对印索引</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_INDEX</span> <span class="operator">=</span> <span class="number">360</span>;<span class="comment">//二维棋盘19*19 = 361后压缩到一维数组中（从0开始）对应的最大索引值，这个360就是(19,19)的位置</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">STEP_C</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//数字索引最小值</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">STEP_R</span> <span class="operator">=</span> <span class="number">19</span>;<span class="comment">//数字索引最大值</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INDEX_ORIGIN</span> <span class="operator">=</span> -<span class="number">1300</span>;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> _index0;<span class="comment">//表示当前Move的数字索引，一维数组的，一个数字就可以代表二维的一个坐标</span></span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> _index1;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">char</span> _col0;<span class="comment">//表示当前Move的字符索引，二维数组的，结合_row0，一起代表一个坐标</span></span><br><span class="line">   <span class="keyword">private</span> <span class="type">char</span> _row0;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">char</span> _col1;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">char</span> _row1;</span><br></pre></td></tr></table></figure><p>关键点是明确一个Move对象的属性值是如何对应到具体的落子位置的，有两种规则：</p><ol><li>字符规则col,row分别取A到S的某个字符</li><li>整型规则index，取一个数字直接对应到转换后的一维数组<br>（index计算规则也很简单，不用看代码就可以想到：index &#x3D; 列号 + (行号-1)*19 - 1，注意行列号从1开始最大到19，最后再减1是因为一维数组从0开始）</li></ol><p>明确了Move之后，我们还应该知道，每个Player实际上自己维护了一个Board；<br>在findNextMove()中会用如下规则更新：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">board.makeMove(opponentMove);</span><br><span class="line"></span><br><span class="line"><span class="type">BoardPro</span> <span class="variable">board</span> <span class="operator">=</span> getBoard();</span><br><span class="line">bestMoveCandidate = board.findwinMoves();</span><br><span class="line"><span class="keyword">if</span> (bestMoveCandidate != <span class="literal">null</span>) &#123;</span><br><span class="line">board.makeMove(bestMoveCandidate);</span><br><span class="line"><span class="keyword">return</span> bestMoveCandidate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进一步查看makeMove()也可以体会到前面关于Move到说明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeMove</span><span class="params">(Move mov)</span> &#123;</span><br><span class="line">   <span class="keyword">assert</span> <span class="built_in">this</span>.legalMove(mov);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">this</span>.moveList.add(mov);</span><br><span class="line">   <span class="built_in">this</span>.set(mov.col0(), mov.row0(), <span class="built_in">this</span>._whoseMove);</span><br><span class="line">   <span class="built_in">this</span>.set(mov.col1(), mov.row1(), <span class="built_in">this</span>._whoseMove);</span><br><span class="line">   <span class="built_in">this</span>._whoseMove = <span class="built_in">this</span>._whoseMove.opposite();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然Board肯定也是一个绕不过去的数据结构，接下里对其进行说明。</p><p>Board对象中比较关键的数据结构如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PieceColor[] _board;<span class="comment">//这就是实际代表board的一维数组；</span></span><br></pre></td></tr></table></figure><p>上述数组是一个PieceColer的对象，这个类型就是界定了当前的黑方棋子、白方棋子、空格；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">PieceColor</span> &#123;</span><br><span class="line">   EMPTY,</span><br><span class="line">   BLACK,</span><br><span class="line">   WHITE;</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>在这一节的最后在简单说明一下findNextMove()的逻辑；</p><ol><li>维护board，使用opponentMove更新自己的board；</li><li>维护board，用自己决定的Move，更新自己的board；</li><li>将自己的Move返回；<br>（自己的Move自己更新，将自己的返回給对手，对手用来更新）</li></ol><h3 id="博弈算法"><a href="#博弈算法" class="headerlink" title="博弈算法"></a>博弈算法</h3><p>判断是否有必胜招式，逻辑集成在findWinMoves()中；</p><p>在开始具体的算法之前，我们要明确一个关键的数据结构，即路Road与路表RoadTable<br>先从一个高度的概念范畴理解：</p><ol><li>Road：在六子棋中，任何连续的 6 个位置（横、竖、斜）都可能连成六子。</li><li>RoadTable：RoadTable 预先计算并存储了棋盘上所有这些可能的 6 连位置。</li><li>好处：这使得 AI 无需遍历整个棋盘去寻找连珠，而是通过 O(1) 的时间复杂度直接从集合中获取威胁信息。</li></ol><p>好处的例子（结合后面的说明很好理解）；</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">roadSetsByStoneCount[<span class="string">blackCount</span>][<span class="symbol">whiteCount</span>] 存储了所有包含 blackCount 个黑子和 whiteCount 个白子的“路”。</span><br><span class="line">即时威胁识别：</span><br><span class="line">如果 roadSetsByStoneCount[<span class="string">5</span>][<span class="symbol">0</span>] 不为空，说明黑方已经有“五连”，下一手必胜。</span><br><span class="line">如果 roadSetsByStoneCount[<span class="string">0</span>][<span class="symbol">4</span>] 不为空，说明白方有“四连”，黑方必须防守。</span><br></pre></td></tr></table></figure><p>关于Road，从其数据结构进行把握</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//主要是根据 起始位置 方向 黑白子数量来界定一个路；</span></span><br><span class="line">   <span class="comment">//默认的前提是一个路最多6个棋子；</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Road</span><span class="params">(<span class="type">int</span> startPos, <span class="type">int</span> dir, <span class="type">int</span> blackNum, <span class="type">int</span> whiteNum, <span class="type">boolean</span> active)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line"><span class="built_in">this</span>.startPos = startPos;<span class="comment">//起始位置，对应的就是一维board的index</span></span><br><span class="line"><span class="built_in">this</span>.dir = dir;<span class="comment">//方向，数字0～3，后面的路表初始化也可以体现（分别是横、竖、左斜、右斜）</span></span><br><span class="line">       <span class="comment">//不用考虑前后，仅管往前，因为不同的startPos会覆盖到当前位置“往后的情况”</span></span><br><span class="line"><span class="built_in">this</span>.blackNum = blackNum;<span class="comment">//黑子数量</span></span><br><span class="line"><span class="built_in">this</span>.whiteNum = whiteNum;<span class="comment">//白子数量</span></span><br><span class="line"><span class="built_in">this</span>.isLegal = active;<span class="comment">//是否合法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于RoadTable</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基本路表</span></span><br><span class="line"><span class="keyword">private</span> Road[][] roadsByStartPos = <span class="keyword">new</span> <span class="title class_">Road</span>[SIDE * SIDE][<span class="number">4</span>];</span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 初始化路表 (伪代码)</span><br><span class="line">function iniRoadTable():</span><br><span class="line">for i from 0 to SIDE-1: // 遍历行</span><br><span class="line">for j from 0 to SIDE-1: // 遍历列</span><br><span class="line">for k from 0 to 3: // 遍历4个方向 (横, 纵, 斜上, 斜下)</span><br><span class="line"></span><br><span class="line">// 1. 预判终点：计算当前点往方向k延伸5步后的坐标</span><br><span class="line">endCol = i + FORWARD[k].x * 5</span><br><span class="line">endRow = j + FORWARD[k].y * 5</span><br><span class="line"></span><br><span class="line">// 2. 合法性检查：判断终点是否还在棋盘内</span><br><span class="line">active = isValidSquare(endCol, endRow)</span><br><span class="line"></span><br><span class="line">// 3. 索引转换：二维坐标转一维</span><br><span class="line">startIndex = getIndex(i, j)</span><br><span class="line"></span><br><span class="line">// 4. 创建路对象：记录起点、方向、初始棋子数(0,0)、是否激活</span><br><span class="line">road = new Road(startIndex, k, 0, 0, active)</span><br><span class="line"></span><br><span class="line">// 5. 存入全量表：无论是否合法都存入 roadsByStartPos</span><br><span class="line">roadsByStartPos[startIndex][k] = road</span><br><span class="line"></span><br><span class="line">// 6. 存入分类表：只有合法的路才加入&quot;0黑0白&quot;的集合中</span><br><span class="line">if active is true:</span><br><span class="line">roadSetsByStoneCount[0][0].add(road)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 杂项 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Computer Graphic</title>
      <link href="/2025/12/15/Computer-Graphic/"/>
      <url>/2025/12/15/Computer-Graphic/</url>
      
        <content type="html"><![CDATA[<p><code>这篇blog用来记录我在大学三年级的秋季学期，选修计算机图形学时学到的专业知识，以备增强自己的专业素养以及应对后续考核</code></p><h2 id="光栅化"><a href="#光栅化" class="headerlink" title="光栅化"></a>光栅化</h2><p>引入：<br>    到目前为止我们完成了：<br>        1）模型变换-放置好了物品；<br>        2）视图变换-放置好了相机；<br>        3）投影变换-得到了标准空间下的图像信息；<br>    下一步我们需要考虑：<br>        如何将图像显示在屏幕上？<br>        视口变换；</p><p>一些基础概念<br>    <em>屏幕</em>：<br>        1）由<em>像素</em>构成，计算机将其抽象为数组进行管理；<br>        2）数组的大小对应<em>分辨率</em>；<br>        3）屏幕是典型的<em>光栅化显示</em>；<br>    光栅：Raster，即德语中的屏幕；<br>    光栅化：Rasterize，画在屏幕上；<br>    像素：Pixel，具有颜色的小正方形，可以用RGB形式来描述颜色；</p><p>视口变换：Viewport Transformation<br>    屏幕空间：<br>        连续坐标系下：屏幕覆盖的区域上(0,0)-&gt;(width,height)；<br>        将屏幕离散为像素进行考虑：<br>            1）分辨率，像素的个数：$width \times height$；<br>            2）每个像素对应的范围是(x,y)-&gt;(x+1,y+1)；<br>            （简单地将一个像素的长宽考虑为单位1）<br>            3）其中x、y是像素的索引，都是整数；<br>            4）当然x、y也可以对应到连续空间中的坐标；<br>            5）x、y的取值范围分别是0～width-1的整数、0～height-1的整数；<br>            （相当于连续空间坐标的离散化，根据2）中每个像素的范围，这些索引范围的像素实际上就覆盖了原始的屏幕空间）<br>        注意：<br>            1）虽然像素被离散化处理了，但是我们在进行图形学上的处理时，经常会将其放在连续空间下讨论对其如何处理；<br>            2）例如(x,y)索引的像素的中心坐标被认为是(x+0.5,y+0.5)<br>        一句话总结：<br>            屏幕坐标是一定范围中的连续空间，其按照每个小单位将坐标离散化作为像素，对用的索引是，离散化后的坐标，其既可以在连续空间中仍旧保持原来的坐标意义，又可以作为计算机管理像素的基本索引<br>    <strong>视口变换</strong>：<br>        1）是将投影变化后的标准空间里的相关图像信息（空间中的点与对应的位置信息），变换到屏幕空间中；<br>        2）与<strong>Z轴无关</strong>，eg：将$[-1,1]^2 \rightarrow [0,width]\times [0,height]$<br>    使用到的<strong>变换矩阵</strong>如下图所示：<br>    <img src="https://raw.githubusercontent.com/Yes-ys/blog-images/main/Computer-Graphic/p1.png" alt="视口转换矩阵"></p><p>计算机中<strong>图像的表示方式</strong>：<br>    多边形网格：<br>        1）<strong>三角形网格</strong>：<br>            最<strong>简单</strong>的多边形；<br>            其他多边形可以<strong>拆分</strong>成三角形；<br>            具有良好的性质：<br>                1）一定是<strong>平面</strong>；<br>                2）<strong>内外</strong>定义清晰；<br>                3）对内部任意点方便做<strong>插值</strong>；（重心坐标插值）</p><p>如何使用像素近似三角形：<br>    前置条件：<br>        三角形的图形信息已经经过一系列变换，到了屏幕空间中，三角形图像的相关坐标信息可以与像素的坐标信息一概而论；<br>    最简单的光栅化方法：<br>        采样：<br>            <strong>基本定义</strong>：给定一个连续的函数，计算某些点上的函数值；<br>            （本质上将连续的函数给离散化的过程）<br>            样本的作用：<br>                1）我们可以利用它得到原始连续物体的信息；<br>                2）对所有的样本进行一系列处理，得到一些结果；<br>        图形学中的常见采样：<br>            1）一维：对时间采样；<br>            2）二维：对面积采样、对方向采样；<br>            3）三维：对体积采样；<br>    使用二维采样进行光栅化：<br>        1）定义二值函数<strong>inside(t,x,y)<strong>，为1则(x,y)在三角形t内，为0则在三角形外部；<br>        （使用判断点是否在三角形内部的方法，常见的如：重心坐标、向量叉乘等）<br>        2）遍历每一个</strong>像素的中心坐标(x+0.5,y+0.5)，判断是否在三角形内部</strong>，即inside(t,x+0.5,y+0.5)等于1与否；<br>        3）对于中心在三角形内部的像素，则像素的颜色使用该三角形t，属性中的颜色；<br>        4）将每一个像素均处理之后，就可以得到一个光栅化的三角形表示；<br>        如下图所示：<img src="https://raw.githubusercontent.com/Yes-ys/blog-images/main/Computer-Graphic/p2.png" alt="光栅化后的三角形"></p><p>采样中存在的问题：<br>    遍历所有的像素点时间消耗太多：<br>        1）使用<strong>包围盒</strong>：<br>            构造方法是取三角形包含坐标的：<br>                x轴方向上最小值-包围盒左下、左上的x坐标；<br>                x轴方向上最大值-包围盒右下、右上的x坐标；<br>                y轴方向上最小值-包围盒左下、右下的y坐标；<br>                y轴方向上最大值-包围盒左上、右上的y坐标；<br>        2）<strong>扫描</strong>的方法：<br>            从下至上、从左至右，逐行或逐列扫描三角形内部像素中心坐标的情况，找到相对应的像素；<br>    光栅化的结果存在采样伪迹：<br>        常见的<strong>采样伪迹</strong>：<br>            1）锯齿；<br>            2）摩尔纹；<br>            3）车轮错觉；<br>        出现<strong>采样伪迹的原因</strong>：<br>            <strong>走样</strong>：<br>                本质原因：<strong>信号变换太快（高频），而采样频率太慢</strong>，导致面向结果估计出的原始信号频率是错误的（与原始信号相差甚远）；<br>                具体的例子：<br>                    锯齿：<strong>空间采样</strong>，频率太低；<br>                    摩尔纹：<strong>欠采样的图像</strong>；<br>                    车轮错觉：<strong>时间采样</strong>，频率太低；<br>        如何<strong>改善走样</strong>问题：<br>            1）提高采样率（需要考虑代价）；<br>            2）反走样；</p><p>反走样：<br>    本质：<strong>采样前过滤掉高频信号</strong>；<br>    光栅化三角形反走样：<br>        <strong>平均像素值</strong>：<br>            1）一般采样的过程，光栅化三角形出现锯齿的地方是因为边界像素值为纯红或纯白；<br>            2）考虑将边界的像素值取中间值，使用平均像素值：<br>                <strong>三角形覆盖像素的面积</strong>，来计算<strong>平均像素值</strong>；<br>            （可是三角形覆盖了像素的多少，这在计算上比较复杂，而且需要对每个边界像素进行操作）<br>        <strong>超级采样</strong>：<br>            在一个像素中进行多次采样，计算他们的平均值作为像素值；<br>            例如：<br>                1）将一个像素分为$2\times 2$对四个子像素<br>                2）对每一个子像素中心点考察是否在三角形中，如果是则子像素在理论上是纯红，不是则是纯白；<br>                3）实际是最后考虑有几个子像素在三角形中，有几个不在，对他们的像素值做平均，得到一个像素的值；</p><p>遮挡与可见性问题：<br>    背景：<br>        1）前面描述视口变换的时候提到，是将x、y方向上的图像信息变换到屏幕空间下，但是z轴上对应的信息是不变的；<br>        2）于是根据<strong>z坐标的大小，显示在屏幕上的图像信息实际上是有远有近的</strong>；<br>        3）我们需要考虑对于相同x、y坐标，但z坐标不同的图像信息，近处的图像会遮挡远处的图像；（于是有了下面几个算法）<br>    <strong>画家算法</strong>：<br>        1）对场景中的多边形按照<strong>深度进行排序</strong>（时间复杂度O(nlogn)）<br>        2）由近远及近的光栅化物体信息，近处物体会遮挡远处物体，在帧缓冲器中重写即可<br>        （但是画家算法存在问题，考虑z轴对应空间，所属同一个图像的信息，可以<strong>部分的z坐标较大、部分的z坐标较小，例如存在如下图所示无法排序</strong>的情况）<br>        <img src="https://raw.githubusercontent.com/Yes-ys/blog-images/main/Computer-Graphic/p3.png" alt="画家算法的问题"><br>    <strong>Z-buffer算法</strong>：<br>        1）假设z永远是正值，<strong>离相机越近z越小；离相机越远z越大</strong>；<br>        （要在实际情况下满足这种条件，可能需要在代码上进行一些变换处理）<br>        2）维护一个<strong>z-buffer，深度缓冲器</strong>，用来缓冲对应<strong>像素记录的图形信息对应深度值z</strong>；<br>        3）逐个光栅化物体，当需要使用当前图像信息设置对应像素的属性值时，先使用<strong>当前图像信息对应的深度值z，与z-buffer中缓存的该像素当前保存图像信息的深度值z，谁更小</strong>；<br>        4）若z-buffer中缓存的z值更小，则跳过该图像信息；<br>        5）若当前图像信息z值更小，则使用当前的图像信息设置相应像素的属性值，其间对使用到的像素，对应在z-buffer中记录该像素当前的深度值；<br>    Z-buffer算法形象的图像表示如下：<br>    <img src="https://raw.githubusercontent.com/Yes-ys/blog-images/main/Computer-Graphic/p4.png" alt="Z-buffer算法"></p><p>Z-buffer算法的伪代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(each Traingle t)</span><br><span class="line">    <span class="keyword">for</span>(each sample(x,y,z) in t)</span><br><span class="line">        <span class="keyword">if</span>(z&lt;Zbuffer[x,y])</span><br><span class="line">            framebuffer[x,y] = rgb;</span><br><span class="line">            zbuffer[x,y]=z;</span><br><span class="line">        <span class="keyword">else</span> ;<span class="comment">//do nothing</span></span><br></pre></td></tr></table></figure><h2 id="着色"><a href="#着色" class="headerlink" title="着色"></a>着色</h2><p>引入：<br>    到目前为止：<br>        1）我们已经可以使用一系列变换将世界坐标系下的图像信息变换到屏幕坐标下，并且使用光栅化来在屏幕上显示图像来；<br>        2）但是正如我们上一节中对三角形的讨论，我们在设置像素值的时候是直接取纯红或纯白；<br>        3）这种方式显然不会应用在真正的图形显示上面，对像素值的操作太粗暴了<br>    下一步：<br>        1）这一节中我们要结合一些光学知识，更加细粒度地讨论如何设置像素值；<br>        2）目的是在屏幕上显示出有<strong>光照效果</strong>的图形；如下图所示：<br>        <img src="https://raw.githubusercontent.com/Yes-ys/blog-images/main/Computer-Graphic/p5.png" alt="纯红色的茶壶考虑光照影响后的光栅化效果"></p><p>一些基本的概念：<br>    着色：<strong>shading</strong>；<br>        严格来说在计算机图形学中，着色是指<strong>将材质应用到物体上</strong>的过程；<br>        （这里的物体大概是指光栅化后表示在屏幕上的物体）；<br>        （所以着色并非仅限于考虑光照的影响，还要考虑具体的材质，这在后续章节中会进行探讨）；<br>    着色器：<strong>shader</strong>；<br>    光照：<br>        高光：<strong>Specular highlights</strong>；光源直接照射；<br>        漫反射：<strong>Diffuse relection</strong>；光源照射后粗糙表面的反射；<br>        环境光：<strong>Ambient lighting</strong>；其他物体反射光源形成的间接光；<br>    注意：<br>        shading不是shadow，对于阴影shadow，我们后续章节也会进行讨论；</p><p>考虑光照的着色：<br>    着色点：<strong>shading point</strong><br>        1）我们需要就一个着色点考虑光照的情况；<br>        2）可以将着色点对应到物体图像信息中的一个局部点；<br>        3）对这些局部点考虑光照后，计算出着色信息存储在对应的图像信息中，光栅化设置像素属性值的时候使用；<br>        4）最终光栅化的整体图形可以呈现出光照的效果；<br>    常用的信息：<br>        1）<strong>观察方向v</strong>；<br>        2）<strong>表面法向n</strong>；<br>        3）<strong>光线方向l</strong>；<br>        4）<strong>表面参数</strong>；<br>    （<img src="https://raw.githubusercontent.com/Yes-ys/blog-images/main/Computer-Graphic/p28.png" alt="相关向量方向">）<br>    Blinn-Phong反射模型：<br>        用来基于常用信息计算着色点的光照情况；</p><p>Blinn-Phong反射模型：<br>    前置知识：<br>        1）兰伯特余弦定理：<br>            1）作用：描述有多少光被表面接收到；<br>            2）公式：每个着色点接收到的光，是照射向该着色点点原始光的：<br>            $\cos\theta &#x3D; l \cdot n$；<br>        2）光的衰减：<br>            1）作用：描述光在扩散过程中的衰减；<br>            2）公式：光源发出的光在单位距离<strong>1处的Intensity为I</strong>，在距离光源距离为<strong>r处，对应的Intensity为$I&#x2F;r^2$</strong><br>            （<em>从后面辐射度量学的角度来看，这里应该是Irradiance，而非Radiant Intensity，但是后续的Blinn-Phong模型均用了I的描述，这是为什么呢？</em>）<br>    漫反射：<br>        1）公式：<br>            $L_d &#x3D; k_d(I&#x2F;r^2)max(0,n\cdot l)$；<br>            说明：<br>                1）$L_d$对应漫反射光；<br>                2）$k_d$是<strong>漫反射系数</strong>；<br>                3）$I&#x2F;r^2$对应的就是<strong>光的衰减</strong>；<br>                4）$n\cdot l$对应的是<strong>兰伯特余弦定理，与0取max是考虑一面受光</strong>；<br>        2）特点：<br>            1）光向各个方向均匀散射；<br>            2）<strong>所有观察方向看到的表面颜色是一致的；</strong><br>            3）因此$L_d$<strong>与$v$无关</strong>，但是与$l$有关；<br>    镜面高光：<br>        1）公式：<br>            $L_s &#x3D; k_s(I&#x2F;r^2)max(0,h\cdot n)^p$；<br>            说明：<br>                1）$k_s$是高光反射系数；<br>                2）$h &#x3D; \frac{l+v}{||l+v||}$，是<strong>半程向量</strong>；<br>                (这里的半程向量对应就是l、v夹角的角平分线，因为l、v是单位向量)<br>                3）$p$用来<strong>控制高光范围</strong>，参考<strong>余弦幂图</strong>进行理解；<br>                <img src="https://raw.githubusercontent.com/Yes-ys/blog-images/main/Computer-Graphic/p6.png" alt="余弦幂图"><br>        2）特点：<br>            1）强度取决于观察方向，靠近镜面的反射方向更加明亮；<br>            2）观察<strong>向量v接近镜面反射方向，等价于半程向量h接近法线向量n</strong>;<br>            3）所以这里使用h与n的点乘；<br>    环境光：<br>        1）公式：<br>            $L_a &#x3D; k_a I_a$<br>            说明：<br>                1）$k_a$是环境光系数；<br>        2）特点：<br>            1）Blinn-Phong模型对环境光的处理是一种<strong>常量颜色</strong>；<br>            2）这是一种近似，并不真实；<br>    最终的Blinn-Phong模型：<br>        $L &#x3D; k_d(I&#x2F;r^2)max(0,n\cdot l) + k_s(I&#x2F;r^2)max(0,n\cdot h)^p + k_a I_a$</p><p>影响着色效果的因素：<br>    1）物体本身的面数（几何处理）：<br>        这与将现实世界中的物体通过几何处理，转换为多边形网格表示有关；<br>        网格的大小、网格的数量等本身就会影响着色处理等细粒度；<br>    2）着色频率（光栅化表示）：<br>        在已有物体的图像信息不改变的前提下，在着色过程中可以考虑：<br>            1）对每一个多边形着色，eg：三角形；<br>                1）多边形通常是平面<br>                2）不适合光滑的表面；<br>            2）对多边形的每一个顶点着色；<br>                1）三角形的各个顶点携带了颜色信息；<br>                2）但是三角形作为平面只有一个平面的法向信息，顶点的法向信息需要插值计算；<br>            3）对每一个像素着色；<br>                1）法向信息同样需要插值计算；<br>                2）在每一个像素上计算着色模型<br>        注意：<br>            上面三种频率的着色对应的专有名词为：<br>                1）Flat Shading；<br>                2）Gourand Shading；<br>                3）Phong Shading；<br>            （Phong Shading要与Blinn-Phong模型区别开，前者对应的是一种着色频率，后者对应的是在该着色频率下采取的具体的着色模型）；<br>    3）三种着色频率随物体面数变化的效果对比：<br>        <img src="https://raw.githubusercontent.com/Yes-ys/blog-images/main/Computer-Graphic/p7.png" alt="着色效果">；</p><p>法向量的插值计算：<br>    1）顶点法向：<br>        公式：$N_v &#x3D; \frac{\sum_i N_i}{||\sum_i N_i||}$<br>        其中：<br>            1）$N_v$对应顶点的法向量；<br>            2）$N_i$对应与该顶点相邻的所有面的法向量；<br>            3）所以顶点法向的插值就是相邻面法向量的平均；<br>    2）像素法向量：<br>        需要使用重心插值，我们后续会进一步学习；</p><p>一种典型的图形管线：<br>    Application输入；<br>    1）Vertex Processing；顶点处理；<br>        1）应用输入的是3D世界空间中的一系列离散点，表示连续图形离散化后的信息；<br>        2）相关操作eg：MVP变换、着色器处理颜色信息（光照、纹理）保存到对应的顶点；<br>    2）Triangle Processing；三角形化；<br>        1）要显示完整的图像，我们要先用离散的点构建多边形网格；<br>        2）相关操作eg：几何处理；（后面会讨论）；<br>    3）Rasterization；光栅化；<br>        1）有了多边形网格之后，对于每一个多边形，例如三角形，我们可以做光栅化处理就像我们之前讨论的一样；<br>        2）相关操作eg：光栅化；<br>    4）Fragment Processing；片元处理；<br>        1）进一步对相关的像素构成的片元，使用着色器处理颜色信息（光照、纹理）；<br>        2）相关操作eg：MVP变换、着色（光照、纹理）；<br>    5）Framebuffer Operations；帧缓冲区处理；<br>        1）将处理完成后的各个像素的信息存入帧缓冲区，等待下一帧改变相应像素的信息为缓冲区中的对应值，显示图像；<br>        2）相关操作eg：画家算法、Z-buffer算法；<br>    输出显示；</p><p>纹理映射（Texture Mapping）<br>    含义：三维空间中的一点可以对应二维图像（纹理）上的一点，将二维图像（纹理）上的属性值应用到三维空间对应的点，即纹理映射；<br>    基本概念：<br>        纹理（Texture Mapping）；<br>        纹理坐标：<br>            为三维空间中的每个点计算一个纹理坐标(u,v)，对应的是纹理图像上的坐标值，可以确定纹理图像上的一点以获取对应的属性；<br>            三维空间中的点通常是网格化处理后的三维图形，的各个多边形网格中的点；<br>            eg：三角形的每个顶点、三角形内部的任意点；<br>        纹素&#x2F;纹理元素：<br>            纹理上的一个像素；<br>            （最终计算机应用的时候纹理图片也是以图形保存的，对应其实就是落实到屏幕空间下各个像素的属性是什么，理解纹素对于理解纹理的应用以及后续纹理贴图存在的问题很重要）<br>    纹理坐标映射的建立：<br>        三角形的顶点：<br>            按照纹理的使用方法，为三角形的每个顶点直接分配纹理坐标；<br>        三角形内部的任意点：<br>            问题：<br>                1）三角形的顶点是离散的、有限的，我们可以也应该为其直接分配相应的纹理坐标；<br>                2）三角形内部的任意点是连续的，不可能手动分配；<br>            解决方法：<br>                进行插值；<br>                    根据顶点的纹理坐标按照一定的方法，计算出合理的三角形内部的纹理坐标<br>                可以插值的对象：<br>                    1）纹理坐标（这也是我们这里引入插值的核心目的）；<br>                    2）颜色；<br>                    3）法向量；<br>                    4）深度；<br>                    5）材质属性；<br>            重心坐标插值法：<br>                重心坐标：<br>                1）使用三角形顶点表示空间中一点：<br>                    考虑三角形的三个顶点$A,B,C$，对应空间中的任意点可以在这三个顶点的基础上，使用一组坐标$\alpha,\beta,\gamma$进行表示，即任意点$P$：<br>                    $P &#x3D; \alpha A + \beta B + \gamma C,s.t.\alpha+\beta+\gamma&#x3D;1$；<br>                2）重心坐标的求法：<br>                    $\alpha &#x3D; \frac{S_A}{S_A+S_B+S_C}$；<br>                    $\beta &#x3D; \frac{S_B}{S_A+S_B+S_C}$；<br>                    $\gamma &#x3D; \frac{S_B}{S_A+S_B+S_C}$；<br>                    1）其中$S_A,S_B,S_C$分别对应顶点$A,B,C$对应的三角形面积；即由$K$与三个顶点相连形成的三个三角形，其中不与某顶点相邻的三角形，就是该顶点对应的三角形；<br>                    2）该面积为有向面积，有正负之分；（了解）；<br>                3）重心坐标的性质：<br>                    1）三角形内部顶点的重心坐标是非负的；<br>                    2）可以用任意点对应三角形的重心坐标来判断点在三角形的内部还是外部；<br>                    3）三角形重心的重心坐标是：$(1&#x2F;3,1&#x2F;3,1&#x2F;3)$；重心总是在三角形的内部；<br>                    4）在投影变换下，重心坐标无法保持不变，需要特殊的处理；</p><p>纹理简单应用的例子：漫反射颜色；<br><img src="https://raw.githubusercontent.com/Yes-ys/blog-images/main/Computer-Graphic/p8.png" alt="伪代码"><br>    因此：<br>        实际上纹理映射不只是管线流程中最开始的3D模型可以将三维空间中一点映射到纹理空间；屏幕空间中的一点，或者是一个像素（它们都在屏幕空间中具有坐标）都能够被映射到纹理空间中的一点；</p><p>纹理使用中存在的问题<br>    纹理分辨率不足：<br>        纹理空间过小导致，映射后纹理坐标并不存在（没有对应的纹素）；<br>            eg：$1024\times 720$的光栅化图像使用$720\times 560$的纹理空间；假设使用1对1对映射，例如(1023,719)对应的像素点，在纹理空间中没有对应(1023,719)的纹理坐标，我们不知道该对这个像素点设置何种属性。这就是纹理分辨率不足带来的问题；<br>        直接的问题：<br>            放大了看可能感觉存在马赛克；<br>        解决方法：<br>            纹理放大：<br>                思想：通过一些操作，将像素点映射到一个或多个合理的纹理坐标，并基于对应的纹理属性给出像素点的属性；<br>                具体操作：<br>                    预处理：<br>                        将纹理空间放大，纹素保持均匀分布；只是改变纹素的空间分布情况，不会增加额外的纹理属性信息；<br>                        （试设想将$720\times 560$个像素点，分布情况拉伸到均匀分布与$1024\times 720$的平面空间；）<br>                    （实际上这一步就是纹理放大）<br>                    预处理基础上可选的几种操作：<br>                        1）最邻近方法(Nearest)：<br>                            1）针对映射后的纹理坐标(u,v)，对应到最近的纹素(x,y)；<br>                            2）将该纹素(x,y)的属性值作为纹理坐标(u,v)的属性值；<br>                        2）双线性插值(Bilinear)：<br>                            1）针对映射后的纹理坐标(u,v)，对应到最近的四个纹素(x,y)&#x2F;(x,y+dy)&#x2F;(x+dx,y)&#x2F;(x+dx,y+dy)；<br>                            2）将四个纹素的属性分别记做：<br>                                u00,u01,u10,u11；<br>                            3）考虑映射后的纹理坐标(u,v) &#x3D; (x,y)+(s,t)<br>                            4）使用双线性插值计算纹理坐标(u,v)对应的属性：<br>                                u0 &#x3D; lerp(t,u00,u01) &#x3D; u00 + t*(u01-u00);<br>                                u1 &#x3D; lerp(t,u10,u11) &#x3D; u10 + t*(u11-u01);<br>                                f(u,v) &#x3D; lerp(s,u0,u1) &#x3D; u0 + u1 + s*(u1-u0);<br>                                其中，u0、u1对应的是纹理属性值，中间变量；f(u,v)是纹理坐标(u,v)对应的纹理属性值；<br>                            注意：t的取值范围为0到1，对应边界取得两个插值项的值；<br>                            为了便于理解放置如下图像<img src="https://raw.githubusercontent.com/Yes-ys/blog-images/main/Computer-Graphic/p9.png" alt="双线性插值"><em>图像中的符号记法与上述笔记描述不同，起因是老师的ppt缺少规范的描述，初看很模糊，所以我在自己理解的基础上写了上述笔记。能够将图像中的记法与上述笔记的记法对应起来也是一种很好的思辨</em>；<br>                        关键点：<br>                            <strong>区分</strong>：纹理坐标、纹素、纹理的属性；<br>                            上述引用纹素的时候，更多的是引用其作为纹理图像上的坐标性质（所以上述描述用纹素坐标更贴切），实际上纹素应该包含了纹理的属性；<br>                注意：<br>                    1）实际情况下，纹理空间与光栅化图像空间或者说3维图像的分布空间，究竟是什么关系，我们是不知道的，但也没有必要知道，这并非此处的讨论重点；<br>                    2）重点在于，当我们对光栅化图像的像素 or 3维图像，进行一个映射来到纹理空间之后，得到的纹理坐标(u,v)，可能无法对应到一个存在的纹素；<br>                    3）整个这一部分我们要讨论的都是这种问题；<br>    纹理分辨率过大：<br>        一个像素&#x2F;3维模型的点等，映射后的纹理坐标涉及范围内，包含多个纹素，此时应该如何设置纹理坐标的属性值。<br>            eg：<img src="https://raw.githubusercontent.com/Yes-ys/blog-images/main/Computer-Graphic/p10.png" alt="纹理过大"><br>        直接的问题：<br>            出现采样伪迹（摩尔纹、锯齿），因为本质是发生了走样（样本频率变化高，采样频率低）；<br>        解决方法：<br>            超级采样：<br>                将一个像素划分为子像素，对子像素计算对应纹素的属性值，让一个像素捕获更多的纹理信息；<br>                （缺点在于开销较大）；<br>            Mipmap：<br>                Mipmap level：<br>                    预处理：<br>                        1）对原始的纹理图像按照层级进行处理；<br>                        2）层级的数量 Level Num &#x3D; log2(原始图像分辨率的宽或高)<br>                        eg:对于128*128的纹理图像，会有7层；<br>                        3）level0对应原始纹理图像；<br>                        4）level(n+1)对应纹理图像的分辨率是leveln的图像分辨率除以2；<br>                        5）具体的处理方式这里不展开，大致是将多个纹素的属性信息汇聚到周围的一个纹素属性信息上，形成分辨率更小的纹理图像；<br>                        （可以参照如下图像进行理解<img src="https://raw.githubusercontent.com/Yes-ys/blog-images/main/Computer-Graphic/p11.png" alt="Mipmap">）<br>                    实际操作（针对屏幕空间-纹理空间的映射进行说明）：<br>                        1）对于每一个像素(x,y)，考虑其相邻两个像素(x+1,y+1)，将三个像素映射到纹理空间，得到(u,v)以及(u1,v1),(u2,v2)；<br>                        2）考虑(u,v)到(u1,v1)的距离是L1，(u,v)到(u2,v2)的距离是L2；<br>                        3）取L &#x3D; max(L1,L2)计算层级D &#x3D; round(log2(L))；<br>                        4）像素(x,y)对应的纹理坐标(u,v)应该在D层级，使用双线性插值，得到纹理属性f；<br>                    或者在2）之后的基础上三线性插值：<br>                        1）对于纹理坐标(u,v)在down(log2(L))层级使用双线性插值得到纹理属性f1；<br>                        2）对于纹理坐标在upper(log2(L))层级使用双线性插值得到纹理属性f2；<br>                        3）对于f1和f2进行单线性插值：f &#x3D; f1 + (L - down(L))(f2 - f1)；<br>                注意：<br>                    1）Mipmap的额外存储空间：<br>                        1）假设原始纹理图像所用空间为1；<br>                        2）每次分辨率减半（长、宽），所用空间变为上一层的1&#x2F;4<br>                        3）对应的所用空间：<br>                            $1 + (\frac{1}{4})^1 + (\frac{1}{4})^2 + \dots &#x3D; \frac{4}{3}[1 - (\frac{1}{4})^n] \rightarrow \frac{4}{3}, when:n \rightarrow inf$<br>                        4）即变为原来的4&#x2F;3，所以多用了1&#x2F;3的空间；<br>                    2）为什么使用D &#x3D; round(log(L))的方式来取层级；<br>                    3）由于我们是泛泛而学，里面仍然有一些细节不清晰：<br>                        1）层级数量计算的时候实际应该选择宽还是高；<br>                        2）对于三线性插值，如果D已经是最大层级了应该如何特殊处；<br>                        3）在三线性插值的最后一步f1和f2如何进行插值不太清楚；</p><p>纹理的应用：<br>    1）环境光照；<br>    2）环境贴图；<br>    3）球形环境贴图；<br>    4）立方体贴图；</p><p>纹理对着色的影响：<br>    纹理本身中存储了颜色信息，通过纹理为模型上色让模型看起来更逼真；<br>    （但是不止如此）<br>        凹凸&#x2F;法线贴图：<br>            作用：用于伪造凹凸不平的几何纹理；<br>            优点：添加表面细节但不改变任何几何信息，不会增加三角形的数目；<br>            （不改变模型的几何形状（顶点位置），而是通过一张纹理贴图来“欺骗”光照计算，改变每个像素点（片段）的表面法线方向。因为光照效果（漫反射、高光）极度依赖于法线，改变法线就能制造出凹凸不平的视觉假象。）<br>        2D方法：<br>            1）定义高度偏移：<br>                使用模型上的一点$p$，以及该点处的法向量$n$，代表高度偏移；<br>                eg：<br>                    表面法线 $n(p) &#x3D; (0,1)$；<br>                    注意：这个法线代表高度偏移，是从p点出发的二维上的(0,1)向量（法向量）；<br>            2）计算扰动后的法向量：<br>                1）原始法线 $n(p) &#x3D; (0,1)$；<br>                2）p点处的导数 $dp &#x3D; c*(h(p+1)-h(p))$；<br>                3）扰动后的法线 $n(p) &#x3D; (-dp,1).normalized$；<br>                其中：<br>                    1）n(p)对应的是原始法向量；<br>                    2）dp对应的是p点处的导数；<br>                    3）h是曲线；<br>                    （注意这种导数计算方法，c是一个常数参数，这是一种近似的方法）；<br>        3D方法：<br>            扰动后的法向量：<br>                1）原始表面法线：$n(p) &#x3D; (0,0,1)$；<br>                2）p点处的偏导数：<br>                    $dp&#x2F;du&#x3D;c1*(h(u+1)-h(u))$；<br>                    $dp&#x2F;dv&#x3D;c2*(h(v+1)-h(v))$；<br>                    （这里类似h(u+1)的含义应该是在p点的u坐标上+1，然后对应到一个新的点？）<br>                3）扰动后的法线：<br>                    $n(p) &#x3D; (-\frac{dp}{dv},-\frac{dp}{du},1).normalized$；<br>                注意：<br>                    <strong>似乎3D下的符号表示与2D下的符号表示有一些矛盾？前者采用了分量的形式，后者直接使用点p，来表示函数值，形成函数曲线；</strong><br>    凹凸&#x2F;法线贴图的问题：<br>        1）在模型边缘处不能很好地模拟凹凸效果；<br>        2）阴影效果是由真实的集合信息计算出的，导致阴影与物体相矛盾；<br>    更好的选择：<br>        位移贴图：<br>            优点：可以解决凹凸&#x2F;法线贴图的两个问题；<br>            原理：在于位移贴图真正地移动了三角形的顶点；<br>            缺点：<br>                1）对三角形数目有要求；<br>            改进：<br>                1）动态细分曲面；</p><h2 id="几何"><a href="#几何" class="headerlink" title="几何"></a>几何</h2><p>几何的表示方法：<br>    隐式表示：<br>        1）代数曲面：<br>            将表面表示成x、y、z多项式的零集；<br>            <img src="https://raw.githubusercontent.com/Yes-ys/blog-images/main/Computer-Graphic/p12.png" alt="代数曲面">；<br>            （缺点是不能表示复杂的几何体）；<br>        2）构造实体几何：<br>            通过布尔运算组合隐式几何；<br>            <img src="https://raw.githubusercontent.com/Yes-ys/blog-images/main/Computer-Graphic/p13.png" alt="构造实体几何">；<br>        3）距离函数：<br>            给出从任何地方到物体的最小距离，然后距离函数逐渐将曲面融合在一起；<br>            <img src="https://raw.githubusercontent.com/Yes-ys/blog-images/main/Computer-Graphic/p14.png" alt="距离函数">；<br>            eg：利用距离函数混合（线性插值）移动边界；<br>        4）水平集：<br>            对于复杂形状，将逼近函数的值存储在格子中，通过插值得到曲面；<br>            <img src="https://raw.githubusercontent.com/Yes-ys/blog-images/main/Computer-Graphic/p15.png" alt="水平集">；<br>            eg：利用水平集编码医疗数据、气液距离<br>        5）分形：<br>            在所有尺度上展现自相似性；<br>            <img src="https://raw.githubusercontent.com/Yes-ys/blog-images/main/Computer-Graphic/p16.png" alt="分形">；<br>    显示表示：<br>        1）参数方程：<br>            通过参数映射给出几何体上的所有点；<br>            <img src="https://raw.githubusercontent.com/Yes-ys/blog-images/main/Computer-Graphic/p17.png" alt="参数方程">；<br>        2）点云；<br>            最简单的表示形式，就是点(x,y,z)点列表；<br>            优点：<br>                1）方便的表示各种几何类型；<br>                2）适用于大数据集合；<br>            缺点：<br>                1）通常需要转换为<strong>多边形网格</strong>；<br>                2）在欠采样区域难以绘制；<br>        3）多边形网格：<br>            存储顶点和多边形（常用三角形、四边形），这是图形学中<strong>最常用的表示方式</strong>；<br>            优点：<br>                1）易于进行处理&#x2F;模拟、自适应采样；<br>            缺点：<br>                1）相较于点云需要更加复杂的数据结构；<br>        4）其他：<br>            Bezier曲面（线）、细分曲面、NURBS；</p><p>代数曲面与参数方程的对比：<br>    1）代数曲面本质上是描述了，空间中坐标点的限制关系，满足这些限制关系的点就在多项式零集对应的几何体上；<br>    2）参数方程本质上是用给定范围的参数，直接查询对应的空间中对应的坐标点；<br>    反映隐式表示与显示表示的优缺点：<br>        隐式表示：<br>            优点：内外测试容易，因为有代数曲面的多项式零集，只需要将相应的坐标点带入多项式中；<br>                1）如果为正，则在曲面外；<br>                2）如果为负，则在曲面内；<br>                3）如果为0，则在曲面上；<br>            缺点：采样困难，不容易找到哪些点在曲面上（因为本质上就是要解方程，这并不简单）；<br>        显示表示：<br>            优点：采样简单，因为只要给出一组参数就可以计算出空间中曲面上对应的坐标点（并且参数的范围是知道的）；<br>            缺点：内外测试困难；</p><p>曲线：<br>    曲线的应用：<br>        1）相机路径；<br>        2）动画曲线；<br>        3）定义字体；<br>        4）贝塞尔曲线；<br>    贝塞尔曲线：<br>        de Casteljau算法（贝塞尔曲线的定义）<br>            1）考虑一系列控制点$b_0,b_1,\dots,b_n$；<br>            2）相邻控制点之间进行线性插值，使用参数t插入一个新的点；<br>            3）用相邻控制点，构成新的控制点，相邻之间又使用线性插值（仍然用参数t），插入新的点；<br>            4）重复过程3），持续插值，递归，直到最后只插入了一个点（这个过程中持续使用参数t）；<br>            （于是最终我们得到了一个使用参数t控制的，移动的点，即最后一个插入的点，其移动的轨迹就是<strong>贝塞尔曲线</strong>）<br>            算法过程：<br>                <img src="https://raw.githubusercontent.com/Yes-ys/blog-images/main/Computer-Graphic/p20.png" alt="递归地进行新点插入"><br>            注意：<br>                由于线性插值前面已有，所以这里没有过多赘述，线性插值点参数t点取值范围仍然是0到1；<br>        eg：<br>            三个控制点的贝塞尔曲线：<br>            <img src="https://raw.githubusercontent.com/Yes-ys/blog-images/main/Computer-Graphic/p18.png" alt="贝塞尔曲线"><br>        贝塞尔曲线的名称：<br>            最初有n个控制点的曲线对应称为<strong>n-1次贝塞尔曲线</strong>；<br>        控制点的命名规范：<br>            1）最初的控制点命名为：b1、b2、…、bn；<br>            2）递归的确定所有控制点的变化范围之后，可以采用“倒推法”命名；（<strong>自己发现的规律，还不太确定原理</strong>，简单来说就是从最初控制点序列中的最后一个控制点开始，倒推，每倒推一次就对应到当前控制点所在序列，构造的下一个序列，并将下标减1，上标加1，直到下标为0；参考该图：<img src="https://raw.githubusercontent.com/Yes-ys/blog-images/main/Computer-Graphic/p19.png" alt="倒推法">）；<br>        贝塞尔曲线的代数公式：<br>            $b^n_0(t) &#x3D; \sum_{j&#x3D;0}^n B_j^n(t)b_j$；<br>            其中：<br>                1）$b^n_0$ 就是定义中递归到最后一个插值点，即贝塞尔曲线上的点，其位置由t控制；（<strong>可以简写为：</strong>$b^n$）；<br>                2）$B_j^n(t)$ 为贝塞尔曲线基函数：<br>                    $B_j^n(t) &#x3D; C_n^j t^j (1-t)^{(n-j)}$；<br>                3）$b_j$ 是最初的第控制点j；（从0开始）；<br>        贝塞尔曲线的性质：<br>            1）端点位置：<br>                1）当t&#x3D;0的时候，为曲线端点，在第一个控制点p0处；<br>                2）当t&#x3D;1的时候，为曲线另一个端点，在最后一个控制点pn处（n+1次贝塞尔曲线）；<br>            2）端点切向量：<br>                1）在p0处，切向量可以对应是$n(p_1-p_0)$<br>                2）在p1处，切向量可以对应是$n(p_n - p_{n-1})$<br>                其中：n对应归一化；<br>            3）仿射变换性质：<br>                通过变换点控制点达到变换曲线的目的；<br>            4）凸包性质：<br>                得到的贝塞尔曲线一定在控制点的凸包内部；<br>        高阶贝塞尔曲线存在的问题：<br>            不直观、难以控制，并不常用！<br>        分段贝塞尔曲线：<br>            思想：通过连接多段低阶贝塞尔曲线来实现；<br>            eg：分段三次贝塞尔曲线；<br>            <img src="https://raw.githubusercontent.com/Yes-ys/blog-images/main/Computer-Graphic/p21.png" alt="分段三次贝塞尔曲线"><br>            连续性：<br>                有几种连续性级别：<br>                    1）C0连续：$a_n &#x3D; b_0$；<br>                    <strong>前一段的终点与后一段的起点相同</strong><br>                    <img src="https://raw.githubusercontent.com/Yes-ys/blog-images/main/Computer-Graphic/p22.png" alt="C0连续"><br>                    2）C1连续：$a_n &#x3D; b_0 &#x3D; \frac{1}{2}(a_{n-1}+b_1)$；<br>                    <strong>前一段终点与后一段起点相同，且交点处，在前一段的切向量与后一段的切向量共线、等长（相等）</strong><br>                    <img src="https://raw.githubusercontent.com/Yes-ys/blog-images/main/Computer-Graphic/p23.png" alt="C1连续"><br>        贝塞尔曲线的问题：<br>            1）控制点较多时，控制点减弱，多项式阶数增大；<br>            2）局部控制能力较差；</p><p>样条：<br>    优于贝塞尔曲线之处：<br>        1）局部修改能力强；<br>        2）易于拼接；<br>    eg：<br>        B样条、NURBS；</p><p>贝塞尔曲面：<br>    双三次贝塞尔曲面：实际上就是在空间中的一个平面内先通过递归插值得到贝塞尔曲线的控制点（不同曲面、不同曲线，相同的控制参数u），然后在各个贝塞尔曲线的控制点之间引入另一个控制参数v，进行递归插值；最终两个控制参数对应一个曲面；<br>    <img src="https://raw.githubusercontent.com/Yes-ys/blog-images/main/Computer-Graphic/p24.png" alt="双三次贝塞尔曲面"></p><p>几何处理：<br>    含义：对传统数字信号处理的扩展，用于对几何信号进行处理；<br>    常见的集合处理：<br>        1）重建：<br>            给定几何样本，重建表面；<br>            eg：给定点、法线，基于轮廓重建；<br>        2）上采样：<br>            通过插值提高分辨率；<br>            eg：双线性插值、三线性插值、<strong>网格细分</strong>；<br>        3）下采样：<br>            降低分辨率同时保持几何体形状外观；<br>            eg：最临近、双线性插值、双三线性插值；<br>            （虽然2、3都有插值，但是2可以类比用在纹理放大、3类比用在纹理缩小）<br>        4）重采样：<br>            修改样本分布，但保持多边形数目不变，以提高质量；<br>        5）过滤：<br>            消除噪声或强调重要特征；<br>        6）形状分析：<br>            识别&#x2F;理解图形中的语义；<br>    挑战：<br>        1）几何信息的欠采样破坏图形特征；<br>        2）几何信息的过采样会影响性能；<br>        3）重复重采样（先下采样再上采样）会导致信号质量变差；<br>    Loop细分：<br>        场景：针对三角形网格的常用细分方法；<br>        思想：增加三角形的顶点，然后调整顶点的位置，从而将一个三角形网格划分为更多的三角形网格；<br>        方法：<br>            1）插入<strong>边点</strong>：对于一个三角形网格，在其每条边的中点插入一个新的点，称为边点；<br>            2）连接插入点三个边点，将一个三角形一分为四；<br>            3）更新顶点的位置，新、旧顶点都要更新：<br>                1）新顶点（边点）：<br>                    $position &#x3D; \frac{3}{8}(x_0+x_1) + \frac{1}{8}(x_2+x_3)$<br>                    其中：<br>                        1）0、1对应该边点所在边点两个端点；<br>                        2）2、3对应与边点所在边相对的两个端点；<br>                    eg：<br>                        <img src="https://raw.githubusercontent.com/Yes-ys/blog-images/main/Computer-Graphic/p25.png" alt="新顶点位置修改"><br>                2）旧顶点：<br>                    $position &#x3D; (1-n\beta)OriginalPosition + \beta \sum NeighborPosition$<br>                    其中：<br>                        1）n是顶点的度，即相邻边&#x2F;点数量；<br>                        2）beta是一个参数，可以由n确定，满足：<br>                            $1-n\beta + \beta &#x3D; 1$<br>                    eg：6个相邻点情况<br>                        <img src="https://raw.githubusercontent.com/Yes-ys/blog-images/main/Computer-Graphic/p26.png" alt="旧顶点位置修改"><br>        <strong>另一种实现方式</strong>：<br>            1）以任意顺序分割原始网格点边；<br>            2）翻转接触<strong>新旧顶点</strong>的新边<br>                eg：在四边形ABCD中，一条四边形内的边连接AD，翻转后就连接BC了，即从一条对角线变成另一条对角线；<br>            （上面两步实际上就对应了插入新点、分割三角形）<br>            3）更新顶点的位置，参照上面的更新方法；<br>            结合图示理解<img src="https://raw.githubusercontent.com/Yes-ys/blog-images/main/Computer-Graphic/p27.png" alt="通过分割、翻转边完成loop细分">；<br>    CatMull-Clark细分：<br>        场景：针对多边形网格，多用于四边形网格；<br>        方法：<br>            1）计算面点：<br>                为该面所有顶点位置的算数平均；<br>            2）计算边点：<br>                为该边的两个端点位置和相邻两个面的面面点，这四个点的算数平均；<br>            3）连接面点与相邻的边点，让一个四边形被划分为四个四边形；<br>            4）计算旧顶点的新位置：<br>                $v &#x3D; \frac{Q+2R+(n-3)S}{n}$；<br>                其中：<br>                    1）v为原始v点的新位置；<br>                    2）Q为原始点相邻面点的算数平均；<br>                    3）R为原始点相邻边点的算数平均；<br>                    4）S为原始点的坐标；<br>            注意：<br>                1）计算旧顶点的新位置的时候，本轮产生的面点和边点仅管已经通过连接变成顶点了，但是它们的位置不会再次更新；<br>                2）在下一轮中这些新的边点、面点会作为旧的顶点使用；<br>    网格简化：<br>        边塌陷：<br>            将边缩拢，两个端点变成一个，原来与两个端点相邻的边均与这一个点相邻；<br>        贪心算法：<br>            1）给每条边一个成本；<br>            2）每次对成本最小的边进行塌陷；<br>            3）重复知道简化到指定的元素（点&#x2F;边&#x2F;面）数目；</p><h2 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h2><p>阴影贴图：<br>    思想：不在阴影中的点必须同时被光源和相机看到；<br>    方法：<br>        第一步：从光源的“眼睛”看世界 - 生成深度快照（阴影贴图）<br>            1）将虚拟摄像机放在光源的位置，对准需要投射阴影的场景。像普通渲染一样，计算从光源到场景中每个可见点的距离（即深度值）。<br>            2）我们不关心这个点是什么颜色、什么材质，只关心它的深度。我们将这个深度值渲染到一张纹理（即阴影贴图）上。<br>            3）结果：这张阴影贴图本质上就是一张深度照片，记录了从光源视角看，离它最近的物体表面的<strong>深度信息</strong>。可以把它想象成光源的“记忆”——“我记得在这个方向上，最近的物体离我有多远”。<br>        第二步：从摄像机的眼睛看世界 - 进行深度比较<br>            1）现在回到我们正常的观察视角（摄像机视角）。对于屏幕上要渲染的每一个像素点P（对应世界空间中的一个点），我们需要判断它是否在阴影中。<br>            2）坐标变换：将点P的3D世界坐标，变换到第一步中光源的摄像机空间中。这样我们就得到了点P在光源视角下的坐标 (x_light, y_light, z_light)。<br>            3）投影与采样：将 (x_light, y_light) 归一化到纹理坐标，用它去采样第一步生成的阴影贴图，得到光源记忆中该方向上的最近深度值 d_map。<br>            4）深度比较：比较点P自己的深度 z_light 和阴影贴图记录的深度 d_map。<br>            如果 <strong>z_light &gt; d_map</strong>：说明点P比光源“记住”的最近表面还要远。这意味着在点P和光源之间有一个更近的物体挡住了光。点P在阴影中。<br>            5）如果 z_light ≈ d_map （在考虑一个微小偏差bias后）：说明点P就是光源“看见”的那个最近表面。点P被照亮。<br>    缺点：<br>        1）生成的是硬阴影，仅限于点光源；<br>        2）质量取决于阴影贴图的分辨率；<br>        3）涉及浮点深度的相等比较；<br>    优点：<br>        1）不需要知道场景的几何信息；</p><h2 id="光线追踪"><a href="#光线追踪" class="headerlink" title="光线追踪"></a>光线追踪</h2><p><code>光线、包围盒、求交，可能会出大题</code></p><p>使用光线追踪的原因：<br>    光栅化不能很好的处理全局信息，尤其是在光线在场景中多次弹射的时候：<br>        1）没有软阴影，是硬阴影；<br>        2）虽然效率高但是质量较差；</p><p>计算机图形学中对光线传播的假设：<br>    1）光线沿直线传播；<br>    2）光线交叉不会相互碰撞；<br>    3）光线从光源光源传播到眼睛；<br>    注意：<br>        前面两条在物理上实际上是错误的，最后一条在物理上是正确的（路径可逆）</p><p>光线投射算法Ray Casting算法：<br>    1）从视点或者像素出发，仅对穿过像素的光线反向追踪；<br>    2）当光线路径到达一个 离视点最近的 可见的 不透明物体的表面，则找到了屏幕上该像素对应的可见面；<br>    3）停止追踪；<br>    （缺点是没有考虑光线的反射和折射，阴影的判别实际上就和阴影贴图类似）<br>    <img src="https://raw.githubusercontent.com/Yes-ys/blog-images/main/Computer-Graphic/p30.png" alt="光线投射算法">；</p><p>递归的光线追踪算法Whitted-Style光线追踪：<br>    基本思想：作为光线投射算法的延伸，通过追踪多条光线在场景中的路径，得到多个表面所产生的反射和折射的影响；<br>    基本过程：<br>        1）沿着到达视点的光线的相反方向追踪；<br>        2）经过屏幕上一像素点找到与视线所相交的物体表面点P0；<br>        3）继续追踪，找到影响P0处光强度所有光源；<br>        4）算出P0处精确的光线强度；<br>        5）结束条件：<br>            1）光线与光源相交；<br>            2）光线与漫反射表面相交；<br>            3）被追踪光线对第一个表面交点的光强贡献度趋近于0；<br>        <img src="https://raw.githubusercontent.com/Yes-ys/blog-images/main/Computer-Graphic/p31.png" alt="递归的光线追踪算法">；</p><p>上述光线追踪算法的一个关键点：光线与物体求交；<br>    注意：<br>        一般的求交过程，是将光线与场景中所有物体尝试求交之后，对所有得到的交点排序，才能确定可见点；<br>        （传统的做法中，大部分工作量用在了求交上，因此求交的方法是我们优化的关键）；</p><p>光线求交：<br>    光线的定义：<br>        1）原点o；<br>        2）方向向量d；<br>        得到定义：光线上任意一点的计算公式 $r(t) &#x3D; o+td,0 \le t \l ∞$;<br>    光线与球面求交：<br>        将光线上一点带入球面方程求解；<br>        <img src="https://raw.githubusercontent.com/Yes-ys/blog-images/main/Computer-Graphic/p29.png" alt="光线与球面求交"><br>    光线与隐式曲面求交：<br>        和与球面求交类似；<br>    光线与三角形网格求交：<br>        基本思路：考虑光线与每一个三角形求交；<br>        方法一：<br>            1）光线与三角形所在平面求交点；（平面也有自己的方程，和与球面求交类似）；<br>            2）判断交点是否在三角形内部（参考前面有很多方法）；<br>        方法二：<br>            直接利用重心坐标建立方程：<br>                $o + td &#x3D; (1-b_1-b_2)P_0+b_1 P_1 + b_2 P_2$<br>            如果：$0 &lt; b_1,b_2,1-b_1-b_2&lt;1$ 则光线与三角形相交；<br>        注意：<br>            方法二刚快，但是本质上两个方法是一样的，只是在重心坐标建立的方程中三角形的三个点又同时表征了平面；<br>    问题：<br>        1）光线与三角形网格求交是图形渲染管线中的常态；<br>        2）简单的光线求交方法，判断一条光线与哪个三角形网格相交，需要将这条光线与所有三角形求交，然后排序判断；<br>        3）问题的规模是：$像素数量 \times 三角形数量 \times 弹射数量(若有)$<br>            （对于一条光线就已经到这个规模了，很慢，需要加速！）；</p><p>光线追踪的加速技术<br>    本质：就是提升光线与场景中物体求交的效率；<br>    包围盒：<br>        思想：<br>            1）包围盒是包围物体的简单形体，与该简单形体求交比较容易，并且如果光线不与包围盒相交那么光线一定不与物体相交；<br>            2）所以可以先与包围盒求交，如果测试相交的话再进一步检查是否与物体相交；<br>            （之前在光栅化的时候也用过包围盒，检查像素是否在三角形内，不用检查所有像素，只用检查包围盒内的）；<br>        二维情况下：<br>            1）物体的包围盒是一个矩形；<br>            2）分别写出两组对边所在的四条直线的参数方程；<br>            3）将光线上一点的参数方程r(t)代入 “宽对边” 求解方程得到$t_{min}^1$和$t_{max}^1$，代入 “长对边” 求解得到 $t_{min}^2$和$t_{max}^2$；<br>            4）计算射入参数 $t_{enter} &#x3D; max{t_{min}^i}$ 和射出参数 $t_{exit} &#x3D; min{t_{max}^i}$<br>            根据射入参数和射出参数判断是否有交点：<br>                1）如果 $t_{exit} \ge 0$ 并且 $t_{exit} &gt; t_{enter}$ 说明有交点；<br>                2）在满足上述条件基础上，如果：<br>                    1）$t_{enter} \le 0$，则光源在物体内部；<br>                    2）$t_{exit},t_{enter} \g 0$，则物体在光源前方；<br>                3）如果 $t_{exit} \l 0$，则物体在光源后面，没有交点；<br>                （注意光线是一条射线）；<br>        三维情况下：<br>            与二维情况方法完全一致，只是有两对边所在四条直线的参数方程，换成了三对平板所在的六个平面的参数方程；<br>        <img src="https://raw.githubusercontent.com/Yes-ys/blog-images/main/Computer-Graphic/p32.png" alt="包围盒求交">；<br>    注意：<br>        实际上在进行光线</p>]]></content>
      
      
      
        <tags>
            
            <tag> 图形学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Double Cross</title>
      <link href="/2025/12/05/Double-Cross/"/>
      <url>/2025/12/05/Double-Cross/</url>
      
        <content type="html"><![CDATA[<h2 id="获取金币"><a href="#获取金币" class="headerlink" title="获取金币"></a>获取金币</h2><ol><li>治理家业，点数大于3，5金币</li><li>投资事件获取金币，20金币与队友，40金币</li><li>赌马、赌狗（全选月牙，最后只赌1个金币），双倍金币</li><li>空置的宅邸，放入治理家业可以有额外金币</li><li>金奢靡用净化之火，30金币</li><li>金币放入俺寻思，会有打工</li></ol><h2 id="获取情报"><a href="#获取情报" class="headerlink" title="获取情报"></a>获取情报</h2><ol><li>上朝</li><li>浴场</li><li>书店</li><li>玛希尔长期研究</li><li>情报卡放进俺寻思，触发情报卡事件可以获得</li></ol><h2 id="获取装备"><a href="#获取装备" class="headerlink" title="获取装备"></a>获取装备</h2><ol><li>空置宅邸，异国商人出租，卖装备</li><li>阿迪莱，带宝剑</li><li>净化之火，金纵欲、杀戮、征服；魅力8、社交8、隐匿8</li><li>妖精国的书，完成冒险得到提灯，放入俺寻思</li></ol><h2 id="获取道具"><a href="#获取道具" class="headerlink" title="获取道具"></a>获取道具</h2><ol><li>侠名大于等于10，生命权杖，选前两个</li><li>星空之镜、小鳄鱼</li><li>热气球，玛希儿研究</li><li>金猫战士，夏玛父亲讨伐</li><li>传承挂毯，异国商人处购买</li><li>黄金鸟</li><li>部落的奇珍，恶名大于等于10，傲慢之罪获得</li></ol><h2 id="人物属性增加"><a href="#人物属性增加" class="headerlink" title="人物属性增加"></a>人物属性增加</h2><ol><li>买书</li><li>野外事件</li><li>厨子哈比卜，做食物</li><li>绣娘，化妆</li><li>哈桑，写诗增加属性</li></ol><h2 id="队友收集"><a href="#队友收集" class="headerlink" title="队友收集"></a>队友收集</h2><ol><li>贝姬夫人、哈桑、热娜、马尔基娜、阿图娜尔（命运商店购买）</li><li>梅姬，妻子的不满，放饰品升级，或命运商店升级</li><li>鲁梅拉，书店门口的乞丐事件</li><li>扎齐尔，救两次法图娜</li><li>法图娜，不要教导扎齐尔不好的东西</li><li>玛希尔，资助两次</li><li>哲瓦徳，监狱解救</li><li>盖斯，监狱救出，和苏丹不一样，调查真相</li><li>奈布哈尼，在欢愉之馆销卡，用魅力5以上的角色销奢靡或纵欲卡；若奢靡卡，奴隶街纵火买哈布娜，救火派奈布哈尼，之后都让他去；若纵欲卡，最受欢迎的男人，主角魅力值大于5，蒙面人时奈布哈尼11点魅力以上，触发妓女事件，随机到朱娜或者夏玛，主角不去参加，过一段时间，触发浪子的悲哀，就可以让他入队，并且撕掉他的标签；（在前面的主角魅力值若最大，他也会入队，但是不能撕标签）</li><li>哲巴尔，打猎，征服卡，送战利品给他，拳击事件中击败他，则可以永久进队并撕掉标签</li><li>赛里曼，纵欲银妃，萨达尔尼，一系列事件最后放过赛里曼</li><li>法里斯，全选月牙，调查，触发唯一的答案，上朝纵欲女奴法徳耶，妻子接待，救赎事件放入幸福感，获得新月，法里斯可以撕掉标签并进队</li><li>阿迪莱，获得犀牛皮，猎场赢过她，送犀牛皮给她，培养战斗</li><li>流浪剑客，狭义大于等于9，劝说贵族</li><li>阿里木，小毛贼偷东西，放过他，人物对话夸奖他，白肚皮事件使用口哨，政敌事件，将小乞丐放进苗圃</li><li>拜玲耶，阴森的宅邸不放卡，夜的栖息地招募她</li><li>阿穆尔，阴森宅邸不放卡，发现凶手，胁迫加入</li><li>法尔达克，上朝15次，苏丹的捉弄，纵欲或奢靡，让他活下来，修完水渠后入队</li><li>拉伊德，杰莫尔，哈马尔，野外事件，击败，在监狱赎人</li><li>朱娜、贾丽娜，欢愉之馆，销卡，做后续人物</li><li>夏玛，+1激情，侠名大于等于10，征服她父亲</li><li>三个妖精，妖精国游记，妖精森林事件</li><li>芮尔，一直帮助她，谋反入队；如果没有触发奴隶纵火，在奈布哈尼线的肉体展览也可以选她，只是不能撕奈布哈尼的标签</li><li>索拉薇尔，奈布哈尼不靠谱的盟友，使用纵欲，选奴隶</li><li>伊曼，领受神恩10金币收祝福，第二次主角在有祝福的时候用纵欲卡，秘密幽会隐匿判定</li><li>召唤物，密教事件放进俺寻思，触发传教发展出密教徒词条，拜玲耶入队送献祭图纸，图纸放入俺寻思，四次之后获得召唤图纸，上祭品后获得召唤物</li><li>娜依拉，纵欲她，杀奴隶</li><li>古利斯，杀娜依拉</li><li>巴拉特，纵欲铜妃，安苏亚，做任务获得倒酒哑铃，给巴拉特</li></ol><h2 id="队友培养"><a href="#队友培养" class="headerlink" title="队友培养"></a>队友培养</h2><p>原则：单个人物培养两个属性；主角全面发展</p><p>化妆之后自带重投骰子：主角、主角的双胞胎、玛希尔、哈桑</p><h3 id="体魄-战斗"><a href="#体魄-战斗" class="headerlink" title="体魄+战斗"></a>体魄+战斗</h3><p>哈马尔、哲巴尔（基础属性高）</p><p>流浪剑客、阿迪莱（化妆后可以双持武器）</p><p>古利斯进队比较苛刻，如果入手了可以培养</p><p>拉伊德化妆后可以双持武器，但是基本属性是魅力比较突出</p><h3 id="魅力-社交"><a href="#魅力-社交" class="headerlink" title="魅力+社交"></a>魅力+社交</h3><p>阿图娜尔，任务自带升级</p><p>夏玛，化妆后有13点魅力+社交</p><p>法拉杰，化妆后有11点魅力+社交</p><p>伊曼，需要纵欲，一般走正教路线才会拉他</p><p>朱娜，化妆后属性高</p><p>奈布哈尼、梅姬，化妆完成后带双饰品栏</p><h3 id="体魄-生存"><a href="#体魄-生存" class="headerlink" title="体魄+生存"></a>体魄+生存</h3><p>主要用来啊赚钱</p><p>法里斯、杰莫尔、哲巴尔（化妆后生存+体魄高）</p><p>铁头后期做盒饭</p><p>小圆化妆后生存高，可以用来打工</p><h3 id="隐匿"><a href="#隐匿" class="headerlink" title="隐匿"></a>隐匿</h3><p>蒙面战士（赛里曼），化妆后隐匿高</p><p>快脚</p><p>阿穆尔（天生自带3点隐匿）</p><p>法图娜，化妆后带4点隐匿</p><p>阿里木、流浪剑客</p><h3 id="智慧"><a href="#智慧" class="headerlink" title="智慧"></a>智慧</h3><p>玛希尔、热娜天生需要智慧，用来研究和做装备</p><p>备用：主角、主角的双胞胎、伊曼、阿穆尔、哲瓦德</p><h3 id="魔力"><a href="#魔力" class="headerlink" title="魔力"></a>魔力</h3><p>鲁梅拉，飞升剧情魔力可以加到其他角色身上</p><p>拜铃耶</p><p>哈桑，前期自带1点魔力</p><p>有点加魔力的书籍必须要1点魔力才能阅读，所以最好注意入手一些带魔力的装备（古老丝质披风、微笑王冠、金羊耳环）</p><h2 id="声望"><a href="#声望" class="headerlink" title="声望"></a>声望</h2><p>一般是通过随机事件和固定的剧情来加</p><h3 id="善名"><a href="#善名" class="headerlink" title="善名"></a>善名</h3><p>20时可以出净化之火，销卡</p><p>30善名，在改革或保守的坏结局中被救</p><h3 id="恶名"><a href="#恶名" class="headerlink" title="恶名"></a>恶名</h3><p>恶之化身，大于20后触发仪式，变成恶魔</p><h3 id="权势"><a href="#权势" class="headerlink" title="权势"></a>权势</h3><p>3权势开监狱</p><p>小于5的时候每次上朝带金币可以加一点权势</p><p>权势大于等于5的时候有特殊判定</p><p>谋反线要权势6的时候触发政敌的清流交汇任务</p><h3 id="侠名"><a href="#侠名" class="headerlink" title="侠名"></a>侠名</h3><p>侠名高可以触发流浪剑客任务、舍屋的建造、玛希尔研究出生命权杖</p><h3 id="灵视"><a href="#灵视" class="headerlink" title="灵视"></a>灵视</h3><p>灵视关联：正教、密教、心灵之战等任务线</p><h2 id="销卡"><a href="#销卡" class="headerlink" title="销卡"></a>销卡</h2><p>一张金色、两张银色、两张铜色、两张岩石</p><h3 id="纵欲卡"><a href="#纵欲卡" class="headerlink" title="纵欲卡"></a>纵欲卡</h3><p>妃子：要准备东西</p><ol><li>法德耶：20金币 or 玛希尔</li><li>安苏娜：进入了巴拉特，寻找道具；三张铜、银情报</li><li>萨达尔尼</li><li>萨姬：30金币、奇珍、魅力3以上的装备、金色内幕、主角带上双头龙或荒唐的情诗上朝</li></ol><p>欢愉之馆：不同角色可以分别销一张</p><p>放如俺寻思，跟带激情的队友销卡；或者跟任意队友，只是要放荒唐的情诗</p><p>事件：娜依拉、法尔达克</p><p>妻子的约会</p><p>金纵欲：沙姬、流浪剑客（主角魅力大于6，判定点数少于5）、生命权杖选梅姬</p>]]></content>
      
      
      
        <tags>
            
            <tag> 杂项 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Computer Network</title>
      <link href="/2025/12/01/Computer%20Network/"/>
      <url>/2025/12/01/Computer%20Network/</url>
      
        <content type="html"><![CDATA[<p><code>期末复习，知识点记录</code></p><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p>端口号的作用；<br>在TCP、UDP中的使用（SOCKET嵌套字）；<br>熟知端口号范围；<br>端口号的独立性；</p><p>传输层的功能；<br>传输层复用和分用的体现；<br>TCP与UDP差错检测的区别；<br>传输层向应用层提供的两种服务的特点</p><p>常见应用层协议使用的传输层端口号：HTTP、FTP、TFTP、DNS；TELENT、SMTP；SNMP</p><p>有连接的传输、无连接的传输；<br>可靠的传输、不可靠的传输；</p><p>UDP首部格式（8B）；<br>伪首部的格式（12B）；<br>UDP校验和计算方式（伪首部，0，17）；<br>UDP使用校验和检错；</p><p>UDP与TCP的对比：<br>1）首部长度<br>2）是否支持报文的拆分、重装<br>3）连接？可靠？拥塞控制？<br>4）一对一？一对多？</p><p>TCP是面向字节流的（报文Y报文Z的例子）；<br>MSS的含义（通常不会太大，避免IP分段；双方可以不同）</p><p>TCP报文：<br>1）源端口、目的端口<br>2）序号，含义（不一定从0开始）<br>3）确认号，含义<br>4）数据偏移，含义，单位<br>5）URG，ACK，PSH，RST，SYN，FIN，含义；出现的时机；对应报文段段别称<br>6）rwnd含义，具体情况下的计算<br>7）TCP校验和计算（伪首部，0，6）；<br>8）紧急指针，含义<br>9）选项的作用（在握手1、2协商MSS etc）<br>10）填充段的长度计算（tip：数据偏移）</p><p>TCP校验和计算、UDP校验和计算 对比 IP校验和计算，相同点，不同点</p><p>TCP协议的主要阶段：<br>1）三次握手<br>2）全双工<br>3）四次挥手</p><p>三次握手的细节：<br>1）SYN、ACK、seq、ack的变化<br>2）第3次握手携带数据，携带多少B消耗多少序号，否则不消耗序号<br>3）第1、2次握手会消耗序号（影响seq、ack）<br>4）客户端、服务器开始发送数据的最短时间</p><p>四次挥手的细节：<br>1）FIN、ACK、seq、ack<br>2）挥手1、3可以不携带数据，但也要消耗一个序号<br>3）挥手2可以携带数据，挥手4不能携带数据<br>4）收到挥手4的一方立刻CLOSE；收到挥手3的一方，要等待2MSL时间（重新计时？）<br>5）服务器可以先发出挥手1<br>6）客户端从挥手1到CLOSE，最短RTT+2MSL；服务器从挥手1到CLOSE，最短1.5RTT（挥手2、3连续发出）</p><p>重传机制中的问题：<br>1）确认报文丢失<br>2）超时定时器设置过短</p><p>基本的超时定时器（重传时间）设置：<br>1）大于RTT<br>2）指数加权滑动平均法<br>3）超时倍增</p><p>TCP的流量控制：<br>1）流量控制的含义<br>2）流量控制的基本要求（公式，发送的字节数小于上次收到的窗口字段）<br>3）rwnd在流量控制中的作用（rwnd、seq、ack在互相发送过程中的变化）<br>4）零通知窗口与持续计时器<br>5）TCP报文发送的时机：3种控制方式</p><p>UDP没有流量控制</p><p>网络的拥塞控制<br>1）拥塞控制的含义<br>2）拥塞控制的方法（2个，哪个说TCP采用的）</p><p>TCP拥塞控制原理<br>1）最大发送窗口的设置（拥塞窗口、通知窗口）<br>2）有效发送窗口的计算<br>3）拥塞窗口的设置：累次增加、成倍减少（方法、问题）；慢开始（方法、问题）；拥塞避免（方法、阈值计算）<br>4）慢开始-&gt;到阈值-&gt;累次增加-&gt;超时重传-&gt;成倍减少(拥塞窗口？、阈值)-&gt;慢开始-&gt;累次增加-&gt;拥塞窗口到达最大的通知窗口值<br>5）？拥塞窗口减半 or 改为初始值，前者对应快重传（出现时机）<br>（<strong>综合运用，理解是否正确？</strong>）</p><h3 id="易错点"><a href="#易错点" class="headerlink" title="易错点"></a>易错点</h3><p>TCP数据偏移、UDP长度字段、MSS；对应的含义比较</p><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>网络层的作用（目的）</p><p>网络层的功能（发送端和接收端；主机和路由器；执行、规划、建立连接）</p><p>网络层服务模型：虚电路网络、数据报网络</p><p>虚电路工作原理（转发表、信令协议）</p><p>路由器的主要功能：软件、硬件（输入端口（转发、排队）、交换结构、输出端口（缓存、调度机制））</p><p>路由器的三种交换结构：内存交换、总线交换、网络式交换</p><p>网络层的三大组件：<br>    IP协议（选路规则、数据报处理规则）<br>    路由协议（内部网关协议、外部网关协议）<br>    网络控制协议（ICMP）</p><p>接口interface（主机、路由器，对应IP）</p><p>IP点分十进制记法</p><p>几类地址的判断<br>    方法：IP地址第一Byte<br>    类型：A（0，8+24）、B（10，16+16）、C(110,24+8)、多播、实验开发</p><p>特殊：<br>网络号码，（全0本网络、0+111..环回测试），A类地址范围<br>主机号码，（全0当前主机、全1所有主机）</p><p>一些保留地址：本地主机测试、私有地址</p><p>ARP协议使用的背景</p><p>ARP表（表项的TTL）</p><p>ARP表的建立（广播查找 ARP请求、单播回应 ARP响应、TTL内使用）</p><p>DHCP协议（应用层，分配ID阶段、核实ID阶段）<br>    discover，68、654<br>    offer，67、654<br>    request，68、655<br>    ack，67、655<br>    （yiaddr、transaction ID）</p><p>IP数据报<br>    长度相关Header length、Datagram length（通常报头长度20B）<br>    Identifier、Flags、Offset（为什么要分组，如何分，8B）<br>    Upper-layer protocol(6 TCP、17 UDP)<br>    校验和（计算、检验）</p><p>常见数据链路可以承载的最大传输单元（MTU）<br>    与MSS类似，都是对应该层的最大数据长度（要考虑IP报头）；（与最大帧的区别是不考虑链路层报头）<br>    以太网1500B</p><p>路由器转发表、最长匹配原则（最佳匹配）</p><p>子网划分、网络地址计算（子网掩码）</p><p>Ipv4地址，CIDR表示法</p><p>分组转发算法（直接交付、特定主机路由、特定网络路由、默认路由；使用子网掩码匹配）；默认路由的子网掩码</p><p>超网聚合、路由聚合（多个C类地址子网聚合成超网），聚合后的地址数（注意去掉两个特殊的主机号）</p><p>路由聚合的好处（找到对应规模的网络地址所需的路由表项数目极大地减少）</p><p>最佳聚合（尽可能地将子网聚合在一起）</p><p>ICMP协议（网络层）：<br>    使用场景，网络中出现错误时进行测试<br>    测试过程（<br>        主机不断发送UDP报文，<br>        TTL逐渐增大，<br>        路由器据TTL丢弃报文并返回ICMP报文，<br>        主机计算对应RTT，<br>        直到目的主机返回ICMP “dest port unreachable”，因为目的端口通常使用较高的端口，不会有应用程序来处理它）<br>    ICMP报文由IP报文包裹（具体的信息处在IP的可选字段处）</p><p>路由选择协议（应用层，OSPF除外）<br>    关注：如何构建转发表（对比前面我们讨论的是如何转发）<br>    选路算法（全局 or 分布式；静态 or 动态）<br>        链路状态广播（LS），原理是Dijkstra；信息传播快，但是不易实现<br>        距离向量（DV），原理是Bellman-Ford方程；好消息传得快，坏消息传得慢（注意为什么）<br>    层次选路<br>        自治系统（路由器聚合而来），网关路由器（运行两种协议）<br>        intra-AS协议（域内选路协议，为内部节点设置表项目）、inter-AS协议（域间选路协议，为外部节点设置表项）</p><p>域内选路协议：IGP（内部网关协议）<br>    RIP协议<br>        基于DV，距离向量信息每30s通过响应报文在相邻节点间交换<br>        每次通告，距离向量最多包含25个AS内部的目的网络信息（Dx(y)，y可取的符号最多有25个，对应经过x可达的25个目的网络）<br>        由UDP提供服务<br>        好消息传播快，坏消息传播慢<br>    OSPF协议<br>        基于LS，使用可靠洪泛法（注意如何实现）将链路状态转发到所有其他相邻的路由器<br>        支持负载均衡（因为每个节点有全局信息）<br>        IP为其提供服务<br>        解决RIP坏消息传播慢的问题<br>    层次化的OSPF协议（Hierarchical OSPF）<br>        边界路由器，连接其他AS；<br>        主干路由器，主干网络上运行OSPF选路<br>        区域边界路由器，汇总自己到各网络的距离，通知其他区域边界路由器<br>        区域内路由器，区域内运行OSPF选路</p><p>域间选路协议：BGP（外部网关协议）<br>    路径向量协议<br>        边界网关通告它到达目的地的整个路径（边界网关X，目的地Z，Path(X,Z) &#x3D; X,Y1,Y2,…,Z））<br>        边界网关X可以发送路径向量给对等的边界网关W，推荐从X出发的路径（Path(W,Z) &#x3D; W,Path(X,Z)）<br>        eBGP，iBGP（不同AS的对等网关、相同AS的对等网关）</p><p>IPv6<br>    128位地址空间<br>    报头没有校验和<br>    没有分片机制</p><p>NAT网络地址翻译？</p><h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><p>物理层功能：高效地传输和接收01比特流，尽量不要出错，为数据链路层提供服务</p><p>数据通信模型<br>    全双工：点到点链路上可以同时传输两个比特流，每个方向传输一个<br>    半双工：一次仅支持数据向一个方向传输的点到点链路</p><p>网络适配器（数据链路层）<br>    网卡驱动程序对其进行管理<br>    基于网络的操作系统会完成网络协议的代码实现，为用户提供接口</p><p>物理层传输的具体链路<br>    物理介质：双绞线（电话线）、同轴电缆（电视连线）、光纤（高带宽、长距离）、空间（无线电破、微波、红外线电波等）</p><p>调制解调器<br>    功能：将代表01点信号放到链路上<br>    核心要求：抗干扰（因为发送到基带信号在传输过程中会失真，必须要求能够还原失真信号）<br>    调制方法：<br>        调幅（eg，幅度大是1，小是0）<br>        调频（eg，高频是1，低频是0）<br>        调相（eg，相位的不同变化对应0和1）</p><p>数据传输相关理论<br>    奈式准则<br>        理想低通信道的极限码元传输速率B&#x3D;2W（W是带宽）<br>        B的单位是Baud（码元&#x2F;秒）<br>        W的单位是Hz<br>        一个码元可能对应多个bit，和具体的信息调制、编码方式有关<br>    香农定理<br>        信道极限传输速率C&#x3D;Wlog2（1+S&#x2F;N）<br>        B的单位是bps<br>        S&#x2F;N是信噪比，转换为db做单位公式是10log10（S&#x2F;N）<br>    一个信号（码元）表示的bit数<br>        B&#x2F;C（对应该信号可能的状态有2^(B&#x2F;C)种）<br>        当B&#x2F;C不是整数的时候一般是向下取值，如果题目中有具体的暗示可能需要向上取值<br>    W是带宽，W&#x3D;频谱上限-频谱下限</p><p>正交振幅调制QAM<br>    含义：用振幅和相位对应一个信号（码元）<br>    M信号状态对应log2（M）个比特<br>    （书上16个信息状态的例子）</p><p>信道共享技术<br>    时分复用<br>        同步时分复用TDM（每个用户使用固定的时隙）<br>        统计时分复用技术SM（同意用户发送的数据帧不一定使用同一个时隙，但是要在时隙中加上目的地址）<br>    波分复用WDM<br>        常用于光纤中，不同波长的光波对应不同的信号<br>        掺耳光纤放大器：对衰减的光信号进行放大（物理层）<br>        DWDM，密集波分复用技术；eg，一根光缆中，放入100根一定速率的光纤，每根光纤使用16倍的DWDM（一个光纤同步传播16个不同波长的光线，对应16个不同的信号）<br>    码分复用技术CDMA<br>        每个用户使用不同的码型，使用相同的频带进行通信，但是互不干扰<br>        基本原理：<br>            一个比特划分成m个时间片（码片序列），序列中0对应-1，1对应+1<br>            用向量S表示该码片序列，其他用户的向量T，S与T”*“运算总为0，与原码卷积为1，与反码的卷积为-1<br>        传输：<br>            传输的过程中，传输方若使用S对应的码片序列，如果要传输0则用S反码，如果要传输1则用S对原码<br>            接收方接受到码片序列M，与S卷积运算，1）如果为0则是其他用户的数据，忽略；2）如果是+1则为1；3）如果是-1则为0</p><h2 id="期末重点"><a href="#期末重点" class="headerlink" title="期末重点"></a>期末重点</h2><p><code>根据老师划的重点整理的内容</code></p><h3 id="物理层-1"><a href="#物理层-1" class="headerlink" title="物理层"></a>物理层</h3><p>物理层的功能：<br>    <strong>高效、正确地传输01比特流</strong>，为链路层提供服务；</p><p>不同信道复用技术的区别：<br>    信道复用技术：<br>        频分复用、时分复用、统计时分复用、波分复用、码分复用；<br>        1）(<strong>FDM</strong>)<strong>频分复用</strong>的各路信号再<strong>同样的时间</strong>占用<strong>不同的带宽资源</strong>（频率带宽而非发送速率）；<br>        2）(<strong>TDM</strong>)<strong>时分复用</strong>的所有用户是在<strong>不同的时间</strong>占用<strong>同样的频带宽度</strong>；<br>        3）(<strong>FDMA</strong>)<strong>频分多址复用</strong>：在频分复用的基础上<strong>多个用户可以轮流使用同一频带</strong>，其中要包含<strong>地址信息</strong>；<br>        4）(<strong>TDMA</strong>)<strong>时分多址复用</strong>：在时分复用的基础上<strong>多个用户可以轮流使用同一时隙</strong>，其中要包含<strong>地址信息</strong>；<br>        5）(<strong>STDM</strong>)<strong>统计时分复用</strong>：使用STDM帧来传送数据，STDM帧<strong>不固定分配时隙</strong>，按需<strong>为每个用户动态分配时隙</strong>，其中要<strong>包含地址信息</strong>；<br>        （基本原理是一个STDM帧中有多个时隙，但小于总用户数量，用户有想发的数据就往集中器中发，集中器按顺序扫描输入缓冲，放入STDM帧的各个时隙中，当一个STDM帧的数据放满了就发送出去）<br>        6）(<strong>WDM</strong>)<strong>波分复用</strong>就是<strong>光的频分复用</strong>，但是由于光的频率很高，所以<strong>习惯用波长</strong>而不用频率这一概念，所以描述为波分复用；</p><p>FDM、TDM、FDMA、TDMA、STDM哪种效率高：<br>    统计时分复用<strong>STDM的效率高</strong>，因为其对于每个用户<strong>没有固定使用的时隙</strong>，总是<strong>动态的进行分配</strong>，保证<strong>每一帧的时隙都被占用满</strong>，避免存在时隙有空便发送信号的情况，所以这种效率高；</p><h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><p>数据链路层的功能：<br>    <strong>正确地</strong>传输<strong>数据帧</strong>；</p><p>为了实现正确传输数据帧需要解决的<strong>三个基本问题</strong>：<br>    <strong>封装成帧</strong>、<strong>透明传输</strong>、<strong>差错检测</strong>；</p><p><strong>封装成帧的含义</strong>：<br>    封装成帧就是在<strong>一段数据</strong>的前后分别添加<strong>首部和尾部</strong>，<strong>构成一个帧</strong>，使得接收方能够在收到物理层上交的比特流之后<strong>根据</strong>首部和尾部的<strong>标记</strong>，<strong>识别</strong>出帧的<strong>开始和结束</strong>；<br>    （首部、尾部的主要作用是<strong>帧定界</strong>）；<br>    （帧的数据部分有长度上限<strong>MTU</strong>，eg：以太网是<strong>1500B</strong>）；</p><p><strong>透明传输的含义</strong>：<br>    无论什么样比特组合的数据，都能够按照原样没有差错地通过数据链路层进行正确地传输，不会因为数据中出现了与<strong>帧定界符相同</strong>的比特组合而导致传输的<strong>错误</strong>；</p><p><strong>透明传输的方法</strong>：<br>    使用转义字符”<strong>ESC</strong>“，十六进制是<strong>0x1B</strong>；<br>    如果数据中有比特组合呈现出：<strong>SOH:0x01或EOT:0x04</strong>，则前面加上转义字符；<br>    如果数据中出现了ESC，也在前面加上ESC；</p><p><strong>差错检测的含义</strong>：<br>    由于实际通信的链路并非是理想的，存在误码率，为了保证数据传输的<strong>可靠性</strong>，在计算机网络传输数据时，必须采用的手段，用于检测是否存在差错；</p><p>差错检测的方法：<br>    <strong>CRC循环冗余校验；</strong><br>    发送方：<br>        1）原始k位01串数据；<br>        2）<strong>除数P</strong>，事先商量好n位；<br>        3）k位原数据+(n-1)个0作为<strong>被除数</strong>；<br>        4）被除数对除数进行<strong>模2除法</strong>；<br>        5）最终得到的<strong>n-1位余数</strong>，就是FCS（帧检验序列）<br>        6）k位原始数据+n-1位FCS，构成<strong>最终发送的数据</strong>；<br>    接收放：<br>        1）使用<strong>k+n-1位数据对约定好的除数做除法</strong>；<br>        2）如果<strong>余数为0</strong>则没有差错；<br>        3）否则存在差错；<br>    注意：<br>        1）n位除数可以用多项式生成，对应<strong>最高为X的n-1次方的多项式</strong>（因为有个常数）；<br>        2）eg：$p(X) &#x3D; X^3 + X^2$，对应：1100</p><p><strong>传输差错：</strong><br>    1）<strong>比特差错，差错检验</strong>可以避免；<br>    2）帧丢失、帧重复、帧失序；<br>        解决它们意味着：<br>            实现了<strong>可靠传输</strong>：数据链路层发送端发送什么，接收端就接收什么；<br>    注意：<br>        <strong>差错检验</strong>可以解决比特差错，但是这并<strong>不确保可靠传输</strong>；</p><p><strong>PPP协议的组成：</strong><br>    1）一个将<strong>IP数据包</strong>封装到<strong>串行链路</strong>的<strong>方法</strong>；<br>    （既支持<strong>同步传输</strong>（一连串比特连续传送），又支持<strong>异步传输</strong>（逐个字符的传输，8bit一字符，没有奇偶校验）<br>    2）用来<strong>建立、配置和测试数据链路连接</strong>的<strong>链路控制协议LCP</strong>；<br>    3）一套<strong>网络控制协议NCP</strong><br>    （其中的每个协议支持不同的网络层协议，例如IP、OSI的网络层）</p><p>PPP协议的<strong>数据帧</strong>：<br>    首部字段从前往后：<br>        1）标志字段F：<strong>0x7E</strong>（对应的就是首尾<strong>帧定界符</strong>）；<br>        2）地址字段A：0xFF，固定；<br>        3）控制字段C：0x03，固定；<br>        4）<strong>协议字段：</strong><br>            1）紧接着控制字段；<br>            2）2个字节；<br>            3）表征当前信息字段的含义：<br>                <strong>0x0021</strong>，对应<strong>IP数据报</strong>；<br>                <strong>0xC021</strong>，对应链路控制协议<strong>LCP的数据</strong>；<br>                <strong>0x8021</strong>，对应网络层的控制数据（<strong>NCP</strong>协议）；<br>    尾部字段从前往后：<br>        1）<strong>FCS</strong>，两个字节，使用CRC；<br>        2）标志字段F：<strong>0x7E</strong></p><p>PPP协议如何完成<strong>透明传输</strong>：<br>    对应的是组成的第一部分的作用（透明传输）；<br>    方法：<br>        <strong>字节填充</strong>：转义字符0x7D；<br>            1）若有<strong>0x7E</strong>，则修改为：<strong>0x7D，0x5E</strong>；<br>            2）若有<strong>0x7D</strong>，则修改为：<strong>0x7D，0x5D</strong>；<br>            3）若有<strong>小于0x20</strong>的字符，则修改为：<strong>0x7D，0x20+原字符</strong>；<br>        <strong>零比特填充</strong>：<br>            1）尤其适用于同步传输的场景，传输一连串比特串；<br>            2）对于信息字段，只要发现有<strong>5个连续的1，则填入一个0</strong>（填在连续的1后面）<br>    通过这些方法：<br>        在所传送的数据比特流中可以传送任意组合的比特流，而不会引起对帧边界的错误判断；</p><p><strong>LCP</strong>链路配置协议的作用：<br>    用来<strong>建立、配置和测试数据链路连接</strong>；</p><p><strong>NCP</strong>网络控制协议的作用：<br>    为新接入的用户个人电脑<strong>分配一个临时的IP地址</strong>；</p><p>PPP协议的工作状态：<br>    <strong>链路静止</strong>：<br>        1）PPP协议的<strong>起始和终止状态</strong>，这时用户个人电脑和ISP路由器<strong>不存在物理层的连接</strong>；<br>    <strong>链路静止-&gt;链路建立</strong>：<br>        <strong>个人电脑</strong>通过调制解调器<strong>呼叫路由器</strong>，路由器检测对应的载波信号，建立<strong>物理连接</strong>；<br>    <strong>链路建立-&gt;鉴别：</strong><br>        进行<strong>LCP配置协商：</strong><br>            链路的<strong>一端发送LCP配置请求帧</strong>，信息字段携带有特定的<strong>配置请求</strong>；<br>                eg：<br>                    1）最大帧长；<br>                    2）所使用的鉴别协议；<br>                    3）不使用PPP协议的地址和控制字段；<br>            链路的另一端发送：<br>                1）配置<strong>确认帧Ack</strong>：所有选项都<strong>接受</strong>；<br>                2）配置<strong>否认帧Nck</strong>：所有选项都理解但<strong>不接受</strong>；<br>                3）配置<strong>拒绝帧Reject</strong>：选项有的不能识别或无法接受，需要<strong>协商</strong>；<br>        注意：<br>            如果配置协商失败，<strong>链路建立-&gt;链路静止</strong>；<br>    <strong>鉴别：</strong><br>        该状态只允许<strong>传送LCP协议的分组</strong>，<strong>鉴别协议</strong>的分组以及<strong>监测链路</strong>质量的分组；<br>        eg：<br>            使用PAP口令鉴别协议：<br>                要求发起通信方，发送身份标识符和口令，系统允许用户重试多次；<br>    <strong>鉴别-&gt;网络层协议：</strong><br>        如果鉴别成功 or 不需要鉴别；<br>        注意：<br>            如果鉴别失败，<strong>鉴别-&gt;链路终止</strong>；<br>    <strong>网络层协议：</strong><br>        PPP协议的<strong>两端的网络控制协议NCP</strong>根据网络层不同的协议，<strong>交换网络层特定的网络控制分组</strong>；<br>        （重要的一步，是<strong>路由器能够同时支持多种网络层协议</strong>的关键，从而让PPP协议两端端网络层在使用不同网络层协议的基础上，仍然使用同一个PPP协议进行通信）；<br>        eg：<br>            如果使用IP协议，则使用NCP中支持IP协议的IPCP（IP控制协议），将其封装成PPP帧，在链路上传送；<br>    <strong>网络层协议-&gt;链路打开：</strong><br>        NCP配置协商完成；<br>    <strong>链路打开：</strong><br>        1）链路的<strong>两个PPP端点可以向彼此发送分组</strong>；<br>        2）也可以发送给回送请求、回送回答对应的<strong>LCP分组，来检查链路状态</strong>；<br>    <strong>链路打开-&gt;链路终止：</strong><br>        终止请求：<br>            1）数据传输结束后，由链路的一方发送<strong>终止请求LCP分组</strong>，请求终止链路；<br>            2）接收到终止请求的一方，发送<strong>终止确认LCP分组</strong>，确认终止；<br>            3）转到链路终止状态；<br>        链路故障；<br>    <strong>链路终止-&gt;链路静止：</strong><br>        调制解调器的<strong>载波停止</strong>；</p><p>CSMA&#x2F;CD协议（<strong>载波监听多点接入&#x2F;碰撞检测</strong> 协议）<br>    背景：<br>        计算机之间在数据链路层端到端的通信，是通过总线实现的；<br>            尽力而为：<br>                1）这是无连接的工作方式，适配器对数据帧不编号、不要求确认，仅发送；<br>                2）以太网提供了尽<strong>最大努力的交付</strong>（不可靠交付），出现差错是否重传由高层决定；<br>                3）即使<strong>有重传帧，以太网也不知道</strong>，只是当作新的数据帧传输；<br>            总线传输：<br>                1）共用一个总线，在<strong>同一时间</strong>只能允许<strong>一台计算机发送数据</strong>；<br>                2）<strong>半双工通信</strong>；<br>            编码：<br>                使用<strong>曼彻斯特编码</strong>，用跳变来代表01<br>                （代表0&#x2F;1的跳变：差分曼彻斯特编码跳变发生在虚线处，有跳变0无跳变1、曼彻斯特编码跳变发生在虚线间，低跳高1，高跳低0）；<br>                （差分曼彻斯特编码实际上会在时钟周期之间用跳变来同步时钟信号）；<br>    CSMA&#x2F;CD协议的作用：<br>        在上述背景下，以太网采用最简单的随机接入，所以需要一个协议来减少冲突发生的概率；<br>        （好像一个没有主持人的会议，大家想发言就发言，但是要找到一个规则，让大家的发言尽可能不同时发生，产生冲突；于是有了CSMA&#x2F;CD协议）；<br>    各部分的含义：<br>        CS：载波监听；<br>            <strong>边发送边监听</strong>，站点不管在发送数据之前，还是在发送数据之中，每个站都必须不停地检测信道；<br>            （在发送之前监听，是为了<strong>碰撞避免</strong>）；<br>            （在发送中监听，是为了<strong>碰撞检测</strong>）；<br>        MA：多点接入；<br>            说明这是<strong>总线型网络</strong>，许多计算机以多点点方式连接在一根总线上；（这就是一个背景，CS、CD才是协议的实质关键）；<br>        CD：碰撞检测；<br>            <strong>适配器</strong>边发送数据边<strong>检测</strong>信道上的信号<strong>电压变化</strong>情况；<br>            （当两个站点同时发送数据的时候，总线上信号电压的幅度会变大）<br>    CSMA&#x2F;CD协议的内容：<br>        1）准备发送：网卡从网络层接收数据报，封装成帧；<br>        2）检测信道：<br>            如果网卡监听到<strong>信道空闲</strong>（<strong>96比特时间</strong>，信道上没有信号），则开始传送帧；<br>            如果监听到<strong>信道忙</strong>，则<strong>等待</strong>信道空闲（从没有信号开始，经过96比特时间）才开始传送帧；<br>            96比特时间称为<strong>帧间最小间隔</strong>；<br>        3）边听边发：<br>            如果在<strong>争用期</strong>内一直未检测到碰撞，就认为发送成功（尽管此时可能还没发送完，接着发送完毕即可），回到1）；<br>            （接收方如果发现数据帧有差错就直接丢弃，等待高层来处理）；<br>            如果<strong>争用期</strong>内检测到碰撞，就立刻停止发送数据，并按规定发送<strong>人为干扰信号</strong>，然后适配器执行<strong>截断二进制指数退避算法</strong>，等待r倍争用期之后，回到步骤2）；<br>            如果重传达到<strong>16次</strong>，仍然不能成功，停止重传向上报错；<br>            （在<strong>10Base5</strong>以太网中，对应的争用期是<strong>512比特时间</strong>，计算如下）；<br>            <img src="/Computer-Network/p1.png" alt="争用期计算"><br>        关键概念：<br>            1）帧间最小间隔，96比特时间；<br>            2）争用期：<br>                1）是对于发送端而言的时间概念；<br>                2）<strong>从发送端开始发送，一个RTT的时间</strong>（2倍总线端到端的传播时延）；<br>                3）这个时间就是发送站发送数据之后，最迟要经过多长的时间才能知道自己发送的数据和其他站发送的数据有没有发生碰撞；<br>            3）截断二进制指数退避算法：<br>                作用：决定冲突后等待，重新开始检测信道的时间；<br>                算法：<br>                    1）从离散集合 $[0,1,\dots,2^k-1]$ 中随机挑选一个数r；<br>                    2）其中 $k &#x3D; min(10，重传次数)$；<br>                    3）推后r倍的争用期（ $r \times RTT$ ），然后开始重新检测信道；<br>                （当重传次数达到16次之后会停止重传，向高层汇报）；<br>            4）强化碰撞：<br>                发送<strong>32比特或48比特</strong>的人为干扰信号，以便让所有用户都知道现在已经发送了碰撞；<br>            5）最短帧长：<br>                目的：为了确保载波监听可以发现争用期内的冲突；<br>                eg：<br>                    如果某站发送了<strong>一个很短的帧</strong>，但在发送完毕之前没有检测出碰撞（即载波监听时间内没有发现冲突），但是在向前传播到目的站之前和别的站发生了冲突（目前<strong>仍然在争用期</strong>以内），因而目的站会接收到有差错的帧，并将它丢弃；但是发送站不知道这个帧发生了碰撞，因而不会重传这个帧；<br>                本质原因：<br>                    1）发送的帧太短了，完全用不了一个争用期的时间；<br>                    2）而载波监听只会在发的时候进行；<br>                    3）如果有冲突发生，理论最迟监听到的时间是一个争用期的时间；<br>                    4）所以至少要让发送时间大于一个争用期；<br>                于是最短帧长：<br>                    <strong>L&#x2F;发送速率 &gt;&#x3D; RTT（争用期）；</strong><br>                注意：<br>                    1）如果发送的数据不足最短帧长，则必须加入一些<strong>填充字节</strong>；<br>                    2）<strong>小于最短帧长</strong>的数据都被站点认为是，由于冲突而异常终止的<strong>无效帧</strong>，收到后会立刻丢弃；<br>                    （<strong>10Base5的以太网</strong>，对应的就是64字节，<strong>512比特</strong>）；</p><p>相关设备：<br>    <strong>网桥（链路层）</strong>：<br>        作用：对收到的帧根据<strong>MAC帧</strong>目的地址进行<strong>转发和过滤</strong>；<br>        <strong>可以隔离冲突域，不能隔离广播域</strong>；<br>    <strong>转发器、集线器</strong>（物理层）：<br>        <strong>不能隔离冲突域</strong>；<br>    <strong>以太网交换机</strong>（链路层）<br>        实质：多端口网桥；<br>        工作方式：<strong>全双工</strong>；<br>        作用：让相互通信的主机可以独占传输媒体，无碰撞地传输数据；<br>        原理：<br>            多端口负责接收数据和转发数据，自学习构建转发表；<br>            存储支持暂存再发送，从而隔离冲突域，用户尽管往交换机发；<br>        <strong>可以隔离冲突域，不能隔离广播域；</strong><br>    <strong>路由器</strong>（网络层）<br>        可以<strong>隔离冲突域，隔离广播域</strong>；<br>    （如果可以冲突域，考虑平均带宽，<em>练习题目</em>）；</p><p>以太网交换机的转发原理：<br>    1）以太网交换机具有<strong>自学习功能</strong>；<br>    2）转发原理：<br>        1）交换机中维护一个<strong>MAC地址-端口表</strong>，用来指示对于目的地址是某个MAC地址的数据帧应该从哪个端口发出去；<br>        2）若有一个<strong>数据帧</strong>发来，数据帧中有（<strong>源MAC地址，目的MAC地址</strong>），并且是从一个交换机可以感知的<strong>端口号进入</strong>的；<br>        3）<strong>更新</strong>表项：<br>            检查该数据帧的<strong>源MAC地址与对应端口号</strong>（进入端口号）是否在表中，如果<strong>不在则记录</strong>；<br>        4）尝试<strong>转发</strong>：<br>            1）如果表中有目的MAC地址对应的端口号则从<strong>对应端口发出</strong>；<br>            2）如果表中没有目的地址对应的端口号，则从除了进入端口号以外的所有端口号<strong>广播出去</strong>；<br>    注意：<br>        1）广播发送可以保证，目的MAC地址方能够接收到；<br>        2）对于不是目的MAC地址方的，会将这个数据帧丢弃，即<strong>过滤</strong>；<br>        3）交换机更新表项的能力就称为<strong>自学习能力</strong>；</p><h3 id="网络层-1"><a href="#网络层-1" class="headerlink" title="网络层"></a>网络层</h3><p>网络层的主要功能：<br>    完成不同网络中的<strong>两个主机之间的通信</strong>；</p><p>路由器之间传送信息：<br>    1）转发<strong>源主机和目的主机</strong>之间所<strong>传送的数据</strong>（将源主机发送的分组一个一个路由器的转发，直到转发到目的主机）；<br>    2）传送<strong>路由器信息</strong>（根据路由选择协议所使用的路由算法，彼此不断地交换路由信息分组，从而建立路由表）；</p><p>ipv4几个类网络地址：<br>    网络地址+主机地址；开头；<br>    1）A：<strong>8+24</strong>；0；<br>    2）B：<strong>16+16</strong>；10；<br>    3）C：<strong>24+8</strong>；110；<br>    其他：<br>        1）D：1110+多播地址；<br>        2）E：1111+实验开发；<br>    注意：<br>        <strong>如何通过开头的地址判断网络类型</strong>；<br>    特殊号码：<br>        1）A类中00000000网络号码，代表<strong>本网络</strong>；<br>        2）A类中01111111网络号码，代表<strong>本地环回测试</strong>；<br>        （B类、C类没有这个问题）；<br>        3）网络号不为全0主机号为全0，代表某个<strong>特定网络</strong>；<br>        4）网络号为全0主机号不为全0，代表<strong>当前网络特定主机</strong>；<br>        5）网络号和主机号均为0，代表<strong>当前主机</strong>；<br>        6）网络号不为全1，主机号为全1，<strong>特定网络的所有主机</strong>；<br>        7）网络号全为1，主机号全为1，代表<strong>当前网络所有主机</strong>；<br>        （注意6、7都可以指广播地址，要注意具体的应用场景）；<br>        8）<strong>127.0.0.1</strong>，本地主机测试地址；<br>    按照某类地址给<strong>机构划分子网</strong>：<br>        1）可以使用二叉树划分法；<br>        2）注意划分的时候主机号全0全1不能用；<br>        （对应特殊号码的3、6，<em>练习题目</em>）</p><p>ARP协议<br>    作用：根据机器的IP地址，找到相应的MAC地址，使得数据能够通过链路层传输；<br>    背景：<br>        1）IP地址与MAC地址格式不同，<strong>前者32位，后者48位</strong>，不存在简单的映射关系；<br>        2）一个网络上可能经常有新的主机加入进来，或撤走一些主机；<br>        3）更换网络适配器也会使主机的MAC地址改变（主机的<strong>MAC地址</strong>实际上就来自其<strong>网络适配器的MAC地址</strong>）；<br>    ARP协议的思想：<br>        在主机中维护一个<strong>ARP高速缓存</strong>，存放一个从IP地址到MAC地址到映射表，这个映射表可以动态更新（新增或超时删除）；<br>    协议具体工作流程：<br>        1）检<strong>查ARP高速缓存表</strong>：<br>            当主机A要向本局域网的某台主机B发送IP数据包时，检查自己的ARP高速缓存，如果其中有B的IP地址对应的MAC地址，则将数据包封装的MAC帧发送到对应的地址，否则进入2）；<br>            （注意，这一步实际上是没有用到ARP协议的）；<br>        2）运行ARP：<br>            1）ARP进程在杂本局域网上<strong>广播发送一个ARP请求分组</strong>（其中写入了A自己的IP地址、MAC地址，想要请求的MAC地址对应的IP地址）；<br>            （这个ARP请求分组的MAC帧目的地址是FF-FF-FF-FF-FF-FF）；<br>            2）局域网上所有运行ARP进程的主机都会收到这个分组；<br>            3）收到ARP请求分组的主机，检查其中请求MAC地址对应的IP地址是否与自己的<strong>IP地址一致</strong>，如果一致就向A<strong>发送ARP响应分组</strong>；<br>            （注意，ARP请求分组虽然是广播发送的，但是ARP响应分组是单播，因为有A确定的MAC地址）；<br>            （注意，为了<strong>减少网络上的通信量</strong>，会采取一种<strong>策略</strong>，即让B在收到A的请求分组后，将A的IP地址和对应MAC地址写入ARP高速缓存中，因为后续B很可能会和A通信）；<br>            4）A收到B的响应分组后，将B的IP地址和对应的MAC地址<strong>写入</strong>自己的ARP高速缓存表中；</p><p>ipv4 IP数据包报头：<br>    1）Version（版本号）：<br>        1）<strong>0100</strong>-ipv4；<br>        2）<strong>0110</strong>-ipv6；<br>    2）Header length（首部长度）：<br>        1）标识首部长度，<strong>单位是4字节</strong>，ip数据报头<strong>最短是20字节</strong>，所以该<strong>字段最小为5</strong>；<br>    3）type of service（区分服务）：<br>        1）一般情况下不会使用这个字段；<br>    4）datagram length（数据报）：<br>        1）<strong>数据包总长度</strong>，<strong>单位是字节</strong>，该字段是16位，所以ip数据包最长是<strong>65535字节</strong>；<br>        2）如果ip数据包进行了<strong>分片</strong>，则该字段1是<strong>当前分片（ip报头+分片数据）的总长度</strong>；<br>    5）identifier（标识）：<br>        1）当ip数据报需要分片的时候，来自于<strong>同一数据报</strong>的分片数据报该<strong>字段相同</strong>，用来<strong>标识分片身份</strong>；<br>        2）实际的赋值机制，是每产生一个数据报计数器就加1（未分片），然后对该数据报进行分片，完成后，将这个字段的值复制到每一个分片；<br>    6）flag（标志）：<br>        1）3位只有<strong>两位</strong>有意义；<br>        2）最低位MF，1代表后面<strong>还有分片</strong>，0代表<strong>没有分片</strong>；<br>        3）中间位DF，1代表<strong>不能分片</strong>，0代表<strong>可以分片</strong>；<br>    7）Fragmentation offset（位偏移）：<br>        1）指出分片后，当前<strong>分片在原始数据报中的相对位置</strong>；<br>        2）偏移<strong>单位是8字节</strong>，也就是说除了最后一个分片其他分片的长度一定是8的倍数；<br>        3）该字段实际使用的时候，字段值是多少就代表该分片的数据部分，第一个字节，在原始数据中是第<strong>字段值乘8+1</strong>字节；<br>            eg：offset &#x3D; 0，则原来是第一个字节；<br>                offset &#x3D; 1，则原来是第65个字节；<br>        （当然如果直接考虑偏移量，使用第0个字节的表述，并以其作为开头的话，实际上offset<em>8的值就代表，当前分片开始的字节，在原始数据报中是第几个字节）；<br>        4）在分片的时候不能忘记，每个分片都要添加报头，<strong>报头在考虑最大分片长度</strong>的时候很重要；<br>        5）但是在计算offset的时候，不能加入报头，<strong>offset纯粹的使用数据部分进行计算</strong>；<br>        6）<strong>当前分片offset值 &#x3D; 前面所有分片的数据部分和，字节数&#x2F;8</strong>；<br>    8）TTL（生存时间）<br>        1）功能是作为<strong>跳数限制</strong>，<strong>防止</strong>不能到达目的地的IP数据报在互联网中<strong>兜圈子，浪费资源</strong>；<br>        2）当数据报到达一个路由器，<strong>在路由器转发它之前将TTL–，然后检查TTL是否等于0</strong>，如果等于0则丢弃；<br>        3）如果一个数据报只允许在局域网中转发，那么将TTL设置为1（到达该局域网的路由器的时候，TTL减为0就会被丢弃）；<br>        4）一个数据报能经过（到达）的路由器<strong>最大数量是255</strong>；<br>    9）upper-layer protocal（协议）<br>        1）指出当前IP数据报携带的数据来自于什么上层协议；<br>        2）常用的：<br>            ICMP-1；<strong>TCP-6；UDP-17</strong>；EGP-8；IGP-9；OSPF-89；<br>    10）check sum（首部检验和）<br>        1）只检验数据报的首部，不包括数据部分；<br>        2）每<strong>经过一个路由器</strong>就要<strong>重新计算</strong>首部检验和；<br>        3）计算方法是<strong>16位一组</strong>，相加，<strong>最高位有进位要回卷</strong>，<strong>结果取反</strong>；<br>        （接收方检验方法是<strong>16位一组相加，再取反</strong>，如果<strong>结果是0则没有出错</strong>，否则认为出错，丢弃；</em>题目练习*）<br>        注意：<br>            1）如果最后一组不足16位，那么在低位补0；<br>            2）在计算之前check sum字段置0；<br>    11）source address（源地址）<br>        1）32位，发送主机的IP地址；<br>        2）32位，接收主机的IP地址；</p><p>最长前缀匹配<br>    1）<strong>原则：</strong><br>        在采用CIDR编址时，如果一个分组在转发表中可以找到<strong>多个匹配的前缀</strong>，那么就应当<strong>选择</strong>前缀<strong>最长</strong>的一个作为匹配的前缀。这个原则称为最长前缀匹配；<br>    2）思想：<br>        网络前缀越长，其地址块就越小，因而路由越具体；</p><p><strong>分组转发算法</strong> 路由表项的排列 特定主机路由 默认路由（若有 若无）<br>    分组转发算法：<br>        1）从收到的分组的首部提取<strong>目的主机的IP地址</strong>；<br>        2）查找是否有<strong>特定主机路由</strong>，对应该IP地址，若有责直接按照下一跳转发；<br>        3）否则，从转发表中<strong>下一行开始</strong>进行检查：<br>            1）将这一行的子网掩码与目的地址AND运算；<br>            2）如果结果和本行<strong>前缀匹配</strong>则按下一跳转发（或直接交付本网络上的目的主机，或转发给下一跳路由器）；<br>            3）如果不匹配则继续检查下一行；<br>        4）如果检查结果均不匹配，则来到最后的<strong>默认路由</strong>，按照指定的接口进行转发；<br>    一些说明：<br>        关于3）：<br>            1）这里查找转发表的逻辑实际上涉及路由表项的排列；<br>            2）路由表项中按照前缀的长度进行排列，由长到短递减；<br>            3）这样的基础上从上到下检查不断“下一行”检查，本身就契合了最长前缀匹配；<br>            4）这样排列也契合了，先检查特定路由，然后进行匹配，最后考虑默认路由；<br>            （因为特定路由等价于前缀长度32，最长；进行匹配就是前缀长度长到短排列；默认路由0.0.0.0是其子网掩码，实际上就等价于前缀长度是0，最短）；<br>        关于1）、4）：<br>            1）特定主机路由和默认主机路由其实都是可选的，不一定存在；<br>            2）尤其是如果默认主机路由不存在，又找不到转发的接口，那么就会报告转发分组错误；</p><p>二叉线索查找转发表：<br>    背景：<br>        1）使用CIDR完成路由聚合后，由于不知道目的网络前缀，让转发表的查找变复杂了；<br>        2）在转发表项目数很大的时候，怎样缩短转发表查找实践是一个非常重要的问题；<br>        3）普通情况，无分类编址的转发表，最简单的查找算法就是对所有前缀进行循环查找，逐行检查网络前缀；<br>    二叉线索查找思想：<br>        1）将无分类编址的转发表存入一种层次数据结构中，然后自上而下地按层次查找；<br>        2）好处就是可以一次排除“一类”前缀，避免不必要的AND运算；<br>    使用方法：<br>        1）用<strong>给定的几个网络前缀</strong>构造<strong>二叉线索树</strong>；<br>        2）是否与<strong>唯一前缀匹配</strong>；（对应到叶节点）；<br>        （转发时用目的地址与唯一前缀进行匹配，对目的地址按照高位到低位的顺序，查看0&#x2F;1，选择二叉树上对应的边，从根节点出发持续向下，直到到达叶节点，如果不能到达叶节点则直接丢弃，因为一定没有匹配的前缀）<br>        3）与掩码运算-&gt;是否与<strong>网络前缀匹配</strong>；<br>        （到达叶节点了之后，只是说明唯一前缀匹配上了，还要查看网络是否匹配）；<br>        4）<strong>转发</strong> or 默认转发 or <strong>丢弃</strong>；<br>        （如果匹配上了就转发，没有的话看有没有默认转发，没有则丢弃，报错）；</p><p>DHCP协议（应用层 C&#x2F;S模式 UDP协议为其提供服务）<br>    作用：<br>        1）<strong>动态主机配置协议</strong>；<br>        2）为<strong>新</strong>进入一个网络的<strong>主机</strong>分配<strong>本网络内的IP地址</strong>；<br>    工作原理：<br>        1）DHCP <strong>discover</strong>：<br>            新到来的主机发送DHCP报文：<br>                1）src: 0.0.0.0:68；（<strong>全0代表本地址</strong>，<strong>68</strong>客户端端口）<br>                2）dest: 255.255.255.255:67；（<strong>全1代表广播地址</strong>，<strong>67</strong>服务器端口）<br>                3）<strong>yiaddr</strong>: 0.0.0.0；（等待服务器分配的地址）<br>                4） transaction ID：654；（代表这是获得动态主机IP地址的请求报文）；<br>        2）DHCP <strong>offer</strong>：<br>            服务器收到discover后回复：<br>                1）src：223.1.2.5，67；<br>                2）dest：255.255.255.255，68；<br>                3）yiaddr：223.1.2.4（<strong>动态分配的ip地址</strong>）；<br>                4）transaction ID：654；（代表这是回复动态主机IP地址请求的应答）；<br>                5）<strong>Lifetime</strong>：3600（动态IP使用时间）；<br>        3）DHCP <strong>requst</strong>：<br>            客户端收到offer后再与服务器<strong>核实</strong>：<br>                1）src：0.0.0.0，68；<br>                2）dest：255.255.255.255，67；<br>                3）yiaddr：223.1.2.4；<br>                4）transaction ID：655；（代表这是核实IP的请求）；<br>                5）Lifetime：3600；<br>        4）DHCP <strong>ACK</strong>：<br>            服务器<strong>回复核实报文</strong>：<br>                1）src：223.1.2.5，67；<br>                2）dest：255.255.255.255，68；<br>                3）yiaddr：223.1.2.4；<br>                4）transaction ID：655；<br>                5）Lifetime：3600；</p><p>RIP协议<br>    基本知识：<br>        1）中文名是<strong>路由信息协议</strong>；<br>        2）是一种<strong>基于距离向量</strong>的选路协议；<br>        3）RIP适用于小型网络，因为不可达距离只有16；<br>    <strong>距离的定义</strong>（跳数、路由器数）：<br>        1）从路由器到直接连接到网络距离为1；<br>        2）从一个主机到非直接连接到网络距离是<strong>路由器数量+1</strong>；<br>        （+1是因为直接相连定义了距离为1）；<br>        3）不可达距离 16<br>    交换信息（特点）：和谁交换信息？交换哪些信息？（1、2、3）何时交换信息（1、2）？<br>        协议是通过交换信息工作的，使用RIP协议的路由器有如下特点：<br>            1）<strong>仅和相邻路由器</strong>交换信息；<br>            2）交换的信息是本路由器知道的全部信息，即自己的路由表（到本自治系统中所有网络的最短距离，对应的下一跳路由器）；<br>            3）按固定的时间间隔交换信息：<br>                1）每隔<strong>30秒</strong>会交换信息；<br>                2）当<strong>网络拓扑结构发生变</strong>化时，交换信息；<br>        注意：<br>            1）<strong>主机</strong>也运行RIP协议的话，它只能被动的接收信息，不能发出自己的信息，因为它没有转发功能；<br>            2）刚<strong>开始的时候</strong>，路由器中路由表是空的，然后可以直接得出与其直接相连的几个网络的距离（定义为1）；     </p><p>距离向量算法：<br>    1）路由器维护的表项目、交换报文（RIP报文）的内容（1、2、3）；<br>        路由器中维护的<strong>表项信息</strong>，就是交换报文中的主要项目信息；<br>            1）<strong>目的网络</strong>Neti：代表往这个方向转发的最终目的地；<br>            2）<strong>下一跳路由器</strong>Ri：要前往目的地下一跳应该向哪个路由器转发；<br>            3）<strong>距离</strong>d：从当前路由器到达目的地的最终距离；<br>    2）收到报文的操作（项目信息(Neti,Ri,d)）：<br>        1）<strong>修改</strong>报文项目（1、2）；<br>            1）将Ri改为该报文的发送路由器Rj；<br>            2）距离d &#x3D; d+1；<br>        2）若<strong>无目的网络</strong>-更新表项目；<br>            如果当前路由器的转发表中没有能够到达Neti的转发表项，则直接将报文项目加入自己的转发表中；<br>        3）若<strong>有目的网络</strong>-下一跳路由器？<br>            如果当前路由器转发表中有能够到达Neti的表项目：<br>                1）如果对应表项的<strong>下一跳是Rj</strong>，则直接将新的报文项目替换这个旧的；<br>                2）如果对应表项<strong>下一跳不是Rj</strong>，谁的距离更小保留谁；<br>    3）3分钟-不可达；<br>        如果<strong>3分钟没有收到</strong>相邻路由器的更新路由表，则把此相邻路由器，标记为不可达路由器，距离设置为16；<br>    注意：<br>        1）一个RIP报文最多25个路由-25个表项，超过25个报文要再用一个发；<br>        （即实际上上述交换的一个RIP报文，不止有一个表项信息）</p><p>坏消息传得慢-例子（RIP报原始内容）<br>    <em>习题练习</em>；</p><p>OSPF：<br>    基本知识：<br>        1）使用<strong>链路状态协议</strong>；<br>    交换信息（特点）：<br>        1）向本自治系统中的<strong>所有路由器</strong>发送信息，使用洪泛法；<br>        2）发送的信息：<br>            1）相邻的所有路由器的链路状态；<br>            2）其中包括链路的度量，用来表示代价；<br>            （可以选择费用、距离、时延等等信息来作为这个度量）；<br>            3）每隔一段时间（<strong>30分钟</strong>） 或者 <strong>链路状态发生变化</strong>的时候，向所有路由器使用可靠的洪泛法发送链路状态信息<br>            （和谁交换信息（可靠的洪泛法）、交换哪些信息（1、2）、何时交换信息（30分钟））<br>    注意：<br>        1）实际上，所有的路由器最终都能建立一个链路状态数据库，对应的就是全网的拓扑结构图，并且这个结构在全网范围是一致的；<br>        （最直接的结果就是，可以直接看作在一个静态的图上面做Dijkstra算法搜索最短路，或者说对于我们应试来说，在使用OSPF路由的时候，我们可以直接看哪条路最短，来确定下一跳路由器）；<br>        2）OSPF收敛得快；<br>        3）OSPF能够适用于大规模网络；<br>        4）OSPF能够实现<strong>负载均衡：</strong><br>            <strong>如果到同一个目的网络有多条相同代价的路径，那么可以将通信量分配给这几条路径；</strong></p><p>OSPF使用层次结构区域划分：<br>    好处：在使用洪泛法的时候将链路状态信息的范围局限在一个区域中，而不是整个自治系统，减少整个网络上的通信量；<br>    1）<strong>主干区域：</strong><br>        <strong>标识符</strong>规定0.0.0.0（本自治系统内生效）；<br>    2）其他区域：<br>        主干区域以外的其他各个区域，标识符自定，例如0.0.0.1，0.0.0.2；<br>        （当然都是本自治系统内生效）；<br>    3）相关路由器：<br>        1）<strong>主干区域路由器</strong>，主干区域内的路由器；<br>        2）<strong>区域边界路由器</strong>，一个区域的边界路由器，负责将当前区域和其他区域连接起来；<br>        3）<strong>自治系统边界路由器</strong>，一个自治系统的边界的路由器，负责将当前AS和其他AS连接起来；<br>        注意：<br>            自治系统边界路由器一般在主干区域中，可以<strong>同时是</strong>主干区域路由器、自治系统边界路由器、区域边界路由器；</p><p>OSPF五种类型的分组：<br>    物种类型分组：<br>        1）<strong>问候分组</strong>（10s一次，40s没有则不可达）；作用？（初始时）；<br>            作用：用来发现和维持邻站的可达性；<br>        2）<strong>数据库描述分组</strong>；（交换链路状态摘要信息，用来确认哪些没有）；<br>            作用：向邻站给出自己链路状态数据库中所有链路状态项目的摘要信息；<br>        3）<strong>链路状态请求分组</strong>；（针对没有的请求）；<br>            作用：向对方请求发送某些链路状态的详细信息；<br>        4）<strong>链路状态更新分组</strong>；<br>            作用：在洪泛法中使用的分组，用来更新全网链路状态；<br>        5）<strong>链路状态确认分组</strong>；<br>            作用：对链路更新分组的确认，也会在洪泛法中使用；<br>    OSPF的工作过程：<br>        1）使用问候分组判断可达与否：<br>            1）相邻路由器每<strong>10s</strong>必须交换一次问候分组，从而明确哪些邻站是可达达；<br>            2）如果<strong>40s</strong>没有收到某个邻站的问候分组，则认为不可达，立即修改链路状态数据库计算新的路由表；<br>            （可达是基本要求，只有可达邻站的链路状态信息才会存入链路状态数据库，路由表是根据链路状态数据库计算出来的）；<br>        2）使用其他分组进行链路状态数据库的同步：<br>            同步的概念：<br>                1）不同路由器的链路状态数据库内容是一样的；<br>                2）两个同步的路由器被称作是<strong>完全邻接</strong>的；<br>                （不完全邻接的路由器可能只是物理上相邻的）；<br>            过程：<br>                1）每个路由器使用数据库描述分组和相邻路由器<strong>交换</strong>本数据库中已有的链路状态<strong>摘要信息</strong>；<br>                2）路由器拿到对方的链路状态描述分组后，根据其中内容<strong>检查</strong>自己<strong>缺少</strong>的某些链路状态；<br>                3）向对方发送链路状态请求分组，<strong>请求</strong>对应自己没有的链路状态信息；<br>                4）收到链路状态请求分组的路由器，按照对方请求的链路状态，用<strong>单播</strong>的方式，将对应链路状态信息发送给请求方；<br>                5）<strong>洪泛法</strong>的启用：<br>                    1）当一个路由器的链路状态发生变化的时候（或经过了30分钟），开始使用洪泛法发送信息；<br>                    2）路由器对所有相邻的路由器<strong>发送</strong>自己的链路状态<strong>更新</strong>分组；<br>                    3）收到该分组的路由器对链路状态更新分组进<strong>行转发</strong>（转发到<strong>排除上游</strong>路由器对所有相邻路由器）；<br>                    4）收到链路状态更新分组的路由器，向给自己发送该分组的路由器发送<strong>确认</strong>信号；<br>                    （确认是<strong>可靠</strong>的洪泛法所必要的，而OSPF就是采用可靠的洪泛法）；<br>                    （收到<strong>重复</strong>的更新分组，只用发送<strong>一次确认</strong>）；</p><p>可靠的洪泛法：<br>    1）发送；<br>    2）转发（除了上游）；<br>    3）确认（忽略重复）；</p><p>BGP协议：<br>    基本知识：<br>        1）BGP是<strong>外部网关协议</strong>；<br>        （RIP、OSPF协议都是<strong>内部网关协议</strong>）；<br>        2）用于<strong>不同AS之间</strong>的路由选择；<br>        3）采用的是<strong>路径向量路由选择协议</strong>；<br>    作用：<br>        选择出一条<strong>能够到达</strong>目的网络前缀且比较好的路由（不兜圈子），而<strong>不是非要</strong>计算出一条<strong>最佳</strong>路由；<br>        为什么不是最佳路由？<br>            1）互联网的规模太大，使得自治系统AS之间的路由选择非常困难；<br>            （例如不同AS中的代价度量不同，比较合理地做法是考虑可达性）；<br>            2）自治系统AS之间的路由选择必须考虑有关策略；<br>            （即考虑多种路由选择策略，包括政治、安全或经济方面；）<br>    相关路由器：<br>        1）AS中有<strong>边界路由器</strong>和<strong>内部路由器</strong>；（这里的边界路由器对应的就是前面的自治系统边界路由器）；<br>        2）一个AS至少有一个边界路由器和相邻AS的边界路由器直接相连；<br>        3）正是有了边界路由器，AS之间才能利用协议BGP交换可达性路由信息；<br>    <strong>BGP路由的一般格式</strong>：<br>        1）这里的路由指的是BGP协议报中有关选路的信息，就类似于RIP报文中的信息；<br>        2）<strong>格式</strong>：“前缀，BGP信息” &#x3D; “前缀，AS-PATH，NEXT-HOP”；<br>        3）其中：<br>            1）前缀，对应的是BGP路由终点的子网前缀；<br>            2）AS-PATH，是自治系统路径，通告BGP路由所经过的自治系统；<br>            3）NEXT-HOP，下一跳，对应当前BGP路由的起点；<br>    BGP协议的使用：<br>        1）<strong>两个边界路由器</strong>建立TCP连接；<br>        2）边界路由器作为对等端通过<strong>eBGP协议</strong>互相发送BGP路由；<br>            注意：<br>                1）例如，BGP路由：“X，AS1，R1”，代表可以到达网络前缀位X的网络，经过AS1，下一跳是R1；<br>                2）边界路由器R2就知道下一跳R1，会进入AS1中的，X前缀对应的网络；<br>                3）建立eBGP的两个路由，即不同AS之间的对等端建立了BGP连接；<br>        3）<strong>边界路由器</strong>收到BGP路由后，更新自己的转发表，然后：<br>            1）<strong>与AS内的路由</strong>两两之间均建立<strong>iBGP连接</strong>；<br>                注意：<br>                    1）这种连接是全连通的，即使物理上没有连通；<br>                    2）建立iBGP的两个路由器，即同一AS中的对等端建立了BGP连接；<br>            2）边界路由器通过iBGP将BGP路由发送给AS内的对等端；<br>        3）内部路由器收到BGP路由后，<strong>构建转发表</strong>：<br>            关键是修改BGP路由中的下一跳信息；<br>            （例如AS2中的R4，不能直接用原始的BGP路由信息中的R1，作为下一跳的转发，因为根本没连接）；<br>            1）通过<strong>两次递归查询</strong>，找到可用的下一跳路由器；<br>                1）找到<strong>非自己所在AS的边界路由器的对等端</strong>，即在自己的AS中的边界路由器，且与BGP路由中的边界路由器相连；<br>                （例如R1在AS1中，R4不清楚R1的位置，就找到R1对应的边界路由器R2）；<br>                2）使用IGP（内部网关协议），查询从自己<strong>到达边界路由器的最佳路由</strong>；<br>                （例如R4要到R2，查看转发表到达R2的最好下一跳发现是R3）；<br>            2）用对应的路由器<strong>修改该BGP路由信息，存入自己的转发表中</strong>；<br>            （例如，最终BGP路由中有“X，R3”，存放在R4的转发表中）<br>    注意：<br>        1）上面的BGP协议使用，我们主要关注了各个路由器如何使用BGP路由来更新自己的路由表；<br>        2）但是BGP路由的AS信息也是需要维护的，每新到一个自治系统，该AS会被加入BGP路由的AS-PATH中；<br>        （例如上面的例子，最终的”X,R3”，实际上是”X,AS2-AS1,R3”）；</p><p>为什么使用BGP？<br>    1）巨大规模的互联网，自制系统AS之间选路；<br>    2）考虑相关策略（可达性而非代价）</p><p>BGP使用：路径向量选路策略</p><p>BGP报文内容（到达AS1对应的前缀、发送报文的路由器、路由器所在的自治系统AS1）<br>BGP协议路由表（前缀X，下一跳路由器）-含义是下一跳经过路由器，前缀X可达；</p><p>eBGP、iBGP（区别，<strong>适用路由器</strong>）</p><p>iBGP的全连通</p><p>RIP OSPF BGP区别对比<br>1）RIP不能使用<strong>多条路由</strong> OSPF可以<strong>负载均衡</strong>，每一个路由器都知道全网有多少路由器，哪些是相连的，代价是多少；<br>2）RIP、OSPF是工作在一个<strong>AS内</strong>的 BGP工作在不同<strong>AS之间</strong>；<br>3）使用的<strong>协议不同</strong>；<br>4）OSPF在网络层 RIP、BGP在应用层（分别由UDP、TCP服务）；<br>5）OSPF、RIP属于IGP 对应BGP；<br>6）OSPF知道<strong>全网的拓扑结构</strong>，RIP不知道；</p><h3 id="传输层-1"><a href="#传输层-1" class="headerlink" title="传输层"></a>传输层</h3><p>运输层的两个主要协议：<br>    1）<strong>TCP传输控制</strong>协议：提供<strong>可靠的</strong>、<strong>面向连接的</strong>运输服务；<br>    2）<strong>UDP用户数据报</strong>协议：<strong>无连接</strong>，<strong>实时</strong>、<strong>快速高效</strong>；</p><p>TCP报文中有一个可选项MSS：<br>    这是<strong>最大报文长度字段</strong>，代表的是数据字段的最大长度，这个字段要加上TCP首部的长度才是TCP报文的总的最大长度；<br>    <em>考虑这个字段与拥塞控制的关系</em>；</p><p>TCP流量控制<br>    1）含义：让发送方的速率不要太快，要让接收方来得及接收；<br>    2）实现方式：滑动窗口；<br>    3）一些细节：<br>        1）发送方的发送窗口大小不能超过接收方给出的接收窗口rwnd；<br>        2）TCP窗口单位是字节不是报文段；<br>        3）当rwnd为0时对应零窗口报文段，发送方不允许再发送数据，直到接收方重新发送一个新的窗口值为止；<br>    4）什么时候会发送零窗口通知：<br>        1）接收端将接收到的数据放入缓冲区，如果上层应用不及时读取，缓冲区满了的时候；<br>        2）当接收方检测到可用窗口为0的时候；<br>        3）出现1、2两种情况的时候发送方在对于先前数据的确认报文中会通知rwnd&#x3D;0；<br>    5）<strong>零窗口的死锁问题</strong>：<br>        描述：<br>            接收方向发送方发送了零窗口报文段之后不久，接收方<strong>释放了一些空间</strong>，向发送方发送了rwnd&#x3D;400的报文段；但是<strong>报文段在传送中丢失了</strong>，发送方一直在等待接收方发送非零窗口报文段，接收方一直在等待发送方发送数据，陷入死锁；<br>        解决方法：<br>            TCP为每个链接设立的——持续时间计时器；<br>            机制：<br>                只要TCP连接的一方<strong>收到</strong>了<strong>零窗口</strong>报文段，就<strong>启动持续计时器</strong>，如果计时器时间到了就发送一个<strong>零窗口探测报文段</strong>（仅携带1字节数据），对方会在确认探测报文段时给出当前窗口值，如果仍是零，则重置计时器，否则死锁局面解除；</p><p>TCP的拥塞控制<br>    基本概念：<br>        1）<strong>拥塞</strong>：在某段时间，若对网络中的某一资<strong>源的需求</strong>超过了该<strong>资源所能提供的可用部分</strong>，网络的<strong>性能就会变坏</strong>，这种情况就叫做拥塞。<br>        2）拥塞控制：<br>            1）含义：防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不至于过载。<br>            2）前提：网络能够承载现有的负荷（负载）；<br>            3）特点：这是一个全局性的过程，对比<strong>流量控制是点对点</strong>的通信量控制（是<strong>端到端</strong>的过程）；<br>        3）<strong>网络负载</strong>：提供给网络的负载，也称为<strong>输入负载</strong>；<br>            （常用于 <strong>网络负载-吞吐量</strong> 图中）；<br>        4）网络的几种状态（用负载和吞吐量进行判定）：<br>            1）理想情况：吞吐量饱和之前，网络吞吐量&#x3D;网络负载，吞吐量曲线是45度的直线；<br>            2）轻度拥塞状态：网络吞吐量还未到饱和，但是已经有分组被丢弃了，网络吞吐量明显小于理想吞吐量；<br>            3）拥塞状态：网络吞吐量随着负载增减开始减少，而不是理想情况下保持饱和不变；<br>            4）死锁：当网络负载增大到一定数量的时候，吞吐量下降到零；<br>    TCP拥塞控制方法：<br>        假定（理想情况方便讨论算法）：<br>            1）数据是单向发送的，对方只传送确认报文；<br>            2）接收方有足够大的缓存空间，因而发送窗口的大小由网络的拥塞程度来决定；<br>            （实际情况发送方接收窗口的上限 &#x3D; min(rwnd,cwnd)，其中rwnd是接收方报文中规定的接收窗口大小）；<br>        基本思想：<br>            1）基于窗口进行拥塞控制，发送方维持一个拥塞窗口cwnd，随着网络拥塞程度动态变化，让发送窗口等于拥塞窗口；<br>            2）只要网络没有拥塞，拥塞窗口就可以增大一些以便发送更多的分组，只要出现了拥塞，拥塞窗口就减小一些，以缓解拥塞；<br>        <strong>慢开始</strong>：<br>            1）设置<strong>初始拥塞窗口大小</strong>：<br>                1）旧规定：将初始cwnd设置为1～2个SMSS（发送方最大报文长度）；<br>                2）新规定：将初始cwnd设置为2～4个SMSS；<br>                    1）如果SMSS &gt; 2190B，则cwnd &#x3D; 2*SMSS；（不得超过两个报文段）；<br>                    2）如果1095 &lt; SMSS &lt;&#x3D; 2190，则cwnd &#x3D; 3*SMSS；（不得超过三个报文段）；<br>                    3）如果SMSS &lt;&#x3D; 1095，则cwnd &#x3D; 4*SMSS；（不得超过四个报文段）；<br>            2）拥塞窗口<strong>增大机制<strong>：<br>                1）在每收到一个对新的报文段的确认后，可以把拥塞窗口增加最多一个SMSS的数值；<br>                2）具体来说，拥塞窗口cwnd每次的增加量 &#x3D; min(N,SMSS)，其中N是原来未被确认的、但是现在刚收到的确认报文段，所确认的字节数；<br>                3）显然，这种规定下，理想情况cwnd在慢开始阶段是成倍增长的（每次扩大为原来的两倍）；<br>            3）慢开始阶段的表现：<br>                1）虽然TCP是用字节数作为窗口大小的单位的，但是拥塞控制中为了方便叙述，通常使用报文段个数作为单位；<br>                2）开始时cwnd&#x3D;1；<br>                3）发送方每收到一个对新报文段段确认（对重传的确认不算），cwnd就加1；<br>                4）那么一个RTT后，cwnd&#x3D;2，允许连续发送两个报文段，再一个RTT后收到两个确认，cwnd&#x3D;4，允许连续发送4个报文段，…以此类推；<br>                （注意，显然发送方不是要在所有的确认都收齐了之后才调整其拥塞窗口，而是收到一个确认就调整一下拥塞窗口，这是里面的细节）；<br>            4）慢开始</strong>门限ssthresh**：<br>                1）当cwnd &lt; ssthresh时使用慢开始算法；<br>                2）当cwnd &gt; ssthresh时停止慢开始算法，启用拥塞避免算法；<br>                3）当cwnd &#x3D; ssthresh时，可以选择一个用，决定下一个时刻的行为；<br>        <strong>拥塞避免</strong>：<br>            1）加法增大：<br>                1）每经过一个RTT的时间，发送方的cwnd大小就增大1，而不是像慢开始那样成倍增长；<br>                2）这样做可以让cwnd缓慢增大；<br>            2）拥塞避免阶段的表现：<br>                cwnd按线性规律缓慢增长；<br>        <strong>超时处理</strong>：<br>            1）超时</strong>标志<strong>：<br>                1）超时重传计时器启动；<br>                2）判断网络出现了拥塞；<br>            2）处理机制：<br>                1）慢开始门限ssthresh设置为cwnd的一半（</strong>ssthresh &#x3D; cwnd&#x2F;2<strong>）；（</strong>乘法减少<strong>）；<br>                2）拥塞窗口置一，</strong>cwnd &#x3D; 1<strong>；<br>                3）重新开始</strong>慢开始<strong>；<br>            注意：<br>                1）</strong>超时的发生不一定就是网络发生了拥塞<strong>，也可能是因为传输出现了差错，而导致分组被丢弃；<br>                2）尽管现代通信线路传输质量都很好，因为传输差错而丢弃分组的概率远小于1%。这也是为什么用超时来判断拥塞，因为超时大概率是拥塞造成的；<br>                3）因此设置了快重传机制；<br>        <strong>快重传与快恢复</strong>：<br>            1）算法要求：<br>                1）</strong>接收方<strong>不要等待自己发送数据时才稍带确认，而是在收到报文后立即发送确认；<br>                2）即使收到的失序的报文段也要立即发出对已收到报文段的重复确认；（尽管本来可以什么都不做）；<br>            2）</strong>快重传<strong>：<br>                1）在接收方一连收到</strong>3个重复确认<strong>之后，判断网络没有出现拥塞，但是接收方少了一个报文段M；<br>                2）对方却少的是被重复确认的报文段的下一个报文段，例如重复确认三次M2，那么缺少了M3；<br>                3）发送方</strong>立即重新发送接收方缺少的报文段<strong>；<br>            3）</strong>快恢复<strong>：<br>                1）在快重传之后启动快恢复；<br>                2）设置慢启动门限为拥塞窗口的一半</strong>ssthresh &#x3D; cwnd&#x2F;2<strong>；<br>                3）将cwnd减小，通常有两种方法：（这个过程称为</strong>乘法减少<strong>）；<br>                    1）</strong>cwnd &#x3D; ssthresh**；（课本上主要阐释的这种）；<br>                    2）cwnd &#x3D; ssthresh + 3MSS；<br>        <img src="/Computer-Network/p1.jpeg" alt="TCP拥塞控制算法流程图">;</p><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>DNS的作用：<br>    进行<strong>域名解析</strong>；</p><p>DNS协议依赖的下层协议：<br>    传输层：<strong>UDP协议</strong>；<br>    网络层：<strong>IP协议</strong>；<br>    数据链路层（以太网）：<strong>CSMA&#x2F;CD协议</strong>；</p><p>HTTP协议依赖的下层协议：<br>    传输层：<strong>TCP协议</strong>；<br>    网络层：<strong>IP协议</strong>；<br>    数据链路层：<strong>CSMA&#x2F;CD协议</strong>；</p><p>使用一个协议就要封装一个协议的数据包（例如使用DNS协议的时候封装了4层数据包）；</p><h3 id="无线网络"><a href="#无线网络" class="headerlink" title="无线网络"></a>无线网络</h3><p><strong>隐蔽站&#x2F;暴露站</strong><br><em>举出一个具体的例子</em></p><p>CSMA&#x2F;CA协议：<br>    背景：<br>        1）无线局域网使用的数据链路比较特殊，对应的是无线信号的信道，但是和物理链路一样也要考虑信道上信号的碰撞问题，同一时刻同一信道上应该只有一种信号；<br>        2）无线局域网的特点：<br>            1）无线局域网的适配器<strong>无法实现碰撞检测</strong>；<br>            2）检测到信道空闲，起始信道可能<strong>并不空闲</strong>；<br>            3）即使我们能够在硬件上实现无线局域网的碰撞检测功能，也无法检测出<strong>隐蔽站问题</strong>带来的碰撞；<br>        3）所以实际上CSMA&#x2F;CA协议不是载波监听多路复用&#x2F;碰撞检测协议，而是载波监听多路复用&#x2F;碰撞避免协议（尽量减少碰撞发生的概率）；<br>    独特的MAC层：<br>        1）802.11标准为CSMA&#x2F;CA协议中设计了<strong>独特的MAC层</strong>；<br>        2）其中集成了协调功能所必需的字段：<br>            1）<strong>DCF：分布式协调功能</strong>，这是为了后面的争用服务必需实现的字段；（重点）；<br>            2）PCF：点协调功能，无争用服务选用；<br>    CSMA&#x2F;CA协议要点：<br>        1）站点如果要发送数据，必须先监听信道，如果信道在DIFS内均空闲，则发送整个数据帧；<br>        2）否则，<strong>争用信道</strong>；<br>            站点选择<strong>随机数</strong>，设置<strong>退避计时器</strong>；<br>            如果信道<strong>忙则冻结</strong>计时器；<br>            如果信道空闲，且<strong>在DIFS内均空闲</strong>，则<strong>启动</strong>计时器；<br>            当计时器减到零，则发送数据帧；<br>        3）如果发送方站点，接收到却认帧，且后续还有帧要发送，再次进入2），但是要在<strong>更大范围</strong>选择随机数；<br>    要点补充：<br>        1）关于DIFS：假设A給B发送数据帧DATA；<br>            1）B接收到数据帧要发送确认ACK；<br>            2）确认发送时间必然滞后于B接收完DATA的时间，因为有CRC校验等；<br>            3）考虑滞后时间统一设置一个标准为SIFS（最短帧间间隔）；（<strong>接收方的行为！</strong>）<br>            4）那么实际上SIFS这段时间内信道是空闲的；<br>            5）为了保证这段空闲时间内其他站点不发送数据，使用更长的DIFS（<strong>分布式协调帧间间隔</strong>）；<br>            6）空闲时间其他站点想发送数据必须等待DIFS的时间；<br>        2）关于监听（确定信道在忙的具体方法）：<br>            1）802.11标准要求每个站必须同时使用两个方法；<br>            2）第一是，虚拟载波监听（软件实现）：<br>                1）源站（发送站）：将自己占用信道的时间（DATA+SIFS+ACK）写入数据帧；<br>                2）广播范围内的各站能够接收到该信息，创建自己的<strong>NAV</strong>（网络分配向量），指出信道在忙的时间，除了源站和目的站在这一时间内不能使用信道；<br>            3）第二是，载波监听（物理层实现）：<br>                每个站检测接收到的信号强度是否超过一定门限数值，由此判断是否有其他移动站在信道上发送数据；<br>        3）关于<strong>争用期的触发</strong>：<br>            1）要<strong>发送数据时检测到信道在忙</strong>；<br>            2）已发送到数据帧未收到确认，要<strong>重传数据帧</strong>；<br>            3）发送了一个数据帧要<strong>接着发送</strong>后续的数据帧；（为了防止一个站点长期垄断信道）；<br>            （其他情况，当站点想要发送数据，并检测到信道空闲时间超过DIFS可以直接发送，不用经过争用期）；<br>        4）争用信道的过程（争用期）：<br>            1）使用<strong>争用窗口CW</strong>，它由许多时隙组成；<br>                （802.11g规定一个时隙为9微秒，SIFS是10微秒，DIFS是28微秒）；<br>            2）退避：<br>                进入争用期（信道空闲）时，<strong>在0～CW的时隙中随机生成时隙个数</strong>，设置退避计时器；<br>            3）推迟接入：<br>                1）退避计时器先降为0的，开始发送数据帧，信道转为忙；<br>                2）正在退避的站，冻结计时器，保留数值不变，等待下一次争用期接着继续倒计时；<br>        5）关于争用窗口CW的维护：<br>            1）<strong>CW需要增大</strong>的两种情况：<br>                1）<strong>紧接着发</strong>送后续帧；<br>                2）每一次<strong>重传</strong>；<br>            2）具体操作：<br>                1）在每次增大的时候CW会<strong>近似翻倍</strong>；<br>                2）例如初始时CW &#x3D; 15 &#x3D; 2^4 - 1，那么<strong>第i次增大的时候CW &#x3D; 2^(4+i) - 1</strong>；<br>                3）通常802.11建议：CW最小取15，最大取1023，当到达<strong>1023之后CW不会再增大</strong>；<br>    信道预约技术：<br>        目的：更好地避免隐蔽站问题；<br>        具体方法：假设A給B发送数据；<br>            1）对于无线局域网，移动站点都会接入一个AP，用来充当站点之间的中介进行信息转发；<br>            2）A在与B通信之前，<strong>A向AP发送RTS</strong>（请求发送）；<br>            3）AP收到之后，经过SIFS，<strong>回复CTS</strong>（允许发送）；<br>            4）其他所有能够收到AP的CTS的站点，都会知道在一段时间内信道被A、B的通信占用，并以此<strong>设置其NAV</strong>；<br>            （实际上这与前面的虚拟载波监听、载波监听，互为一个补充）；</p><p>关于802.11数据帧的地址</p><p>移动IP：<br>    背景：<br>        1）如果我们需要在移动中浏览网页，那么移动站建立的TCP连接，在移动站漫游时，应当一直保持连接，否则移动站与网站的连接就会变为断断续续的（因为建立TCP连接，不可能瞬间就建立好）；<br>        2）移动IP就是要解决“TCP连接在移动站漫游时如何一直保持”这个问题；<br>    区别：<br>        1）便携式的笔记本电脑，可以带到各种地方办公上网，这个过程会使用DHCP动态主机配置协议，自动获取新的IP地址；<br>        2）这里虽然电脑移动了，但是IP并没有移动，这只是用户在不同地点用不同IP上网，和传统的固定地点上网没有本质区别；<br>    相关概念：<br>        1）永久地址（归属地址）：移动站的原始地址；<br>        （类似于老同学们保留彼此父母的家庭地址，在未来即使没有在具体的联系地址，也总是能够通过家庭地址询问对方父母取得联系）；<br>        2）归属网络：移动站原始连接的网络；<br>        （永久地址就是移动站在归属网络中的地址，这个关联是不会变的）；<br>        3）归属代理：为移动IP提供代理服务，从而实现移动站地址的改变，对互联网的其余部分保持透明；<br>        （通常这个代理就是移动站归属网络的路由器，作为代理的特定功能是在应用层完成的，归属代理既是路由器又是主机）；<br>        4）被访网络（外地网络）：移动站移动到另一个地点所接入到网络；<br>        5）外地代理：移动站在被访问网络中的代理；<br>        （通常也是被访网络的路由器，当然也是主机）；<br>        6）转交地址：外地代理为移动站创建的临时地址；<br>            注意：<br>                1）转交地址仅供移动站、归属代理、外地代理使用；<br>                2）转交地址不具有唯一性，这不会出现问题，因为外地代理给移动站发送数据的时候，不会用类似ARP协议的方法来解析转交地址，而是直接通过移动站的MAC地址发送数据；<br>                3）转交地址的网络号要和被访网络的网络号一致；<br>        7）同址转交地址：移动站本身作为外地代理的情况，这时的转交地址就是同址转交地址；<br>        （这种情况的移动站可以移动到任何网络，而不必担心外地代理是否可用）；<br>    相关工作过程：<br>        1）相关准备：<br>            1）移动站进入被访网络，并向外地代理登记；<br>            2）外地代理将移动站在被放网络中的转交地址告诉归属代理；<br>        2）通信者向移动站通信：<br>            1）通信者发送给移动站数据报，目的地址使用移动站的归属地址；<br>            2）数据报被归属代理截获，归属代理使用转交地址对数据报封装，通过隧道技术发送给外地代理；<br>            3）外地代理将数据报拆封，得到目的地址为移动站归属地址的数据报，转交给移动站；<br>        3）移动站向通信者通信：<br>            1）移动站使用自己的归属地址作为源地址，使用通信者的IP地址作为目的地址，直接发送，不必经过归属代理；<br>    为了支持移动网络，网络层新增功能：<br>        1）移动站到外地代理的协议：<br>            1）移动站进入被访网络的时候，向外地代理进行登记，从而获得一个转交地址；<br>            2）移动站离开被访网络的时候，注销原来的登记；<br>        2）外地代理到归属代理的协议：<br>            1）外地代理向归属代理提供移动站的转交地址；<br>            2）注意：外地代理不会向归属代理注销转交地址，因为移动站到新的被访网络的时候新的外地代理会向归属代理提供新的转交地址，覆盖原来的地址；<br>        3）归属代理数据报封装协议：<br>            1）归属代理收到发送给移动站的数据报后要将其封装成新的数据报；<br>            2）通过隧道将新数据报转交给外地代理；<br>        4）外地代理拆封协议：<br>            1）外地代理收到归属代理封装的数据报后要进行拆封，将原始的数据报给移动站；<br>        注意：<br>            1）这种过程又叫做间接路由选择，因为通信者所在的源站不知道移动站的当前地址，而是将数据报发送给归属网络，以后的寻址工作都由归属代理完成；<br>    三角形路由选择问题：<br>        使用间接路由选择，可能会引起数据报转发的低效，因为：<br>            1）如果通信者和移动站本来有一条更加有效的路由；<br>            2）极端情况是通信者和移动站就在同一个网络中，即通信者在被访网络中；<br>            3）完全可以通过网络直接交付；<br>            4）但是仍然使用移动IP的方法，会让数据报两次穿越广域网，浪费时间还增加通信量；<br>        解决方法：<br>            直接路由选择；<br>            1）通信者创建一个通信者代理；<br>            2）通信者代理向归属代理，询问移动站在被访网络的转交地址；<br>            3）通信者代理，使用隧道技术，即将数据报发送到外地代理；<br>        需要考虑的问题：<br>            1）增加移动用户定位协议：用来让通信者代理向移动站的归属代理查询转交地址；<br>            2）当移动站移动到其他网络的时候，获得移动站的位置信息：<br>                1）将移动站首次使用的外地代理，称为锚外地代理；<br>                2）通信者代理，将要发送的数据报再封装后，发送给锚外地代理；<br>                3）锚外地代理，拆封，转交给移动站；<br>                4）移动站移动到另一个被访网络后，向新外地代理登记；<br>                5）新外地代理将新转交地址告诉锚外地代理；<br>                6）通信者代理仍然使用锚外地代理，当锚外地代理收到封装的数据报后，转发给新外地代理，新外地代理拆封后交给移动站；<br>    注意：上面的问题可以统称移动性管理；</p><h2 id="try-yourself"><a href="#try-yourself" class="headerlink" title="try yourself"></a>try yourself</h2><p><code>if you make sure you&#39;re ready, just try this</code></p><p>辨认一下这些数字的意义：</p><ol><li>1500B </li><li>0x1B&#x2F;0x01&#x2F;0x04</li><li>0x7E</li><li>0x0021&#x2F;0xC021&#x2F;0x8021</li><li>0x7D,0x5D&#x2F;0x7D,0x5E&#x2F;0x7D,0x20</li><li>96比特时间&#x2F;10Mbps,512比特时间</li><li>0&#x2F;10&#x2F;110</li><li>8,24&#x2F;16,16&#x2F;24,8</li><li>32,48</li><li>16,30,3</li></ol><p>透明传输的含义是什么？</p><p>PPP协议的组成是什么？</p>]]></content>
      
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Intro_of_AI</title>
      <link href="/2025/11/07/Intro-of-AI/"/>
      <url>/2025/11/07/Intro-of-AI/</url>
      
        <content type="html"><![CDATA[<h2 id="ch1-绪论"><a href="#ch1-绪论" class="headerlink" title="ch1 绪论"></a>ch1 绪论</h2><p>人工智能相关概念：<br>    人工智能的<strong>定义</strong><br>        1）<strong>四个维度</strong>：（像人，理性）<em>（思考，行动）；<br>        2）业界通常认为“<strong>理性地行动</strong>”是作为AI的最重要维度；<br>    人工智能的*<em>本质问题</em></em><br>        研究如何<strong>制造出智能机器或系统</strong>，来<strong>模拟人类智能活动</strong>的能力，以<strong>延伸人们智能</strong>的科学。<br>    人工智能名字的由来<br>        <strong>1956年</strong>在<strong>美国</strong>召开的<strong>达特茅斯会议</strong>，提出了Artificial Intelligence；（约翰麦卡锡、马文明斯基）；<br>    人工智能未来的研究目标<br>        近期目标：建造智能计算机<strong>代替人类的部分智力劳动</strong>；<br>        远期目标：用自动机模仿人类的<strong>思维过程</strong>和<strong>智能行为</strong>；</p><h2 id="ch2-搜索"><a href="#ch2-搜索" class="headerlink" title="ch2 搜索"></a>ch2 搜索</h2><h3 id="搜索概述"><a href="#搜索概述" class="headerlink" title="搜索概述"></a>搜索概述</h3><p>什么是搜索问题：<br>    搜索问题的本质：探索替代方案，基于知识表示提供的信息，遍历所有可能的解决方案空间；</p><p>搜索问题如何求解：<br>    在状态图中找到一条从起点到终点的路径；<br>    关于这个解（路径）：<br>        1）代价就是路径上所有边的耗散值之和；<br>        2）最优解拥有最小的代价；</p><p>什么是状态图：<br>    状态图：用图结构描述问题的状态空间以及状态之间的转换关系，是AI搜索算法的基础；<br>    状态图构成要素：<br>        1）节点：问题的状态与状态图中的节点一一对应；<br>        （例如8数码问题中每种棋局就是一种状态，对应状态图中的一个节点）；<br>        2）边：代表状态的转移，如果节点s‘是节点s的后继状态，则用有向弧链接s和s‘；<br>        3）状态图可能包含多个连通分量，即图中互相无法到达的子图；<br>    如何针对具体问题建模状态图：<br>        明确状态空间：问题的所有可能状态的集合；<br>        设计后继函数：将一个状态映射到状态空间中的另一个状态，完成状态的转移；<br>        确定初始状态：问题的初始状态；<br>        规定目标测试：如何判断当前状态是否是目标状态；<br>        考虑边的耗散值：一次状态转移的代价，可以用于衡量最后解路径的代价；</p><p>搜索树：<br>    含义：将在状态图中进行搜索的过程，即节点的转移，按照当前节点是父节点转移后的节点是子节点的方式，展开为树；<br>    注意：<br>        1）可能会有状态图中的重复节点在树上不加以区分，仍然按照上述方式展开；<br>        2）因此，如果允许状态被重新访问，即便状态空间是有限的，搜索树也可能是无限的；<br>        3）通常这种情况容易引发搜索的死循环，在实际开发过程中会采用记录已访问节点的方式；<br>    相关概念（数据结构）：<br>        1）节点：<br>            1）状态封装而成的数据结构，在搜索算法中使用；<br>            2）注意区别状态图中的节点，前者是“图论中的概念”，这里是真实存在（可以编程实现的）数据结构；<br>            （后续搜索所说的节点，基本上都是这个节点）；<br>        2）节点的深度：从树的根节点到节点N的边的数量；<br>        3）节点的扩展：<br>            1）对节点的状态调用后继函数，生成后继状态；<br>            2）对于每个后继状态，生成相应的子节点；<br>        4）节点的生成：<br>            1）将状态信息封装为节点这一数据结构；<br>            2）它是节点扩展中的关键一步，但是同于节点的扩展；<br>        5）边缘队列Fringe：<br>            1）搜索树上还没有扩展的节点的集合；<br>            2）边缘队列中的节点不同于叶节点；<br>        6）叶节点：<br>            无法扩展的节点；</p><h3 id="无信息搜索"><a href="#无信息搜索" class="headerlink" title="无信息搜索"></a>无信息搜索</h3><p>图搜索的一般过程：<br>    搜索算法1:<br>        1）检查初始节点，是否到达目标状态，是则返回；<br>        2）将初始节点插入边缘队列；<br>        3）循环：<br>            1）检查，如果边缘队列为空，则返回失败；<br>            2）从边缘队列中取出节点N；<br>            3）取出节点N对应的状态s；<br>            4）对s使用后继函数，对每一个后继状态：<br>                1）生成一个新的节点N’，作为N的子节点；<br>                2）检查当前后继状态s’是否是目标状态，是则返回解路径 or 状态；<br>                3）将N’插入边缘队列；<br>    注意：<br>        1）搜索策略的决定因素：边缘队列中节点的排序方式；（主要区别）；<br>        2）返回的是解路径 or 状态取决于问题本身；<br>            1）有的问题状态本身就是解，例如8皇后；<br>            2）有的问题就需要一条解的路径，例如8数码；</p><p>算法性能度量：<br>    <strong>完备性：</strong>有解必能找到；<br>    <strong>最优性：</strong>总能返回代价最小的路径；<br>    复杂性：时间复杂性和空间复杂性；<br>        <strong>时间复杂性：</strong>对应需要访问的节点的总数（为了找到解）；<br>        <strong>空间复杂性：</strong>边缘队列中最多同时存储的节点数；<br>    搜索算法的评估：<br>        搜索算法的参数：<br>            1）<strong>分支因子数b</strong>：描述搜索树中每个节点能扩展出的子节点的最大数量；<br>            2）<strong>最浅目标节点深度d</strong>：从初始节点到达目标节点的所有路径中，路径长度最短的那条路径所对应的目标节点的深度；<br>            （注意，路径长度最短不一定代价最小）；<br>            3）<strong>叶子节点最大深度m</strong>：搜索树中不可扩展的所有叶子节点对应的最大深度；<br>        <strong>常用搜索算法的评估：</strong><br>            1）宽度优先搜索：<br>                1）具有<strong>完备性</strong>；<br>                2）<strong>最优性</strong>，只在边的耗散值为1的时候成立（<strong>通常是默认的</strong>）；<br>                3）<strong>时间</strong>复杂度$O(b^d)$；<br>                4）<strong>空间</strong>复杂度$O(b^d)$；<br>                （通常认为<strong>边的耗散值是1</strong>；）<br>            2）双向宽度优先搜索：<br>                1）时间复杂度$O(b^{d&#x2F;2})$；<br>                2）空间复杂度$O(b^{d&#x2F;2})$；<br>            3）深度优先搜索：<br>                1）<strong>完备性</strong>，对于有限的搜索树是成立的；<br>                2）<strong>最优性</strong>，不具备；<br>                1）<strong>时间</strong>复杂度：$O(b^m)$；<br>                2）<strong>空间</strong>复杂度：$O(bm)$或者说$O(m)$；<br>                （通常认为<strong>边的耗散值是1</strong>；）<br>            4）迭代加深搜索：<br>                1）<strong>完备性</strong>，具备；<br>                2）<strong>最优性</strong>，只在边的耗散值为1的时候成立；<br>                3）<strong>时间</strong>复杂度：$O(b^d)$；<br>                4）<strong>空间</strong>复杂度：$O(bd)$或者说$O(d)$；<br>            通常认为：<br>                1）BFS是完备且最优的，但是空间复杂度很高；<br>                2）DFS空间复杂度低，但是不完备、不最优；<br>                3）IDS空间复杂度较低，并且具有完备性、最优性；</p><p>无信息搜索（注意与启发式搜索进行对比）：<br>    <strong>不利用状态描述</strong>来对<strong>边缘队列</strong>中的节点进行<strong>排序</strong>，仅<strong>依据节点在搜索树中的位置</strong>来决定处理顺序；<br>    （例如参考节点的深度、节点被先后生成的顺序；）</p><p>常用的无信息搜索算法：<br>    1）宽度优先搜索；<br>    2）双向宽度优先搜索；<br>    3）深度优先搜索；<br>    4）迭代加深搜索；<br>    5）一致代价搜索；<br>    （这一部分最好自己画一下）；</p><p>一致代价搜索：<br>    目标：找到一条路径代价最小的解；<br>    关键：<br>        1）路径代价是从根节点到当前节点到所有边的耗散值之和g(N)；<br>        2）边缘队列中的节点按照g(N)的升序进行排列；<br>    使用的算法框架：<br>        路径搜索算法2:<br>            1）将初始节点插入边缘队列；<br>            2）循环：<br>                1）检查，边缘队列为空则返回失败；<br>                2）从边缘队列中取出节点N；<br>                3）从节点N中取出状态s；<br>                4）检查，状态s是否是目标状态，是则返回解路径 or 状态；<br>                5）对于s的每一个后继状态：<br>                    1）生成节点；<br>                    2）将节点插入边缘队列；<br>        注意：<br>            1）路径搜索算法2与1的不同点在于状态是否是目标状态的检查时机，2是在从边缘队列中取出来的时候检查，1是由后继函数生成的时候进行检查；<br>            2）因此，2不需要在开始时对初始节点做检查；<br>    一致代价搜索的性质：<br>        对于任意状态s，当其对应的节点N被选中扩展时，所走过的路径就是从根节点状态到状态s对应节点的最佳路径；        </p><h3 id="启发式搜索"><a href="#启发式搜索" class="headerlink" title="启发式搜索"></a>启发式搜索</h3><p>启发式搜索：<br>    会利用<strong>状态描述</strong>来对<strong>边缘队列</strong>中的节点<strong>进行排序</strong>，将“最具备前景”的节点置于边缘队列的前端，<strong>优先进行扩展</strong>，以高效地<strong>接近目标</strong>；</p><p>最佳优先搜索<br>    1）引入评估函数f，将当前问题状态信息映射为一个实数；<br>    2）f是根据当前问题的状态描述来评估当前搜索节点好坏的指标（越小越好，f代表代价）；（评估函数定义）<br>    3）最佳优先搜索算法就是在搜索算法2的基础上，按照f从小到大为边缘队列中的节点排序；<br>    性质：<br>        1）若状态空间无限，则BS搜索不完备；<br>        2）若状态空间有限，但是不丢弃重复访问的节点，BS搜索不完备；<br>        3）若状态空间有限，切丢弃重复访问节点，则BS搜索完备；<br>    （BS搜索无法保证完备性和最优性）；<br>    拓展性质：<br>        1）如果启发式函数<strong>h是可纳的</strong>，f &#x3D; g+h，则BS搜索能够找到<strong>最优解</strong>；</p><p>评估函数f的构造方式：<br>    f(N) &#x3D; g(N)+h(N)；<br>    其中：<br>        1）g是初始节点到节点N的实际代价；<br>        2）h是初始节点到目标节点路径代价的估值，也就是启发式函数；</p><p>启发式函数h：<br>    定义：是对<strong>从当前状态</strong>到<strong>目标状态</strong>的<strong>路径耗散值</strong>的一个估计；（<strong>启发式函数定义</strong>）；<br>    注意：h的值与当前搜索树<strong>无关</strong>，只与当前状态和目标状态<strong>有关</strong>；</p><p><strong>可采纳的启发式</strong>函数：<br>    1）h<em>：从<strong>当前节点到目标节点</strong>的<strong>最优路径代价</strong>；<br>    2）如果启发式函数是<strong>可纳的</strong>，则0 &lt;&#x3D; h &lt;&#x3D; h</em>；<br>    注意：<br>        本质上是一种乐观估计，估计的代价永远小于实际最优的代价；</p><p>启发式函数的<strong>一致性</strong>：<br>    一个可纳的启发式函数被称为一致的或者单调的，如果对于任意的<strong>节点N</strong>以及其任意的<strong>子节点N’<strong>有</strong>h(N) &lt;&#x3D; c(N,N’)+h(N’)<strong>；<br>    直观的理解：<br>        1）随着搜索树的不断加深，一致启发式函数的估值会变得</strong>更加精确</strong>；<br>        2）h(N) - c(N,N’) &lt;&#x3D; h(N’) &lt;&#x3D; h*(N’)<br>    （实际上一致性的条件，可以推导出可纳，即使没有直接说该启发式函数是可纳的，因此一致性是一个更强的条件）；</p><p>如何比较两个<strong>启发式函数的好坏</strong><br>    启发式函数的<strong>准确性</strong>：<br>        令h1、h2是两个满足一致性的启发式函数，如果对于所有节点N，都有h1 &lt;&#x3D; h2，则称h2更准确（预见性更强）；<br>    （使用更准确的启发式函数的A*算法扩展过的节点，几乎都会被使用较不准确的启发式函数的算法扩展）；</p><p>N-puzzle问题的启发式函数：<br>    1）<strong>不在位将牌</strong>；（可纳）；<br>    2）曼哈顿距离；（可纳）；<br>    3）逆序对数；（不可纳）；<br>    （具体计算的时候<strong>不会考虑空白格</strong>，例如不在位将牌，不会因为空白格不在最后一个位置而给启发式函数值+1）；<br>    （曼哈顿距离比不在位将牌<strong>更加准确</strong>）；</p><p>如何<strong>避免访问重复</strong>的节点：<br>    1）维护一个闭表，在节点从边缘队列（开表）中取出，完成扩展之后，就<strong>放入闭表</strong>；<br>    2）后续如果出现一个节点<br>        1）其状态和<strong>闭表</strong>中某个节点对应的<strong>状态相同</strong>，则丢弃该节点；<br>        2）如果<strong>边缘队列</strong>中存在一个节点和该节点<strong>状态相同</strong>，则丢弃具有更大f值的那个（或者如果没有考虑f &#x3D; g+h，则丢弃具有更大g值的那个）；</p><p>常用的概念：<br>    开表，边缘队列，fringe、frontier、open table；<br>    闭表，closed table，explored table；<br>    <strong>数据结构：</strong><br>        开表：通常使用<strong>优先队列</strong>；<br>        闭表：通常使用<strong>哈希表</strong>；</p><h2 id="ch3：对抗搜索及博弈"><a href="#ch3：对抗搜索及博弈" class="headerlink" title="ch3：对抗搜索及博弈"></a>ch3：对抗搜索及博弈</h2><h3 id="棋类介绍及分类"><a href="#棋类介绍及分类" class="headerlink" title="棋类介绍及分类"></a>棋类介绍及分类</h3><p>棋类：完备信息的动态博弈；<br>牌类：不完备信息的动态博弈；</p><p>棋类的特点：<br>    可以决出胜负；<br>    规则简单明确；<br>    博弈过程透明、公平；<br>    智力与经验决定胜负；<br>    变化无穷；</p><p>一些具体的棋类特点：<br>    象棋：60步不吃子判和；<br>    国际象棋：相对子力；<br>    围棋：规则最简单，计算机博弈难度最大；（19<em>19）；<br>    五子棋：已被证明先手必胜，有禁手；（15</em>15）；<br>    六子棋：先手下一子，之后每手下两子；（19*19）；</p><p>棋类的分类：<br>    参与人数划分：<br>        双人：象棋、围棋、五子棋等；<br>        多人：跳棋；<br>    按兵种分：<br>        单一兵种：围棋、五子棋、六子棋；<br>        多兵种：国际象棋、中国象棋；<br>    按着法分：<br>        走子类：开局摆好棋子后，轮流走动棋子；象棋等；<br>        添子类：开局盘面无子，轮流落子；围棋等；<br>        吃子类：对局过程中可以吃掉对方的子；象棋、围棋等；<br>        混合类：在添子的过程中可以吃子、在走子的过程中可以吃子还可以添子；日本将棋等；<br>    （通常情况下下棋的双方轮流走子，但是有的棋可以一次下多步，连续施着称为轮）<br>    按胜负判决分类：<br>        擒获首领：如象棋；<br>        摆成形状：如五子棋；<br>        占领领域：如围棋；<br>        剩余子粒：如黑白棋；<br>        活动剩余：如亚马逊；<br>        到达目标地：如跳棋；</p><h3 id="计算机博弈"><a href="#计算机博弈" class="headerlink" title="计算机博弈"></a>计算机博弈</h3><p>将搜索应用于博弈的思想：<br>    1）任何一方搜索时都要考虑对方可能的走步；<br>    2）优秀的搜索，不应该只考虑对方一步，而是考虑若干步；<br>    3）这个过程动态进行，当考虑对方若干步走了一子之后，待对方走子后，要重新进行考虑若干步；<br>    （即若干步的向后考虑只影响当前步的走子）</p><p>我们关注的博弈满足如下特点：<br>    1）双人对弈，双方轮流走步；<br>    2）信息完备，双方看到的棋局是一样的；<br>    3）零和博弈，非合作博弈，一方的收益必然意味着另一方的损失；</p><p>博弈的基本原理（普遍、基本、其他规律的基础）<br>    1）棋类要素，棋盘、棋子、棋规（着法与胜负规则）；<br>    2）弈棋要素，用着法推演局面，从有利局面中选择着法；<br>    3）局面评估，指标分析，根据棋种不同而具体分析；<br>    （实际上这三个点构成了我们后续博弈树的基础）</p><p>弈棋过程的形式化描述：</p><ol><li>$S_n$：n手之后的局面</li><li>$q_{n+1}$：第n+1手</li><li>$Q$：棋谱$q$的集合</li><li>$Q_odd,Q_evn$：红方与黑方的着手</li></ol><p>棋局状态展开（计算机基于搜索的博弈过程）？<br>    1）在当前棋局状态上，使用着法生产器，由具体的着法算子生成可能的着法；<br>    2）使用对应的着法，考虑转移后的棋局状态，即博弈树展开；<br>    3）根据具体的搜索策略，在博弈树上做搜索；<br>    4）对搜索到的叶节点做状态评估，最终确定着法？</p><h3 id="棋局要素的数据结构"><a href="#棋局要素的数据结构" class="headerlink" title="棋局要素的数据结构"></a>棋局要素的数据结构</h3><p>计算机博弈数据结构主要涉及：<br>    1）对棋盘、棋子、棋局进行编码；<br>    2）对着法、规则、知识等进行编码；<br>    3）编码得到数据元素，将各种数据元素以特定关系构成数据结构；</p><p>常见的编码方法：<br>    1）棋盘：棋位编码（eg，数字对应位置）<br>    2）棋子：角色和方（eg，二元组）<br>    3）着法：棋位序列（eg，数字向量）<br>    4）局面：棋位棋子对的向量（eg，1）、2）构成的二元组，形成的向量）<br>    5）对局过程：着法形成的向量<br>    （当然具体的棋要考虑具体的编码方式）</p><p>局面（盘面）存储的最好方式：<br>    Zobrist哈希技术：将盘面转换为哈希数，哈希数即key、盘面即value；<br>        1）基本原理<br>            1）每个棋子的位置、颜色（所属方）、角色，转换为64位随机数；<br>            2）将棋盘上的每个棋子对应的随机数异或求和；<br>            3）得到的结果作为64位哈希数，key，作为盘面的索引值（Zborist键值）；<br>        2）好处：<br>            根据哈希数的定义，当盘面变化的时候只需要用当前盘面的哈希数与相应变化棋子的哈希数异或一次，就可以得到新的盘面对应的哈希数；<br>        3）关键点：<br>            1）在转换为64位随机数的时候，我们要使用到哈希算法，本质是将任意长度的二进制值映射为固定长度的较小二进制值，即哈希值；（eg，因为棋子本质上经过编码在计算机中最终是以01的形式存储的，它可能是一段很长的01串，被我们转换为了一个64位的01串）<br>            2）哈希算法要求对应的散列空间，满足：想找到两个不同的输入可以满足有相同的散列值，在计算上是不可能的；<br>        4）注意：<br>            1）我们无法直接将Zobrist的哈希数key直接转换为value，也没必要这样做，因为设计Zobrist表的目的本身是为了指纹而非压缩；通常可以将盘面作为value存储起来，key即哈希数，建立一个“一一映射”，就像我们开头提到的一样；（这样我们能够给基于一个key，快速找到一个盘面，当然如果是之前没有保存过的key-value，是找不到的）<br>            2）Zobrist技术的应用通常是为了：<br>                1）快速识别：判断两个局面是否相同；<br>                2）重复检测：检测是否到达过某个局面；<br>                3）查表加速：在置换表中快速查找局面的评估值；<br>                （而非完全把弈棋过程转换为异或运算，抛弃其他信息；这也是肯定做不到的，因为信息就不对等）</p><p>位棋盘（Bit Board）<br>    应用场景：在着法生成是需要对棋局进行评估，评估的时候时常只关心一些棋子的分布，这是可以用比特棋盘（位棋盘）；<br>    使用方式：本质就是棋子状态条件的布尔表示；<br>    形式化表示：$B &#x3D; {b_{i,j}}<em>{m \times n}$，其中$b</em>{i,j} &#x3D; 1,when:s_{i,j} &#x3D; true$，以及$b_{i,j} &#x3D; 0,when:s_{i,j}&#x3D;false$；而$s_{i,j}$就是棋位$(i,j)$的布尔条件；<br>    eg：当关注某些棋位上是否有黑车时，条件就可以是在$(i,j)$上有黑车时，$s_{i,j}&#x3D;true$；</p><h3 id="博弈树展开与分析"><a href="#博弈树展开与分析" class="headerlink" title="博弈树展开与分析"></a>博弈树展开与分析</h3><p>博弈树的基本概念：<br>    博弈树：树枝和节点组成的单向无环图；<br>    树枝：对应着法；<br>    节点：对应着法生成的局面；<br>    博弈树的展开：着法的生成，代表从当前局面的演化和发展，是进行局面分析的基础；（当前局面作为根节点）；<br>        常见的着法生成策略（展开策略）：<br>            1）选择生成：根据当前局面，生成部分可行的着法，不考虑其他着法；（eg：象棋被将军的情况下要避将）；<br>            2）渐进生成：先生成一些着法，沿着某个着法沿伸下去，直到足以中止，再考虑其他着法；（eg：象棋先考虑吃子，再考虑非吃子）<br>            3）完全生成：一次产生所有的着法；</p><p>具体的着法生成方法：<br>    走子类：<br>        1）棋盘扫描法：<br>            在当前局面中逐一考虑可行的落子点；<br>            通常没有实战意义；<br>        2）模板匹配法：<br>            对于有特殊要求的走子类，根据具体的棋子与要求，逐一找到可行的落子点；<br>        3）预置表法：<br>            将全部棋子在所有棋位上的着法预先放在表中，开局自动生成放入内存，弈棋过程中直接查找；<br>            空间换时间的做法；<br>    添子类：<br>        通常比较直观，在盘面上合法的空位处即可落子；<br>        （略）</p><p>博弈树展开的分析：<br>    分子因子：<br>        节点所对应的局面，有多少种着法就有多少种分支；eg：国际象棋的平均分支因子大约是35；<br>    节点的层数：<br>        博弈树展开的深度；<br>    （分支因子越大、层数越多，博弈树规模就越庞大）<br>    树的复杂度：<br>        将博弈树完全展开，从当前的初始局面，到分出胜负时，博弈树上的节点树；eg：五子棋大约是225；<br>    状态复杂度：<br>        全部可行局面的数量；eg：五子棋大约是2225；<br>    （由于博弈树种有大量重复的状态，所以树的复杂度远高于状态复杂度）？为什么五子棋的不是，是特例吗？</p><h3 id="计算机博弈求解的基本搜索方法"><a href="#计算机博弈求解的基本搜索方法" class="headerlink" title="计算机博弈求解的基本搜索方法"></a>计算机博弈求解的基本搜索方法</h3><p>优化搜索与博弈搜索：<br>    优化搜索的特点：<br>        1）单一决策主体，即性能指标函数；<br>        2）明确的目标函数与约束条件，可以使用数学模型描述；<br>        3）主要用于解决基本规划和优化问题；<br>        4）进行单步考虑；<br>    博弈搜索：<br>        1）主要特点：<br>            1）两个非合作主体构成；<br>            2）涉及多步考虑；<br>            3）对弈双方对立，零和，是对决策目标的约束；<br>            4）目标函数难以用数学模型描述；<br>        2）主要方法：<br>            使用博弈树对博弈过程进行描述，在博弈树中搜索当前的最佳着法，并亦步亦趋地进行下去。<br>            （即目标是找到最好的“根着法”，并且这不是一个目标，而是当前的目标）</p><p>极大极小搜索算法<br>    <strong>基本思想：</strong><br>        1）将当前状态作为初始状态，建立一个深度为h的搜索树，h可以表征“视野“，时间允许范围内能看到的最大深度；<br>        2）对所有叶节点的状态进行评价；<br>        3）叶节点回推到根节点，选择其中最好的一个动作决策；<br>        （重要的假设：对手MIN的应对总是给MAX带来最坏的结果）；<br>    使用到的术语：<br>        1）节点 or 结点；<br>        2）根节点 or 顶节点；<br>        3）叶节点 or 端节点；<br>        4）MAX着棋，MIN着棋：通常分别对应我方、对方<br>        5）评估函数f：当f&gt;0时对MAX方有利；f&lt;0时对MIN方有利；f&#x3D;0时双方势均力敌；f绝对值越大对一方越有利，另一方越不利；<br>    具体的算法流程：<br>        1）从根节点开始按照所有可能的着法，扩展博弈树；使用的着法视哪一方着棋而定，MAX、MIN交替着棋；<br>        2）根节点深度h&#x3D;0，每次往下扩展深度+1，到达深度阈值后停止扩展，此时的节点为叶节点；<br>        3）对所有的叶节点按照评估规则计算估值f；<br>        4）逐层上推非叶子节点的估值，按照规则：<br>            1）若非叶子节点对应局面由MAX着棋，则选择其儿子节点中最大的估值作为自己的估值<br>            2）若非叶子节点对应局面由MIN着棋，则选择其儿子节点中最小的估值作为自己的估值<br>            （这就是选择对自己最有利的动作决策）；<br>        5）上推到根节点时，根节点按照4）中的确定估值规则，选择最好的估值，对应的着法就是当前MAX or MIN方使用的着法；<br>        （于是就完成了一次最大最小搜索，找到了当前最好的动作决策）</p><p><strong>棋局评估</strong>：</p><p>棋局评估：若叶子节点不能够给出胜-负-和的结果，那么有利局面需要依靠棋局评估</p><p>静态估值函数f定义的基本规则：</p><ol><li>有利于MAX为正</li><li>有利于MIN为负</li><li>势均力敌为0</li><li>根据势态的优劣进行定义，从而完成对叶节点的价值度量</li><li>若f(p) &#x3D; +∞则MAX赢，若f(p) &#x3D; -∞则MIN赢</li></ol><p>对一个棋局状态s的评估函数通常是考虑不同类型的知识后，对每种考虑因素进行估值，最后进行加权求和得到的。</p><p>即：$e(s) &#x3D; \sum w_i f_i(s)$</p><p>其中估值函数$f_i$可以对应：</p><ol><li>子力</li><li>位置</li><li>空间</li><li>机动</li><li>拍节</li><li>威胁</li><li>形状</li><li>图案</li></ol><p>等等。</p><p>值得注棋局性能 &#x3D; <strong>知识✖️速度</strong>意的是，考虑的因素越多，花费的时间必然越多，这个时候时间就会成为掣肘。而有时候考虑得少，时间少速度快，搜索的速度更快，深度更深。</p><h3 id="alpha-beta剪枝"><a href="#alpha-beta剪枝" class="headerlink" title="alpha-beta剪枝"></a>alpha-beta剪枝</h3><h4 id="剪枝思想"><a href="#剪枝思想" class="headerlink" title="剪枝思想"></a>剪枝思想</h4><p>极小极大搜索算法随着搜索深度的增长，节点数会成指数增长，所以要考虑一种剪枝算法</p><p>alpha-beta剪枝算法的思想</p><ol><li>将向下生成和倒推计算结合起来</li><li>根据一定的条件判定，尽早地修剪一些无用的分支</li><li>生成到达规定深度的节点时立刻计算其估值，一旦某个非端节点有条件计算其倒推值则立刻计算</li></ol><h4 id="具体规则"><a href="#具体规则" class="headerlink" title="具体规则"></a>具体规则</h4><p><code>需要进一步补充一下具体的例子</code></p><ol><li>alpha，MAX节点的估值下界，随着子节点生成alpha只可能上升</li><li>beta，MIN节点的估值下界，随着子节点生成beta只可能下降</li><li>alpha剪枝，MIN节点的beta 小于等于 <strong>先辈</strong>的MAX节点的alpha；则终止MIN子节点向下的搜索，令其估值为beta</li><li>beta剪枝，MAX节点的alpha 大于等于 <strong>先辈</strong>的MIN节点的beta；则终止MAX子节点向下的搜索，令其估值为alpha</li></ol><p>算法过程（参考图示笔记）；</p><p>算法过程注意：<br>    0）每个节点都会维护alpha、beta、v；<br>    1）向前扩展时将alpha、beta传下去；<br>    2）向后更新的时候传播v；<br>    3）MAX层更新alpha；<br>    4）MIN层更新beta；<br>    5）MAX、MIN层都会更新v<br>        MAX层v取 子层中v或自己的v 的最大值；<br>        MIN层v取 子层中v或自己的v 的最小值；<br>    6）剪枝在更新完成后发生：<br>        if(alpha &gt;&#x3D; beta) return v；</p><p>注意：</p><ol><li>仅在MAX、MIN两种不同类型的节点间比较，alpha、beta之间不能比较</li><li>不仅要和直接的父节点比较，要和直系的所有先辈比较（这里对应的是算法中alpha、beta是上面传递下来的）；</li><li>当估值被确定后，才能向上传递</li><li>这种剪枝方法的结果和极小极大的方法是一致的</li></ol><h3 id="负极大值搜索"><a href="#负极大值搜索" class="headerlink" title="负极大值搜索"></a>负极大值搜索</h3><p>思想：<br>    1）父节点的估值是各子节点估值的变号极大值，从而避免奇数层极大、偶数层极小的情况。（实际上这样的话每次只用从子节点中挑选MIN的估值，对MAX节点的子节点，MIN意味着负的越多，取正越大；对MIN节点的子节点，MIN意味着正的越少，取负越大）<br>    2）并且由于实际上，这样处理估值后，无论MAX、MIN都是做的MIN节点的搜索，找子节点中估值最小的，于是只需要实现beta剪枝</p><p>关键点：<br>    1）估值函数的处理：<br>        红方：RedValue-BlackValue；<br>        黑方：BlackValue-RedValue；<br>    2）返回的不再是value而是-value；<br>    3）反向更新的时候，中间节点的估值是子节点估值的负数（-value）中的最大值；<br>    4）前向传播的时候子节点的beta，alpha &#x3D; 父节点的-alpha，-beta；<br>    5）反向更新的时候只更新alpha的值对应的也是 子节点估值的负值 自己的alpha值 中最大的（和value更新类似）；<br>    （参考下面的伪代码…）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">negamax_alpha_beta</span>(<span class="params">node, depth, alpha, beta, color</span>):</span><br><span class="line">    <span class="keyword">if</span> depth == <span class="number">0</span> <span class="keyword">or</span> node.is_terminal():</span><br><span class="line">        <span class="keyword">return</span> color * evaluate(node)</span><br><span class="line">    </span><br><span class="line">    value = -<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> child <span class="keyword">in</span> node.children():</span><br><span class="line">        child_value = -negamax_alpha_beta(child, depth-<span class="number">1</span>, -beta, -alpha, -color)</span><br><span class="line">        value = <span class="built_in">max</span>(value, child_value)</span><br><span class="line">        alpha = <span class="built_in">max</span>(alpha, value)</span><br><span class="line">        <span class="keyword">if</span> alpha &gt;= beta:</span><br><span class="line">            <span class="keyword">break</span>  <span class="comment"># 这就是唯一的剪枝条件</span></span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="蒙特卡洛树搜索"><a href="#蒙特卡洛树搜索" class="headerlink" title="蒙特卡洛树搜索"></a>蒙特卡洛树搜索</h3><p>基本思想：</p><ol><li>从某一棋局出发，随机走棋</li><li>走棋必须按照对应的规则，但不需要任何策略</li><li>进行非常多次对局后，可以基于统计，给出该棋局的固有胜率和胜率最高的着法</li></ol><p>基本步骤：<br>    1）选择：<br>        从根节点（当前局面）开始，递归选择子节点，直到到达：<br>            1）一个未完全展开的节点（还有未探索的着法）；<br>            2）或一个终端节点（游戏结束）；<br>    2）扩展：<br>        当选择一个未完全展开的非终端节点时，扩展一个或多个子节点（添加新的着法到树中）；<br>    3）模拟：<br>        1）模拟之前要选择从哪个新扩展的节点开始，依据可以是 UCB1 的值；<br>        2）从新扩展的节点开始，进行随机模拟直到游戏结束；<br>        3）记录最终结果（胜、负、平）；<br>    4）反向传播：<br>        1）将模拟结果沿着选择路径反向传播到根节点；<br>        2）更新路径上所有节点的统计信息；<br>        3）通常更新：访问次数N和获胜次数W；</p><p><strong>回去问问老师吧，就让老师按照ppt上的例子解释…</strong></p><h2 id="ch4：局部搜索"><a href="#ch4：局部搜索" class="headerlink" title="ch4：局部搜索"></a>ch4：局部搜索</h2><p>引入：<br>    无信息or有信息的搜索：<br>        1）问题的解是一个路径（动作序列）；<br>        2）关注的是路径的代价；<br>        3）环境是可观测的、确定、静态、已知的；<br>    局部搜索：<br>        1）问题的解是一个状态；<br>        2）不需要关注到达该状态的过程；<br>        eg：<br>            1）八皇后问题，只关注最终皇后的排列位置；<br>            2）优化问题求解，只关注最终的解是什么；<br>            3）作业空间调度，只关注调度的方案是什么；<br>            4）旅行商问题，寻找一条满足条件的路径；<br>        （注意甄别，问题的解是路径，这里的路径是指搜索过程的状态序列 or 动作序列；当然动作序列就对应了状态序列，只需要按照动作依次进行状态转移即可；而不是指具体的什么路径。虽然旅行商问题中最终也要找到一条路径，但是那条路径实际上是一个状态）<br>    局部搜索算法的思想：<br>        1）目标：在状态空间（所有状态的集合）中搜索一个最大的状态；<br>        2）思想：从单独的一个状态出发，通常只移动到与之相邻的状态，并且不保留解的路径；<br>        （简单来说，维持当前状态，不断改进；）<br>    局部搜索算法的优点：<br>        1）需要很少的内存；<br>        2）可以从很大、无限的状态空间中找到合适的解；</p><p>优化问题与状态空间地形图：<br>    优化问题：<br>        1）目标函数的目标：最高峰，全局最大值；<br>        2）代价函数的目标：最低谷，全局最小值；<br>    目标函数对应的状态空间地形图：<br>        1）shoulder；<br>        2）Global maximum；<br>        3）Local maximum；<br>        4）“flat” local maximum；<br>    对应如图：<br>    <img src="/Intro-of-AI/p1.png" alt="状态空间地形图">;</p><p>局部搜索算法1：爬山法<br>    思想：随机选择一个位置爬山，每次朝着更高的方向移动，直到到达山顶；<br>    具体的算法：<br>        1）将当前节点的估值与邻居节点进行比较；<br>        2）如果当前节点估值最好，则返回当前节点作为最大值（山峰）<br>        3）否则使用估值更好的邻居节点，替换当前节点；<br>        4）循环这个过程直到退出；<br>    伪代码如图所示：<br>    <img src="/Intro-of-AI/p2.png" alt="爬山搜索"><br>    eg：<br>        8皇后问题：<br>            目标：任何一个皇后都不会攻击到其他的皇后；<br>            耗散值h：存在冲突的皇后对数；<br>            状态转移（决定相邻节点）：<br>                考虑皇后只能在该列上移动，$8\times 8$的棋盘，则有56个后继状态；<br>            局部搜索求解：<br>                每次考虑相邻状态中耗散值最小的，直到找到耗散值为0的状态，即目标状态；<br>    存在的问题：<br>        局部最优解问题，locl maximum or flat local maximum（山脊与高原）；</p><p>局部搜索算法2：随机重启爬山法<br>    思想：在到达局部最优的时候，通过随机生成初始状态来引导爬山法搜索；<br>    具体的算法：<br>        注意：<br>            1）实际上是否处于局部最优在某些情况下比较难判断，我们这里假设全局最优已知；<br>            2）如果我们已经知道了全局最优，为什么还要搜索？实际上这里的全局最优已知，指的是全局最优满足的条件是知道的，我们可以判断是否到达了全局最优；<br>            3）eg，八皇后中，耗散值为0的状态一定是全局最优，尽管我们不知道具体的状态是什么；<br>        步骤：<br>            1）设定一个搜索步数阈值；<br>            2）使用爬山法，但是返回的不是当前估值最好的节点，而是必须返回满足全局最优的节点；<br>            3）如果不是全局最优，则继续搜索；<br>            4）超过搜索步数则随机重置初始状态；<br>    完备性：<br>        完备性在概率上接近1，因为理论上总会随机到最优解作为初始状态；</p><p>局部搜索算法3：模拟退火算法<br>    物理背景：<br>        1）学习的冶金学中金属加热-冷却的过程，模拟了物理退火的过程；<br>        2）加热、等温、冷却；<br>        3）<br>    基本思想：<br>        1）与前面两种相同，属于一种贪心的算法，只是在搜索过程中引入了随机因素，迭代更新的时候会以一定的概率接受一个比当前解更差的解，因此有希望跳出局部最优，到达全局最优；<br>        如图所示：<img src="/Intro-of-AI/p3.png" alt="模拟退火算法"><br>    具体过程：<br>        1）初始化：初始温度t0，初始状态s0，全局轮次k；<br>        2）状态产生函数，产生新状态<br>        3）状态接受函数，判断是否接受新状态；<br>        4）抽样稳定准则，判断是否退温；<br>            是则进入5）；<br>            否则回到2）；<br>        5）适当退温，更新t，k&#x3D;k+1；<br>        6）算法终止准则，判断是否终止；<br>            是则终止；<br>            &#x2F;&#x2F;或许可以记录过程中的最好状态，最后返回，尽管这里没提到；<br>            否则回到2）；<br>    关键点：<br>        三函数+两准则+初温：<br>            1）代价函数 or 目标函数C<br>                原则：<br>                    1）代价 or 代价函数，更好的解对应越小，坏的解对应越大；（当然可以更改）；<br>                作用：衡量解的好坏；<br>            2）状态产生函数<br>                原则：产生的候选解可以遍布状态空间；<br>                方法：在当前状态的领域结构用一定概率方式产生新状态；<br>            3）状态接受函数：<br>                原则：<br>                    1）固定温度下，接受好的解的概率更大；<br>                    2）随温度下降，接受坏的解的概率下降；<br>                    3）当温度接近0，只能接受更好的解；<br>                方法：<br>                    通常采用$min[1,exp(-\Delta C&#x2F;t)]$；<br>                    1）对于好的新状态，该函数值为1，必定会接受；<br>                    2）对于坏的新状态，t较大时，该函数值在0～1之间，以概率值接受；<br>                    3）当t较小时，对于好的新状态函数值为1，必定会接受；坏的新状态，函数值接近0，基本不会接受；<br>                具体使用：<br>                    if $min[1,exp(\Delta C&#x2F;t)] &gt; rand(0,1)$:<br>                        s &#x3D; si;&#x2F;&#x2F;新状态；<br>            4）抽样稳定准则（内循环终止准则）：<br>                常用方法：<br>                    1）检验目标函数均值是否稳定；<br>                    （可能需要维护一个目标函数均值，在状态变化的时候不不断更新）；<br>                    2）连续若干步的目标值变化较小；<br>                    （可能需要记录状态变化时的目标值变化）<br>                    3）按一定的步数抽样；<br>                    （这种就类似给内循环设置次数？）<br>            5）外循环终止准则：<br>                常用方法：<br>                    1）设置终止温度阈值，低到一定值；<br>                    2）设置外循环迭代次数；<br>                    3）算法搜索到的最优值连续若干步保持不变；<br>                    4）概率分析？<br>            6）初温设置：<br>                常用方法：<br>                    1）均匀抽样一组状态，用状态的目标值C到方差作为初温；<br>                    2）随机产生一组状态，计算两两状态间的目标值差的最大值，根据差值利用一定函数确定初温；<br>                    3）利用经验公式；<br>        物理学背景：<br>            1）在温度T，分子停留在状态r满足玻尔兹曼概率，这意味着同一温度下，分子停留在能量小的状态比停留在能量大的状态概率更大；<br>            <img src="/Intro-of-AI/p4.png" alt="模拟退火物理学背景公式"><br>            2）从这种概率关系下，引出了Metropolis准则——“以一定概率接受新的状态”</p><p>局部性搜索算法4：遗传算法</p><h2 id="ch5：不确定性推理"><a href="#ch5：不确定性推理" class="headerlink" title="ch5：不确定性推理"></a>ch5：不确定性推理</h2><p>不确定性推理：<br>    含义：<br>        从不确定的初始证据出发，运用不确定的知识，最终推出以某种不确定度成立的结论的过程；<br>    不确定环境：<br>        不确定性推理进行的环境；<br>        包括：<br>            证据不确定：<br>                证据是初始证据或推出的证据；<br>                不确定性：<br>                    歧义性、不完全性、不精确性、随机性、不一致性；<br>            规则不确定：<br>                规则是启发类的知识，描述由已有的证据可以推得的结论；<br>                不确定性：<br>                    证据组合、规则自身、结论；<br>    推理不确定的体现：<br>        知识不确定性的动态积累和传播；<br>    一个关键的问题：<br>        如何计算不确定程度（不确定度）<strong>定量的对不确定性进行描述，这是本章展开的关键</strong>；</p><p>贝叶斯决策论：<br>    一种使用概率框架进行决策的不确定推理工具；<br>    作用：<br>        针对分类问题，在所有概率已知的理想情况，贝叶斯决策考虑如何基于这些概率和误判损失来选择最优的类别标记；<br>    问题的形式化描述：<br>        1）$N$种类别标记：$y &#x3D; {c_1,c_2,\dots,c_n}$；<br>        2）误判损失（将$c_j$判为$c_i$）：$\lambda_{ij}$；<br>        3）后验概率：$P(c_i|x)$<br>        （对于一个具体的样本，其属于一个类的概率）<br>        4）条件风险（将样本x分类为$c_i$的期望损失）：<br>            $R(c_i|x) &#x3D; \sum_{j&#x3D;1}^N \lambda{ij} P(c_j|x)$；<br>            （简单理解就是，该样本有概率是1～N中的任意一类，但是现在分类为$c_i$，必然要承担相应的损失）<br>        5）目标：<br>            找到判定准则：<br>                $h:X\rightarrow Y$；<br>            使得总体风险最小：<br>                $argmin_{h} E_x[R(h(x)|x)]$；<br>            （实际上就是最小化对于样本x这一随机变量的随机变量函数——条件风险的期望）<br>    贝叶斯最优分类器：<br>        用来实现贝叶斯决策论目标的工具；<br>        贝叶斯判定准则：<br>            内容：为了最小化总体风险，只需要在每个样本上选择那个能使条件风险$R(c|x)$最小的类别标签；<br>            形式化描述：<br>                即对样本x，其标签应该是：<br>                $h^* &#x3D; argmin_{c\in y} R(c|x)$；<br>        注意：<br>        1）满足贝叶斯判定准则的分类器即<strong>贝叶斯最优分类器</strong>；<br>        2）此时总体风险称为<strong>贝叶斯风险</strong>；<br>        3）贝叶斯风险能够表征模型的最好性能，是机器学习的理论上限；<br>        （<em><em>1 - R(h</em>)是这里的3）的描述，但是应该不太准确？</em><em>）<br>    问题转换：<br>        一个具体的情况：<br>            $\lambda{ij} &#x3D; 0 if:i&#x3D;j;else:lambda{ij} &#x3D; 1$；<br>            （没有误判的时候不存在损失，其他情况损失都是1）<br>        这时条件风险为：<br>            $R(c|x) &#x3D; 1 - P(c|x)$；<br>        此时贝叶斯最优分类器对于样本x：<br>            给出的标签满足：<br>                $h^</em>(x) &#x3D; argmax_{c \in y}P(c|x)$；<br>            注意：<br>                1）简单来说，我们选择的标签是要让后验概率最大的标签；<br>        注意：<br>            1）这种情况下，贝叶斯最优分类器称为<strong>贝叶斯最小化错误率分类器</strong><br>            2）问题的关键被转换到了关注如何选择一个<strong>后验概率</strong>更大的标签上；<br>    后验概率：<br>        定义：<br>            想要清晰的理解它比较困难，这是随着统计学的演进逐渐被明确的概念，属于现代统计学奠基石部分的概念；<br>            于是简单放一个参考在这里<img src="/Intro-of-AI/p5.png" alt="后验概率"><br>        简单理解：<br>            先验概率：<br>                “先”于证据的概率。它是基于历史数据、长期经验或领域知识，在获得当前观测证据之前，对事件发生可能性的一般性估计。它代表了我们的初始信念。<br>            （<strong>先验概率可以直接按照频率估计</strong>）<br>            后验概率：<br>                “后”于证据的概率。它是我们在获得了特定观测数据x之后，利用<strong>贝叶斯定理</strong>对先验概率进行更新后得到的概率。它代表了结合新证据后，我们对事件发生的修正信念。<br>            后验概率是在先验概率与实验数据的基础上，由贝叶斯定理导出的概率；<br>    机器学习的目标：<br>        在现实中后验概率是无法直接得出的，机器学习实际上要做的就是基于有限的样本尽可能准确地估计出后验概率；</p><p>估计后验概率从而实现分类的两种策略模型：<br>    判别式模型：<br>        1）给定x，通过直接建模$p(c|x)$来预测c；<br>        eg：决策树、BP神经网络、支持向量机<br>        （分类的结果，对于一个样本，通常就是其属于各个类别的概率，然后取概率最大的）<br>    生成式模型：<br>        1）先对<strong>联合概率分布</strong>P(x,c)进行建模，再由条件概率的定义得到后验概率：$P(c|x) &#x3D; \frac{P(x,c)}{P(x)}$</p><p>基于生成式模型的问题转换：<br>    我们知道后验概率：$P(c|x) &#x3D; \frac{P(x,c)}{P(x)}$<br>    贝叶斯定理：$P(c|x) &#x3D; \frac{P(x|c)P(c)}{P(x)}$<br>        1）其中$P(c)$是先验概率，可通过各类别出现的频率估计（大数定理）<br>        2）$P(x)$是证据因子，样本、实现现象，与类标记c无关；<br>        3）$P(x|c)$是类c中出现样本x的<strong>类条件概率</strong>；<br>        （先确定了一个类别，其中出现一个具体的样本的概率）<br>    问题转换：<br>        如何估计<strong>类条件概率</strong>：$P(x|c)$；</p><p>极大似然估计：<br>    作用：估计类条件概率的常用策略；<br>    思想：<br>        假定类条件概率具有某种确定的概率分布形式，基于训练样本对概率分布参数进行估计；<br>    问题转换：<br>        假设$P(x|c)$具有确定形式，被参数$\theta_c$唯一确定，我们的任务就是要使用训练集$D$估计参数$\theta_c$；<br>        （概率模型的训练过程就是参数的估计过程）</p><p>估计确定类条件概率的参数：<br>    频率主义学派的思想：<br>        参数虽然未知，但是存在客观值，可以通过优化似然函数等准则来确定参数；<br>    具体的做法：<br>        $\hat{\theta}<em>c &#x3D; argmax</em>{\theta_c} LL(\theta_c)$<br>        其中：<br>            1）$LL(\theta_c) &#x3D; \log P(D_c|\theta_c) &#x3D; \sum_{x \in D_c} \log P(x|\theta_c)$<br>            2）训练集中第c类样本的一个子集$D_c$<br>            3）假设集合中的样本是独立的，原本的式子是：<br>                $P(D_c|\theta_c) &#x3D; \prod_{x\in D_C}P(x|\theta_c)$；<br>            4）为了避免连乘溢出，所以改为了对数似然；<br>            5）实际上就是<strong>我们通过实验找到了这么多的样本，那么就应该尽量让参数接近使得这种情况出现的概率较大的情况</strong><br>            （枪响了，兔子死了，很大概率是枪打死了兔子）<br>    eg：<br>        <img src="/Intro-of-AI/p6.png" alt="极大似然估计例子"><br>    贝叶斯学派的思想：<br>        认为参数是未观察到的随机变量、其本身也可由分布，因此可假定参数服从一个先验分布，然后基于观测到的数据计算参数的后验分布。<br>    <strong>最终使用(生成式模型，类条件概率)<strong>：<br>        1）我们现在有很多样本x以及对应的标签c；<br>        2）那么对于标签c的类条件概率P(x|c)可以使用极大似然进行估计；<br>        （</strong>这两步就类似于在对分类器进行训练</strong>）<br>        3）从而我们可以对于一个新来的样本x，按照P(x|c)的参数表达式进行计算；<br>        4）进一步可以估计后验概率P(c|x)；<br>        5）对于新来的样本x，考虑所有标签，分别按照上述步骤计算后验概率，选择后验概率最大的对应的标签；</p><p>朴素贝叶斯分类器：<br>    含义：基于类条件概率和属性条件独立性假设的贝叶斯最优分类器；<br>    目标：<br>        1）与贝叶斯最优分类器一样；<br>        2）满足分类结果让后验概率最大（总体风险最小）的分类器；<br>    属性条件独立性假设：<br>        每个属性独立地对分类结果发生影响；<br>    方法：<br>        1）基于类条件概率和贝叶斯定理可以将后验概率展开；<br>        2）使用属性条件独立性假设，将类条件概率展开为属性条件概率；<br>    具体表达式：<br>        $P(c|x) &#x3D; \frac{P(c)}{P(x)} P(x|c)$；<br>        进一步：$\frac{P(c)}{P(x)} \prod_{i&#x3D;1}^d P(x_i|c)$；<br>        其中：<br>            1）后验概率、先验概率、类条件概率，不多赘述；<br>            2）$P(x_i|c)$ 是属性条件概率，即对于该类，出现了一个具体属性的概率；<br>            3）$x$是具体的样本，$x_i$是它的一个属性，一共有d个属性；<br>    最终的分类器：<br>        分类结果对于所有样本x，得到的标签c满足如下表达式的分类器，就是贝叶斯朴素分类器：<br>        $h_{nb}(x) &#x3D; argmax_{c\in y} P(c)\prod_{i&#x3D;1}^d P(x_i|c)$；<br>        注意：<br>            1）去掉了后验概率展开为属性条件概率的式子中的$P(x)$，因为无论是否考虑它，优化都是等价的；<br>    属性条件概率的计算：<br>        1）离散属性：使用频率直接进行估计；<br>            eg：<img src="/Intro-of-AI/p7.png" alt="离散属性条件概率的计算">;<br>        2）连续属性计算：按照分布进行计算；（当然，分布参数又可以按照类条件概率的估计那样，使用极大似然法进行计算）<br>            eg：<img src="/Intro-of-AI/p8.png" alt="连续属性条件概率的计算">;<br>    <strong>最终的使用(朴素贝叶斯分类器)</strong><br>        1）对于已有的样本x，以及其对应的标签c；<br>        2）使用已有所有样本的属性xi，以及对应的标签c，计算：<br>            1）离散属性条件概率（直接按照频率进行计算）；<br>            2）估计连续属性条件概率的概率分布（或许可以用极大似然）；<br>        （<strong>对于朴素贝叶斯分类器的训练</strong>）<br>        3）对于新来的样本x；<br>        4）考虑样本属于类别c<br>            按照前面计算的离散属性条件（属性属于该类别）概率，设置其新样本各离散属性的条件概率（对应相等）；<br>            按照前面估计的连续属性概率分布，将新样本的连续属性带入概率分布表达式，计算出连续属性条件概率；<br>        5）根据计算出的所有属性条件概率，计算类别c对应的后验概率；<br>        6）按照上面3～5的步骤，考虑所有的类别，取后验概率最大的类别作为该样本x的类别；</p><p>拉普拉斯修正：<br>    目的：<br>        修正先验概率和离散属性条件概率的计算；<br>    背景：<br>        若某个属性值在训练集中没有与某个类同时出现过，则直接计算会出现问题，比如“敲声&#x3D;清脆”测试例，训练集中没有该样例，因此连乘式计算的概率值为0，无论其他属性上明显像好瓜，分类结果都是“好瓜&#x3D;否”，这显然不合理。<br>    修正方法：<br>        1）类先验概率：$\hat{P(c)} &#x3D; \frac{|D_c|+1}{|D|+N}$；<br>        2）离散属性条件概率：$\hat{P}(x_i|c) &#x3D; \frac{|D_{c,x_i}|+1}{|D|+N_i}$；<br>        其中：<br>        1）$|D_c|$是数据集中类别c对数据数量；<br>        2）$|D|$是所有数据的数量；<br>        3）$N$是所有可能的类别数量；<br>        4）$N_i$是属性i所有可能的取值数量；</p><p>贝叶斯网络：<br>    含义：<br>        1）结点间增加了连接强度的因果关系网；<br>        2）贝叶斯网络&#x3D;网络结构+CPT<br>    其中：<br>        1）连接强度对应的是条件概率；<br>            eg：<br>                1）$P(B|A)$：A到B到连接强度；<br>                2）$P(B|AC)$：A、C对B到联合作用；<br>        2）CPT：条件概率表；<br>    一个贝叶斯网络的例子：<br>        <img src="/Intro-of-AI/p9.png" alt="贝叶斯网络"><br>    贝叶斯网络的性质：<br>        条件独立：<br>            含义：有结点A、B和C，若 P(A|BC) &#x3D; P(A|B)，则称A和C在B条件下独立、A在B条件下独立于C，或A和C关于B独立。<br>        几种典型的条件独立情况：<br>            1）串行连接：如图，B确定的时候，A与C关于B条件独立；<br>            <img src="/Intro-of-AI/p10.png" alt="串行连接"><br>            2）分叉连接：如图，给定父节点确定的时候，各子节点条件独立；<br>            <img src="/Intro-of-AI/p11.png" alt="分叉连接"><br>            3）汇集连接：如图，后继节点<strong>不确定</strong>的时候，同一后继的前驱节点间条件独立；（<strong>即使后继节点的再后继的某个结点确定，前驱节点就不独立了</strong>）<br>            <img src="/Intro-of-AI/p12.png" alt="汇集连接"><br>    贝叶斯网络常见的推理模式：<br>        1）因果推理：已知父节点，计算子节点的条件概率；<br>        （在父节点确定了，子节点出现某种状态的概率）<br>        2）诊断推理：已知一个子节点，计算父节点的条件概率；<br>        （子节点确定了，计算父亲节点出现某种状态的概率）<br>        3）辩解推理：已知父节点和子节点，计算其他父节点的条件概率；<br>        （后继节点以及一个前驱节点确定了，计算该后继节点的另一个前驱节点出现某种状态的概率）<br>    注意：<br>        1）<strong>贝叶斯网络不允许包含因果循环</strong>；<br>        2）在这些推理的过程中，可以使用条件概率的一系列性质，来计算出需要推理访问的节点的状态；</p><h2 id="机器学习概述"><a href="#机器学习概述" class="headerlink" title="机器学习概述"></a>机器学习概述</h2><p>机器学习：<br>    定义：用机器来模拟人类学习活动，本质是要从大量数据中学习到隐藏的模式，最终要用这种模式对新的样本进行判别和预测；<br>    不同流派：<br>        1）符号主义：用符号、规则和逻辑来表征知识进行推理；<br>        2）贝叶斯派：基于贝叶斯定理；<br>        3）连接主义：神经网络；<br>        4）进化主义：用计算机模拟进化过程；<br>        5）行为类推主义：根据约束条件来优化函数；<br>    目标：<br>        预测事物；</p><p>基本概念：<br>    特征：<br>        特征变量：用来描述问题一种性质的属性；<br>        属性值：特征变量的一个具体取值；<br>        特征向量：由多个特征变量组成的，用来描述问题对象的整体性质；<br>        特征空间：变量组成的空间；<br>    数据集合：<br>        样本空间：特征空间中的一组示例；<br>            记法：$D &#x3D; {x_1,x_2,\dots,x_m}$；<br>        标记空间：标签变量or预测变量的取值集合；<br>            记法：$Y$；<br>        样例集合：特征向量（样本）与标签变量对集合；<br>            记法：$D &#x3D; {(x_1,y_1),(x_2,y_2),\dots,(x_m,y_m)}$；<br>        数据集：<br>            用于训练的样例构成的集合，是样例集合的子集；<br>        测试集：<br>            用来对学习到的模型进行检测的样例构成的集合，是样例集合的子集；<br>    常见的学习任务：<br>        1）分类；<br>            1）Y是离散值；<br>            2）常见二分类、多分类；<br>        2）回归；<br>            1）Y是连续值；<br>            2）目标是预测；<br>        3）聚类；<br>            1）无监督学习（1、2是有监督），没有Y信息；<br>        4）强化学习；<br>            1）通过与环境交互逐步学习；<br>        5）泛化能力；<br>            1）考量学习结果对新样本的适应能力（本质就是对样本空间的描述能力，ps不是对样例空间）<br>    假设空间：<br>        机器学习的结果是一个<strong>从样本空间到标记空间的映射</strong>，所有可能映射的集合是假设空间；<br>        记法：$H,s.t.f:G\rightarrow H,f\in H$；<br>    版本空间：<br>        假设空间的一个子集，<strong>与训练样例一致</strong>的所有假设的集合；（这里的假设就是映射）；<br>    归纳偏好：<br>        在机器学习算法学习中，可能有多种假设均满足训练样例，但是具体的算法会偏好于其中一个；<br>            1）奥卡姆剃刀：当有多个假设与观察结果一致的时候，选择最简单的那个；<br>            2）NFL定理：总误差与算法无关，不可能找到一个适用于所有场景的算法，具体的问题选择具体的算法</p><p>机器学习的基本流程：<br>    1）定义分析目标；<br>    2）收集数据；<br>    3）数据预处理；<br>        数据中可能存在噪声、不一致、异常等问题，需要数据清洗；<br>    4）数据建模；<br>        算法本身没有绝对的好坏，不同算法有各自适用的范围（NFL定理）<br>    5）模型训练；<br>    6）模型评估；<br>    7）模型应用；</p><p>模型评估：<br>    目标：评估机器学习结果在多大程度上能够帮助实现业务目标，量化相关评估结果；<br>    常用量化指标：<br>    （注意：<strong>这些指标没有明确说明的，默认是在测试集上的表现</strong>）<br>        错误率：<br>            1）分类错误的样例占样例总数；<br>            2）$E &#x3D; a&#x2F;m$；<br>        精度：<br>            1）$acc &#x3D; 1 - E$；<br>        误差：预测输出与真实情况的差异<br>            1）训练误差（经验误差）：在训练集上的误差；<br>            2）泛化误差：在测试集（新样本）上的误差；<br>    常见问题：<br>        1）过拟合，过度学习了训练样例中的细节特征，导致泛化能力下降；<br>            eg：认为必须边缘有锯齿的才是树叶；<br>        2）欠拟合，没有充分学习到训练样例的特征，导致泛化能力下降；<br>            eg：认为绿色的大树也是树叶；<br>    训练集与测试集的划分：<br>        1）留出法：<br>            1）直接讲数据集D拆分为两个互斥的集合，其中S是训练集，T是测试集；<br>            2）$D &#x3D; S \cap T$；<br>        2）交叉验证：<br>            1）按照一定的分布规律，将数据集D依次排列为互斥子集；<br>            2）几个互斥的子集组成一组，其中有训练集和测试集；<br>        3）自助法；<br>            1）直接从原始的数据集中自助采样样例，生成训练集；<br>            2）注意采样之后会放回，所以一个样本m可能被多次采到；<br>            3）某个样本永远不会被采到的概率是$1&#x2F;e$；（等概率采样）；<br>    参数调优：<br>        一些算法中存在人为设置的超参数，需要手动进行调节；<br>    针对分类问题性能度量：<br>        已知：<br>            1）数据集 $D &#x3D; {(x_1,y_1),(x_2,y_2),\dots,(x_m,y_m)}$；<br>            2）机器学习器 $f:y &#x3D; f(x)$；<br>        性能度量：<br>            1）错误率：$E(f,D) &#x3D; \frac{1}{m} \sum \textbf{1}_{f(x_i)\ne y_i}$<br>            2）精度：$acc(f,D) &#x3D; 1 - E(f,D)$；<br>            3）混淆矩阵：<br>                1）从二分类问题出发，样例的标签有正例、反例；<br>                2）根据<strong>预测</strong>的正反情况与<strong>实际</strong>的正反情况，我们给出基本混淆矩阵的元素；<br>                    1）TP：真正，预测正确，为正例；<br>                    2）FN：假反，预测为反，实际为正；<br>                    3）TN：真反，预测正确，为反例；<br>                    4）FP：假真，预测为正，实际为反；<br>                3）元素名称规律：<br>                    1）T&#x2F;F，代表预测的正确&#x2F;错误；<br>                    2）P&#x2F;N，代表预测结果为正&#x2F;反；<br>                    （组合起来当然也可以推断实际结果）；<br>            4）查准率（precision 准确率）：<br>                1）预测为正的，有多少正确；<br>                2）$P &#x3D; TP&#x2F;(TP+FP)$；<br>                3）理解：声称找到的好东西，里面有多少是真的；<br>                4）eg：邮件过滤通常追求查准率，FP越大代表实际上为垃圾邮件但被判断为重要邮件的数量越大，惩罚越大；（追求准确，宁缺毋滥）<br>            5）查全率（recall 召回率）：<br>                1）实际为正的，有多少被我们预测到了；<br>                2）$R &#x3D; TP&#x2F;(TP+FN)$；<br>                3）理解：对于所有的好东西，你找到了多少；<br>                4）eg：疾病诊断通常追求查全率，FN越大代表实际上有病但是被诊断为每有病的数量越大，惩罚越大；（追求全面，宁可错杀）<br>            5）平衡指标：<br>                F1:<br>                    1）查准率和查全率的调和平均；<br>                    2）$F_1 &#x3D; \frac{2PR}{P+R}$；<br>                    3）当P、R均较高时F1会较高；当P、R偏差较大时F1较小，当P、R均较小时F1较小，用来施加惩罚；<br>                $F_\beta$:<br>                    1）查准率与查全率的加权调和平均；<br>                    2）$F_\beta &#x3D; \farc{(1+\beta^2)PR}{\beta^2 P + R}$<br>                    3）通常设置：<br>                        1）$\beta &#x3D; 1$ 平衡；<br>                        2）$\beta &#x3D; 2$ 重视查全率；<br>                        3）$\beta &#x3D; 0.5$ 重视查准率；</p><p>混淆矩阵补充：</p><table><thead><tr><th>实际 \ 预测</th><th>预测为正类</th><th>预测为负类</th></tr></thead><tbody><tr><td>实际为正类</td><td>TP</td><td>FN</td></tr><tr><td>实际为负类</td><td>FP</td><td>TN</td></tr></tbody></table><p><code>重要点：常用评价指标（分类正确率、回归均方误差、acc、auc、二维表格对应几个指标）</code></p><h2 id="ch7：监督学习-决策树"><a href="#ch7：监督学习-决策树" class="headerlink" title="ch7：监督学习-决策树"></a>ch7：监督学习-决策树</h2><p><code>重点？决策树的基本思想、算法过程</code></p><p>决策树的基本思想：<br>    1）决策树通过把数据样本分配到某个叶子结点来确定数据集中样本所属的分类</p><p>决策树的算法过程：<br>    1）从决策树根结点出发，自顶向下移动，<strong>在每个决策结点都会进行一次划分</strong>，通过划分的结果将样本进行分类，导致不同的分支，最后到达个叶子结点，这个过程就是利用决策树进行分类的过程；</p><p>决策树的基本结构：<br>    1）决策结点表示在样本的<strong>一个属性上进行的划分</strong>；<br>    2）分支表示对于决策结点进行划分的输出；<br>    3）叶结点代表经过分支到达的分类结果；</p><p>ID3算法：<br>    分支处理：<br>        1）分支属性 选择：对决策节点上选择哪一个属性来对数据集进行划分；<br>        2）分类属性 标签 计算信息熵以及影响算法是否终止<br>            选取原则：<br>                1）要求每个分支中样本的类别纯度尽可能高；<br>                2）不要产生样本数量太少的分支；<br>        2）衡量指标：<br>            信息熵：度量样本纯度的指标<br>            <img src="/Intro-of-AI/p17.png" alt="信息熵"><br>            (<strong>公式与作用</strong>)<br>    算法流程：<br>        1）计算当前分支节点信息熵；<br>        2）选择分支属性，得到当前分支节点的子节点（分支节点）；<br>        3）计算各个子分支节点的信息熵加权和，权重是样本的数量；<br>        4）直到得到的分支节点只有一类标签，则得到了一个叶节点，该标签就是这个叶节点对应的标签；<br>        （or 达到了要求的分类条件：深度限制、样本数量较少，如果此时还有多类标签，则取样本数量最多的标签为对应的标签）；<br>    注意：<br>        ID3算法在完成一次根据某个分支属性进行分类之后，在分支节点中（对应自己的样本集合），再次进行划分，<strong>各个分支节点是独立不相互影响</strong>，即再次考虑信息熵增益最大的时候只需要考虑各个分支节点，自己再次划分的时候信息熵增益最大（<strong>此时对应信息熵计算使用的样本集合D就是分支节点所具有的全部样本组成的</strong>）。</p><p>扩展算法的基本思想<br>    1）C4.5算法：使用信息增益率代替信息增益作为划分度量，解决ID3算法往往选择取值较多的分支属性的情况；<br>    <img src="/Intro-of-AI/p18.png" alt="C4.5">（注意图中的例子）；<br>    2）CART算法：二分循环切割，无论选择什么分支属性，都<strong>只分出两个分支</strong>，即构建二叉树；如果分支属性取值不止两个的话，就进行一些组合，最后保留两个组合；使用的是<strong>Gini指数</strong>；<br>    <img src="/Intro-of-AI/p19.png" alt="CART">（注意例子）；</p><h2 id="ch8：监督学习-支持向量机"><a href="#ch8：监督学习-支持向量机" class="headerlink" title="ch8：监督学习-支持向量机"></a>ch8：监督学习-支持向量机</h2><p><code>重点？</code><br><code>注意这一节不只涉及支持向量机</code></p><p>重要点：<br>    线性回归：<br>        最小二乘法存在闭式解<br>    支持向量机：<br>        大间隔<br>        核函数（四种核函数，不知道该用什么的一般用高斯核函数，sigmod核函数使用比较少）<br>    KNN算法：<br>        多数表决，由输入的k个近邻训练实例多数所属的类来决定</p><h2 id="ch9：无监督学习-聚类"><a href="#ch9：无监督学习-聚类" class="headerlink" title="ch9：无监督学习-聚类"></a>ch9：无监督学习-聚类</h2><p>无监督学习：<br>    含义：在没有标签（标注）的样本上进行的学习；<br>    最常用的方法：聚类；</p><p>聚类：<br>    目标：<br>        1）将数据样本划分为若干个不相交（通常）的“簇”（Cluster）<br>        2）簇内样本的相似度尽可能的高，簇间样本的相似度尽可能的低；<br>        3）簇内样本与中心的距离尽可能的小，簇间的距离尽可能的大；<br>    一些基本概念：<br>        衡量指标：<br>            外部指标：<br>                使用事先指定的聚类模型作为参考来评判聚类结果的好坏；<br>            内部指标：<br>                不依赖于任何外部知识，只使用参与聚类的样本来评判聚类结果的好坏；<br>        簇的属性：<br>            作用：用来对簇的一些性质进行描述；<br>            1）聚类中心：簇中所有样本的均值（质心）；<br>            2）簇大小：簇中含有样本的数量；<br>            3）簇密度：簇中样本的紧密程度；<br>            4）簇描述：簇中样本的业务特征；</p><p>聚类的常见外部指标：<br>    情景：对于含有n个样本点的数据集S，其中的两个不同样本点(xi,xj)，假设C是聚类算法给出的簇划分结果，P是外部参考模型给出的簇划分结果。对于(xi,xj)样本点来说，存在以下四种关系：<br>        1）SS，在结果C、P中(xi,xj)在相同的簇中；<br>        2）SD，在结果C中(xi,xj)在相同的簇中，在结果P中不在相同的簇中；<br>        3）DS，在结果C中不在相同的簇中，在结果P中在相同的簇中；<br>        4）DD，在结果C中不在相同的簇中，在结果P中不在相同的簇中；<br>    四种关系的数量关系：<br>        客观事实：对于任意两个不同的样本(xi,xj)，它们一定只能满足SS&#x2F;SD&#x2F;DS&#x2F;DD四种关系中的一种；<br>        假设：对应令四种关系成立的样本数量对为a、b、c、d；<br>        关系：$a+b+c+d &#x3D; C_n^2$（实际上就是样本对的数量）；<br>    在四种关系的数量关系之上建立的外部指标：<br>        1）Rand统计量：<br>            英文术语：R-Statistc<br>            公式：$R &#x3D; \frac{a+d}{a+b+c+d}$；<br>            含义：？<br>        2）F值：<br>            英文术语：F-Measure；<br>            公式：$F &#x3D; \frac{(\beta^2 + 1)PR}{\beta^2P + R}$；<br>            含义：<br>                1）P表示准确率$P &#x3D; \frac{a}{a+b}$；<br>                2）R表示召回率$R &#x3D; \frac{a}{a+c}$；<br>                （注意区分召回率和Rand Statistic）；<br>                3）$\beta$是参数，当其为1的时候对应F1-Measure；<br>        3）Jaccard系数：<br>            英文术语：Jaccard Coefficient；<br>            公式：$\frac{a}{a+b+c}$；<br>        4）FM指数：<br>            英文术语：Fowlkes and Mallows Index；<br>            公式：$\sqrt{\frac{a}{a+b} \frac{a}{a+c}}$；<br>        四种外部指标的意义：<br>            这四个度量指标的值越大，表明聚类结果和参考模型直接划分的结果越吻合，聚类结果越好；</p><p>聚类常见的内部指标：<br>    情景：考虑在聚类分析中，对于两个m维的样本xi &#x3D; (xi1,xi2,…,xim)，xj &#x3D; (xj1,xj2,…,xjm)，对于任意两个样本xi，xj，我们可以考虑距离度量；<br>        1）欧几里得距离；<br>        2）曼哈顿距离；<br>        3）切比雪夫距离；<br>        4）明可夫斯基距离；<br>            公式：$dis_{mind} &#x3D; (\sum_{k&#x3D;1}^m |x_{ik} - x_{jk}|^p)^{\frac{1}{p}}$；<br>            注意：<br>                1）这是距离度量的最一般形式；<br>                2）当p &#x3D; 1的时候，即曼哈顿距离；<br>                3）当p &#x3D; 2的时候，即欧几里得距离；<br>                4）当$p \rightarrow \inf$的时候，即切比雪夫记录；<br>    针对距离度量得出的聚类性能度量内部指标：<br>        1）紧密度(CP)：<br>            英文术语：Compactness；<br>            公式：$CP_c &#x3D; \frac{1}{n} \sum_{i&#x3D;1}^n ||x_i - w_c||$；<br>            含义：<br>                1）$w_c$是簇c的聚类中心，可以用样本加和求平均得到；<br>                2）$CP_c$对应的是簇c的紧密度；<br>                3）对于整个聚类结果的紧密度为：<br>                    $CP &#x3D; \frac{1}{n} \sum_i^n CP_i$；<br>                4）这里两个样本的距离使用的曼哈顿距离，也可以用其他距离替换；<br>            意义：<br>                紧密度的值越小，表示簇内样本点的距离越近，簇内样本的相似度越高；<br>        2）分隔度(SP)：<br>            英文术语：Seperation；<br>            公式：$SP &#x3D; \frac{2}{k^2 - k}\sum_{i&#x3D;1}^k\sum_{j&#x3D;i+1}{k} ||c_i - c_j||$；<br>            含义：<br>                1）聚类的结果是k个簇；<br>                2）其中$c_i$对应的是簇i的聚类中心；<br>            意义：<br>                分隔度的值越大，表示各聚类聚类中心相互之间的距离越远，簇间相似度越低，效果越好；<br>        3）戴维森堡丁距离：<br>            作用：衡量任意两个簇的簇内距离和簇间距离之比，求最大值；<br>            意义：DBI的值越小，表示簇内样本之间距离越小，同时簇间距离越大，即簇内相似度高，簇间相似度低，说明聚类结果越好；<br>        4）邓恩指数：<br>            作用：任意两个簇的样本点的最短距离与任意簇中样本点点最大距离之商；<br>            意义：DVI的值越大，表示簇间样本距离越远，簇内样本距离越近，效果越好；<br>        5）意义总结：<br>            1）CP越小越好；<br>            2）SP越大越好；<br>            3）DBI越小越好；<br>            4）DVI越大越好；</p><p>聚类方法一：基于划分的方法<br>    特点：<br>        1）基于划分的方法是最简单、常用的聚类算法；<br>        2）将对象划分为簇进行聚类，每个对象属于且仅属于一个簇；<br>        3）划分追求的结果是，簇间相似度低，簇内相似度高；<br>    常用的基于划分的算法：<br>        1）k-means；<br>        2）k-medoids；<br>        3）k-prototype；<br>    k-means算法：<br>        思想：计算样本点与类簇质心的距离，与类簇质心相近的样本点划分为同一类簇；<br>            1）类簇是指还没有完成最终划分之前的各个簇；<br>            2）常常使用簇中所有样本的均值来表征簇；<br>        算法流程：<br>            1）选取k个类簇，用户指定或随机选取指定k个质心；<br>            2）对剩余样本点，计算到各个质心的欧式距离，将其归入距离最小的质心对应的类簇；<br>            3）每次确定一个样本点所属的类簇，都立刻更新该类簇的质心；<br>            4）所有样本点都划分完毕后，每个簇都有了新的质心；<br>            5）根据新的质心，重新对所有的样本进行划分；<br>            6）重复2～5，直到划分结果基本保持不变，返回结果；<br>        Q：<br>            如何确定划分结果基本保持不变？<br>        优点：<br>            运行效率比较高、容易解释适合高维数据聚类；<br>        缺点：<br>            1）容易局部收敛（贪心策略）；<br>            2）对离群点和噪声点非常敏感；<br>            3）初始聚类中心的选取对算法结果影响很大；<br>            4）不适用于，离散的类别数据；<br>                因为最基础的度量指标是基于距离得到的；<br>                需要做哑变量处理；<br>            5）不适用于非图面形状（非球形）的数据集，尤其是长条形的数据集（结果会与初始目标有非常大的差别）；<br>        注意：<br>            1）变量处理：<br>                离散变量要做哑变量处理，将不能定量处理的变量量化；<br>                原始数据要做标准化处理（防止量纲带来的影响）；<br>            2）k值的选择：<br>                即最终结果应该聚为几个类，这是人为确定的；<br>                通常可以：<br>                    1）使用层次聚类法得到初始的k值，以及初始的簇中心；<br>                    2）使用系统演化的方法；<br>    k-means++算法：<br>        思想：为了克服k-means结果依赖于初始类簇的选择，而提出的；<br>        算法流程：<br>            1）从样本集合中随机选择一个样本点ci，作为第1个聚类中心；<br>            2）计算其他样本点x到“已有的，最近的聚类中心的距离”，d(x)；<br>            3）以概率$\frac{d(x)}{\sum_i^n d(x)}$选择x作为新的聚类中心；（概率越大被选中概率越大）；<br>            4）重复2～3，直到选出k个聚类中心；<br>            5）使用这k个聚类中心，进行k-means算法；</p><p>聚类方法二：基于层次聚类<br>    BIRCH算法<br>    CURE算法</p><p>聚类方法三：基于密度聚类<br>    思想：<br>        将样本中的高密度区域（样本点分布稠密的区域）划分为簇，将簇看作样本空间中被稀疏区域（or 噪声）分隔开的稠密区域；<br>    优点：<br>        基于样本分布的稠密程度进行聚类，可以克服基于划分&#x2F;层次的聚类方法通常智能用于挖掘球状簇的问题；<br>    DBSCAN算法<br>        ？<br>    OPTICS算法<br>        优点：改进了DBSCAN，降低了其对于输入参数的敏感程度；<br>    DENCLUE算法<br>        优点：综合了基于划分、层次、密度的方法；</p><p>聚类方法四：基于网格聚类（了解）</p><p>聚类方法五：基于模型聚类（了解）</p><p><code>聚类模型前三个比较重要（划分、层次、密度），k-means很重要，CF-tree很重要（构建CF-tree，更新CF-tree），BIRTCH方法很重要、CURE算法知道即可、基于密度聚类很重要</code>   </p><h2 id="ch10：神经网络模型"><a href="#ch10：神经网络模型" class="headerlink" title="ch10：神经网络模型"></a>ch10：神经网络模型</h2><p><code>前馈神经网络是我们学习的重点，神经网络的结构，怎样使用</code>；<br><code>前向过程，评价指标：回归（最小二乘法）/分类（交叉熵）</code></p><p>神经网络：<br>    人工神经网络的思想：<br>        由简单神经元经过相互连接形成网络结构，通过调节各个连接的权重值来改变连接的强度，进而实现感知和判断；<br>    基本分类：<br>        1）前馈神经网络；<br>        2）反馈神经网络；<br>        3）自组织神经网络；<br>    基本概念：<br>        1）激活函数；<br>        2）损失函数；<br>        3）学习率；<br>        etc.</p><p>前馈神经网络：<br>    含义：一种单向多层的网络结构；<br>    （信息层开始，逐层向一个方向传递，直到输出层结束）；<br>    特点：<br>        1）前馈过程中不会调整各层的权重参数；<br>        2）反向传播的时候会将误差向后传递调整权重；<br>            eg：BP算法反向传播，理论上可以逼近任何连续函数；<br>    感知器：一种最简单的前馈神经网络；<br>        构成：<br>            1）可以接收n个输入（n维特征向量）；<br>            2）对应有n个权重值$\omega_i$；<br>            3）偏置项阈值b；（防止溢出？）；<br>            4）激活函数f；<br>            （整个过程就是n个输入根据n个权重，加权求和，最后得到一个值，将其输入激活函数，得到输出）<br>            eg：$y &#x3D; f(x\omega^T+b)$；<br>        作用：<br>            1）用于作为神经元，构造更加复杂的神经网络；<br>            2）如果直接使用可以理解为直线划分；<br>            3）单个感知器甚至不能解决最简单的非线性问题（异或问题）；<br>    BP神经网络<br>        含义；一种具体的前馈神经网络，但是权重值只由反向传播学习算法进行调整；<br>        拓扑结构组成：<br>            1）输入层；<br>            2）隐层；<br>            3）输出层；<br>        激活函数：<br>            1）必须满足处处可导的条件；<br>            eg：sigmoid函数：<br>                1）连续可微，单调递增；<br>                2）输出值在0～1之间；<br>                3）$\sigma(x) &#x3D; \frac{1}{1+e^{-x}}$；<br>            2）可能的问题：梯度消失问题；<br>        eg：<img src="/Intro-of-AI/p13.png" alt="BP神经网络的结构"><br>        BP神经网络训练流程：<br>            1）初始化网络权值和神经网络阈值；<br>            2）前向传播<br>            ？？？</p><h2 id="ch11：深度学习"><a href="#ch11：深度学习" class="headerlink" title="ch11：深度学习"></a>ch11：深度学习</h2><p><code>什么是卷积，怎么卷（运算），什么是循环，怎么做</code></p><p>深度学习与前馈神经网络的区别：<br>    1）传统的BP算法仅有几层网络，需要<strong>手工指定特征</strong>且易出现<strong>局部最优问题</strong>，而深度学习的<strong>层数更多</strong>且引入了<strong>概率生成模型</strong>，可<strong>自动地从训练集提取特征</strong>，解决了手工特征考虑不周的问题，而且<strong>初始化了神经网络权重</strong>，采用反向传播算法进行训练，与BP算法相比取得了很好的效果。<br>    2）特征工程与特征学习：<br>        1）特征工程由人类专家根据现实任务来设计, <strong>特征提取与识别</strong>是分开的两个阶段（传统）；<br>        2）特征学习通过深度学习自动产生有益于分类的特征, 是一个<strong>端到端</strong>的学习框架（深度学习）；<br>    （主要区别：层数更多、自动提取特征端到端）；</p><p>深度学习基本思想与优缺点<br>    idea来源：<br>        1）多层前馈网络有强大的表示能力（”万有逼近性”）；<br>        2）仅需<strong>一个包含足够多神经元的隐层</strong>, 多层前馈神经网络就能以任意精度逼近任意复杂度的连续函数 [Horniket al., 1989]；<br>    于是增加模型复杂度有两种思路：<br>        1）模型宽度：增加隐层神经元的数目；<br>        2）模型深度：增加隐层数目；<br>    深度学习使用的是方法2），而非方法1），原因是？<br>        老师说：层数的增加可以有更多的抽象，层级式的抽象可以升维，带来更好的表示的方式；<br>        deepseek：参数效率与表示效率，这是最核心的理论原因。深度网络可以用指数级更少的神经元（参数）来表示一个复杂函数，而一个浅层网络可能需要指数级更多的神经元。<br>    复杂模型的挑战：<br>        1）梯度消失的问题：深度网络难以直接用经典算法（例如BP算法）进行训练, 因为误差在多隐层内传播时会出现梯度消失问题（即梯度迅速为0），难以收敛到稳定状态<br>    （<strong>这些是理论无法解决的问题，需要trick</strong>）<br>    训练技巧（trick）：<br>        1）<strong>预训练+微调</strong>：预训练阶段，每次训练时将上<strong>一层隐层结点的输出作为输入, 本层隐结点的输出作为输出，仅训练一层网络</strong>；预训练全部完成后，对整个网络进行<strong>微调训练</strong>，一般采用BP算法；<br>        2）<strong>新型激活函数（LeakyReLU）</strong>：求导更容易，缓解梯度消失；<br>        3）<strong>Dropout</strong>：当训练一个深度神经网络时，我们可以随机丢弃一部分神经元以及其对应的连接边；<br>    基本思想：<br>        idea1）+思路2）<br>    缺点：<br>        挑战<br>    优点：<br>        idea 1）</p><p>卷积神经网络的基本思想：<br>    1）启发：卷积神经网络是人工神经网络的一种，由对猫的视觉皮层的研究发展而来，视觉皮层细胞对视觉子空间更敏感，<strong>通过子空间的平铺扫描实现对整个视觉空间的感知。</strong>；</p><p>卷积神经网络特点：<br>    1）优势在于具有共享权值的网络结构和局部感知（也称为稀疏连接）的特点，能够降低神经网络的运算复杂度。<br>    （通过卷积和池化局部<strong>感知能力更强了</strong>）；</p><p>卷积神经网络的结构：<br>    1）输入：卷积层和子采样器提取得到的特征；<br>    2）低层：子采样器和卷积层交替得到的；<br>    3）更高层：全连接层；<br>    4）输出：可以是分类器 or 逻辑回归；</p><p>卷积层：<br>    1）输入；<br>    2）<strong>卷积核</strong>（如何运算）；<br>    3）步长；<br>    4）确定输出维度；<br>    （<strong>注意相关参数影响，输入维度、步长</strong>）<br>eg：<strong>卷积核</strong><br>输入7,7 -&gt; 输出3,3（<strong>要会算这个例子</strong>）<br>1 2 3 4 5 6 7<br>1 2 3<br>    1 2 3<br>        1 2 3<br><img src="/Intro-of-AI/p14.png" alt="卷积层运算过程"></p><p>RNN的基本思想（循环神经网络）<br>    思想：<br>        1）循环神经网络是一种用于<strong>处理序列数据</strong>的神经网络结构，其基本原理在于网络中存在循环连接，使得网络具有记忆能力，能够捕捉时间序列中的依赖关系。<br>        2）RNN不同于前向神经网络，它的层内、层与层之间的信息可以双向传递，更高效地存储信息，利用更复杂的方法来更新规则，通常用于处理信息序列的任务。</p><p>RNN的基本结构<br>    1）RNN主要用来处理序列数据，在传统的神经网络模型中，是从输入层到隐含层再到输出层，每层内的节点之间无连接，<strong>循环神经网络中一个当前神经元的输出与前面的输出也有关</strong>，网络会对前面的信息进行记忆并应用于当前神经元的计算中，<strong>隐藏层之间的节点是有连接的</strong>，并且<strong>隐藏层的输入不仅包含上层的输出还包含上一时刻隐藏层的输出</strong>。<br>    2）公式表示：<br>        $h_t &#x3D; f_w(h_{t-1},x_t)$；<br>        含义：<br>            1）$h_t$：新的目标状态；<br>            2）$h_{t-1}$：前一目标状态；<br>            3）$x_t$：当前输入向量；<br>            4）$f_w$：权重参数函数；<br>    3）图像表示：<br>        <img src="/Intro-of-AI/p15.png" alt="RNN的结构">；</p><p>RNN的每次执行会作为下次执行输入的一部分：<br>    一个RNN可认为是同一网络的多次重复执行，每一次执行的结果是下一次执行的输入。<br>    即输入为：$x_t$以及$W_{s_{t-1}}$<br>    <img src="/Intro-of-AI/p16.png" alt="隐层连接展开">；</p><p>RNN的特点是循环连接和共享参数：<br>    1）循环连接就是隐层节点之间的连接；<br>    2）共享参数是指无论输入序列有多长，使用的都是同一套结构的权重；<br>        W_hh: 连接上一个隐状态 (h_{t-1}) 到 当前隐状态 (h_t) 的权重。<br>        W_xh: 连接当前输入 (x_t) 到 当前隐状态 (h_t) 的权重。<br>        W_hy: 连接当前隐状态 (h_t) 到 当前输出 (o_t) 的权重（如果有输出的话）。</p><p>由于上述特点RNN通常用于处理<strong>序列</strong>式的任务，在图像识别、自然语言处理很好；</p><h2 id="ch12：强化学习"><a href="#ch12：强化学习" class="headerlink" title="ch12：强化学习"></a>ch12：强化学习</h2><p>强化学习与监督学习、无监督学习的区别：<br>    1）任务类型的不同：<br>        监督、无监督学习：预测型任务，预测仅产生信号<strong>不会影响环境</strong>；<br>        强化学习：决策型任务，决策下达到环境会<strong>直接改变环境</strong>；<br>        （序贯决策问题：决策者序贯地一次次做出决策，并不断看到新的观测，直到任务结束）；<br>    2）实现细节的不同：<br>        强化学习与监督学习相比：<strong>不需要事先准备样本集</strong>，而是通过不断尝试发现不同的动作反馈来指导策略学习；<br>        强化学习与无监督学习相比：<strong>不只是探索事物的特征</strong>，而是通过建立与环境的交互到输入输出映射，来找到最优策略；</p><p>强化学习的定义：<br>    强化学习是agent与环境之间进行交互，并将其状态映射到动作以获得<strong>最大累计奖励</strong>，实现最优策略学习机制；</p><p>强化学习的关键要素：<br>    1）状态S：对当前环境的描述；<br>    2）动作A：对智能体采取的行动；<br>    3）策略$pi$：定义在给定状态下的行为准则；<br>    4）策略函数：从当前状态下到该状态下应该采取的行动的映射；<br>    （策略函数通常表示为$\pi_t (a_t|s_t)$表示在给定状态下采取对应行动的<strong>概率分布</strong>）；<br>    5）状态转移：智能体从当前状态在某个动作下转移到下一个状态；<br>    （状态转移概率，表示在当前状态下做出了一个行动后可以转移到的状态的概率分布）；<br>    6）奖励函数：定义了agent可能碰到的有利和不利的情景，用于度量决策的价值；<br>    （agent的长期目标是长期地获得更高的奖励或者最大限度地减小惩罚）；<br>    7）奖励Rt：在一回合中获得的总奖励用R1+R2+…+Rt表示，t是回合的长度；<br>    8）折扣因子：对未来奖励的加权处理；<br>    9）目标：最大化当前时刻t的累计奖励$G_t &#x3D; \sum_{k&#x3D;t}^T gamma^{k-t} r_k(s_k,a_k)$；<br>    （其中$gamma$折扣因子代表了agent的目光短浅程度，当为1时其目光长远，等于0的时候目光浅显只针对当前奖励）；<br>    关键要素的基本思想：<br>        1）价值函数：用来评估不同状态 or 策略的好坏，预估未来的收益期望；<br>        2）状态价值函数：<br>            1）用来度量给定状态的好坏；<br>            2）用V(s)来表示，意味着该状态下的长期收益期望（平均收益）；<br>        3）动作价值函数：<br>            1）用来度量给定状态和策略下，采取某种动作的好坏；<br>            2）用Q(s,a)来表示，也是一个期望值；<br>        4）最优策略：<br>            1）基本思想是最大化最终的累计奖励；<br>            2）$Q^*(s_t,a_t) &#x3D; max_{\pi} Q_{\pi}(s_t,a_t)$；<br>        5）最优动作：<br>            1）在最优策略下某个状态应该采取的最好动作；<br>            2）$a^* &#x3D; argmax_a Q^*(s,a)$；</p><p>强化学习的交互过程：<br>    回合：从开始到结束的试验称为一个回合，开始可以开始于任何位置，结束可能在预期的位置可能在非预期的位置；<br>    一个回合的过程：<br>        对于时刻t：<br>            1）观察到状态st，根据策略$\pi(s_t)$做出决策at；<br>            2）执行动作at，完成状态的转移$s_{t+1}$，获得奖励rt<br>        持续这个过程得到<strong>轨迹trajectory</strong>：<br>            从开始到结束过程中所有的状态、动作、奖励的序列，在每一个时刻：观察状态、执行动作、状态转移&amp;获得奖励；</p><p>强化学习的特点：<br>    1）试错学习： agent与环境交互，每一步通过试错的方式学习最佳决策，没有任何的指导。<br>    2）延迟反馈： agent的试错获得环境的反馈，可能需要等到过程结束才会得到一个反馈。<br>    3）过程性学习：强化学习的训练过程是一个随着时间变化的过程。<br>    4）环节之间的行为相关性：当前的行为影响后续的状态和行为。<br>    5）探索（explore）和利用（exploit）的综合：强化学习开始时agent更偏向于探索，行为具有一定的随机性，尝试多种可能性。训练很多轮后再降低探索的比例。</p><p>强化学习的应用领域：<br>    游戏AI：AlphaGo、AlphaZero、Dota2、星际争霸2；<br>    运动控制：机器人手臂、双足机器人、无人机运动控制、路径规划；<br>    自动驾驶与交通：特斯拉，信号灯优化；<br>    自然语言处理：RL优化生成式对话模型策略，让回答更加的自然；<br>    机器翻译：机器翻译一般使用监督学习，但是可以优化与直接翻译质量相关的评估指标；<br>    文本生成：生成更加连续且有意义的文本；<br>    推荐系统：个性化推荐；<br>    医疗与健康、金融领域；</p><p><code>最后一节课会划重点</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建各种环境的记录</title>
      <link href="/2025/11/02/%E6%90%AD%E5%BB%BA%E5%90%84%E7%A7%8D%E7%8E%AF%E5%A2%83%E7%9A%84%E8%AE%B0%E5%BD%95/"/>
      <url>/2025/11/02/%E6%90%AD%E5%BB%BA%E5%90%84%E7%A7%8D%E7%8E%AF%E5%A2%83%E7%9A%84%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p><code>随着大学课程的进行，每学期总是会被要求搭建各种各样的运行环境，但在学习完成之后通常我不会再用到它们，所以用这篇blog来记录我搭建过的一些环境，简单描述它们的过程，以便我后续能记得我做过哪些改动，从而可以更好地管理我的电脑空间。</code></p><h2 id="default"><a href="#default" class="headerlink" title="default"></a>default</h2><p>我在Mac上安装了命令行工具、Vscode，配置了C&#x2F;C++的基本环境（参照[<a href="https://www.bilibili.com/video/BV1U741157Rd/?spm_id_from=333.1387.favlist.content.click&vd_source=80df09f481ef5f0671e5e0e35d02e33e">bilibili</a>]）</p><p>于是这一部分我想记录一些命令行常用命令</p><ol><li>查看当前目录的大小<code>du -sh .</code>，这个命令会显示磁盘使用情况，包括当前目录以及所有子目录</li></ol><h2 id="搭建hexo（Mac）"><a href="#搭建hexo（Mac）" class="headerlink" title="搭建hexo（Mac）"></a>搭建hexo（Mac）</h2><ol><li>从github上clone了homebrew的仓库</li><li>在用户目录下，修改了.zshrc与.bashrc文件，配置了homebrew在tuna的镜像源</li><li>运行了homebrew仓库的脚本文件，安装了homebrew，另外<strong>仓库中还有卸载用的文件</strong></li><li>使用包管理器homebrew安装了node以及其附带的nmp</li><li>使用nmp为全局配置了hexo环境</li><li>将为win上的blog源码打包，传到Mac上，并使用<code>nmp install</code>，索引到package.json文件，完成了依赖包的安装</li><li>使用git为全局配置了用户名与邮箱</li><li>使用<code>ssh-keygen -t rsa -C 我的邮箱</code>，生成了公私钥，<strong>同时在本地设置了访问该私钥的密码</strong>，相关文件均在用户目录中隐藏，密码同我的Mac密码</li><li>在github我的主页setting中，添加了访问仓库用的公钥</li><li>完成了所有配置，并写下这篇blog，上传到了github</li></ol><h2 id="搭建java环境（Mac）"><a href="#搭建java环境（Mac）" class="headerlink" title="搭建java环境（Mac）"></a>搭建java环境（Mac）</h2><ol><li>在网址<a href="%5Btext%5D(https://www.oracle.com/java/technologies/downloads/#jdk25-mac)">ORACLE</a>，中下载了<strong>ARM64 DMG Installer</strong>，对应的是Mac M系列芯片，jdk25.0.1的安装包（170MB）</li><li>启动安装包，选择安装位置<strong>为所有用户安装</strong>，相关依赖安装在路径&#x2F;Library&#x2F;Java下（300MB左右），可以使用命令<code>/usr/libexec/java_home -V</code>，该命令用于列出所有已安装的jdk版本及路径</li><li>注意由于为选择了为所有用户安装，所以对应依赖谁在系统级的Library下，而非用户级别的Library下</li><li>然后我在Vscode中安装了扩展<strong>Extension Pack for Java</strong>，对应一共为我自动安装了7个扩展项目（30MB左右），在Vscode中点开扩展清空搜索栏，默认会显示已经安装的扩展</li><li>最后我在我的Mac用户目录下创建了<strong>Java_projects</strong>用来存放我的各种java项目，并创建了一个test项目，完成了测试。此外，实际上在运行的时候要依赖于我签名安装的扩展项目中的java run，如果要使用debug的话则依赖于java debug。（但我注意到也可以使用run code运行，这个插件是我前面为了运行C&#x2F;C++而安装的，不过如果使用它运行，它会将为的java源文件先编译成一个.class的文件）</li></ol><h2 id="搭建Vue环境（Mac）"><a href="#搭建Vue环境（Mac）" class="headerlink" title="搭建Vue环境（Mac）"></a>搭建Vue环境（Mac）</h2><ol><li>检查了我的Mac电脑上具有node.js的环境，以及npm的包管理器</li><li>于是我使用npm下载了Vue CLI(一个Vue项目的命令行工具)，使用命令<code>npm install -g @vue/cli</code>，在全局安装了这个命令行工具</li><li>我在用户目录下创建了Vue_projects，用于存放Vue的项目，并在此文件夹下使用<code>vue create test-project</code>创建了一个测试项目，选择了默认配置Vue2;</li><li>在创建Vue项目的时候遇到了提示<code>yesys@MacBookAir Vue_projects % vue create test-project?  Your connection to the default npm registry seems to be slow. Use https://registry.npmmirror.com for faster installation? (Y/n) </code>，提示我使用npm下载包使用的默认源，较慢，建议我切换到镜像源；于是我切换到了<code>https://registry.npmmirror.com</code>，如果要切换回默认源可以使用<code>npm config set registry https://registry.npmjs.org</code></li><li>接下来cd到我的项目目录，并使用<code>npm run serve</code>打开了我的项目，可以使用浏览器，以及本地的端口号<code>http://localhost:8080/</code>进行访问</li><li>后续我可以使用Vscode在项目文件夹下进行开发工作，使用5中运行项目的命令可以实时查看效果；最后如果项目完成了的话可以使用<code>npm run build</code>生成生产版本</li><li>为了在Vscode中进行Vue开发，我安装了Vue(Official)的插件</li><li>注意：使用vue create project—name创建的项目，所有相关依赖都在该项目文件夹下（node_modules中），当然也有创建全局依赖的方法；总之明确这一点可以帮助我管理好空间。</li></ol><h2 id="搭建微信小程序开发环境（Mac）"><a href="#搭建微信小程序开发环境（Mac）" class="headerlink" title="搭建微信小程序开发环境（Mac）"></a>搭建微信小程序开发环境（Mac）</h2><ol><li>我在微信公众平台<a href="https://mp.weixin.qq.com/">WeChat</a>，为我即将开发的小程序注册了一个账号；</li><li>成功注册后进入了小程序发布流程界面，完成了前置的一些信息设置，并根据引导下载了<code>普通小程序开发工具</code>，网址是<a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/stable.html">小程序开发工具下载</a>，下载了<strong>macOS ARM64</strong>的开发工具，dmg文件390.1MB</li><li>我使用dmg文件安装了微信小程序开发app，名为<code>微信开发者工具</code>，并推出了安装器，删除了dmg文件；</li><li>使用开发工具，在我的用户目录下创建了<code>WeChatProjects</code>文件夹以及我的项目文件<code>EasyCN</code>，使用的是基础模版；</li><li>在Vscode中安装了一个名为<code>微信小程序开发工具</code>的扩展，大概200多MB；</li></ol><h2 id="Py环境"><a href="#Py环境" class="headerlink" title="Py环境"></a>Py环境</h2><p>在vsc中安装了py扩展包，大概200MB</p><p><strong>我的mac环境中自带了python3，或许是和系统开发工具一起安装的</strong></p><p>一般的开发流程中需要先配置虚拟环境并手动选择</p><p>配置虚拟环境</p><ol><li>使用vsc命令面板，Python: Create Environment；</li><li>选择Venv，选择python解释器版本，设置环境名称；（或者直接使用终端命令<code>python -m venv env_name</code>）</li><li>选择是否安装requirements文件中的内容（如果有的话，.txt .yaml）等</li><li><code>source env_name/bin/activate</code> 激活虚拟环境（激活环境之后vsc当前语法检测这一项目会显示目前使用的虚拟环境，或者使用命令<code>which python</code>可以直接查看）；</li><li>使用<code>pip install -r requirements.txt</code>安装环境（如果3中没有选择）；</li></ol><p>使用虚拟环境</p><ol><li>创建项目配置文件<code>.vscode/settings.json</code></li><li>添加虚拟环境有关配置如下，其中<code>$&#123;workspaceFolder&#125;</code>会自动指向VSCode中打开的项目目录；</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;python.defaultInterpreterPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;/venv/bin/python&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// Windows用户使用：</span></span><br><span class="line">    <span class="comment">// &quot;python.defaultInterpreterPath&quot;: &quot;$&#123;workspaceFolder&#125;/venv/Scripts/python.exe&quot;,</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 其他有用的Python设置</span></span><br><span class="line">    <span class="attr">&quot;python.terminal.activateEnvironment&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;python.terminal.activateEnvInCurrentTerminal&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;python.analysis.extraPaths&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;./src&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;[python]&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;editor.formatOnSave&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;editor.defaultFormatter&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ms-python.autopep8&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="虚拟环境lx-back-env"><a href="#虚拟环境lx-back-env" class="headerlink" title="虚拟环境lx_back_env"></a>虚拟环境lx_back_env</h3><p>用来做软件工程课设的虚拟环境，里面有一些dj的框架；</p><p>虚拟环境~&#x2F;Py_projects&#x2F;THINKPADSTROE-BACKEND&#x2F;lx_back_env</p><p>整个环境大概几十MB</p><h2 id="配置Mac桌面平铺功能"><a href="#配置Mac桌面平铺功能" class="headerlink" title="配置Mac桌面平铺功能"></a>配置Mac桌面平铺功能</h2><p>配置yabai：</p><ol><li>使用homebrew安装yabai<code>brew install koekeishiya/formulae/yabai </code>；</li><li>将yabai初始配置文件&#x2F;opt&#x2F;homebrew&#x2F;opt&#x2F;yabai&#x2F;share&#x2F;yabai&#x2F;examples&#x2F;yabairc移动到本地~&#x2F;.yabai</li><li>编辑文件~&#x2F;.yabai可以编辑yabai的配置；</li><li>我在开机的时候按住电源键（长按直到出现选项界面），进入了恢复模式，打开终端使用<code>crsutil disable</code>，关闭了系统完整性保护SIP；</li><li>使用命令<code>shasum -a 256 $(which yabai)</code>，查看了yabai的哈希值，并使用命令<code>sudo code /etc/sudoers</code>编辑该文件，给yabai添加sudo权限；在&#x2F;ect&#x2F;sudoers文件的最后新添加了一行<code>yesys ALL=(root) NOPASSWD:sha256:7f17e8ff8a6131368c013af4029f3831a8e57723d5e2413a3e3f6cc1b8cdae52 /opt/homebrew/bin/yabai --load-sa</code>；</li><li>使用命令<code>yabai --start-service</code>便可以启动yabai服务；</li><li>使用命令<code>sudo yabai --load-sa</code>让yabai将自己的功能注入到系统中；</li><li>使用命令<code>yabai --stop-service</code>可以停止yabai的进程，系统的窗口管理恢复正常；</li></ol><p>使用的时候遇到过yabai不能获得完整的窗口管理权限的问题，参考解决方案<img src="https://blog.gitcode.com/7853f91c8ad85cb1610aae8074028280.html" alt="git"></p><p>配置skhd：</p><ol><li>使用<code>brew install</code>安装skhd；</li><li>在~&#x2F;.skhd中编写skhd的配置文件；</li><li>使用<code>skhd --start-service</code>启动skhd服务；</li></ol><h3 id="yabai常用命令"><a href="#yabai常用命令" class="headerlink" title="yabai常用命令"></a>yabai常用命令</h3><p><code>yabai -m space --focus 2</code>切换到第二个桌面</p><p><code>yabai --stop-service</code>终止yabai服务</p><p><code>yabai --start-service</code>启动yabai服务</p><p><code>yabai --restart-service</code>重新启动yabai服务</p><h2 id="配置Mac个性化终端"><a href="#配置Mac个性化终端" class="headerlink" title="配置Mac个性化终端"></a>配置Mac个性化终端</h2><p>首先是一个全新的终端</p><ol><li>使用命令<code>brew install --cask wezterm</code>安装wezterm</li><li>不再使用终端，而是使用wezterm</li><li>创建一个文件保存配置文件在~&#x2F;.config&#x2F;wezterm&#x2F;wezterm.lua</li></ol><p>其次是终端的提示效果</p><ol><li>使用<code>brew install starship</code>安装了starship，安装信息：“zsh completions have been installed to:<br>  &#x2F;opt&#x2F;homebrew&#x2F;share&#x2F;zsh&#x2F;site-functions”；</li><li>编辑～目录下的.zshrc文件（在安装homebrew的时候也创建过），配置starship在zsh启动时生效，加入<code>eval &quot;$(starship init zsh)&quot;</code>；</li><li>在~&#x2F;.config目录下创建starship.toml，用来配置starship（然后在starship.rc网站中下载了一个预设的toml文件使用）</li></ol><p>终端的文字高亮</p><ol><li>使用命令<code>brew install zsh-syntax-highlighting zsh-autosuggestions</code>安装zsh高亮提示工具</li><li>在.zshrc中配置了初始化启动，以及相关效果设置</li></ol><p>终端命令自动补全</p><ol><li>使用命令<code>brew install zsh-autocomplete</code>下载zsh自动补全插件；</li><li>在.zshrc中添加相关配置；</li></ol><h3 id="wezterm的常用操作"><a href="#wezterm的常用操作" class="headerlink" title="wezterm的常用操作"></a>wezterm的常用操作</h3><ol><li>ctrl+shift+n新开一个窗口</li><li>Ctrl+Shift+T：新建一个标签页</li><li>ctrl+tab：切换到下一个标签页（循环切换）</li><li>我配置了ctrl+h、l左右切换，然后使用alt+数字切换1～9标签；</li></ol><h2 id="配置系统级进程监视工具htop"><a href="#配置系统级进程监视工具htop" class="headerlink" title="配置系统级进程监视工具htop"></a>配置系统级进程监视工具htop</h2><ol><li>使用<code>brew install htop</code>安装htop</li></ol><p>htop使用</p><ol><li>使用命令<code>htop</code>可以开启它；</li><li>上下左右可以移动选中条；</li><li>空格可以选中F9+return可以结束进程</li></ol><h2 id="配置个性化导航栏"><a href="#配置个性化导航栏" class="headerlink" title="配置个性化导航栏"></a>配置个性化导航栏</h2><ol><li>使用<code>brew install sketchybar</code>安装了sketchybar;</li><li>我clone了一个大佬的仓库到本地<code>git clone https://github.com/FelixKratz/dotfiles.git /tmp/felix_dotfiles_complete</code>;</li><li>导航到需要提交的特定版本<code>cd /tmp/felix_dotfiles</code>以及<code>git checkout e6288b3f4220ca1ac64a68e60fced2d4c3e3e20b</code></li><li>复制 sketchybar 配置到你的配置目录 <code>cp -r .config/sketchybar ~/.config/</code></li><li>安装了一系列外部依赖：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 安装必备命令行工具</span></span><br><span class="line">brew install jq              <span class="comment"># JSON处理 (必需)</span></span><br><span class="line">brew install sf-symbols      <span class="comment"># Apple系统图标 (必需)</span></span><br><span class="line">brew install gh              <span class="comment"># GitHub CLI (用于某些插件)</span></span><br><span class="line">brew install switchaudio-osx <span class="comment"># 音频设备切换 (用于音频插件)</span></span><br><span class="line">brew install cava            <span class="comment"># 音频频谱可视化</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意：`background-music` 可能需要额外步骤，请访问其GitHub页面安装</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 安装 Nerd Fonts (图标字体，必需!)</span></span><br><span class="line">brew tap homebrew/cask-fonts</span><br><span class="line">brew install --cask font-hack-nerd-font font-sf-pro</span><br><span class="line"><span class="comment"># 安装后，务必打开【字体册】应用，确保这些字体已激活。</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="设置导航栏的音乐组件"><a href="#设置导航栏的音乐组件" class="headerlink" title="设置导航栏的音乐组件"></a>设置导航栏的音乐组件</h3><ol><li>使用<code>brew install --cask blackhole-2ch</code>安装blackhole；</li><li>使用<code>brew install ffmpeg</code>安装ffmpeg（这个依赖似乎比较多有100多MB）；</li><li>配置音频路由，让音频不仅输出到扬声器、耳机，还输出到balckhole；</li><li>配置多输出设备（输出到我原始的设备以及balckhole）这是为了让blackhole能够捕捉到信号，并将blackhole设置为主设备，全部使用48khz；</li><li>编写相应的plugins和items脚本，名为：audio_dynamic_item.sh audio_beat_item.sh以及dynamic_audio_bar.sh；</li><li>reload sketchybar；</li></ol><p>显示当前播放的信息：</p><ol><li>使用<code>brew install nowplaying-cli</code>安装nowpalying工具；</li><li>。。。。先搁置吧</li></ol><h2 id="配置yazi"><a href="#配置yazi" class="headerlink" title="配置yazi"></a>配置yazi</h2><ol><li>使用<code>brew install yazi</code>安装yazi；</li><li>创建文件夹~&#x2F;.config&#x2F;yazi</li><li>在yazi中复制粘贴了github仓库中的默认配置文件yazi-default.toml、keyboard-defualt.toml、dark-theme.toml；</li><li>在~&#x2F;.local&#x2F;bin&#x2F;yazi-copy-files-macos中编写yazi的快捷键脚本（为了将yazi中复制粘贴的内容放到finder的粘贴板）</li><li>赋予脚本执行权限<code>chmod +x ~/.local/bin/yazi-copy-files-macos</code>；</li></ol><dl><dt>yazi的使用：<br>类别    按键                            功能<br>基础导航h j k l &#x2F; 方向键左、下、上、右移动 &#x2F; 进入文件夹<br>Enter进入目录或打开文件<br>q退出 Yazi<br>文件操作<Space>标记&#x2F;取消标记文件（用于批量操作）<br>y复制标记的文件<br>x剪切标记的文件<br>p粘贴文件<br>d将文件移至回收站<br>D永久删除文件（慎用）<br>a新建文件&#x2F;文件夹（新建文件夹需以&#x2F;结尾）<br>r重命名文件<br>视图与高级.显示&#x2F;隐藏隐藏文件（以点开头的文件）<br>~ 或 F1打开内置帮助菜单，忘记快捷键时随时查阅<br>Tab切换标签页</Space></dt><dd>执行 Shell 命令</dd></dl><h2 id="配置typst"><a href="#配置typst" class="headerlink" title="配置typst"></a>配置typst</h2><ol><li>在vsc安装typst扩展Tinymist Typst；</li><li>使用<code>brew install typst</code>安装typst编译器；</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 杂项 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OS</title>
      <link href="/2025/10/23/OS/"/>
      <url>/2025/10/23/OS/</url>
      
        <content type="html"><![CDATA[<p><code>这篇blog用来记录我于大三秋季学期，学习操作系统时，了解到的知识，以备复习以及增强自己的专业素养</code></p><h2 id="操作系统的基本概念L1"><a href="#操作系统的基本概念L1" class="headerlink" title="操作系统的基本概念L1"></a>操作系统的基本概念L1</h2><h3 id="操作系统需要解决的问题"><a href="#操作系统需要解决的问题" class="headerlink" title="操作系统需要解决的问题"></a>操作系统需要解决的问题</h3><p><strong>操作系统的功能？</strong></p><ol><li>作为<strong>用户与计算机硬件系统之间的接口</strong>（例如上层的编程者使用系统调用完成相关工作）</li><li>对计算机系统<strong>资源进行管理</strong>（eg. 管理硬件CPU、存储器、外设，管理软件程序、数据；管理资源状态，如PCB、TCB；采取相关策略，对资源分配、回收等）</li><li>在需要的时候马上对计算机<strong>资源进行抽象</strong>（通过逻辑功能扩展物理功能，如在裸机上附加外设管理、文件管理、存储管理、处理器管理）</li></ol><p>一些启发的问题：</p><ol><li>直接使用计算机是很不方便的，因为计算机是一个复杂精密的仪器，而大部分人只需要计算机的部分功能，无需去了解整个计算机系统的工作原理</li><li>计算机衍生出各种不同的资源，显示器、音响、打印机，各种外设，资源多样意味着，1）资源管理复杂，那么管理应该落到谁身上？使用者？某种软件？；2）不同厂家生产的设备需要纳入计算机的体系协同工作，缺少统一标准，谁来负责与不同的接口交互？</li></ol><h3 id="操作系统的位置"><a href="#操作系统的位置" class="headerlink" title="操作系统的位置"></a>操作系统的位置</h3><ol><li>OS是配置在<strong>硬件上的第一层软件，是对硬件系统的首次扩充</strong>（<strong>操作系统是什么？</strong>）</li><li>OS工作在内核态</li></ol><h3 id="操作系统的发展过程"><a href="#操作系统的发展过程" class="headerlink" title="操作系统的发展过程"></a>操作系统的发展过程</h3><p><strong>操作系统发展的过程？</strong><br><strong>各个阶段的特点？</strong></p><h4 id="未配置操作系统的计算机系统"><a href="#未配置操作系统的计算机系统" class="headerlink" title="未配置操作系统的计算机系统"></a>未配置操作系统的计算机系统</h4><p>工作方式：用户作为计算机专业人员，使用机器语言编程，输入输出如纸带。</p><p>工作特点：用户独占资源，资源不能在用户间共享；CPU等待用户手工装、卸纸带，利用率很低。</p><h4 id="单道批处理系统"><a href="#单道批处理系统" class="headerlink" title="单道批处理系统"></a>单道批处理系统</h4><p>动机：为充分利用计算机系统，应尽量让系统连续运行，以减少空闲时间</p><p>工作方式：一批作业，<strong>脱机输入</strong>道磁带，监督程序控制有序处理</p><p>工作特点：内存中只保持<strong>一个作业运行</strong>，先进先出（单道）；成批处理作业（批处理，或许是指一批作业同时输入）</p><p><strong>注</strong>：单道批处理系统是最早出现的一种OS，单严格来说只能算OS前身，并非人们现在所理解的OS</p><h4 id="多道批处理系统"><a href="#多道批处理系统" class="headerlink" title="多道批处理系统"></a>多道批处理系统</h4><p>动机：单道批处理系统中内存中仅有一道作业，每次处理完一个作业，程序发出I&#x2F;O请求的时候CPU都处于等待状态，无法充分利用资源</p><p>工作方式：作业成批进入内存，按照一定策略由程序调度，轮流使用CPU</p><p>工作特点：内存中维护<strong>多个作业，交替使用CPU</strong>（多道性）；<strong>作业进出顺序不定</strong>（无序性）；作业经历两次调度（作业调度、进程调度）</p><p><strong>注</strong>：为了完成这样的工作方式，实际上牵扯到许多问题，包括处理器争用、内存分配和保护、IO设备分配、文件组织管理、作业管理、用户与系统接口等等，<strong>所以应该增加一组软件来解决这些问题，于是这些软件构成了现代意义上的操作系统</strong></p><h4 id="分时系统"><a href="#分时系统" class="headerlink" title="分时系统"></a>分时系统</h4><p>动机：多个程序员围着一台批处理系统的主机，缺乏一些机制来很好地为每个用户作业分配时间、为程序员提供良好的<strong>交互</strong>体验，有时一个逗号的编译错误会浪费程序员半天的时间，他们希望自己的程序可以更快地得到响应</p><p>工作方式：在多道批处理系统的基础上，将系统资源在时间上进行分割，每个时间段称为一个时间片，每个用户依次轮流使用时间片</p><p>工作特点：多个终端共享一个主机（多路性）；各个用户独立操作，互不干扰（独立性）；请求能在<strong>很短的时间得到响应</strong>（及时性）；用户可以通过中断与系统进行<strong>人机交互</strong>（交互性）</p><p><strong>注</strong>：实际上分时系统已经很接近如今我们使用的操作系统了，或者说就是在其基础上加入了更多的现代化改进，而下面的实时系统则是为了应对一些特殊的场景</p><h4 id="实时系统（特殊，仅作了解）"><a href="#实时系统（特殊，仅作了解）" class="headerlink" title="实时系统（特殊，仅作了解）"></a>实时系统（特殊，仅作了解）</h4><p>动机：在一些场景下我们特别强调作业处理的及时响应，甚至不再是及时性，而是实时性与可靠性，例如武器装备、订票系统等场景</p><p>实时任务种类：硬实时任务、软实时任务，前者要求系统<strong>必须满足任务对截止日期</strong>的要求，后者可以偶尔错过截止日期</p><h4 id="微机操作系统（了解存在）"><a href="#微机操作系统（了解存在）" class="headerlink" title="微机操作系统（了解存在）"></a>微机操作系统（了解存在）</h4><p>略</p><h2 id="操作系统的特性"><a href="#操作系统的特性" class="headerlink" title="操作系统的特性"></a>操作系统的特性</h2><p><strong>四大特征？两个基本特征？</strong></p><p>并发、共享是最<strong>基本的特征</strong></p><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>并发的含义：指处理多个同时性活动的能力</p><ol><li>针对单核CPU讨论，具体来说：<strong>宏观</strong>上是这些程序同时在执行，<strong>微观</strong>上是每个时刻实际只有一个程序在执行，<strong>程序轮流使用CPU</strong></li><li><strong>并发不同于并行</strong>，后者是不同程序同一时刻在多个硬件部件上执行，例如多核CPU</li><li><strong>并发不同于同步</strong>，两个完全不同的概念，同步指的是<strong>协调并发执行的任务</strong>（进程&#x2F;线程）之间的执行顺序和共享资源的访问，以防止出现竞态条件或数据不一致。</li></ol><h3 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h3><p>共享的含义：<strong>操作系统与多个用户的程序</strong>共同使用计算机中的有限资源</p><p>共享的分类：互斥共享（打印机）、同时共享（读文件）</p><h3 id="虚拟"><a href="#虚拟" class="headerlink" title="虚拟"></a>虚拟</h3><p>虚拟的含义：<strong>一个物理实体</strong>映射为若干<strong>多个对应逻辑实体</strong></p><p>虚拟的实现方法：分时 分空间</p><p>对应的具体例子：时分CPU，在每个进程看来是一个虚拟处理机；空分存储器，每个进程拥有独立的虚拟地址空间；</p><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>异步的含义：操作系统必须随时对<strong>不可预测的次序</strong>发生的<strong>事件</strong>进行<strong>响应和处理</strong></p><ol><li>多个进程发生与运行速度的不可知，导致了在<strong>操作系统视角下</strong>，整个系统在每时每刻的状态都是<strong>难以重现</strong>的</li><li>操作系统需要保证，只要<strong>环境相同</strong>，进程的<strong>运行结果就要一致</strong>（进程对复杂、不可重现的整个系统是感知不到的，系统对进程是透明的）</li><li>更准确一点来说，异步是操作系统面对的挑战</li></ol><h2 id="操作系统的功能"><a href="#操作系统的功能" class="headerlink" title="操作系统的功能"></a>操作系统的功能</h2><p>总的来说，其需要保证多道程序，有条不紊地运行，提高系统中各种资源的利用率，并方便用户的交互。</p><h3 id="处理器管理"><a href="#处理器管理" class="headerlink" title="处理器管理"></a>处理器管理</h3><p>进程控制：以进程为基本单位进行处理机的分配和运行</p><p>具体而言：</p><ol><li>为作业创建进程</li><li>撤销已经结束的进程</li><li>控制进程在运行过程中的状态转换</li></ol><p>注：在现代OS中，进程控制除了这些以外还有关于线程的管理，后续会学习到</p><p>进程同步：通过进程同步机制，协调进程间的资源共享，推进并发进程执行</p><p>进程同步的主要方式：</p><ol><li>互斥方式，各进程在对临界资源访问的时候应该采取互斥的方式</li><li>同步方式，有的进程之间需要相互合作，同步机制来协调她们的次序</li></ol><p>进程通信：让多个相互协作的进程可以交换信息</p><p>例如：I-C-P，三个进程互相通信，I为C提供数据，C为P提供结果，P进行打印</p><p>进程调度：控制作业、进程的运行切换，从而高效地利用处理机资源提高系统性能</p><ol><li>作业调度：从后备队列上按照一定的算法，选择出若干个作业，为其分配必要的资源</li><li>进程调度：从就绪队列上，挑选出一个新进程，将处理机分配给它，并为其设置好运行现场，使其投入运行</li></ol><h3 id="存储器管理"><a href="#存储器管理" class="headerlink" title="存储器管理"></a>存储器管理</h3><p>内存分配：为多道程序分配内存，提高存储器利用率</p><ol><li>静态分配：内存空间在作业装入时确定，不允许作业再申请新的内存空间，也不允许作业在空间中移动</li><li>动态分配：允许作业在运行过程中申请新的内存空间，适应程序和数据的动态增长，也允许作业在内存中“移动”</li></ol><p>内存保护：确保每个进程在自己的内存空间运行，互不干扰</p><p>例如：设置两个界限寄存器，用来存放正在执行进程的上下界，系统对每条指令访问的地址进行检查，如果有越界行为则停止程序执行</p><p>地址映射：将逻辑地址分配给进程，让用户可以通过逻辑地址透明地访问物理地址</p><p>实际上就是一种虚拟化</p><p>内存扩充：借助虚拟存储技术，从逻辑上扩充内存容量，让用户感知道的内存容量比实际容量大得多</p><h3 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h3><p>管理计算机所有的外围设备</p><p>缓冲区管理：解决CPU和I&#x2F;O设备速度不匹配的问题</p><p>设备分配：控制设备的分配和回收</p><p>设备处理：实现CPU和设备控制器之间的通信</p><p>（设备在操作系统中同样会被映射为地址）</p><h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h3><p>文件存储空间管理：为每个文件分配必要的外存空间，对空间进行回收（通常采用离散分配的方式）</p><p>目录管理：就为了让用户能方便地在外存上找到所需文件，系统为文件建立目录项</p><p>读写保护：文件读写管理，以及防止文件被非法窃取、破坏</p><h3 id="用户接口"><a href="#用户接口" class="headerlink" title="用户接口"></a>用户接口</h3><p>联机用户接口：为联机用户提供的接口，由一组键盘命令及命令解释程序组成</p><p>脱机用户接口：为批处理作业的用户提供的接口（这类用户无需实时交互）</p><h3 id="其它功能"><a href="#其它功能" class="headerlink" title="其它功能"></a>其它功能</h3><p>系统安全、网络功能与服务、支持多媒体</p><p><code>写在操作系统功能的最后：实际上操作系统功能这一块可以作为一张地图使用，我们后续的学习实际上就是在这个框架上的展开，一步步去学习操作系统是怎么具体地将这些功能进行实现的</code></p><h2 id="操作系统的结构设计"><a href="#操作系统的结构设计" class="headerlink" title="操作系统的结构设计"></a>操作系统的结构设计</h2><p><strong>操作系统的几种架构？</strong>；<br><strong>微内核？</strong>；</p><p><strong>结构发展过程</strong>：<br>    1）无结构；<br>    2）模块化OS结构；<br>    3）层次式OS；<br>    4）客户服务器模式；<br>    5）采用面向对象的程序方法设计；<br>    6）微内核OS；<br>    注意：<br>        1）第一代～第三代称为<strong>传统OS结构</strong>；<br>        2）微内核称为<strong>现代OS结构</strong>；</p><p>模块化OS结构：<br>    1）将模块作为组成操作系统的基本单位；<br>    2）按照功能需求根据程序和数据特性将系统分解为若干个模块；<br>    3）模块可以分为若干子模块，每个模块具有独立性，所有模块组成完整的操作系统；</p><p>分层式的OS：<br>    1）将单一的OS按照功能划分为不同的层次，底层的功能为紧临的上一个层次提供服务；</p><p>微内核：<br>   1）微内核是经过精心设计的，实现现代OS<strong>核心功能</strong>的<strong>小型内核</strong>；<br>   2）并非完整的OS，是构建通用OS的一个重要基础；<br>   3）在微内核中通常采用客户服务器模式；<br>   （OS的大部分功能通过若干服务器实现，例如文件服务器、作业服务器、网络服务器）；<br>    微内核的结构特征：<br>        以<strong>微内核为OS的核心</strong>，以<strong>客户服务器模式为基础</strong>，采用<strong>面向对象的程序设计方法</strong>；<br>    微内核的功能：<br>        进程管理、存储器管理、进程通信管理、I&#x2F;O设备管理；</p><p>客户服务器模式：<br>    基本思想：将操作系统分为两大部分<br>        1）运行在<strong>用户态</strong>，以<strong>客户&#x2F;服务器方式活动的进程</strong>；<br>        2）运行在<strong>内核态</strong>的<strong>内核</strong>；<br>    <strong>内核态包括</strong>：<br>        微内核、计算机硬件；<br>    <strong>用户态包括</strong>：<br>        用户进程、操作系统服务进程；<br>    注意：在这种模式下：<br>        1）除了微内核，<strong>操作系统的其他部分</strong>被分为相对独立的若干进程，称为服务进程，和用户进程一起活动<strong>在用户态</strong>；<br>        2）用户进程和服务进程的<strong>交互要通过微内核</strong>，用户请求服务，服务回应进程，都是微内核做中介；<br>    优点：<br>        将操作系统在很多模块（进程管理、存储器管理…）应有的功能从内核中抽离出来作为服务进程，在内核中保留最<strong>基本的功能</strong>，让内核变得<strong>简洁可靠</strong>；<br>    eg：<br>        <strong>假脱机系统</strong>就是客户服务器模式的典型代表；</p><p>采用面向对象的程序设计思想：<br>    <strong>文件、进程、内存块</strong>都被认为是一种<strong>对象</strong>；</p><h2 id="L3进程的基础概念"><a href="#L3进程的基础概念" class="headerlink" title="L3进程的基础概念"></a>L3进程的基础概念</h2><h3 id="进程引入的原因"><a href="#进程引入的原因" class="headerlink" title="进程引入的原因"></a>进程引入的原因</h3><p>引入进程的根本原因，程序的并发执行会破坏程序执行的：</p><ol><li>顺序性；</li><li>封闭性；</li><li>可再现性</li></ol><p>前驱图：</p><ol><li>节点：表示1）一句语句；2）程序段；3）进程</li><li>有箭头的边：节点之间的前躯关系，后继节点的执行一定是依赖于前躯节点的</li><li>初始节点、终止节点：没有前躯、后继的节点</li></ol><p>并发执行的程序：</p><ol><li>执行过程交替进行</li><li>共享资源部具有封闭性</li><li>不具有可再现性（当然是在当前，我们没有加任何限制条件）</li><li>程序之间<strong>间接或直接相互制约</strong></li></ol><p>我们以程序为基础，为了让程序可以并发执行，引入进程的概念，来对并发程序进行描述与控制</p><h3 id="进程的描述"><a href="#进程的描述" class="headerlink" title="进程的描述"></a>进程的描述</h3><h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h4><p>进程 &#x3D; <strong>程序（数据段+程序段）+ PCB（进程控制模块）</strong></p><p>创建、撤销进程：实际上就是创建、撤销了PCB模块</p><p>进程的严格定义：进程是<strong>进程实体的运行过程</strong>，是系统进行<strong>资源分配</strong>和<strong>调度</strong>的基本单位</p><p>（除了最小微内核作为程序始终存放在内存中一直运行，例如原语操作、时钟管理、进程管理等，其他都作为进程管理）</p><p>进程的<strong>特性</strong>：</p><ol><li>动态性</li><li><strong>并发性</strong></li><li>独立性（资源调度）</li><li><strong>异步性</strong>（各进程间的执行情况）<br>（操作系统的特性是：并发、异步、虚拟、共享，并发和异步与进程的特性相同）</li></ol><p>一个程序可以对应多个进程，一个进程可以包含多个程序</p><h4 id="进程的基本状态与转换"><a href="#进程的基本状态与转换" class="headerlink" title="进程的基本状态与转换"></a>进程的基本状态与转换</h4><ol><li>创建状态：为要执行的程序作业创建PCB，创建进程</li><li>终止状态：执行完毕，回收相关资源</li><li>就绪状态：进入了就绪队列，等待执行，得到了除CPU以外的所有资源</li><li>执行状态：获得了CPU，正在被执行</li><li>阻塞状态：因为某些原因无法继续执行，放弃了CPU了使用，进入了一种暂停等待的状态</li></ol><p>相关状态转换如下图：</p><p><img src="https://raw.githubusercontent.com/Yes-ys/blog-images/main/OS/ProcessStateTransform1.png" alt="进程状态转换1"></p><p>挂起：将内存中的进程临时保存到外存</p><p>当由于某些原因，例如内存不够了、用户需要等等，这时就需要做挂起操作</p><p>有了挂起之后进程有7种基本状态，其中活动、静止分别对应 在内存中 和 被挂起</p><ol><li>创建状态</li><li>终止状态</li><li>活动就绪状态</li><li>静止就绪状态</li><li>活动阻塞状态</li><li>静止阻塞状态</li><li>执行状态</li></ol><p>相关状态转换如下图：</p><p><img src="https://raw.githubusercontent.com/Yes-ys/blog-images/main/OS/ProcessStateTransform2.png" alt="进程状态转换2"></p><p>注意：<strong>各状态的转换要很熟悉</strong></p><p>其实可以记住以下几个关键点：</p><p>无挂起</p><ol><li>执行可以到 就绪 阻塞</li><li>就绪可以到 执行</li><li>阻塞可以到 就绪</li></ol><p>在无挂起的基础上，有挂起</p><ol><li>静止到对应的活动 静止阻塞可以到静止就绪</li><li>执行可以到静止就绪，不能到静止阻塞</li></ol><p>此外，作为阻塞原因的常用例子是<strong>IO</strong></p><h4 id="进程管理到数据结构"><a href="#进程管理到数据结构" class="headerlink" title="进程管理到数据结构"></a>进程管理到数据结构</h4><ol><li>操作系统管理进程的数据结构：资源信息表&#x2F;进程信息表</li><li>进程自己的数据结构：PCB的数据结构</li></ol><p>关于PCB</p><ol><li>PCB是进程存在的唯一标识</li><li>能提供进程控制、调度、互相通信的信息</li><li>能够用于实现间断运行</li></ol><h3 id="进程的控制"><a href="#进程的控制" class="headerlink" title="进程的控制"></a>进程的控制</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>进程控制：进程的创建、终止以及状态的切换（基本状态和挂起）</p><p>进程控制的实现：操作系统<strong>内核</strong>中的<strong>原语</strong>来实现的</p><p>用户态：目态，权限较低，执行规定指令，访问指定寄存器和存储区；一般应用程序的执行状态，不去执行OS区域与指令</p><p>管态：内核态，高特权，执行所有指令，访问所有寄存器和存储区；<strong>传统OS</strong>都在管态，<strong>常驻于内存之中</strong></p><p>操作系统内核提供的功能：</p><ol><li>中断处理</li><li>时钟管理</li><li>原语操作</li></ol><p>操作系统内核依托于自己的功能进行的管理：</p><ol><li>进程管理</li><li>存储器管理</li><li>设备管理</li></ol><h4 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h4><p>一个典型的例子：多道批处理系统中，内核进行作业调度，将作业装入内存</p><p>创建的步骤：申请空PCB、分配资源、初始化PCB信息、插入就绪队列</p><p>进程可以继续创建进程，于是就有了父进程与子进程</p><h4 id="进程的终止"><a href="#进程的终止" class="headerlink" title="进程的终止"></a>进程的终止</h4><ol><li>正常终止</li><li>异常终止（出现错误）</li><li>外界干预（如死锁时）</li></ol><h4 id="阻塞与唤醒"><a href="#阻塞与唤醒" class="headerlink" title="阻塞与唤醒"></a>阻塞与唤醒</h4><p>原语是<strong>block和wakeup</strong></p><p>引起阻塞的事件：（这个可以仔细了解一下）</p><ol><li>请求OS服务，不能立刻被满足，如IO</li><li>启动OS的某种操作，等待OS操作完成</li><li>数据尚未到达</li><li>无新工作可做</li></ol><p>引起唤醒的事件与引起阻塞的事件相对应</p><h4 id="挂起与激活"><a href="#挂起与激活" class="headerlink" title="挂起与激活"></a>挂起与激活</h4><p>原语时<strong>suspend和active</strong></p><p>阻塞与激活一般是OS进行处理，挂起和激活可以由用户干预</p><h2 id="L4–L5进程同步和经典同步问题"><a href="#L4–L5进程同步和经典同步问题" class="headerlink" title="L4–L5进程同步和经典同步问题"></a>L4–L5进程同步和经典同步问题</h2><h3 id="进程同步（进本概念）"><a href="#进程同步（进本概念）" class="headerlink" title="进程同步（进本概念）"></a>进程同步（进本概念）</h3><p>进程同步的基本概念：对多个相关进程在执行次序上进行协调，使<strong>并发执行</strong>的诸进程之间能够按照一定的规则（或时序）<strong>共享系统资源</strong>，并能很好的<strong>相互合作</strong>，从而使得程序的执行具有<strong>可再现性</strong>。<br>（进程同步的主要任务：使并发执行的诸进程有效地<strong>共享资源</strong>和<strong>相互合作</strong>，从而使程序的执行具有<strong>可再现性</strong>）；</p><p>两种形式的制约关系</p><ol><li>直接相互制约关系（源于进程之间的合作）</li><li>间接相互制约关系（源于进程对资源共享）</li></ol><p>临界资源：多个进程采用互斥的方式访问的资源（例如打印机）</p><p>对临界资源要进行<strong>互斥访问</strong>：即一个进程在使用该资源的时候其他进程不允许使用该资源</p><p>临界区：每个进程中访问临界资源的代码段</p><p>实现互斥访问临界资源：保证每个进程互斥地进入自己的临界区</p><p>同步机制：进程互斥地进入自己临界区的机制</p><p>同步机制要遵循的规则</p><ol><li>空闲让进（临界资源空闲的时候，允许希望访问的进程进入自己的临界区）</li><li>忙则等待（临界资源被占用的时候，希望访问的进程不能进入临界区，而需要等待）</li><li>有限等待（等待的进程不能一直等待，最终一定要能够访问到临界资源）</li><li>让权等待（拿不到临界资源的进程要释放处理机，不要忙等）</li></ol><p>当无进程处于临界区时，表明临界资源处于空闲状态，应允许一个请求进入临界区的进程立即进入自己的临界区。</p><p>当已有进程进入临界区时，表明临界资源正被访问，因而其它试图进入临界区的进程必须等待，以保证对临界资源的互斥访问。</p><p>对要求访问临界资源的进程，应保证在有限的时间内能进入自己的临界区，以免陷入“死等”状态。</p><p>当进程不能进入自己的临界区时，应立即释放处理机，以免进程陷入“忙等”状态。</p><h3 id="进程同步机制：硬件机制"><a href="#进程同步机制：硬件机制" class="headerlink" title="进程同步机制：硬件机制"></a>进程同步机制：硬件机制</h3><ol><li>关中断</li><li>Test and Set指令</li><li>Swap指令</li></ol><p>硬件实现不可被打断</p><p>后面两种方法的共同点是为临界资源维护公共变量lock</p><p>硬件实现的缺点：当临界资源被占用的时候，其他进程会<strong>不断进程测试</strong>，浪费处理器资源，属于<strong>忙等</strong>状态，不符合<strong>让权等待</strong>。</p><h4 id="关中断"><a href="#关中断" class="headerlink" title="关中断"></a>关中断</h4><p>在进入锁测试前关闭中断，直到完成锁测试才能打开中断。这样，进程在临界区执行期间，计算机系统不响应中断，从而不会发生调度。</p><p>缺点很多：限制CPU交叉执行能力、在多核CPU中不适用</p><h4 id="Test-and-Set指令"><a href="#Test-and-Set指令" class="headerlink" title="Test and Set指令"></a>Test and Set指令</h4><p>lock是临界资源的全局boolean变量</p><p>记忆点就在<strong>while(TS(&amp;lock));</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">while</span>(TS(&amp;lock));</span><br><span class="line">    critical section;</span><br><span class="line">    lock = FALSE;</span><br><span class="line">    remainder section;</span><br><span class="line">&#125;<span class="keyword">while</span>(TRUE)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">boolean TS(boolean *lock)&#123;</span><br><span class="line">    boolean old = *lock;</span><br><span class="line">    *lock = TRUE;</span><br><span class="line">    <span class="built_in">return</span> old;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Swap指令"><a href="#Swap指令" class="headerlink" title="Swap指令"></a>Swap指令</h4><p>lock是临界资源的全局boolean变量</p><p>swap就是单纯的交换功能</p><p>关键的记忆点在<strong>do{…}while(key !&#x3D; FALSE)</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    key = TRUE;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        swap(&amp;lock,&amp;key);</span><br><span class="line">    &#125;<span class="keyword">while</span>(key != FALSE)</span><br><span class="line">    critical section;</span><br><span class="line">    lock = FALSE;</span><br><span class="line">    ...</span><br><span class="line">&#125;<span class="keyword">while</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void swap(boolean* lock, boolean* key)&#123;</span><br><span class="line">    boolean temp = *lock;</span><br><span class="line">    lock = *key;</span><br><span class="line">    key = *temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="进程同步机制：信号量机制（Semaphore）"><a href="#进程同步机制：信号量机制（Semaphore）" class="headerlink" title="进程同步机制：信号量机制（Semaphore）"></a>进程同步机制：信号量机制（Semaphore）</h3><h4 id="整型信号量"><a href="#整型信号量" class="headerlink" title="整型信号量"></a>整型信号量</h4><p>基本思想：在OS中维护一个整型变量作为信号量，通过改变整型变量的值来标记临界资源是否可以访问。</p><p>实现细节：</p><ol><li>整型变量S只能通过wait(S), signal(S)来访问</li><li>S的初始值只能是1或者更大值，来标记临界资源的剩余量</li><li>wait、signal操作由系统原语实现，执行时不可中断</li></ol><p>关于wait、signal</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">wait</span>(S):&#123;</span><br><span class="line">    <span class="keyword">while</span>(S&lt;0);</span><br><span class="line">    S--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">signal(S):&#123;</span><br><span class="line">    S++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>整型信号量的缺点在于<strong>不满足让权等待</strong>，没有获得处理器的进程会不断执行while循环，访问信号量</p><h4 id="记录型信号量"><a href="#记录型信号量" class="headerlink" title="记录型信号量"></a>记录型信号量</h4><p>基本思想：使用一个整型变量value保存剩余临界资源的数量，维护一个链表L对应阻塞队列，将无法获得临界资源的进程进行阻塞，防止忙等。</p><p>实现细节：</p><ol><li>整型变量value，与整型信号量类似，只能用signal、wait访问（但signal、wait实现有所不同）</li><li>维护一个等待进程的队列</li></ol><p>关于数据结构</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">type</span> semaphore = record</span><br><span class="line">value <span class="built_in">integer</span>;</span><br><span class="line">L : list of process;</span><br><span class="line">end</span><br><span class="line">//其实落到做题上不一定要这样写</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>关于wait、siganl</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">wait</span>(S):</span><br><span class="line"></span><br><span class="line">var S:semaphore;</span><br><span class="line">begin</span><br><span class="line">    S.value := S.value-1;</span><br><span class="line">    <span class="keyword">if</span> S.value &lt; 0 <span class="keyword">then</span></span><br><span class="line">        block(S.L);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">signal(S):</span><br><span class="line"></span><br><span class="line">var S:semaphore:</span><br><span class="line">begin</span><br><span class="line">    S.value := S.value+1;</span><br><span class="line">    <span class="keyword">if</span> S.value &gt;= 0 <span class="keyword">then</span></span><br><span class="line">        wakeup(S.l);</span><br><span class="line">end</span><br><span class="line">//不需要完全背住这两个实现，但是在多个进程运行的情况下，理解它们对<span class="built_in">wait</span>、signal的调用以及执行效果，对于理解这种信号量机制的运行原理很有帮助；</span><br><span class="line">//后续同步问题会直接将它们作为一种默认的存在直接调用</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>记录型信号量的缺点是如果操作不当可能出现死锁，例如进程A、B执行均需要两个临界资源，A、B各自拿到一个，等待另一个点时候陷入阻塞且持有资源，于是A、B死锁，谁也无法继续下去。<strong>这种情况尤其容易在两个进程的wait顺序不同时发生</strong></p><p>注意：</p><ol><li>记录型信号量虽然有缺点，但是缺点是在不当的代码编写时发生的；不像整型信号量的硬性缺陷；所以这种方式还是比较常用的，并且我们后续各种同步问题的解决，基本上都是用这种方法</li><li>使用的时候要自己定义value的数据结构，但是L、wait、signal不用自己声明，它们上默认存在的</li></ol><h4 id="AND型信号量"><a href="#AND型信号量" class="headerlink" title="AND型信号量"></a>AND型信号量</h4><p>基本思想：AND型信号量是为了解决记录型信号量可能导致死锁而引入的，方法就是将所有的临界资源一次性分配给需要的进程，不允许一个进程一次持有部分临界资源，要么全有了，要么一个都没有。</p><p>原语操作：</p><ol><li>Sswait(s1,s2,…,sn)</li><li>Ssignal(s1,s2,…,sn)</li></ol><h4 id="信号量集"><a href="#信号量集" class="headerlink" title="信号量集"></a>信号量集</h4><p>提出的背景；可能产生死锁？</p><p>原语操作：s、t、d的含义</p><ol><li>Swait(s1,t1,d1,s2,t2,d2,…,sn,tn,dn)</li><li>Ssignal(s1,d1,s2,d2,…,sn,dn)</li></ol><p>注：t作为进程设置的下限，如果资源量低于该下限还给对应的进程分配，可能造成死锁，想一想提出的背景</p><p>几种特殊的信号量集合</p><ol><li>Swait(S,d,d)</li><li>Swait(S,1,1)</li><li>Swait(S,1,0)</li></ol><h4 id="信号量机制的应用"><a href="#信号量机制的应用" class="headerlink" title="信号量机制的应用"></a>信号量机制的应用</h4><p>进程互斥：</p><ol><li>定义信号量（这里要做初始化），通常初始化为1</li><li>分进程，wait与signal在同一进程中成对出现</li><li>将各进程对临界资源访问的代码放在wait和signal之间<br>注意：</li><li>缺少wait导致系统混乱</li><li>缺少signal导致阻塞进程无法被唤醒</li><li>此时信号量称为互斥信号量</li></ol><p>进程协调：</p><ol><li>定义信号量初始化，通常初始化为0</li><li>分进程，wait与signal在两个进程中分别出现，作为一对（先执行的完成后signal，后执行的先wait）</li><li>signal出现在对临界资源访问的代码之后，wait出现在对临界资源访问的代码之前<br>注意：</li><li>此时信号量称为同步信号量</li><li>应用同步信号量可以实现复杂前驱关系</li></ol><p>通常我们说到互斥信号量的时候，对应的就是进程互斥；<br>说到同步信号量的时候，就是前驱关系；</p><p>信号量S的含义：</p><ol><li>S&gt;0，可用资源的数量</li><li>S&#x3D;0，无可用资源，无等待进程</li><li>S&lt;0，|S|为阻塞的进程数量</li></ol><h3 id="管程机制：另一种进程同步的方法"><a href="#管程机制：另一种进程同步的方法" class="headerlink" title="管程机制：另一种进程同步的方法"></a>管程机制：另一种进程同步的方法</h3><p>基本印象&amp;与信号量机制的点：</p><ol><li>管程外面有锁，开则可以进入管程，关则进程在锁队列上等待；对应互斥信号量</li><li>管程使用公共变量记录资源数量；对应信号量</li><li>管程使用条件变量实现进程同步；对应同步信号量</li><li>管程的wait、signal操作只会阻塞、唤醒进程；没有类似对信号量的操作</li></ol><h2 id="L6经典的进程同步问题"><a href="#L6经典的进程同步问题" class="headerlink" title="L6经典的进程同步问题"></a>L6经典的进程同步问题</h2><p>问题入手的思路（一般情况下）：<br>    考虑存在的问题：互斥？同步？局部资源？<br>        其中局部资源可以类比到哲学家用餐问题，所有哲学家持有自己左边的筷子时；即大家都持有局部的资源而不释放造成的死锁问题；<br>    考虑设置几个信号量：<br>        互斥问题：一个互斥信号量对应一个临界资源；<br>        同步问题：一个同步信号量对应一个前驱关系；<br>    信号量如何初始化？<br>    使用什么信号量机制？<br>    是否需要更加复杂的逻辑？<br>        例如应对局部资源问题；<br>    其他必要的变量和初始化？</p><p>生产者消费者问题：<br>    背景：<br>        数据结构：环形缓冲区；<br>            缓冲区：buffer[0,…,n-1]；<br>            缓冲区满：counter&#x3D;n;<br>            缓冲区空：counter&#x3D;0;<br>        生产者：生产商品放置到缓冲区；<br>            放入一个商品：in &#x3D; (in+1)mod n;<br>        消费者：从缓冲区取走商品；<br>            取走一个商品：out &#x3D; (out+1)mod n;<br>    存在的问题：<br>        进程互斥：缓冲区不能同时被多个进程访问；（因为这些进程都要修改缓冲区，相当于都要写，不能同时写）<br>        进程同步：在特殊情况下存在前驱关系，即缓冲区空时，只能先生产再消费；缓冲区满时，只能先消费再生产；<br>    使用的信号量：<br>        互斥信号量：<br>            mutex，用于缓冲区的互斥访问；<br>        同步信号量：<br>            full，标识缓冲区中是否有商品，对应前驱关系：生产-&gt;消费；<br>            empty，标识缓冲区是否有空位，对应前驱关系：消费-&gt;生产；<br>    解决方案1：使用记录型信号量<br>        相关代码在最后；<br>        注意事项：<br>            1）wait(mutex)和signal(mutex)成对出现；<br>            2）wait(full)和signal(full)在消费者和生产者之间成对出现；<br>            3）wait(empty)和signal(empty)在生产者和消费者之间成对出现；<br>            4）注意mutex、empty、full的初始化；<br>            5）<strong>一种约定成俗</strong>对互斥变量的操作写在最靠近对临界资源的访问的位置；<br>    解决方案2：使用AND型信号量<br>        相关代码在最后；<br>        注意事项：<br>            1）注意Swait、Signal的使用方法</p><p>生产者消费者问题：记录型信号量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ini：</span></span><br><span class="line"><span class="type">int</span> mutex = <span class="number">1</span>;<span class="comment">//互斥访问缓冲区</span></span><br><span class="line"><span class="type">int</span> empty = n;<span class="comment">//可用的空位</span></span><br><span class="line"><span class="type">int</span> full = <span class="number">0</span>;<span class="comment">//可用的商品</span></span><br><span class="line"><span class="type">int</span> in,out = <span class="number">0</span>;<span class="comment">//初始指针；</span></span><br><span class="line">Array buffer[n];<span class="comment">//缓冲区0～n-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//生产者</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    wait(empty);</span><br><span class="line">    wait(mutex);</span><br><span class="line">    buffer[in] = product;</span><br><span class="line">    in = (in+<span class="number">1</span>) mod n;</span><br><span class="line">    signal(mutex);</span><br><span class="line">    signal(full);</span><br><span class="line">    <span class="keyword">if</span>(stop)<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费者</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    wait(full);</span><br><span class="line">    wait(mutex);</span><br><span class="line">    product = buffer[out];</span><br><span class="line">    out = (out+<span class="number">1</span>)mod n;</span><br><span class="line">    siganl(mutex);</span><br><span class="line">    signal(empty);</span><br><span class="line">    </span><br><span class="line">    consume(product);</span><br><span class="line">    <span class="keyword">if</span>(stop)<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>生产者消费者问题：AND型信号量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ini：</span></span><br><span class="line"><span class="type">int</span> mutex = <span class="number">1</span>;<span class="comment">//互斥访问缓冲区</span></span><br><span class="line"><span class="type">int</span> empty = n;<span class="comment">//可用的空位</span></span><br><span class="line"><span class="type">int</span> full = <span class="number">0</span>;<span class="comment">//可用的商品</span></span><br><span class="line"><span class="type">int</span> in,out = <span class="number">0</span>;<span class="comment">//初始指针；</span></span><br><span class="line">Array buffer[n];<span class="comment">//缓冲区0～n-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//生产者</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    Swait(empty,mutex);</span><br><span class="line">    buffer[in] = product;</span><br><span class="line">    in = (in+<span class="number">1</span>) mod n;</span><br><span class="line">    Ssiganl(full,mutex);</span><br><span class="line">    <span class="keyword">if</span>(stop)<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费者</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    Swait(full,mutex);</span><br><span class="line">    product = buffer[out];</span><br><span class="line">    out = (out+<span class="number">1</span>) mod n;</span><br><span class="line">    Ssignal(empty,mutex);</span><br><span class="line">    consume(product);</span><br><span class="line">    <span class="keyword">if</span>(stop)<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>哲学家进餐问题：<br>    背景：<br>        哲学家与筷子：<br>            1）5个哲学家围成一圈，进行吃饭和思考；<br>            2）相邻哲学家之间有一支筷子，一共有5支筷子；<br>            3）哲学家吃饭的时候要拿起与自己相邻的两只筷子；<br>            4）哲学家吃饭和思考交替进行；<br>    存在的问题：<br>        1）进程互斥：筷子是公共资源，不能同时访问；<br>        2）局部资源：只有一支筷子不能进餐，需要避免所有人都获得部分资源而不释放，造成死锁的情况；<br>    使用的信号量：<br>        1）互斥信号量：<br>            chpsitck[i]，对应第i支筷子的互斥信号量<br>    解决方案1：<br>        记录型信号量，至多4位哲学家拿起左边的筷子；（<strong>破坏环路等待</strong>）<br>        需要额外使用的信号量：<br>            互斥信号量：conut，左边的筷子最多同时被四个进程访问；<br>            （相当于抽象了一个资源数量为4的临界资源，这个操作的逻辑要互斥锁来实现）；<br>    解决方案2：<br>        AND型信号量；（<strong>破坏请求和保持</strong>）<br>    解决方案3：<br>        记录型信号量，区分奇偶编号，奇数哲学家先拿左边的筷子，偶数哲学家先拿右边的筷子；（<strong>破坏环路等待</strong>）<br>    注意事项：<br>        1）访问左边筷子与右边筷子的下标（i与i+1）；<br>        2）一定要拿到左右筷子之后才能吃饭；<br>    解决方案4：<em>25年试题上出现的方案</em><br>        哲学家在获取资源的时候先对资源使用MIN、MAX排序，按顺序拿；（<strong>破坏环路等待</strong>）</p><p>解决方案1:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ini</span></span><br><span class="line"><span class="type">int</span> count = <span class="number">4</span>;</span><br><span class="line"><span class="type">int</span> chopstick[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="comment">//第i个哲学家</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    wait(count);</span><br><span class="line">    wait(chopstick[i]);<span class="comment">//左边的筷子;</span></span><br><span class="line">    wait(chopstick[i+<span class="number">1</span>]);<span class="comment">//右边的筷子</span></span><br><span class="line">    eat();</span><br><span class="line">    signal(chopstick[i+<span class="number">1</span>]);</span><br><span class="line">    signal(chopstick[i]);</span><br><span class="line">    signal(chop)</span><br><span class="line">    siganl(count);</span><br><span class="line">    think();</span><br><span class="line">    <span class="keyword">if</span>(stop)<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决方案2:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ini</span></span><br><span class="line"><span class="type">int</span> chopstick[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="comment">//第i个哲学家</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    Swait(chopstick[i],chopstick[i+<span class="number">1</span>]);</span><br><span class="line">    eat();</span><br><span class="line">    Ssignal(chopstick[i],chopstick[i+<span class="number">1</span>]);</span><br><span class="line">    think();</span><br><span class="line">    <span class="keyword">if</span>(stop)<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决方案3:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ini</span></span><br><span class="line"><span class="type">int</span> chopstick[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(i mod <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">        wait(chopstick[i+<span class="number">1</span>]);</span><br><span class="line">        wait(chopstick[i]);</span><br><span class="line">        eat();</span><br><span class="line">        signal(chopstick[i]);</span><br><span class="line">        signal(chopstick[i+<span class="number">1</span>]);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        wait(chopstick[i]);</span><br><span class="line">        wait(chopstick[i+<span class="number">1</span>]);</span><br><span class="line">        eat();</span><br><span class="line">        signal(chopstick[i+<span class="number">1</span>]);</span><br><span class="line">        signal(chopstick[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    think();</span><br><span class="line">    <span class="keyword">if</span>(stop)<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读者写者问题：<br>    问题背景：<br>        1）读者进程，可以读取数据文件；<br>        2）写者进程，可以写入数据文件；<br>    存在问题：<br>        1）多个读者进程可以同时访问；<br>        2）只要有一个写者进程访问，其他读者进程、写者进程就不能访问；<br>    解决方案1:<br>        1）维护一个写锁write；<br>        2）写进程获取write的时候其他进程都只能等待；<br>        3）读进程获取到write的时候，其他读进程可以访问临界区，写进程需要等待；<br>            1）维护读者计数器reader_count，表示当前在读进程；<br>            2）只需要检查reader_count的情况就可以判断当前是否有读进程在工作；<br>            3）如果有读进程在工作，其他读进程可以直接访问临界区；<br>            4）对于reader_count作为公共资源，也需要一个锁来控制；<br>            （注意reader_count的维护，意味着对于读者进程来说，第一个开始读的进程要负责获取到write，最后一个读完的进程要负责释放write）<br>        存在的问题：<br>            1）读者优先；<br>            2）可以看作读者和写者都在一个队列上；<br>            3）但是只要前面有读者，那么新来的读者就会插队到写者的前面；<br>    解决方案2：<br>        1）在解决方案1的基础上维护一个排队排队信号量prior，放在开始；<br>        2）无论读者写者，获得这个信号量才能往下执行；<br>        3）这样在写者持有prior的时候读者就不能直接增加reader_count，导致“插队”了；<br>        存在的问题：<br>            1）读写平等；<br>            2）大多数情况下写意味着更高的权限，所以应该是写者优先，而不应该是平等；<br>    解决方案3:<br>        1）在解决方案2的基础上维护一个写者计数writer_count；<br>        2）如果有写者获得了prior的排队权，那么后面的写者可以直接排队；<br>        3）第一个写者等待prior，最后一个写者释放prior；<br>        4）读者必须要等待到prior才能开始排队；</p><p>解决方案1:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ini:</span></span><br><span class="line"><span class="type">int</span> mutex = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> reader_count = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> write = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//reader:</span></span><br><span class="line"><span class="comment">//我写的这种似乎有点问题，因为要访问reader_count的值都应该在获取到mutex之后；</span></span><br><span class="line"><span class="comment">//就好像没有拿到锁就直接读取了文件数据</span></span><br><span class="line"><span class="comment">// while(1)&#123;</span></span><br><span class="line"><span class="comment">//     if(reader_count &gt; 0)&#123;</span></span><br><span class="line"><span class="comment">//         wait(mutex);</span></span><br><span class="line"><span class="comment">//         reader_count++;</span></span><br><span class="line"><span class="comment">//         signal(mutex);</span></span><br><span class="line"><span class="comment">//         read_file();</span></span><br><span class="line"><span class="comment">//         wait(mutex);</span></span><br><span class="line"><span class="comment">//         reader_count--;</span></span><br><span class="line"><span class="comment">//         signal(mutex);</span></span><br><span class="line"><span class="comment">//     &#125;else&#123;</span></span><br><span class="line"><span class="comment">//         wait(write);</span></span><br><span class="line"><span class="comment">//         wait(mutex);</span></span><br><span class="line"><span class="comment">//         reader_count++;</span></span><br><span class="line"><span class="comment">//         signal(mutex);</span></span><br><span class="line"><span class="comment">//         read_file();</span></span><br><span class="line"><span class="comment">//         wait(mutex);</span></span><br><span class="line"><span class="comment">//         readr_count--;</span></span><br><span class="line"><span class="comment">//         signal(mutex);</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//     if(readr_count==0)</span></span><br><span class="line"><span class="comment">//         signal(write);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//reader:（教材上的写法）</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    wait(mutex);</span><br><span class="line">    <span class="keyword">if</span>(reader_count == <span class="number">0</span>)</span><br><span class="line">        wait(write);</span><br><span class="line">    reader_count++;</span><br><span class="line">    signal(mutex);</span><br><span class="line">    read_file();</span><br><span class="line">    wait(mutex);</span><br><span class="line">    reader_count--;</span><br><span class="line">    <span class="keyword">if</span>(reader_count == <span class="number">0</span>)</span><br><span class="line">        signal(write);</span><br><span class="line">    signal(mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//writer:</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    wait(write);</span><br><span class="line">    write_file();</span><br><span class="line">    signal(write);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决方案2:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ini:</span></span><br><span class="line"><span class="type">int</span> reader_count = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> write = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> mutex = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> prior = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//reader:</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    wait(prior);</span><br><span class="line">    wait(mutex);</span><br><span class="line">    <span class="keyword">if</span>(reader_count == <span class="number">0</span>)</span><br><span class="line">        wait(write);</span><br><span class="line">    reader_count++;</span><br><span class="line">    signal(mutex);</span><br><span class="line">    signal(prior);</span><br><span class="line"></span><br><span class="line">    read_file();</span><br><span class="line">    wait(mutex);</span><br><span class="line">    reader_count--;</span><br><span class="line">    <span class="keyword">if</span>(reader_count == <span class="number">0</span>)</span><br><span class="line">        signal(write);</span><br><span class="line">    signal(mutex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//writer:</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    wait(prior);</span><br><span class="line">    wait(write);</span><br><span class="line">    write_file();</span><br><span class="line">    signal(write);</span><br><span class="line">    signal(prior);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//prior释放的位置应该比较随意，只要确保，wait(prior)和signal(prior)将wait(write)和reader_count++包裹了就好；</span></span><br><span class="line"><span class="comment">//wait(write)理解为排队，那么prior就是来防止插队的，reade_count++就是在插队，所以要将其获取给包裹起来；</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>解决方案3</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ini:</span></span><br><span class="line"><span class="type">int</span> reader_count = <span class="number">0</span>,writer_count = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> reader_mutex = <span class="number">1</span>,writer_mutex = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> prior = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> writer = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//reader:</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    wait(prior);</span><br><span class="line">    wait(reader_mutex);</span><br><span class="line">    <span class="keyword">if</span>(reader_count == <span class="number">0</span>)</span><br><span class="line">        wait(write);</span><br><span class="line">    reader_count++;</span><br><span class="line">    signal(reader_mutex);</span><br><span class="line">    read_file();</span><br><span class="line">    signal(prior);</span><br><span class="line">    wait(read_mutex);</span><br><span class="line">    reader_count--l</span><br><span class="line">    <span class="title function_">if</span><span class="params">(reader_count == <span class="number">0</span>)</span></span><br><span class="line">        <span class="title function_">signal</span><span class="params">(write)</span>;</span><br><span class="line">    signal(read_mutex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//writer:</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    wait(writer_mutex);</span><br><span class="line">    <span class="keyword">if</span>(writer_count == <span class="number">0</span>)</span><br><span class="line">    <span class="comment">//&#123;</span></span><br><span class="line">        wait(prior);</span><br><span class="line">        <span class="comment">//wait(write);</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    writer_count++;</span><br><span class="line">    signal(writer_mutex);</span><br><span class="line">    wait(write);<span class="comment">//注意writer优先获取的只是排队权；注释掉的逻辑其实是一个写者有了write，其他也可以写，这显然错误；</span></span><br><span class="line">    write_file();</span><br><span class="line">    signal(write);</span><br><span class="line">    wait(writer_mutex);</span><br><span class="line">    write_count--;</span><br><span class="line">    <span class="keyword">if</span>(write_count == <span class="number">0</span>)</span><br><span class="line">        signal(prior);</span><br><span class="line">    signal(wirter_mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><h3 id="进程通信的类型"><a href="#进程通信的类型" class="headerlink" title="进程通信的类型"></a>进程通信的类型</h3><p>进程通信的含义：<br>    <strong>高效大量且方便（透明）</strong>的进程之间消息交换；<br>    eg：<br>        进程同步（可以看作一种低级的信号机制，信号量机制就是一种简单的消息，并且<strong>不透明</strong>，用户感知得到，并且需要用户操作；并发时手动上锁belike）</p><p>进程通信的类型：<br>    共享存储器系统：<br>        1）基于共享数据结构的通信方式；<br>        （低效、适合少量数据传输，程序员手动管理）<br>        2）基于共享存储区的通信方式；<br>        （高级，进程通过对存储区数据的读写来进行通信）<br>    管道系统：<br>        首创于UNIX，一切皆文件的思想；<br>        管道：<br>            一个共享文件（pipe文件），用来连接一个发送进程和一个接收进程，实现通信；<br>        管道的性质：<br>            1）互斥，一个进程读写管道，其他进程必须等待；<br>            2）同步，发送进程，写入一定数量后就会阻塞自己，接收进程接收后再唤醒；接收进程遇到空管道会阻塞，等待有内容后再唤醒；<br>            3）可靠性，双方都确认对方存在再通信；<br>        （管道的性质机制由管道自己控制，不由通信双方控制，满足透明性）<br>        消息传递系统：<br>            进程不借助任何共享存储区或数据结构，使用message格式数据进行交换，由OS提供通信命令；<br>            方式：<br>                1）直接通信方式：直接消息传递系统；<br>                    方法：OS提供相关原语；<br>                        1）Send(Receiver,message);<br>                        2）Receive(Sender,message);<br>                2）间接通信方式：信箱通信；<br>                    方法：通过共享数据结构——信箱，用消息暂存的方式实现通信；<br>                        1）信箱创建、撤销；<br>                        2）发送原语：send(receiver,a);&#x2F;&#x2F;a是发送区地址；<br>                        3）接收原语：receive(b);&#x2F;&#x2F;b是接收区地址</p><h3 id="线程的基本概念和实现方式"><a href="#线程的基本概念和实现方式" class="headerlink" title="线程的基本概念和实现方式"></a>线程的基本概念和实现方式</h3><p>引入线程的原因：<br>    使用进程效率太低了：<br>        1）进程独立拥有资源，创建消亡的时候需要分配和回收进程；<br>        2）进程切换需要CPU保存状态代价巨大；<br>    如果不独立分配资源呢？<br>        共享资源依赖于进程通信，依然很复杂，就像我们上一节讨论的一样；</p><p>线程：<br>    <strong>线程 &#x3D; 进程-共享资源</strong>；<br>    线程的特性：<br>        1）实体之间并发地执行；<br>        2）实体之间共享相同的地址空间；<br>    与进程的关系：<br>        1）资源与调度；<br>            1）引入线程后，进程最主要的作用是将一组相关的资源组合起来，形成资源平台（代码段、数据段、打开文件的操作），线程就是进程中真正执行的流程；<br>            2）所以，<strong>资源分配&#x2F;调度 的基本单位：进程&#x2F;线程</strong><br>            3）但是线程还是必须持有必不可少的，保证独立运行的资源；<br>                eg：TCB（线程控制模块）、PC、保留局部变量、状态参数以及返回地址的一组寄存器和堆栈；<br>                （这些就像进程在堆栈中动态分配时所需要的，只是免去了大量的静态资源）；<br>        2）并发性：<br>            1）支持多线程的OS中，同一进程不同线程可以并发；<br>            2）多CPU系统中，单进程多线程可以多核并发；<br>        3）独立性：<br>            1）进程和进程之间独立；<br>            2）线程和线程之间不独立；<br>        4）系统开销：<br>            1）进程切换开销大，线程切换开销小；<br>            2）进程通信开销大，同一进程不同线程通信开销小。<br>        5）安全性：<br>            1）只使用进程更安全，在使用线程的时候一个线程崩溃，会导致整个进程崩溃；<br>        6）高效性：<br>            1）使用线程更加高效，可以减少并发执行的时间和空间；<br>            （线程的并发可以在很多情况下代替从前需要进程并发执行的工作）<br>            eg：<br>                MP3播放软件，三个核心模块（从MP3中读取数据、解压数据、将解压后的数据转换为音频数据播放）</p><p>线程的状态：<br>    三个基本状态：执行、就绪、阻塞；<br>    TCB：线程控制模块</p><p>操作系统角度看线程：<br>    等价概念：<br>        1）传统的进程——单线程方法；<br>        eg：传统的UNIX；<br>        2）每个进程支持多个线程——多线程方法；<br>        eg：Windows2000<br>    如何看待进程：<br>        进程是拥有资源的基本单位，是一个不可执行的实体，进程的状态是线程执行的状态；</p><p>线程的实现方式：<br>    1）内核支持线程KST；<br>        内核完成线程的管理；<br>    2）用户级线程ULT；<br>        一组用户级的线程库函数，帮助用户自己管理线程的管理；<br>    3）组合方式ULT&#x2F;KST；</p><h2 id="处理机调度"><a href="#处理机调度" class="headerlink" title="处理机调度"></a>处理机调度</h2><h3 id="处理机调度的层次和调度算法的目标"><a href="#处理机调度的层次和调度算法的目标" class="headerlink" title="处理机调度的层次和调度算法的目标"></a>处理机调度的层次和调度算法的目标</h3><p>处理机调度：<br>    含义：采用一定的算法从就绪队列中，选择一个作业&#x2F;进程，让CPU执行它；<br>    （本质就是面对大量作业&#x2F;进程，如何将有限的CPU合理地分配给它们使用）<br>    层次：<br>        1）高级调度<br>            别名：作业调度、长程调度；<br>            调度对象：作业；<br>            适用的操作系统：多道批处理系统；（单道、分时中没有）；<br>            发生的时机：在一批作业已运行完毕退出，需要将一批新的作业调入<strong>内存</strong>的时候；<br>            特点：<strong>运行频率较低、允许较复杂；</strong><br>        2）中级调度<br>            别名：内存调度（挂起和激活，对应存储器管理那一块）；<br>            调度对象：进程；<br>            发生的时机：<br>                1）内存紧张的时候，将暂时不能运行的进程调至外存；<br>                2）内存空闲的时候，将具备运行条件的进程重新调入内存；<br>            特点：运行频率适中，算法复杂度适中；<br>        3）低级调度<br>            别名：进程调度、短程调度；<br>            调度对象：进程（内核级线程）；<br>            使用操作系统：多道批处理、单道、分时都有；<br>            发生的时机：决定<strong>就绪队列中</strong>哪个进程获得<strong>处理机</strong>；<br>            特点：<strong>运行频率非常高，不允许很复杂；</strong><br>        从进程调状态看调度层次：<br>            <img src="https://raw.githubusercontent.com/Yes-ys/blog-images/main/OS/p1.png" alt="处理机调度层次"><br>    目标：<br>        批处理系统：<br>            平均周转时间短、系统吞吐量高、处理机利用率高；<br>                相关概念：<br>                    周转时间：<br>                        1）作业提交给OS的时间到作业完成的时间；<br>                        2）作业在后备队列的时间+作业在就绪队列的等待时间+作业在阻塞队列的等待时间+作业的执行时间；<br>                    平均周转时间：<br>                        1）周转时间按照作业数量平均；<br>                    带权周转时间：<br>                        1）针对一个作业；<br>                        2）作业周转时间&#x2F;作业获得CPU的时间（执行时间）；<br>                    平均带权周转时间：<br>                        带权周转时间按照作业数量平均；<br>                    系统吞吐量：<br>                        单位时间内系统完成的作业数；<br>        分时系统：<br>            响应时间快、均衡性好；<br>                注意：<br>                    均衡性对应根据任务的复杂度不同，等待的容忍度不同；<br>                        1）复杂任务允许等待时间长；<br>                        2）简单任务允许等待时间短；<br>                （买15个煎饼果子的人愿意等买1个多，反之不然）；<br>        实时系统：<br>            截止时间的保证、可预测性；<br>        共同目标：<br>            1）资源利用率：CPU利用率 &#x3D; CPU有效工作时间&#x2F;(CPU有效工作时间+CPU空闲等待时间)<br>                （计算量大的作业越多，即长作业越多，上下文切换的工作量会减少，CPU利用率越高）<br>            2）公平性：每个进程都应该获得合理的CPU时间，不会发生进程饥饿现象；<br>            3）平衡性：CPU和I&#x2F;O设备都能经常处于忙碌状态，系统资源使用平衡；<br>            4）策略强制执行；</p><h3 id="作业与作业调度"><a href="#作业与作业调度" class="headerlink" title="作业与作业调度"></a>作业与作业调度</h3><p>作业：<br>    定义：<strong>程序+数据+作业说明书</strong>；<br>        1）作业是从外存调入内存的基本单位；<br>        2）调入之前称为作业，调入之后就是进程；<br>    作业步：<br>        编译-链接装配-运行；<br>        （调入之前必要的步骤）<br>    作业控制块：JCB；<br>    作业多三个阶段和三种状态：<br>        1）收容阶段：<br>            1）对应后备状态；<br>            2）系统把用户提交的作业放入硬盘，建立JCB，放入后备队列；<br>        2）运行阶段：<br>            1）对应运行状态；<br>            2）作业被选中，为其分配资源，<strong>建立进程</strong>，进入就绪队列；<br>            3）从第一次进入就绪队列到运行完毕，都属于运行阶段（状态）；<br>        3）完成阶段：<br>            1）对应完成状态；<br>            2）系统回收资源和JCB；<br>            3）作业结果形成输出文件后输出；</p><p>作业调度：<br>    挑战：作业数量多少的平衡；<br>        1）如果数量少，并行（发？）效率低，CPU利用率低；<br>        2）如果数量多，中断多，上下午切换频繁，CPU利用率低；<br>    相关算法：<br>        1）FCFS先来先服务算法<br>            思想：谁先来，先服务；<br>            特点：有利于长作业，不利于短作业；长作业愿意等短作业，反之不然；<br>            相关计算：<br>                1）到达时间（给定）；<br>                2）服务时间（给定）；<br>                3）开始执行时间（上一个进程的的完成时间）；<br>                4）完成时间（开始执行时间+服务时间）；<br>                5）周转时间（完成时间-到达时间）；<br>                6）带权周转时间（周转时间&#x2F;服务时间）；<br>            eg：<br>                <img src="https://raw.githubusercontent.com/Yes-ys/blog-images/main/OS/p2.png" alt="FCFS例题">；<br>        2）SJF短作业优先算法<br>            思想：作业越短优先级越高；<br>            特点：利于短作业，长作业可能会出现饥饿现象；<br>        3）PSA优先级调度算法<br>            思想：基于作业等紧迫程度，外部赋予作业优先级；<br>            类型：静态优先级、动态优先级；<br>            动态优先级算法：<br>                高响应比优先算法(HRRN)：<br>                    <strong>优先权 &#x3D; (等待时间+要求服务时间)&#x2F;要求服务时间;</strong><br>                特点：<br>                    1）等待时间相同，要求服务时间越短优先权越高，有利于短作业；<br>                    2）要求服务时间相同，长作业随着等待时间越长，优先权增大，不会让其出现饥饿现象；</p><h3 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h3><p>进程调度实现的关键机制：<br>    1）排队器：<br>        1）按照策略将进程分为一个或多个队列；<br>        2）排出就绪队列；<br>    2）分派器：<br>        1）按照策略从队列中选出特定的进程；<br>        2）是从就绪队列中选；<br>    3）上下文切换：<br>        1）切换的时候不只要保存执行的进程还要保存分派器的进程；<br>        2）主要是对PCB与相关寄存器的操作；</p><p>进程调度的方式：<br>    1）非抢占式调度；<br>        一旦CPU分配个某个进程，就一直运行它；<br>        发生调度的原因：<br>            1）进程执行完毕；<br>            2）I&#x2F;O请求；<br>            3）wait、block、wakeup等系统调用；<br>            4）其他不能继续执行的原因；<br>    2）抢占式调度：<br>        按照某种原则暂停当前进程，执行另一个；<br>        常见抢占原则：<br>            1）优先权；<br>            2）短进程抢占长进程；<br>            3）时间片原则；<br>        抢占的实现机制：<strong>中断</strong></p><p>进程调度算法：<br>    1）轮转调度算法：<br>        1）系统将就绪进程按先来先服务排成队列；<br>        2）每次调度将CPU按一个时间片分给队首进程；<br>        3）时间片完成，中断，更新队列（队首到队尾）<br>        4）重复上述步骤；<br>        注意：<br>            1）时间片大小选择很重要，过短有利于短作业但是上下文切换频繁，过长有利于长作业但是退化为FCFS；<br>            2）TIP：选择略大于一次典型交互所需的时间为时间片大小；<br>        <strong>计算：</strong><br>            1）RR Q时间片大小；<br>            2）其他关键量化值与作业调度中FCFS一样；<br>            3）计算的时候要注意时间片的切换；<br>            eg：<img src="https://raw.githubusercontent.com/Yes-ys/blog-images/main/OS/p3.png" alt="轮转调度算法">；<br>    2）优先级调度算法：<br>        1）静态；<br>        2）动态；<br>        注意：都不常用，因为进程调度追求简单；<br>    3）多级反馈队列调度算法：<br>        1）设置多个就绪队列（按优先级划分），<strong>优先级越高（队列序号小），获得时间片越小，反之越大</strong>；<br>        2）新进程进入系统后，放入第一个队列，按FCFS原则等待；<br>        3）进程在第i个队列的时间片执行完成，就放入i+1队列的队尾；<br>        4）当前面的队列为空的时候，从后面的队列进行调度（可以抢占式）；<br>        特点：<br>            1）性能较好；<br>            2）能满足各类用户需求，短进程在一两个时间片完成，长进程不用担心长期得不到处理；<br>    4）基于公平原则的调度算法<br>        1）保证调度算法：<br>            思想：系统中有n个进程，保证每个进程都获得处理机时间的1&#x2F;n；<br>            算法：<br>                1）计算每个进程自创建以来应该获得处理机的时间：<br>                    应获得处理机时间 &#x3D; 创建以来时间&#x2F;n；<br>                2）计算实际执行时间和应获得时间的比率：<br>                    实际执行时间&#x2F;应获得时间；<br>                3）选择比率值最小的调度获得时间片；<br>            注意：<br>                1）应获得处理机时间的n，要分段考虑，因为进程进入的时间不同，在前面的时间段不会考虑后面时间段才出现的进程；<br>                2）根据比率情况，可能有多个最小比率相等的，对应有多个应该最优先调度的进程。（这时实际的处理是随机选择一个）<br>            计算：<br>                <strong>哪个进程是当前应该优先调度的</strong>；<br>                eg：<img src="https://raw.githubusercontent.com/Yes-ys/blog-images/main/OS/p4.png" alt="保证调度算法"><br>            缺点：<br>                在每个用户拥有进程数不同的时候，按照保证调度的方法分配，对用户不公平；<br>        2）公平分享调度算法：<br>            思想：分别按照顺序，依次对不同用户的进程按照保证调度算法进行调度；<br>            eg：<br>                用户1有ABCD四个进程，用户2有E；<br>                则：A E B E C E D E调度；<br>            注意：<br>                当然根据一些具体的情况，可以设置轮到一个用户的时候允许调度的次数；<br>                eg：<br>                    用户1付了两倍的钱；<br>                    则A B E C D E调度；</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="死锁的基本概念"><a href="#死锁的基本概念" class="headerlink" title="死锁的基本概念"></a>死锁的基本概念</h3><p>死锁：<br>    含义：多个进程在运行过程中，因争夺资源而造成的一种僵局。当进程处于这种僵持状态时，如果没有外力作用，它们都无法再向前推进；<br>    死锁的例子：<br>        1）竞争不可抢占资源引起死锁；（P1持有R1，需要R2，P2持有R2，需要R1）<br>        2）竞争可消耗资源引起死锁；（P1消耗S1来制造S2，P2要消耗S2才能制造S1）<br>        3）不合理的有限资源分配引起死锁；<br>            <img src="https://raw.githubusercontent.com/Yes-ys/blog-images/main/OS/p5.png" alt="资源分配图1"><br>            <img src="https://raw.githubusercontent.com/Yes-ys/blog-images/main/OS/p6.png" alt="资源分配图2"></p><p>造成死锁的原因：<br>    四大必要条件：只有同时满足时，才会死锁；<br>        1）互斥条件：<br>            进程使用某资源的时候，不允许其他进程使用；<br>        2）请求和保持：请求保持了一个自己获得的资源，请求另一个资源的时候，无法获得，不释放自己的资源便进行阻塞；<br>        3）不剥夺条件：资源使用完之前，不允许剥夺，直至用完；<br>        4）环路等待条件（循环等待）：发生死锁，一定会有“进程-资源”的环形链；</p><p>处理死锁的方法：<br>    四种类型：对应的是不同的处理方法；<br>    1）预防死锁：<br>        设置限制条件，破坏四个条件中的一个或几个；<br>        问题：限制条件比较严格，会影响效率；<br>        eg：哲学家用餐问题，通过一定的规则确保一定不会出现死锁；<br>    2）避免死锁：<br>        按照一定条件动态分配资源时，防止系统推进过程中进入不安全状态；<br>        问题：实现较难；<br>        eg：银行家算法，天才的Dijkstra～<br>    3）检测死锁：<br>        不用任何限制条件，不检查系统是否进入安全区。允许死锁发生，使用机制及时检测；<br>    4）解除死锁：<br>        撤销或挂起一些进程，以便回收资源，再将其重新分配给陷入死锁的进程；<br>    （其中3、4一般是一起使用的）；</p><h3 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h3><p>依次考虑破坏四个必要条件：<br>    1）互斥条件：<br>        <strong>不可破坏</strong>：因为资源的互斥是非共享设备必须的属性，是OS的重点保护对象，所以不可破坏；<br>        （无法让一个打印机同时打印两份资料）<br>    2）请求和保持条件：<br>        1）协议一：运行前，必须一次性获得整个运行过程的所有资源；<br>            1）如果获得了，不再申请，破坏请求条件；<br>            2）只要一种不能获得，其他也不允许分配，破坏保持条件；<br>            问题：<strong>浪费资源，进程饥饿</strong>；<br>        2）协议二：进程获得初期的资源后开始运行，必须释放全部资源后才能申请新的；（这种比较难实现）<br>    3）不可抢占性（不剥夺）：<br>        1）当已经保持的某些不可抢占资源时，如果请求的新资源不能满足，则必须释放自己的不可抢占资源；<br>        问题：<br>            1）实现机制复杂，代价极大；<br>            2）有些不可抢占资源如果前段实效，后面的工作是无法继续的；<br>            （比如打印机，你不能要求它只打印一半）；<br>    4）环路等待条件（循环等待）<br>        1）对系统中的所有资源进行线性排序，对每个资源赋予唯一的一个序号，每个进程必须按照资源递增的顺序进行资源的获取；<br>        问题：<br>            1）如果系统有新增资源，排序无法稳定；<br>            2）资源的使用顺序和系统排序有出入时造成资源的浪费（没有意义的申请）；<br>            3）对用户不透明，破坏了虚拟化和共享，用户需要了解到资源编号才能正确编程；<br>    问题：<br>        <strong>总的来说，预防死锁添加的限制比较多，代价比较大</strong>；</p><h3 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h3><p>基本概念：<br>    避免死锁含义：按照一定条件动态分配资源，防止系统推进过程中进入不安全的状态；<br>    避免死锁实质：避免安全状态向不安全状态的转换；<br>    安全序列：<br>        系统能按某种进程的顺序，为各个进程分配所需的资源，分配时满足每个进程对资源的最大需求，最终每个进程都可以顺利完成。这这组进程顺序就是一个<strong>安全序列</strong>。<br>    系统安全状态：<br>        如果系统能够找到一个安全序列，则系统处于安全状态，否则系统处于不安全状态；<br>        （<strong>当我们考虑一个时刻系统是否安全的时候，实际上是考虑是否能够找到一个安全序列</strong>）</p><p>避免死锁的算法：银行家算法<br>    思想：<br>        用户申请一组资源的时候，系统首先判断如果把这些资源分配出去，系统是否处于安全状态。如果是则可以分配，如果不是则申请暂时不予满足；<br>    使用的数据结构：<br>        1）可用资源向量Available[1…m]：<br>            1）初始值是第1～m个资源的全部数量；<br>            2）系统运行过程中保存的是当前可用的数量；<br>        2）最大需求矩阵Max[1…n,1…m]<br>            1）Max[i,j]代表第i个进程对于第j个资源的<strong>最大</strong>需求量；<br>        3）已分配矩阵Allocation[1…n,1…m]<br>            1）Allocation[i,j]代表第i个进程对于第j个资源已经获得的数量；<br>            2）Allocation也可以称作Work<br>        4）需求矩阵Need[1…n,1…m]<br>            1）Need[i,j]代表第i个进程对于第j个资源还需要多少个；<br>        显然，根据定义上述数据满足：<br>            $Max[i,j] &#x3D; Allocation[i,j]+Need[i,j]$<br>    算法步骤：<br>        1）进程申请资源：<br>            进程i使用Request[j]向系统申请资源j<br>        2）合理性检查：<br>            系统检查Request[j]是否小于等于Need[i,j]，如果是则分配；否则认为进程申请了不必要的资源，拒绝；<br>        3）资源存量检查：<br>            系统检查Request[j]是否小于等于Allocation[j]，如果是则予以分配；否则系统认为资源存量不足以分配，进程必须等待；<br>        4）虚拟分配：<br>            将资源分配给该进程，更新数据结构：Available、Allocation、Need；<br>        5）安全性算法：<br>            检查此次资源分配后，系统是否处于安全状态。如果安全则<strong>真正分配</strong>，如果不安全则不予分配，进程必须等待；<br>    安全性算法：<br>        1）可以在任何时刻，根据Allocation(Work)、Need、Available、Max执行安全性算法，判断系统在当前时刻是否安全；<br>        2）<strong>主要是掌握表格的结构，有多种可用的表格结构，在最后展示一种我常用的；</strong><br>        3）注意有时候Need需要根据Max和Allocation进行推导，<strong>Max一般不用于表格中</strong>；<br>        4）Allocation+Available是比较特别但是必要的，代表该进程结束后，系统的可用资源情况，可以看作一个过渡的中间变量，其会作为考虑下一个进程时的Available；<br>        5）按照安全序列的定义，在寻找安全序列的时候有一定顺序，但是实际考察<strong>通常使用顺序执行</strong>；</p><p>银行家算法-安全性算法表格结构：</p><table><thead><tr><th>进程 \ 资源</th><th>Available(Work)</th><th>Need</th><th>Allocation</th><th>Available+Allocation</th><th>Finish</th></tr></thead><tbody><tr><td>P1</td><td>(1,2,3)</td><td>(0,0,1)</td><td>(1,1,1)</td><td>….</td><td>true</td></tr><tr><td>…</td><td>…</td><td>…</td><td>…</td><td>….</td><td>…</td></tr></tbody></table><p><em>老师推荐的也是这种表结构</em></p><h3 id="死锁的检测与解除"><a href="#死锁的检测与解除" class="headerlink" title="死锁的检测与解除"></a>死锁的检测与解除</h3><p>资源分配图（RAG）：用于检测死锁的工具；<br>    定义：RAG是一个有向图，其中的点集合V对应的是进程集合，边集合E对应的是资源集合；<br>    边点类型：<br>        1）分配边缘：由资源指向进程；<br>        2）请求边缘：由进程指向资源；<br>        （注意都是有向边）；<br>    具体表示：<br>        1）进程点，通常使用<strong>圆形</strong>；<br>        2）资源点，通常使用<strong>矩形</strong>，矩形中有点，点的数量代表<strong>资源的数量</strong>；<br>        3）分配边缘，由资源的<strong>点</strong>，指向具体的进程；<br>        4）请求边缘，由进程指向代表资源的<strong>矩形</strong>；</p><p>死锁检测：<br>    通过资源分配的化简，如果能化简则不存在死锁，如果不能化简则存在死锁；<br>    化简方法：<br>        1）在资源分配图中找到，一个仅持有资源，不请求资源点非孤立进程点；该进程持有所有必须的资源，可以正常执行，释放它持有的资源，将它变成孤立点；<br>        2）进行资源分配，将1）中释放的资源也纳入考虑，考虑当前剩余资源的数量，考虑分配给可以满足的进程；得到必须资源的进程，可以正常执行，释放它持有的资源，将它变成孤立点；<br>        3）重复1）、2），直到所有点都变成孤立点，则化简成功过；否则化简失败；<br>    应用：<br>        主要是合理地将进程和资源进行抽象，然后对对应到资源分配图的情况，考虑是否可以化简；<br>        eg：<img src="https://raw.githubusercontent.com/Yes-ys/blog-images/main/OS/p7.png" alt="资源分配图的应用">；</p><p>死锁解除算法：<br>    思想：按照某种顺序，逐个终止进程，知道拥有足够的资源，打破循环等待，将系统从死锁状态解除；<br>    问题：终止所有死锁进程代价巨大；<br>    选择终止进程的原则：<br>        1）进程优先级；<br>        2）进程已经执行的时间；<br>        3）进程已使用的资源和未来要使用的资源；<br>        4）进程是交互式还是批处理式；</p><h2 id="存储器管理-1"><a href="#存储器管理-1" class="headerlink" title="存储器管理"></a>存储器管理</h2><h3 id="存储器的层次结构"><a href="#存储器的层次结构" class="headerlink" title="存储器的层次结构"></a>存储器的层次结构</h3><p>内存和外存的区别：<br>1）易失？<br>2）容量<br>3）速度<br>4）CPU操作方式</p><p>存储器层次结构：<br>1）6个层次<br>    1）寄存器；<br>    2）高速缓存；<br>    3）主存储器；<br>    4）磁盘缓存；<br>    5）固定磁盘；<br>    6）可移动存储介质；<br>2）三种类别<br>    1）CPU：寄存器；<br>    2）Memory：高速缓存、主存储器、磁盘缓存；<br>    3）Storage：固定磁盘、可移动存储介质；<br>3）所在位置</p><p>高速缓存的作用？<br>    高速缓存介于寄存器和存储器之间，用于缓和CPU和内存之间的速度的矛盾；</p><p>磁盘缓存的作用？真实存在？<br>    作用：缓解内存和外存访问速度的差异；<br>    利用了虚拟技术在内存中开辟了磁盘缓存；</p><h3 id="程序的装入和链接"><a href="#程序的装入和链接" class="headerlink" title="程序的装入和链接"></a>程序的装入和链接</h3><p>源程序运行需要经过的步骤？<br>    1）编译：<br>        由编译程序对用户源程序进行编译，形成若干个目标模块；（.obj文件）<br>    2）链接：<br>        由链接程序将编译后的一组目标模块以及需要的库函数，链接在一起，形成完整的装入模块；（如果是静态链接，可以得到.exe文件）；<br>    3）装入：<br>        由装入程序将装入模块装入内存；</p><p>什么是装入？<br>    本质：将逻辑地址修改为物理地址；<br>    （源程序编译的时候使用的是逻辑地址空间，程序有从0开始的自己单独的地址空间）；</p><p>三种装入方式：<br>1）绝对装入（含义）<br>    程序员明确知道装入内存中的物理地址，整个程序用绝对地址编码；<br>2）可重定位装入（含义，运行时地址不变）<br>    程序从零地址开始编码，装入内存时将逻辑地址改为物理地址，一旦装入不能在内存中移动；<br>3）动态运行时的装入（含义，重定位寄存器作用）<br>    装入内存时不改变地址，运行时才将逻辑地址改成物理地址；<br>    （因为运行时每次都要计算物理地址，需要一个<strong>重定位寄存器</strong>来保障执行速度）；</p><p>什么是链接？<br>    将一组独立编址的目标文件合成一个统一编址的目标文件；</p><p>三种链接方式：<br>1）静态链接（含义，缺点）<br>    含义：事先将几个目标模块链接成一个装入模块，以后不再拆分；<br>    缺点：可共享的目标文件需要复制，形成多个副本，无法实现单个文件的共享；<br>2）装入时动态链接（含义，优点，缺点）<br>    含义：在装入的过程中，如果发现需要链接一个新的目标文件，则发生一个外部模块调用事件，将目标模块装入内存；<br>    优点：可以实现对于目标文件的共享；<br>    缺点：有的代码用不到，比如错误处理，类似很多分支的情况所有模块都要链接；<br>3）运行时动态链接（含义，优点）<br>    含义：运行的过程中需要哪个目标文件，就将哪个文件装入内存进行链接，运行无关的模块不装入也不链接；<br>    优点：节省空间，提高内存利用率，加速装入过程，支持共享；</p><h3 id="连续分配存储管理方式"><a href="#连续分配存储管理方式" class="headerlink" title="连续分配存储管理方式"></a>连续分配存储管理方式</h3><p>什么是连续分配？<br>    为一个进程分配连续的内存空间；</p><p>四种连续分配存储的方式：<br>1）单一连续分配（内存情况，缺点）<br>    内存情况：<br>        1）把内存分为系统区和用户区，前者给OS使用，后者给用户使用；<br>        2）OS可以存放在内存的两端（高地址 or 低地址区域）；<br>        3）每次仅允许放入一个进程；<br>    缺点：<br>        1）每次只能有一个程序进入内存，内存利用率低，工作效率低；<br>        2）如果程序所需内存必用户区大，则不能运行；<br>        3）只适用于单道OS；<br>2）固定分区分配（分区相等、分区不等；内存情况，缺点）<br>    内存情况：<br>        把内存划分为一些大小固定的分区，每个进程可以使用一个分区，实现并发；<br>        1）大小相等的分区；<br>        2）大小不等的分区；<br>    内存分配：<br>        1）每次从头到尾检查分区，如果分区大小满足进程需要，则分配给进程；<br>        2）分配出去的分区就是已分配状态，不再空闲（即使里面有没有使用的内存）；<br>    缺点：<br>        1）如果大小相等，那么十分不灵活；<br>        2）固定分区分配浪费较大；<br>3）动态分区分配（空闲分区表 or 链）；<br>    使用的数据结构：<br>        1）空闲分区表：<br>            1）只记录空闲分区；<br>            2）起始地址、长度、标志（未分配）；<br>        2）空闲分区链：<br>            将所有的空闲分区表链接成一个双向链表；<br>    算法：<br>        1）首次适应算法：内存情况，最小不可分区域，优点，缺点<br>            1）以地址递增次序查找空闲分区；<br>            2）找到第一个满足请求大小的分区，从中<strong>划出</strong>请求大小的空间，余下仍然留在空闲分区中；<br>            缺点：<br>                低地址不断被划分，会留下很多难以利用的小空闲分区，下次查找会浪费时间；<br>        2）循环首次适应算法：内存情况，查找指针，优点，缺点<br>            1）从上次找到的空闲分区的下一个空闲分区查找；<br>            2）需要设置查找指针，来指示下次从哪开始找；<br>        3）最佳适应算法：内存情况，分后排序<br>            1）找到能满足分配的最小空闲分区；<br>            2）每次分配之后对空闲分区按照从小到大（递增顺序）进行排序；<br>            缺点：<br>                每次分割下的空闲分区总是最小的，难以利用；<br>        4）最坏适应算法：内存情况，分后排序；<br>            1）找到能满足分配的最大空闲分区；<br>            2）每次分配之后对空闲分区按照从大到小（递减顺序）进行排序；<br>            缺点：<br>                缺乏较大的空闲分区；<br>        5）回收合并（4种相邻情况）<br>            当一个进程终止时，OS会回收它所占用且未释放的所有空间，以便供其他请求者使用；<br>            回收时四种邻接情况：<br>                1）回收区与插入的前一个空闲分区相邻；<br>                2）与后一个相邻；<br>                3）与前后两个空闲分区相邻；<br>                4）前后都没有相邻的；<br>                关键：如果有相邻的，回收了之后得到的新空闲区要和相邻的合并；<br>        6）伙伴系统（判断前一块 or 后一块）<br>4）动态可重定位分区分配（与动态分区分配的区别）<br>    1）主要是针对前面的连续分配算法，会在完成一系列分配任务之后，让系统只剩下若干小的分区，即使这些分区总和大于程序，也无法分配；<br>    2）该算法能够<strong>紧凑</strong>，即，将各程序（前面已经分配了空间的程序）移动位置并拼凑到一起，从而使小分区组成大分区；</p><h3 id="对换"><a href="#对换" class="headerlink" title="对换"></a>对换</h3><p>对换的含义</p><p>两种对换方式：<br>1）整体对换（含义）<br>2）部分对换（含义）</p><p>文件区与对换区：作用、区别</p><h3 id="分页存储管理方式"><a href="#分页存储管理方式" class="headerlink" title="分页存储管理方式"></a>分页存储管理方式</h3><p>进程逻辑地址空间、内存物理地址空间，分页（块）处理<br>（页大小与块大小一致，通常前者划分称页、后者划分称块）</p><p>页面小～大，优点、缺点</p><p>地址结构：页号、位移量；计算</p><p>页表：内容？给谁建立？建立的时机？保存的位置？用什么找到页表？</p><p>地址变化机构：<br>    作用？重定位；<br>    操作过程，无快表（两次访问内存）<br>    快表，使用方式</p><h3 id="分段存储管理方式"><a href="#分段存储管理方式" class="headerlink" title="分段存储管理方式"></a>分段存储管理方式</h3><p>分段与分页的区别（划分依据？大小固定？地址空间维度？）</p><p>分段的优势（支持共享）</p><p>地址结构：段号、偏移量</p><p>段表：内容？</p><p>地址变换过程（两次访问内存）</p><p>段页式存储：<br>    如何划分<br>    地址结构<br>    地址变换过程（3次访问内存，2维地址空间）</p><h2 id="虚拟存储管理"><a href="#虚拟存储管理" class="headerlink" title="虚拟存储管理"></a>虚拟存储管理</h2><h3 id="虚拟存储器概述"><a href="#虚拟存储器概述" class="headerlink" title="虚拟存储器概述"></a>虚拟存储器概述</h3><p>为什么要引入虚拟存储管理？<br>    常规存储管理要求一次性和驻留性，这对于作业很大、很多作业需要同时执行的场景是有问题的，并且与局部性原理相矛盾；<br>    一次性，即程序一次性装入内存；驻留性，即程序运行期间一直被保存在内存中；<br>    局部性原理<br>        时间局部性：某条指令，该指令及其上下指令很可能再次被访问<br>        空间局部性：一旦程序访问了某个存储单元，这不久后附近的存储单元也将被访问</p><p>虚拟存储器的定义？<br>    功能描述上来说：虚拟存储技术允许程序、数据、堆栈能够超过内存大小，用户程序可以在自己感知到的充足的空间下运行；<br>    具体实现来说：但实际的内存没有那么大的空间，而是通过“常规分页（段）存储器+请求调入功能+置换功能”实现了虚拟存储器<br>        当有了虚拟存储之后，CPU访问对应的内存单元，会将地址发送给MMU（由MMU将虚拟地址翻译为物理地址，并进行缺页处理等操作，再供CPU访问）<br>        而不是直接将地址送到内存地址总线上进行访问</p><p>虚拟存储的逻辑容量：内存容量+外部扩充的存储量<br>    其最大容量是由计算机的地址结构决定的（总线位数）</p><p>虚拟存储器的优点：<br>    让程序足以执行的充足空间<br>    为每个用户建立一个虚拟存储器，每个用户可以在自己的地址空间中编程</p><p>虚拟存储器的实现方式：<br>    请求分页系统：硬件（页表、缺页中断机构、地址变换机构）；软件（请求调页、页置换）<br>    请求分段系统：硬件（段表、缺段中断机构、地址变换机构）；软件（请求调段、段置换）<br>    虚拟段页系统</p><h3 id="请求分页存储管理方式"><a href="#请求分页存储管理方式" class="headerlink" title="请求分页存储管理方式"></a>请求分页存储管理方式</h3><p><code>上面三个虚拟存储器中，我们重点了解请求分页系统</code></p><p>页表（PT）<br>    入参：虚拟页号（VPN）<br>    输出：物理页号（PPN）<br>    页表项（PTE）<br>        页号：物理块号：状态位P：访问字段A：修改位M：外存地址<br>            P，该页是否调入内存<br>            A，该页在一定时间内的被访问次数<br>            M，该页调入内存后是否被修改过<br>            外存地址，该页在外存上的地址</p><p>缺页中断机构（由硬件支持）<br>    处理流程：<br>        1）访问页面不在内存中；2）产生缺页中断；3）保存现场；4）分析中断原因；5）转入中断处理程序；6）调入页面<br>    缺页中断与一般的中断不同：<br>        其是在指令执行的过程中产生和处理中断信号；而不同于一般的中断是在每次指令之后检测是否有中断；<br>        一次指令执行可能产生多次缺页中断；<br>        交换操作：<br>            缺页中断除了保护现场以外还需要判断内存中是否有足够的存储空间来保存所需的段或页，然后再调入内存，否则需要执行交换操作；<br>            而一般的只需要保护现场；<br>        返回位置：缺页中断返回时，执行产生中断的当前指令（保存返回地址的时候是当前指令的地址）；一般的是执行下一条<br>        <em>相关操作会对页表进行对应的修改，如果有块表的话会同步地修改块表</em>；</p><p>地址变换机构的工作流程<br>    页命中<br>        1）CPU生成虚拟地址VA；2）VA给到MMU，查询到对应的页表项地址PTEA给到CPU；3）CPU读取PTE，给到MMU；4）MMU将PTE中的物理页框号（PPN）复制到寄存器高位，并将PTE中的偏移量（VPO）复制到寄存器低位，构成物理地址，供CPU访问；5）CPU根据物理地址访问数据<br>    页未命中<br>        在上面的4）中，发现PTE有效位是0，转入缺页中断处理；<br>        缺页程序检查，虚拟页号是否合法，是否有空闲的物理页框PPN可以映射给虚拟页面，否则进行置换<br>        从磁盘调入新的页面到内存，更新PTE<br>        重新执行先前的指令<br>    有快表且快表命中<br>        在页命中的流程中，2）MMU直接根据VA从TLB中取出PTE，执行后面的步骤<br>    有快表且快表未命中<br>        3）MMU拿到PTE之后，会放入快表TLB，供下次使用（可能需要置换）<br>（主要注意，MMU要借助CPU在内存或快表中找到PTE，以及物理地址使用了虚拟地址中的偏移量）</p><p>请求分页中的内存分配：<br>    保证进程运行的最小物理块数<br>        直接寻址：指令页面和数据页至少两个；<br>        间接寻址：指令页面、地址页面、数据页面，至少三个<br>        （长指令可能会跨页面，具体的块数主要取决于指令的格式、功能和寻址方式）<br>    进程执行过程中分配给进程的物理块数是固定的还是可变的？<br>        固定分配局部置换，分配固定的物理块数，置换的时候置换自己的<br>        可变分配全局置换，根据具体情况，分配需要的物理块数，运行的时候根据需要从所有页面中进行置换<br>        可变分配局部置换，根据具体情况分配需要需要的物理块数，运行的时候从自己的页面中进行置换<br>    内存给进程分配物理块遵循的原则？<br>        平均分配：按照进程数量<br>        按比例分配：按照进程所占页面的比例分配<br>        优先权分配：按照重要性和紧迫性</p><p>内存调入策略<br>    系统应该在何时调入：预调页策略、请求调页（发生缺页时调入，主流）<br>    系统从哪里调入：<br>        1）如果有足够的对换区，全部放到对换区，结束后写入文件区<br>        2）如果对换区不够，不会被修改的从文件区调入，可能被修改的换出放在对换区，调入从对换区调入，结束后写入文件区<br>        3）UNXI方式，未运行过的，从文件区读，运行过又被换出的，放到对换区<br>    如何调入：页面置换算法</p><h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><p><code>前面提到了内存调入策略的关键问题是如何进行调入，对应的就是页面置换算法，这一部分重点讨论这些</code></p><p>什么时候需要置换：当内存空间用完之后，或者是分配给某个进程的空间用完了。</p><p>涉及的算法：</p><ol><li>最佳置换算法</li><li>先进先出置换算法</li><li>最近最久未使用算法</li><li>Clock置换算法</li></ol><p>最佳置换算法<br>    方法：从内存中移除永远不需要再访问的页面 or 最长时间不需要访问的页面<br>    注意：不是实际上的方法，具有理论上的最佳意义，可以作为衡量优劣的标准</p><p>FIFO算法<br>    方法：先进入内存的页面先淘汰<br>    注意：可能出现Belady现象，分配的页面数增多，缺页率反而提高</p><p>最近最久未使用算法（LRU）<br>    方法：选择最近一段时间内最久不使用的页面进行淘汰<br>    实现机制<br>        1）寄存器实现：为每个页面配置一个移位寄存器，每次访问所有移位寄存器右移1位，访问到的页面的寄存器最高位置1；挑选寄存器中值最小的淘汰；<br>        2）栈实现：保存页号，访问的时候从栈内取出，再压入栈顶；淘汰的时候淘汰栈底对应的页面</p><p>Clcok置换算法<br>    1）在发生缺页的时候：<br>        检查表指针指向的页面，如果R&#x3D;0则淘汰该页面替换入新页面，新页面R&#x3D;1；如果R&#x3D;1，则令R&#x3D;1；<br>        表指针向下移动<br>    2）没有发生缺页的时候：<br>        被访问的页面R&#x3D;1<br>    注：Clock算法有一种改进<br>        改进：考虑置换代价，将前面的R替换为(A,M)，A与R功能类似，M代表页面是否有被修改过；具体来说(0,0)&#x2F;(0,1)&#x2F;(1,0)&#x2F;(1,1)分别对应：1）最近未被访问，未修改，置换代价最小，优先置换；2）最近未被访问，被修改过，置换代价较大，可以置换；3）、4）最近被访问过不宜置换，尤其是4）被访问同时也被修改过<br>        被修改意味着：将该页换处的时候要将修改内容写回磁盘上，这个样子的话花费较多</p><p>评价指标：<br>    1）缺页次数（原本没有该页面也算缺页）；<br>    2）缺页率：缺页次数&#x2F;访问次数</p><p>访问内存的有效时间EAT（查找快表的时间：$\lambda$，访问实际物理地址的时间$t$，缺页中断的时间$\epsilon$）</p><ol><li>页表项在快表中，页在内存中：$EAT &#x3D; \lambda + t$</li><li>页表项不在快表中，页在内存中：$EAT &#x3D; \lambda+t+\lambda+t$</li><li>页不在内存中：$EAT &#x3D; \lambda + t + \epsilon + \lambda + t$（缺页中断可以将内存、快表一并补齐）</li><li>快表命中率$\alpha$，缺页率$f$，考虑EAT期望（<strong>可以问一下老师，当时上课讲的好像有一点问题，但可能不是那么重要</strong>）</li></ol><h3 id="抖动与工作集"><a href="#抖动与工作集" class="headerlink" title="抖动与工作集"></a>抖动与工作集</h3><p>抖动<br>    定义：页面在内存与磁盘之间频繁地调度，使得调度页面所需的时间比进程实际运行的时间还多，系统效率极具下降<br>    造成的结果：随着多道程序度的增加，处理器的利用率先上升后下降的现象<br>    产生的原因：页面置换算法、页面本身的大小、程序编制的方式（行优先、列优先）、驻留集的大小</p><p>驻留集<br>    定义：分配给进程使用的物理块的数量（可以对应到前面考虑各种置换算法的时候，同一时刻最多维持的页面的数量）<br>    注意：通常情况下，缺页率随着驻留集的增大而下降，但是这种效果逐渐减弱</p><p>工作集<br>    定义：在某段时间间隔$\Delta$里，进程实际要访问的页面的集合<br>    符号记法：工作集$W(t,\Delta)$，其中$t$是时刻，$\Delta$是尺窗口（要会找工作集对应的页）<br>    注意：<br>        1）工作集是基于局部性原理提出的，程序对页面的访问并不均匀；<br>        2）工作集的大小会变化<br>        3）对于变化而言相对稳定和快速变化的阶段会交替出现（一段时间稳定在一个局部性的页面，当局部位置变化的时候工作集快速变化，然后又进入一段时间的稳定）<br>        4）找到一个作业的最大工作集，可以帮助设计驻留集的大小</p><p>预防抖动的方法<br>    1）局部置换策略<br>    2）将工作集算法融入处理器调度中<br>    3）尽量让平均的执行时间等于缺页服务的时间，如果前者过大内存可能利用不够充分（因为相当于充足的内存给到了部分进程，其实还可以同时执行其他进程的）；如果后者过大，缺页过多，缺页服务时间太长，系统效率下降</p><h3 id="请求分段的存储方式"><a href="#请求分段的存储方式" class="headerlink" title="请求分段的存储方式"></a>请求分段的存储方式</h3><p>请求分段的存储方式<br>    构成：在基本分段方式上加入了：1）请求分段；2）段置换机制</p><p>硬件机制：<br>    1）请求段表机制；<br>    2）缺段中断机制；<br>    3）地址变换机构；</p><p>请求段表机制：<br>    段表与页表的不同点：<br>        在原本表项中加入了：1）存取方式（只读&#x2F;只写&#x2F;读写）；2）增补位（是否动态增长）<br>        （新增表项切合了段面向程序划分的需求）</p><p>缺段中断机构：<br>    缺段中断与缺页中断的区别：<br>        1）不会出现一条指令或一组信息在两个段的情况（页可能有这种情况）</p><p>地址变换机构：<br>    分段的地址变换与分页的区别：<br>        1）段的长度不是固定的</p><p>共享段表（分段的特色所在）<br>    由于段是面向程序划分的，所以段可以支持进程的共享（如需要访问相同的库函数）<br>    工作方式：<br>        分配：当某进程需要访问某段时，如果内存中没有则调入；会在共享段表中存储其信息，当其他进程需要的时候优先查共享段表，如果有的话直接使用；共享段表中会记录当前使用该段的进程和进程数量<br>        回收：一个进程不再使用该段的时候会在共享段表中消除它的记录，当共享段表中记录进程数量为0的时候，对应段的内存空间就被回收。<br>    注意：<br>        区别共享段表和进程自己使用的段表项</p><p>分段保护：<br>    共享段表需要进行保护<br>        1）越界检查；<br>        2）存取控制检查；<br>        3）环保护</p><h2 id="输入输出系统"><a href="#输入输出系统" class="headerlink" title="输入输出系统"></a>输入输出系统</h2><h3 id="I-O系统的功能、模型和接口"><a href="#I-O系统的功能、模型和接口" class="headerlink" title="I&#x2F;O系统的功能、模型和接口"></a>I&#x2F;O系统的功能、模型和接口</h3><p>I&#x2F;O系统的功能<br>    管理I&#x2F;O设备，包括打印机、键盘、屏幕等交互设备，以及磁盘等存储设备；<br>    基本功能：<br>        1）隐藏物理设备细节；<br>        2）与设备无关性；<br>        3）提高处理器和I&#x2F;O设备等利用率；<br>        4）设备控制；<br>        5）设备共享；<br>        6）错误处理；</p><p>I&#x2F;O软件的层次：<br>    1）用户层软件：产生I&#x2F;O请求、格式化I&#x2F;O、Spooling（假脱机系统）；<br>    2）设备独立性软件：主要是几个表，为了实现设备无关性；（缓冲区是设备无关层）<br>    3）设备驱动程序：操作系统的一部分，用来启动设备<br>    4）中断处理程序：执行I&#x2F;O时用户进程、驱动程序被阻塞，I&#x2F;O完成后触发中断，由CPU唤醒驱动程序进行后续处理；<br>    5）硬件：执行I&#x2F;O操作；</p><h3 id="I-O设备和设备控制器"><a href="#I-O设备和设备控制器" class="headerlink" title="I&#x2F;O设备和设备控制器"></a>I&#x2F;O设备和设备控制器</h3><p>I&#x2F;O设备的类型：<br>    数据传输单位分：<br>        1）块设备；<br>        2）流设备（字符设备）；<br>    共享属性上分：<br>        1）独占设备；<br>        2）共享设备；</p><p>控制方式<br>    1）无通道：<br>        CPU与设备控制器通信；<br>        设备控制器与设备通信；<br>    2）有通道<br>        I&#x2F;O通道：可以通过访问内存，取指令执行；<br>            1）算一种特殊的处理机；<br>            2）但是可执行指令单一，并且没有自己的内存（和CPU共享内存）；<br>        CPU向通道发出一条I&#x2F;O指令，通道直接访问内存，从中取出本次所需的I&#x2F;O程序执行，执行完毕后再触发中断告诉CPU；</p><p>I&#x2F;O设备寻址问题：<br>    I&#x2F;O设备寻址的时候，CPU怎么定位I&#x2F;O设备里的寄存器；<br>    1）特定I&#x2F;O指令，定制指令集，因为访问的内存不一样；<br>    2）内存映象I&#x2F;O，在编制方式上不去分内存和设备控制器的寄存器地址，进行统一编址，只是范围不同，例如以n为界限；</p><h3 id="中断机构和中断处理程序"><a href="#中断机构和中断处理程序" class="headerlink" title="中断机构和中断处理程序"></a>中断机构和中断处理程序</h3><p>与I&#x2F;O相关的中断应用场景：<br>    阻塞式系统调用：用户进程、驱动程序即将开始进行I&#x2F;O操作，调用I&#x2F;O程序然后将自己阻塞，当I&#x2F;O程序执行完毕之后，使用中断让CPU恢复用户进程、驱动程序；</p><p>中断处理的过程：<br>    中断处理程序：<br>        1）每当指令执行完，检测是否有未处理的中断信号；若有则转入中断处理程序；<br>        2）保护现场，保护CPU当前执行到的地址、寄存器的状态等；<br>        3）转入处理程序，找到中断源，发出确认信号，<strong>取消中断信号</strong>；<br>        4）中断处理；<br>        5）恢复线程并退出中断；</p><p>一个大概的I&#x2F;O过程：<br>    1）用户进程请求I&#x2F;O设备；<br>    2）操作系统调用驱动程序；<br>    3）<strong>驱动程序启动设备</strong>，发出控制命令，将<strong>自己阻塞，继而用户进程也被阻塞</strong>；<br>    4）进程切换，CPU执行其他进程；<br>    5）<strong>I&#x2F;O设备执行完成，发出中断信号</strong>；<br>    6）CPU检测到中断信号，开始处理：<br>        唤醒驱动、确认中断源、取消中断信号，驱动程序进行后续处理（这就是在中断处理）、恢复现场…</p><h3 id="设备驱动程序"><a href="#设备驱动程序" class="headerlink" title="设备驱动程序"></a>设备驱动程序</h3><p>设备驱动程序的作用：<br>    1）通信程序：驱动程序是I&#x2F;O系统的高层和设备控制器之间的通信程序；<br>    2）指令转换：接收抽象的I&#x2F;O指令，将其转换为具体的适合硬件的指令和参数；</p><p>驱动程序对I&#x2F;O设备的控制方式：<br>    1）程序控制方式；<br>        使用轮询的可编程I&#x2F;O方式：<br>            基本思想：CPU发出一条I&#x2F;O指令之后，令寄存器busy&#x3D;1；CPU不断对busy进行检查，如果busy为1则<strong>一个字符</strong>的I&#x2F;O没有完成，直到busy&#x3D;0，CPU才继续处理<strong>下一个字符</strong>的IO；<br>        缺点：忙等，CPU一直在询问，无法解脱；<br>    2）中断驱动方式；<br>        使用中断的可编程I&#x2F;O方式<br>            基本思想：I&#x2F;O设备处理数据中，无需CPU干预，CPU与I&#x2F;O设备并行工作，只有I&#x2F;O完成之后CPU才回来用极少的时间处理中断信号；<br>            （具体的过程和前面中断部分，I&#x2F;O的大概过程类似）；<br>        缺点：按字为单位进行的I&#x2F;O，每个输入完成之后就会有一次中断，效率本应该更高；<br>    3）DMA方式；<br>        直接存储器方式：<br>            基本思想，增大传输的基本单位，CPU与I&#x2F;O设备之间每次至少传输一个数据块，数据由<strong>DMA控制器</strong>控制，直接送入内存；<strong>只在每个数据块处理的开始和结束需要CPU的干预</strong>；<br>        优点：<br>            仅在传送一个或多个数据块多开始和结束为止需要使用到中断，大大提高了效率；<br>        （2、3对比：前者以字节为单位，后者以数据块为单位；前者数据传送到内存，由CPU控制，后者由DMA控制器控制）；<br>        缺点：<br>            DMA方式是以数据块为单位，这意味着每个数据块的开始和结束时需要CPU进行干预，如果一次能直接处理一组数据块会更加高效；<br>    4）I&#x2F;O通道控制方式；<br>        基本思想：属于DMA方式的发展，把对一个数据块的读写改为对一组数据块的读写；CPU要执行一组数据块的读写的时候，给通道发送一条指令，给出通道程序首地址和设备号，通道自行执行通道程序，并操作内存；</p><h3 id="与设备无关的I-O软件"><a href="#与设备无关的I-O软件" class="headerlink" title="与设备无关的I&#x2F;O软件"></a>与设备无关的I&#x2F;O软件</h3><p>与设备无关的I&#x2F;O软件主要目的是实现：<br>    1）对独立设备的分配和回收（实现设备的复用）；<br>    2）主要的方式使用独立于设备的逻辑数据块（隐藏设备的具体参数细节向高层提供统一操作的“对象”）；</p><p>主要的表与表结构：<br>    设备控制表（DCT）：每个I&#x2F;O设备都有自己的控制表，里面有设备相关的信息；<br>    控制器控制表（COCT）：例如DMA控制器；<br>    通道控制表（CHCT）：例如I&#x2F;O通道；<br>    （指向关系：DCT-&gt;COCT-&gt;CHCT）；<br>    系统控制表（SCT）：全局表，DCT可以看作SCT都表目；<br>    逻辑设备表（LUT）：为每个用户分配的，里面的表项是相关设备的逻辑名称以及对应的物理名词；</p><p>设备分配的过程：<br>    1）用户在自己的LUT中找到要用设备的逻辑名，以及对应的物理名，例如&#x2F;dev&#x2F;打印机对应5；<br>    2）使用物理名去查SCT，找到对应的DCT；<br>    3）DCT找到对应的COCT，COCT找到对应的CHCT；<br>    4）全部确认没问题了，先分配：设备，再分配：控制器，最后分配：通道；</p><h3 id="用户层软件"><a href="#用户层软件" class="headerlink" title="用户层软件"></a>用户层软件</h3><p>假脱机系统：<br>    组成：<br>        1）输入井和输出井：在硬盘上分出的存储区域；<br>        2）输入缓冲区和输出缓冲区：在内存上的数据中转站；<br>        3）输入进程和输出进程：模拟外围机；<br>        4）井管理程序：直接和用户打交道；<br>    使用流程：<br>        1）输入进程 输入数据 到用户进程：<br>            1）输入进程控制设备输入到输入缓冲区；<br>            2）然后转移到输入井；<br>            3）用户进程通过井管理程序从输入井中读取数据；<br>        2）用户进程 输出数据 到输出设备：<br>            1）用户进程通过井管理程序输出到输出井；<br>            2）输出进程从输出井将数据读入输出缓冲区；（在设备空闲时）<br>            3）输出设备读取输出缓冲区的数据输出；</p><h3 id="缓冲区的管理"><a href="#缓冲区的管理" class="headerlink" title="缓冲区的管理"></a>缓冲区的管理</h3><p>缓冲区是<strong>设备独立性软件</strong>管理的资源；<br>（属于设备无关层，设备独立性软件层）</p><p>引入缓冲区的原因：<br>    1）缓解CPU和I&#x2F;O设备速度不匹配的问题；<br>    2）减少CPU的中断频率；<br>    3）解决数据粒度不匹配的问题；<br>    4）提高CPU与I&#x2F;O设备的并行性；（越多并行越强）；</p><h3 id="磁盘存储器的性能和调度"><a href="#磁盘存储器的性能和调度" class="headerlink" title="磁盘存储器的性能和调度"></a>磁盘存储器的性能和调度</h3><p>磁盘的基本结构：<br>    1）磁盘包括一个或多个盘面；<br>    2）每个盘面有两个存储面；<br>    3）每个面按同心圆环组织，对应环就是磁道，每条磁道上存储相同数目的二进制位；<br>    4）每条磁道从逻辑上划分为多个扇区，一个扇区称为一个盘块；</p><p>磁盘容量的计算：<br>    已知：1）8个双面盘片，2）每面16384个磁道，3）64个扇区，4）每个扇区512个字节；<br>    按照基本结构：<br>        容量 &#x3D; 8 16384 64 512B 累乘 -&gt; 8GB<br>    （注意<strong>64个扇区是指每个磁道64个扇区</strong>）；</p><p>注意：现代磁盘为了提升容量不会将内外磁道算作相同的存储容量，外磁道显然会大一些，提供给OS的是抽象后的几何信息，这些会由驱动器处理；</p><p>磁盘调度算法：<br>    衡量指标：<br>        磁道x，y之间的距离（磁头从x-&gt;y的移动距离） &#x3D; |x-y|；（其中x、y是编号）；<br>        平均寻道长度 &#x3D; 一系列磁道读写完成之后，磁头移动距离之和 &#x2F; 磁头移动次数；<br>    1）FCFS（先来先服务）：<br>        按照对于磁道请求读写的时间顺序先后，依次移动磁头道对应磁道进行读写；<br>    2）SSTF（最短寻道优先算法）：<br>        按照一系列磁道读写请求中，距离当前所在磁道的距离进行选择，下一次选择距离当前最近的磁道；<br>    3）SCAN（扫描算法）：<br>        对于一系列读写请求，磁头按照当前读取<strong>方向（磁道号增大或减小）</strong>，继续读取同一方向的磁道，直到读完该方向最大&#x2F;最小 的磁道，再改变反向；<br>        （注意方向，以及改变方向不是轮回，而是掉头）；<br>    4）CSCAN（循环扫描算法）：<br>        对于一系列读写请求，磁头总是沿着一个方向移动，增大&#x2F;减小，直到最大&#x2F;最小，磁头<strong>立马移动道最小&#x2F;最大处</strong>（当然这个距离也算移动距离），重新开始；<br>        （注意方向，并且这个改变方向也是掉头，只是掉头直接走到底，再重新扫一遍）；</p><h2 id="文件管理-1"><a href="#文件管理-1" class="headerlink" title="文件管理"></a>文件管理</h2><p>文件的相关操作：<br>    1）最基本操作：<br>        1）创建文件；<br>        2）删除文件；<br>        3）读文件；<br>        4）写文件；<br>        5）设置文件读&#x2F;写位置；<br>    2）文件的“打开”和“关闭”操作；<br>    3）其他操作；</p><p>文件的打开操作：<br>    引：<br>        1）在没有打开操作之前，对文件操作我们需要检索目录，找到文件的属性和它在外存上的属性；<br>        2）缺点是对文件进行多次操作，每次都要重新检索目录，于是OS发明了“打开”文件这一概念；<br>    文件的打开：<br>        1）OS将指定文件的属性（包括物理位置）从外村拷贝到内存的“打开文件表”，作为一个表目，并将这个表目的索引&#x2F;编号，返回给用户；<br>        2）让用户对文件操作的时候，可以使用这个索引向OS进行请求，OS可以直接利用这个索引查找到对应的文件，避免了二次检索；</p><p>文件的关闭操作：<br>    对应着打开：<br>        当用户不需要对该文件再操作时，利用关闭的系统调用，将文件关闭，OS把该文件对应的表目从“打开文件表”中删除；</p><p>文件的逻辑结构：<br>    作用：记录数据在一个文件中的组织方式；<br>    按照记录的组织方式划分：<br>        1）顺序文件：<br>            含义：一条接一条的记录顺序组合在一起；<br>            两种结构：<br>                1）串结构：依据时间最先存储的作为第一个记录，然后是第二个记录，以此类推；<br>                2）顺序结构：按照关键字（词）排序，例如关键词长短、英文的顺序；<br>            两种寻址方式：<br>                1）隐式寻址：一条一条记录查找，直到找到想要的记录；<br>                2）显示寻址：对记录实现直接或随机访问（可以直接定位到记录）；<br>                注意：显示寻址只能对<strong>定长</strong>对记录实现，不能对变长的记录实现（注意变长是指一个记录的长度可以变，而一个文件有多个记录）；<br>        2）索引文件：<br>            含义：针对变长记录文件，配备一个索引表，按记录的关键字排序，表项可以直接索引到记录；<br>            注意：索引表本身是一个定长记录文件；（表项长度固定）；<br>        3）索引顺序文件：<br>            含义：将顺序文件中的所有记录分组，为每组建立一个索引项，指向每组的第一个记录；<br>            本质上就是有一定额外逻辑结构，但是没有记全的索引文件（它们的结构实际上也是一样的）；<br>            优点：克服了在文件中记录较多时，出现大量索引的，检索费事的问题；</p><p>（索引顺序文件）多级索引下文件访问时间问题：<br>    1）n条记录的文件，顺序访问，平均查找次数是n&#x2F;2；<br>    2）建立了一级索引：均分的来说，应该有$\sqrt{n}$个索引项，对应每组有$\sqrt{n}$条索引记录；<br>        所以平均查找次数是 $\sqrt{n}&#x2F;2 + \sqrt{n}&#x2F;2 &#x3D; \sqrt{n}$；<br>    3）如果建立了二级索引，考虑均分，应该有 $n^{1&#x2F;3}$ 个二级索引，每个二级索引对应同样数量个一级索引，每个一级索引对应同样数量个记录项；<br>        所以平均查找次数是 $n^{1&#x2F;3}*3&#x2F;2$</p><p>文件目录：<br>    本质：定长顺序文件；<br>    组成：文件控制块（FCB）；<br>        1）基本信息：文件名、文件物理位置、文件逻辑结构、文件物理结构；<br>        2）存取控制信息：各种用户的存取权限；<br>        3）使用信息：例如上一次修改的日期、创建日期etc.<br>        （文件控制块就是“文件目录”这个定长顺序文件中的记录）；<br>    改进：<br>        问题：如果文件较多，文件目录中记录很多，导致系统将文件目录调入内存时占用空间很大，效率很低；<br>            （操作系统开机的时候就是读取目录，后续根据需要读取文件）；<br>        解决方案：索引节点；<br>            1）索引节点中记录FCB中的信息（UNIX中称为i节点）；<br>            2）文件目录中只记录文件名和索引节点的编号；<br>            （相当于在需要一个文件详细记录的时候，再根据索引节点编号，索引到索引节点，其中记录了原始FCB会有的信息）；<br>    常见的文件目录：<br>        1）一级文件目录：<br>            整个文件系统建立一张目录表，每个文件占一个目录项，目录项中是文件的meta info；<br>            优点：<br>                实现了按名存取；<br>            缺点：<br>                速度慢，不允许重名；<br>        2）二级文件目录：<br>            为每个用户单独建立一个文件目录表UFD，系统中建立一个主文件目录MFD，MFD中存了用户名和对应的指针，UFD中存到是文件名以及对应的指针（索引），类似于索引节点的方式；<br>            优点：<br>                1）提高了检索速度，不同用户可以使用相同文件名；<br>                2）不同用户可以使用不同用户名来访问共享文件；<br>        3）树形文件目录：<br>            唯一的根目录，其他每个文件、目录有唯一的父目录；一个目录中指向子目录的记录类似于MFD，指向文件的记录类似于UFD（即类似索引节点）；<br>            （其中文件是树叶、目录是树的节点）；<br>            路径名：<br>                1）绝对路径名：在树形文件目录中，从根目录到任何数据文件都有唯一的路径名；<br>                2）相对路径名：从当前目录开始直到数据文件为止构成的路径名；<br>            路径名的表示方式：<br>                1） “.&#x2F;“ 当前目录；<br>                2） “..&#x2F;“ 上级目录；<br>                3） “&#x2F;“ 根目录；<br>            <img src="https://raw.githubusercontent.com/Yes-ys/blog-images/main/OS/p8.png" alt="文件路径名的例子">；</p><p>文件目录的查找：<br>    注意哈希法不适用于有通配符的模糊查找；</p><p>文件共享：<br>    含义：系统应该允许多个用户共享一个文件，这样系统只用保存一份文件的副本；<br>    基于索引节点实现共享：<br>        利用索引节点，只需要不同用户的某个记录项索引指向同一索引节点，即可实现文件共享；<br>    改进：基于符号链接Link文件实现共享：<br>        问题：<br>            这种方式需要记录一个当前文件的用户使用数量，只有在数量为0的时候才删除文件；这带来了拥有者问题，当一个文件的Onwer不需要该文件了，如果有其他用户在共享这个文件，那么文件就无法删除，这是不公平的（A消费，B买单）；而强行删除的话会带来悬空指针问题；<br>        方法：<br>            只有拥有者指向索引节点，<strong>共享者</strong>创建一个Link型文件用于记录指向实际文件的路径，共享者可以访问到的是该Link型文件的索引节点；<br>            （相当于共享者只有共享文件的路径，实际的文件掌握在拥有者手中，如果拥有者删除文件，系统就会因为找不到文件而访问失败，让用户删除自己是失效的Link型文件）；</p><h2 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h2><p>这一节讲的是数据在磁盘上的物理组织方式，要和上一章文件管理的逻辑组织区别开来；</p><h3 id="外存的组织方式"><a href="#外存的组织方式" class="headerlink" title="外存的组织方式"></a>外存的组织方式</h3><p>连续组织方式：<br>    要求为每个文件分配一组相邻的盘块，又称为连续分配的方式；<br>    优点：<br>        顺序访问容易、速度快；<br>    缺点：<br>        必须事先知道文件的长度；<br>        不能灵活地删除和插入记录；<br>        无法组织动态增长的文件；</p><p>链接组织方式：<br>    可以将文件装到多个离散的盘块，对于这些不连续的盘块，通过盘块上的指针链接成一个链表，形成完整的文件；<br>    优点：<br>        不需要连续空间，提高了外存利用率；<br>        插入删除相对容易，可以应对动态增长的文件；<br>    类别：<br>        1）隐式链接：<br>            文件中目录项，含有指向第一个盘块和最后一个盘块的指针；<br>            （相当于访问的时候目录项索引到第一个盘块，然后用读取链表的方式依次访问）；<br>            缺点：<br>                只能顺序访问效率低；<br>                可靠性低，某个盘块的指针出问题了，整个文件后续的信息就丢失了；<br>        2）显示链接：<br>            在内存中维护一张链接表，将链接文件物理盘块的各指针，显示地存放在表中；<br>            FAT技术：<br>                显示链接使用FAT，将整个盘块作为基本分配单位，FAT中记录各个盘块的索引（指针）；<br>                计算FAT表的容量：<br>                    实质：计算FAT表记录管理的盘块空间有多大；<br>                    FAT12：<br>                        1）以盘块为基本管理单位；<br>                        2）表项是12位；<br>                        3）最大容量空间：$2^12 * Block_size$；<br>                    FAT16：<br>                        1）以簇为基本管理单位；<br>                        2）一个簇可以有多个扇区；<br>                        3）表项是16位；<br>                        4）<br>                            最大容量空间：$2^16 * number_sector * size_sector$；（number_sector是一个簇有几个扇区，size_sector是扇区大小）；<br>                            或者 $2^16 * size_cluster$；（size_cluster直接考虑一个簇的大小）；<br>                    FAT32：与FAT16类似，只是表项是32位，容量计算方式也是对应的；<br>            缺点：<br>                FAT占用较大的内存空间；</p><p>索引组织方式：<br>    实质：在显示链接FAT方式上的改进；<br>    1）为每一个文件分配一个索引盘块，记录文件所有内容所在的盘块（对应前面FAT中对应当前文件的表项）；<br>    2）打开文件的时候只需要将该文件占用的编号调入，没有必要调入整个FAT表（FAT表中存储了所有文件的所有内容所在盘块的信息）；<br>    3）为了找到文件的索引盘块，建立文件的时候在FCB中存储索引块指针；<br>    增量式索引组织方式：<br>        基本上比较贴近现在的技术了，UNIX V操作系统中用的就是这个；<br>        采取多级组织方式，小文件索引盘块的指针直接存储在FCB中，中型文件使用单级索引（FCB中的指针索引到 一个盘块，该盘块中存放的是一些指针，这些指针又索引到一些盘块，这些盘块就是最开始的索引盘块，其中存放了文件内容的索引），大型文件使用的是二级或三级索引（基本上就是通过增加索引次数扩大最终对应的空间）；</p><h3 id="文件存储空间的管理"><a href="#文件存储空间的管理" class="headerlink" title="文件存储空间的管理"></a>文件存储空间的管理</h3><p>文件存储空间的管理方式：<br>    磁盘是如何分配和回收相应的空间的；<br>        空闲表法；<br>        空闲链表法；<br>        位示图法；<br>    （对应类似内存空间的管理方式，外存的管理知道有这几种方法即可）；</p><h3 id="提高磁盘I-O速度的途径"><a href="#提高磁盘I-O速度的途径" class="headerlink" title="提高磁盘I&#x2F;O速度的途径"></a>提高磁盘I&#x2F;O速度的途径</h3><p>RAID技术；<br>    廉价磁盘冗余阵列：利用一台磁盘阵列控制器，统一管理和控制一组(几台到几十台)磁盘驱动器，组成一个高度可靠、快速的大容量磁盘系统；<br>    （如果改进一个组件很难在性能上取得提升，那么可以通过重复使用多个相同的组件来达到性能提升的效果；）<br>    RAID0：最早提出的RAID技术；<br>        1）使用了数据分条技术；<br>        2）需要2块磁盘；<br>        3）目标是提高整个磁盘的性能、吞吐量，没有提供冗余和错误修复的能力；<br>        4）可靠性对应单独的一块硬盘，只要有一块硬盘故障，整个系统都会出问题；<br>    RAID1：<br>        1）使用了磁盘镜像技术；<br>        2）需要2块磁盘；<br>        3）目标是保证系统的可靠性和可修复性；<br>        4）性能与单块硬盘性能相同，可靠性高；<br>    RAID2：<br>        1）在RAID0上的改进，使用了汉明码提升可靠性；<br>        2）需要3块磁盘；<br>        3）目标是在RAID0性能提升的基础上增加可靠性；<br>        4）整体数据容量大一些，按位存储校验信息，至少要3块磁盘；<br>    RAID3：<br>        1）在RAID2基础上使用了奇偶校验，并且单独使用盘块存放校验信息，更加可靠；<br>        2）需要3块磁盘；<br>    RAID4：<br>        与RAID3类似，需要3块磁盘；<br>    RAID5：<br>        校验信息螺旋分布，需要3块磁盘；<br>    RAID6：<br>        在RAID5的基础上增加了一个独立的奇偶校验块，需要4块磁盘；<br>    特殊的组合：<br>        RAID01：<br>            1）先做条带再做镜像；<br>            2）需要4块磁盘；<br>            3）如果有一块磁盘坏了，那该组中另一块也不能用了，退化成了RAID0，如果另一组中坏一个就不能用了；<br>        RAID10：<br>            1）先做镜像再做条带；<br>            2）需要4块磁盘；<br>            3）如果有一块磁盘坏了，该组中另一块还能用，如果该组另一块也坏了，或者另一组两块都坏了才不能用；<br>        总结：RAID10比RADI01更加安全；<br>        参考下图：<br>            <img src="https://raw.githubusercontent.com/Yes-ys/blog-images/main/OS/p9.png" alt="RAID01与RAID10">；</p><h3 id="数据一致控制"><a href="#数据一致控制" class="headerlink" title="数据一致控制"></a>数据一致控制</h3><p>事务：用于控制和修改各种数据项的一个程序单位，可以看作一系列相关读写操作；</p><h2 id="随堂测试"><a href="#随堂测试" class="headerlink" title="随堂测试"></a>随堂测试</h2><p><code>这门课老师貌似不布置作业，但其实随堂测试基本上涵盖了每一章的知识点，在这里进行记录</code></p><h3 id="第四次随堂测试：存储器管理"><a href="#第四次随堂测试：存储器管理" class="headerlink" title="第四次随堂测试：存储器管理"></a>第四次随堂测试：存储器管理</h3><h4 id="1-1）"><a href="#1-1）" class="headerlink" title="1.1）"></a>1.1）</h4><p>动态分区分配中，系统回收一块内存需要修改空闲分区表，造成空闲区数减1的是：</p><p>C. 既有上邻空闲区，也有下邻空闲区。</p><p>原因是当内存回收后，新增的一块和原来的两块合并成一块了，就相较于原来少了一块。</p><h4 id="1-2）"><a href="#1-2）" class="headerlink" title="1.2）"></a>1.2）</h4><p>在页式存储管理方案中，使用？实现地址变换</p><p>页表</p><h4 id="1-3）"><a href="#1-3）" class="headerlink" title="1.3）"></a>1.3）</h4><p>根据存储区分配所用基本单位的不同，可以将离散分配方式为？</p><p>分页、分段、段页式</p><h4 id="1-4）"><a href="#1-4）" class="headerlink" title="1.4）"></a>1.4）</h4><p>在一个页式存储管理系统中，页表内容如图。若页大小为4K，则地址变换机构将逻辑地址0变换为物理地址为？</p><p>页号    块号<br>0       2<br>1       1<br>2       6<br>3       3<br>4       7</p><p>4K * 2 &#x3D; 8K &#x3D; 8 * 1024 &#x3D; 8192</p><h4 id="1-5）"><a href="#1-5）" class="headerlink" title="1.5）"></a>1.5）</h4><p>在一个页式存储管理系统中，页表保存在内存中，CPU每存取一个数据，都需要？次访问内存</p><p>2次</p><h4 id="2-1）"><a href="#2-1）" class="headerlink" title="2.1）"></a>2.1）</h4><p>在程序装入方式中的可重定位装入方式可以实现进程在内存中位置的移动</p><p>错误</p><p>可重定位是在放入内存的时候改地址，放入后不能再更改地址。</p><h4 id="2-2）"><a href="#2-2）" class="headerlink" title="2.2）"></a>2.2）</h4><p>静态链接方式形成的完整的装入模块是可执行文件</p><p>正确</p><h4 id="2-3）"><a href="#2-3）" class="headerlink" title="2.3）"></a>2.3）</h4><p>装入时的动态链接方式便于实现对目标模块的共享</p><p>正确</p><p>什么时候装，什么时候链接，可以实现目标共享</p><h4 id="2-4）"><a href="#2-4）" class="headerlink" title="2.4）"></a>2.4）</h4><p>页式存储比段式存储更利于实现对目标模块的动态链接</p><p>错误</p><p>说反了，段式有逻辑，更适合动态链接，共享</p><h4 id="2-5）"><a href="#2-5）" class="headerlink" title="2.5）"></a>2.5）</h4><p>装入时的动态链接比运行时的动态链接更加节省内存空间</p><p>错误</p><p>运行时动态链接更节省，只有执行到的会被装入，前者所有需要的都会被装入</p><h4 id="3-1）"><a href="#3-1）" class="headerlink" title="3.1）"></a>3.1）</h4><p>给定一个逻辑地址为A&#x3D;2170B，若页面大小为1KB，则该地址所对应的页号为？页内地址为？</p><p>页号：2170&#x2F;1024 &#x3D; 2，页内地址：2170-2048&#x3D;122</p><p>2048在2号页中，页内地址为0；地址实际上都是偏移，从0开始，页号也是从0开始</p><h4 id="3-2）"><a href="#3-2）" class="headerlink" title="3.2）"></a>3.2）</h4><p>在动态分区分配算法中，如果采用最佳适应算法，需要将空闲分区链按照？顺序排列，如果按照最坏适应算法，则需要将空闲分区链按照？顺序排列。</p><ol><li>递增</li><li>递减</li></ol><p>递增排列，来了程序从前往后遍历，第一次找到可行的分区空间，就是最小能适合它的空间，所以最佳；递减顺序含义类似。</p><h4 id="3-3）"><a href="#3-3）" class="headerlink" title="3.3）"></a>3.3）</h4><p>在具有对换空间的操作系统中，磁盘空间分为对换区和文件区两个部分，其中对换区采用？分配方式，而文件区采用？分配方式。</p><ol><li>连续</li><li>离散</li></ol><p>对换区要求时间效率高，因为调度频繁，所以使用连续分配方式；文件区要求空间利用率高，因为文件需要长时存储，且访问不频繁，所以使用离散分配的方式。</p><h4 id="3-4）"><a href="#3-4）" class="headerlink" title="3.4）"></a>3.4）</h4><p>在段页式系统中，如果段表和页表都在内存中，那么CPU完成一次数据或指令的读取，需要？次访问内存。</p><p>需要3次访问内存</p><p>1次访问段表，获得页表地址，第2次反问页表获得物理地址，第3次访问物理地址读取内容；</p><h4 id="3-5）"><a href="#3-5）" class="headerlink" title="3.5）"></a>3.5）</h4><p><code>这里需要再明确一下</code></p><p>只采用分页方式的用户地址空间是？维的，而采用分段方式的用户地址空间是？维的。</p><ol><li>2 改 1</li><li>2</li></ol><p>页号+位移量，段号+位移量，都是两个维度</p><p>注：段页式也是2维   分页式是1维的</p><h4 id="4-1）"><a href="#4-1）" class="headerlink" title="4.1）"></a>4.1）</h4><p>某OS采用动态分区分配存储管理方法，用户区为512K,且始址为0。若分配时采用分配空闲区低地址部分的方案，且初始时用户的512K空间空闲，对下述申请序列:申请300K，申请100K，释放300K，申请150K，申请30K，申请40K,申请60K，释放30K回答:</p><ol><li>采用首次适应算法，空闲分区中有哪些空块（给出始址、大小）？</li><li>采用最佳适应算法，空闲分区中有哪些空块（给出始址、大小）？</li><li>如再申请100K，针对（1）和(2)各有什么结果？</li></ol><p>Q1:</p><p>申请300K后：空闲块1，起始地址：300K&#x3D;300*1024&#x3D;307200，大小212K</p><p>申请100K后：空闲块1，起始地址：400K&#x3D;400*1024&#x3D;409600，大小112K</p><p>释放300K后：空闲块1，起始地址：0，大小300K；空闲块2，起始地址：409600，大小112K</p><p>申请150K后，空闲块1，起始地址：150K，150*1024&#x3D;153600，大小150K；空闲块2，起始地址：409600，大小112K</p><p>申请30K后，空闲块1，起始地址：180K，大小120K，空闲块2，起始地址，400K，大小112K</p><p>申请40K后，空闲块1，起始地址，220K，大小80K，空闲块2，起始地址，400K，大小112K</p><p>申请60K后，空闲块1，起始地址，280K，大小20K，空闲块2，起始地址，400K，大小112K</p><p>释放30K后，空闲块1，起始地址，150K，大小30K，空闲块2，起始地址280K，大小20K，空闲块3，起始地址400K，大小112K</p><p>若再申请100K，空闲块1，起始地址，150K，大小30K，空闲块2，起始地址280K，大小20K，空闲块3，起始地址500K，大小12K</p><p>Q2是类似的，只是<strong>每次内存从较小的空闲块开始出</strong>，最后的答案是：</p><p><strong>注意，最佳适应法最后给答案的时候，空闲块也要按照从小到大给</strong>；<br><strong>最坏适应法，按从大到小给</strong>；<br><strong>首次适应法，按照地址空间低到高给</strong>；</p><p>空闲块1:400K～430K，30K，空闲块2：470K～512K，42K，空闲块3：210K～300K，90K</p><p>若再申请100K，是给不出来的</p><h4 id="4-2）"><a href="#4-2）" class="headerlink" title="4.2）"></a>4.2）</h4><p>设有一块页式存储管理系统，向用户提供的逻辑地址空间最大为64页，每页1024B，内存总共有32存储块，试问逻辑地址至少应为多少位？内存空间有多大？</p><p>逻辑地址：（页号）（页内偏移）：2^6 2^10，故16位</p><p>内存空间：32*1024 &#x3D; 2^15 Byte</p><p>从这里可以看到实际内存是小于逻辑地址的，那么当进程尝试使用的空间大于实际内存，计算机是如何处理的呢？</p><h4 id="4-3）"><a href="#4-3）" class="headerlink" title="4.3）"></a>4.3）</h4><p>如果分段式地址具有如下结构，在该地址中，允许一个作业最长有多少个段？每个段的最大长度是多少？</p><p>（63～32段号）（31～0段内地址）</p><p>2^32 &#x3D; 4G</p><p>2^32 &#x3D; 4G</p><h4 id="4-4）"><a href="#4-4）" class="headerlink" title="4.4）"></a>4.4）</h4><p><code>再理解一下，虽然记住做法是很简单的</code></p><p>在采用伙伴系统的动态分区算法中，有一个大小为128的块，其地址为640，其伙伴块的地址是什么？</p><p>形成的块大小是256，判断当前地址是否能整除640</p><p>如果能整除，则它是靠前的，否则它是靠后的</p><p>640 MOD 256 !&#x3D; 0</p><p>所以它是靠后的，则伙伴块地址为640-128&#x3D;512</p><h3 id="第五次随堂测试：虚拟存储管理器"><a href="#第五次随堂测试：虚拟存储管理器" class="headerlink" title="第五次随堂测试：虚拟存储管理器"></a>第五次随堂测试：虚拟存储管理器</h3><p>1）虚拟存储器的最大容量是由？</p><p>由计算机的地址结构决定的</p><p>注：虚拟存储器会尝试解析处理任意输入的地址，也就是说其感知到的可寻址空间由输入地址的范围决定，计算机的地址结构就决定了这个输入地址的上、下限</p><p>2）在虚拟存储系统中，若进程在内存中占3块（开始时为空），采用FIFO算法，当执行访问页号序列为1、2、3、4、1、2、5、1、2、3、4、5、6时，将产生几次缺页</p><p>进程的内存块随访问页号变化如下</p><p>1、12、123、234、341、412、125、125、125、253、534、534、346</p><p>每一次改变对应一次缺页，有10次改变，3次未变，所以一共缺页10次</p><p>3）系统“抖动”现象的发生可能是由？引起的</p><p>抖动现象可能产生的原因是：</p><ol><li>置换算法的选择不当</li><li>页面本身的大小有问题</li><li>程序的编写不当</li><li>驻留集大小不当</li></ol><p>所以这里的答案是，置换算法选择不当</p><p>4）实现虚拟存储器的目的是</p><p>扩充内存容量</p><p>注：实际上扩充内存容量是伴随虚拟存储器出现的好处，初衷是为了解决常规存储管理模式中<strong>一次性、驻留性</strong>的问题</p><p>5）作业在执行中发生了缺页中断，经操作系统处理后，应让其执行？指令</p><p>被中断的指令</p><p>因为发生了中断，该指令还没有得到执行，所以要执行它</p><p>6）在请求分页存储管理中，若采用FIFO页面淘汰算法，但分配的页面数增加时，缺页中断的次数将</p><p>可能增加也可能减少</p><p>FIFO算法存在发生belady现象的可能</p><p>7）虚拟存储管理系统的基础上程序的？理论</p><p>局部性</p><p>时间局部性、空间局部性、局部性原理</p><p>8）下述？页面淘汰算法会产生Belady现象</p><p>先进先出</p><p>即FIFO</p><p>9）在页式存储管理方案中，采用？实现地址变换</p><p>页表</p><p>10）在请求分页系统中，主要的硬件支持有请求分页的页表机制，缺页中断机构和？</p><p>地址变换机构</p><p>11）假设某程序的页面访问序列为1、2、3、4、5、2、3、1、2、3、4、5、1、2、3、4且开始执行时内存中没有页面，则在分配给该程序的物理块数是3且采用FIFO方式时，缺页次数是？，在分配给该程序的物理块数是4且采用FIFO方式时，缺页次数是？，在分配给该程序的物理块数是3且采用LRU方式时，缺页次数是？，在分配给该程序的物理块数是4且采用LRU方式时，缺页次数是？</p><p><strong>老师说写序列的时候最好按照访问页面序列写，先将序列抄下来，每访问一个页面在对应序号下面写当前内存块中的序列</strong>。</p><p>物理块数为3时</p><p>FIFO：1、12、123、234、345、452、523、231、231、231、314、145、145、452、523、234：13次<br>LRU：1、12、123、234、345、452、523、231、231、231、423、235、351、512、123、234：14次</p><p>物理块为4时</p><p>FIFO：1、12、123、1234、2345、2345、2345、3451、4512、5123、1234、2345、3451、4512、5123、1234：14次<br>LRU：1、12、123、1234、2345、！3452、！4523、5231、！5312、！5123、1234、2345、3451、4512、5123、1234：12次</p><p>12）在段页式存储管理系统中，每道程序都有一个？表和一组？表</p><p>维护一个段表，一组页表</p><p>先将程序划分为段，然后将一个段划分为若干页，最终使用的都是页表，所以先用段表索引到对应页表存储的位置，然后用页表索引到实际的物理内存，那么就应该是一个段表、一组页表，即每个段都有自己的页表。</p><p>13）设谋进程的页面访问串为1、3、1、2、4，分配的物理块是3块，采用FIFO置换算法时，访问页面4时，要淘汰？号页面</p><p>1、13、13、32、24</p><p>所以淘汰的是3号页面</p><p><strong>？</strong></p><p>14）上一题，若采用LRU算法，则应该淘汰？号页面</p><p>1、13、31、12、24</p><p>淘汰1号页面</p><p><strong>？</strong></p><p>注：<strong>这一部分没有涉及最佳置换算法的考察，注意复习</strong></p><h3 id="第六次随堂测试：I-O系统"><a href="#第六次随堂测试：I-O系统" class="headerlink" title="第六次随堂测试：I&#x2F;O系统"></a>第六次随堂测试：I&#x2F;O系统</h3><h4 id="选择题"><a href="#选择题" class="headerlink" title="选择题"></a>选择题</h4><ol><li>以下哪个功能是操作系统的输入输出管理功能？</li></ol><p>设备管理对应输入输出管理；进程、内存、文件系统管理不是</p><ol start="2"><li>操作系统的输入输出系统中，设备驱动程序的作用是？</li></ol><p>与硬件交互，提供统一接口给上层应用。</p><ol start="3"><li>在操作系统中，哪种设备属于块设备</li></ol><p>硬盘属于块设备，键盘、显示器属于流设备</p><p><strong>似乎打印机也属于块设备？</strong>（来自AI）</p><p>（从数据传输单位上区分，块设备和流设备，流设备又叫做字符设备）</p><ol start="4"><li>在I&#x2F;O设备的管理中，以下哪个不是缓冲区的作用？</li></ol><p>进行内存的保护不是缓冲区的作用，感觉缓冲区本身还可能带来溢出的危险</p><ol start="5"><li>以下关于I&#x2F;O控制器的说法，哪一项是正确的？</li></ol><p>I&#x2F;O控制器负责将高层输入输出请求转化为硬件指令</p><p>（对应的应该是I&#x2F;O设备与设备控制器的部分，这里将设备控制器称为I&#x2F;O控制器？）</p><ol start="6"><li>操作系统中，缓冲区的作用是？</li></ol><p>缓解设备和CPU的速度差异</p><ol start="7"><li>以下哪个设备属于字符设备？</li></ol><p>键盘</p><p>注意，打印机应该也是块设备</p><ol start="8"><li>操作系统中，I&#x2F;O中断的作用是？</li></ol><p>让CPU暂停当前进程，处理I&#x2F;O事件</p><ol start="9"><li>在磁盘管理中，哪个算法取决于磁头移动的顺序？</li></ol><p>SCAN，该算法会考虑当前磁头的移动方向</p><p>FCFS，先来先服务，该变方向就变方向</p><p>还有SSTF（确保距离最短），以及CSCAN（不变换方向，循环扫描）</p><ol start="10"><li>假脱机技术主要用于</li></ol><p>在硬盘上提供一个区域存储I&#x2F;O请求，并通过输入输出进程按照顺序执行。</p><h4 id="判断题"><a href="#判断题" class="headerlink" title="判断题"></a>判断题</h4><ol><li>I&#x2F;O管理的核心是通过中断机制来处理I&#x2F;O请求</li></ol><p>错，感觉中断只是I&#x2F;O管理的一部分</p><ol start="2"><li>设备驱动程序是操作系统与硬件之间的桥梁</li></ol><p>对</p><ol start="3"><li>硬件和操作系统之间不需要任何交互</li></ol><p>错</p><ol start="4"><li>在输入输出系统中，CPU对设备的访问是直接的</li></ol><p>错</p><ol start="5"><li>缓冲区能够提高设备和CPU之间的速度匹配</li></ol><p>对</p><ol start="6"><li>操作系统使用轮训机制来处理I&#x2F;O请求是比较高效的</li></ol><p>对</p><ol start="7"><li>I&#x2F;O设备的驱动程序只能用于一个特定型号的设备</li></ol><p>对</p><ol start="8"><li>中断机制使CPU在处理I&#x2F;O操作时完全停止运行，直到I&#x2F;O完成</li></ol><p>错</p><ol start="9"><li>假脱机技术通过输入和输出进程和内存缓冲区实现从硬盘到其他I&#x2F;O外设的数据传输</li></ol><p>对</p><ol start="10"><li>逻辑设备表用于记录实际物理设备的设备号、状态以及对应的物理设备信息</li></ol><p>错</p><h4 id="填空题"><a href="#填空题" class="headerlink" title="填空题"></a>填空题</h4><ol><li>I&#x2F;O系统的层次结构包括：I&#x2F;O硬件、中断处理程序、（驱动）程序、设备独立性软件、用户层软件</li><li>I&#x2F;O设备与控制器：数据信号线、控制信号线、状态信号线；控制器与处理器：数据信号线、控制信号线、地址信号线</li><li>I&#x2F;O通道是一种特殊的处理机，具有执行I&#x2F;O指令的能力，但是与一般处理机不同在于：1）指令较为简单；2）没有自己的内存空间与处理机共享</li><li>中断分为中断和陷入，也称为外中断和内中断</li><li>对于多中断源的情况处理方式有：1）屏蔽中断；2）嵌套中断；中断处理的过程：1）检测有没有中断信号，2）保存现场，3）中断复位，4）转入中断处理程序，5）恢复现场</li><li>设备驱动程序的主要功能是</li></ol><h2 id="期末重点"><a href="#期末重点" class="headerlink" title="期末重点"></a>期末重点</h2><h3 id="ch1"><a href="#ch1" class="headerlink" title="ch1"></a>ch1</h3><p>操作系统是什么：</p><ol><li>操作系统是硬件之上的第一层软件</li><li>操作系统是用户和系统交互的接口</li><li>操作系统是用来管理资源的</li></ol><p>整个操作系统的发展过程：</p><ol><li>手工操作</li><li>单道批处理系统</li><li>多道批处理系统<br> 每个任务交上去后操作系统依次进行处理；<br> 问题是用户不知道任务何时被反馈，所以是缺少交互的；    </li><li>分时系统<br> 分时系统的特点，处理每个用户任务的时候是分时间片的，按照用户的优先级等信息为用户任务分配时间片，好像每个用户是在独享系统；<br> 要求是即时交互，即时相应；</li><li>实时系统<br> 截止时间要求，到截止时间一定要响应；</li></ol><p>什么要的需求用什么样的系统：<br>    要求大量吞吐量，效率高——多道批处理系统；<br>    要求有交互，用户即时响应，用分时系统；<br>    对安全性要求高，实时截止时间，用单道批处理系统；</p><p>从多道批处理系统开始真正有了操作系统的概念</p><p>操作系统四大特征：</p><ol><li>并发</li><li>共享</li><li>虚拟</li><li>异步</li></ol><p>基本特征：</p><ol><li>并发</li><li>共享</li></ol><p>和进程一样有的特征：</p><ol><li>并发</li><li>异步</li></ol><p>操作系统的体系结构</p><p>现代操作系统三大特点</p><ol><li>面向对象<br> 例如管程；</li><li>微内核<br> 内核态可以看到所有的资源，用户态只能看到自己的资源；<br> 内核态和用户态的切换：看是应用程序在跑，还是操作系统在跑；</li><li>客户服务器架构<br> 例如假脱机，输入进程、输出进程，典型的客户服务器架构；</li></ol><h2 id="ch2"><a href="#ch2" class="headerlink" title="ch2"></a>ch2</h2><p>进程的两种关系：互斥关系、前驱（同步）关系；</p><p>为什么引入线程？</p><p>进程和线程的区别：<br>    进程：分配资源的单位，线程：独立运行的单位</p><p>前驱图要会画</p><p>整个进程的基本状态要明确：<br>    三个：就绪、执行、阻塞；<br>    五个：创建、就绪、执行、阻塞、终止；<br>    七个：创建、静止就绪、活动就绪、静止阻塞、活动阻塞、执行、终止；</p><p>状态的转换：<br>    刚开始程序在执行；<br>    需要资源——阻塞；<br>    如果在内存里，就是活动阻塞；<br>    资源得到满足，就绪；<br>    在内存里，活动就绪；<br>    如果内存空间不够，活动就绪、活动阻塞里，进行挂起，静止就绪、静止阻塞；<br>    静止阻塞，获得了资源，静止就绪，再被换入内存，唤醒，编程活动就绪；</p><p>进程 &#x3D; 程序+数据+PCB，程序、数据在用户态，PCB在内核态</p><p>进程和程序之间的区别</p><p>进程同步：<br>    互斥、同步关系的设计；<br>    关键点是找到临界区；</p><p>课堂上练习过的题目</p><p>进程同步四大规则</p><ol><li>空闲让进</li><li>忙则等待</li><li>有限等待</li><li>让权等待</li></ol><p>以四大规则为线索，有了多种进程同步的实现方式的演进</p><ol><li>硬件实现</li><li>信号量实现<br> 整型信号量，不能满足让权等待；<br> 记录型信号量，为什么可以满足让全等待？阻塞队列，将不满足的进程放到队列上；（例如不同的外设上都挂有等待资源的进程，每个资源都有对应的队列将这些进程挂上）；<br> AND型信号量，避免死锁，多个资源同时申请，不会一个拿到A要B，一个拿到B要A；<br> 信号量集，同一个资源可以申请多个；</li><li>管程</li></ol><p>AND型信号量和信号量集是在记录型信号量上的升级，功能强大了会损失一些效率；</p><p>四种信号量机制是怎么实现的，和后面调度的死锁问题联系在一起（预防死锁破坏必要条件）；</p><p>信号量的含义：初始值——资源的初始数量，变为0——资源耗尽，负数——等待的进程数；</p><p>几个特殊的信号量集</p><p>考大题，三大类：</p><ol><li>生产者消费者（基本形式要会写）</li><li>读者写者（不会直接考原题，会变形，例如过独木桥）</li><li>哲学家就餐（几种避免死锁的方法每种都要会写，对应了哪种预防死锁的方式）</li></ol><h2 id="ch3"><a href="#ch3" class="headerlink" title="ch3"></a>ch3</h2><p>处理机的调度和死锁，主要是计算题</p><p>调度的层次</p><ol><li>高级、中级、低级</li><li>长程、中程、短程</li><li>作业调度、存储器管理的挂起状态、进程调度</li></ol><p>高级调度计算：</p><ol><li>周转时间</li><li>平均周转时间</li><li>带权周转时间（越大效率越低）</li><li>平均带权周转时间</li></ol><p>高级调度算法：</p><ol><li>先来先服务</li><li>最短作业优先</li><li>高响应比优先（大概了解一下）</li></ol><p>作业调度只在批处理系统中有，其他系统中没有；</p><p>作业调度里有一个时间片算法？（进程调度里的轮转调度算法）</p><p>进程的保证调度算法；</p><p>死锁</p><p>预防死锁的四个必要条件：</p><ol><li>互斥</li><li>请求保持（AND型信号量，一次获得所有资源）</li><li>不可抢占（比较难实现，抢占你的资源，让你回退；）</li><li>环路等待（给每个进程加序号，从小到大申请；哲学家的几个基本上都是破坏了环路等待，除了AND的解决方案）</li></ol><p>预防死锁会有考点；</p><p>银行家算法，表格一定要记住（work allocation need allocation+work flag），合理性检查一定要做（两个检查）；</p><p>检测死锁，资源分配图；</p><h2 id="ch4"><a href="#ch4" class="headerlink" title="ch4"></a>ch4</h2><p>程序的装入和链接</p><p>装入：把逻辑地址变成真正可执行的地址（关键的核心点）；</p><p>几种装入方法（什么时候改地址）</p><ol><li>静态装入</li><li>可重定位装入，装入内存之后就不能改了</li><li>运行时装入，什么时候run什么时候改地址</li></ol><p>链接：关键是把分散的文件变成一个整体；</p><ol><li>静态链接：.exe文件，可执行文件，用静态链接</li><li>装入时链接：什么时候改地址，什么时候链接</li><li>运行时链接：run到了链接再链接过来</li></ol><p>静态不能共享，从装入时链接就可以实现共享了，运行时链接是在装入时链接的基础上节省空间资源；</p><p>连续分配存储管理方式（分配内存）</p><ol><li>首次适应算法</li><li>循环适应算法（用一个指针，指的是当前的位置）</li><li>最佳适应算法（要排序，小到大）</li><li>最坏适应算法（要排序，大到小）</li></ol><p>对换，知道有对换区就可以了；</p><h2 id="ch5"><a href="#ch5" class="headerlink" title="ch5"></a>ch5</h2><p>分页分段存储管理方式（离散的存储管理方式，数据是块，内存是页和页框）</p><p>页表、段表（长什么样）、地址转换机构、</p><p>基本分页、分段的时候，页表、段表长什么样、会算物理地址和逻辑地址的转换；</p><p>分页存储、分段存储，访问一次数据要多少次访问内存（基本的，没有快表，分页、分段都是两次；没有块表，段页式管理，三次）；</p><p>虚拟存储器，存储空间的决定方式（由地址结构决定）；</p><p>虚拟存储，请求分页、请求分段（在基本的基础上加了一些请求机构）；</p><p>虚拟分页、分段相对于基本分页、分段表头多出了哪几位（区别）；</p><p>虚拟存储，缺页中断要知道</p><ol><li>执行时发生缺页，陷入，调用缺页中断；</li><li>从外存将页面调进来；</li><li>如果内存空间足够的话直接调入，修改页表（如果有快表同步修改），中断响应完了，就从阻塞状态恢复到就绪状态，再次执行刚才发生了中断的指令（PC指在原位置）；</li><li>如果内存空间不够的话，使用页面置换算法完成页面的置换，将页面调进来，修改页表（有快表同步修改），进程阻塞到恢复（再次执行刚才发生了中断的指令）；<br>（所有的页面变化都要改页表，PC会指到原位置，再次访问页面）；</li></ol><p>虚拟存储，地址变换机构</p><p>页面置换算法：</p><ol><li>最佳置换算法（理想的，不能实际执行，baseline）</li><li>最近最久未使用（寄存器如何实现，置1右移，替换最小的）</li><li>先进先出（Belady现象，分的页面多了，效率反而变低了）</li></ol><p>请求分段，权限管理（了解，这次没怎么涉及）</p><p>知道抖动的概念；</p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DBS</title>
      <link href="/2025/09/30/DBS/"/>
      <url>/2025/09/30/DBS/</url>
      
        <content type="html"><![CDATA[<p><code>我在大学三年级的秋季学期选修了数据库系统导论这门课程，这篇blog用来记录：1）我对于相关知识点复习的梳理；2）一些习题；3）考试的重点</code></p><h2 id="复习梳理"><a href="#复习梳理" class="headerlink" title="复习梳理"></a>复习梳理</h2><p><code>复习梳理≠照搬原文，内容阐释点到为止，最重要的是达成两个目的1）梳理整体知识脉络，形成框架；2）标记重点，便于回到资料中复习；所以最后阶段的背诵记忆，应该用这份梳理为参考结合老师的资料进行</code></p><p><strong>期末：1）过一遍要背的；2）练习时间多关注关系代数、SQL、综合分析（关系数据理论）</strong>；</p><h2 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h2><p>这一章主要有4个部分，从前往后，1）在数据库系统概述中了解了与数据库有关的基本概念；2）在此基础上，为了把现实世界中的事物抽象为数据保存，我们学习了数据模型；3）有了抽象的数据模型之后，我们回到抽象的数据库系统，从整体上，探讨了数据库系统的三级模式；4）最后从细节上，了解了数据库系统的组成</p><h3 id="数据库系统概述"><a href="#数据库系统概述" class="headerlink" title="数据库系统概述"></a>数据库系统概述</h3><p><code>一些与数据库有关的基本概念</code></p><p><strong>数据：定义&amp;基本对象、特点（语义）</strong><br>    定义：数据库中存储的基本对象，描述事物的<strong>符号记录</strong>；<br>    特点：<strong>数据与语义</strong>是不可分的；<br><strong>数据库：定义（具有4个特点的集合）</strong><br>    数据库是<strong>长期存储</strong>在计算机内部的，<strong>有组织</strong>、<strong>可共享</strong>的<strong>大量数据</strong>的集合；<br>数据库管理系统：定义（某位置的软件）；缩写DBMS；能力（了解）<br>    位于用户与操作系统之间的一层数据库管理软件；<br>数据库系统：定义；构成（4）<br>    数据库+数据库管理系统+应用系统+数据库管理员；<br><em>关于数据库系统定义的理解（例如使用MySQL来管理数据的基础上，开发了一个实际的应用，就可以叫做数据库系统）</em>；</p><p><code>关于数据管理技术的发展，主要得注意DBS阶段和文件系统阶段的对比，以及数据库系统的特点</code></p><p>发展的阶段（3个阶段）</p><p>阶段对比：</p><p>共享程度（无共享，很多冗余-差共享，多冗余-多共享，低冗余）；</p><p>独立性（不独立，依赖程序-差独立，数据逻辑结构改变需修改程序-高度物理独立性与一定的逻辑独立性）；</p><p>结构化情况（无结构-记录内有结构，整体无结构-整体结构化）；</p><p>数据控制能力（应用控制-应用控制-数据库管理系统自己控制）</p><p><em>讨论独立性的时候，讨论的是数据与应用程序的独立性</em>；</p><p><strong>数据库系统的特点（4个特点，对应前面四种对比的维度）</strong>：</p><p>数据<strong>结构化</strong>：主要特点之一；不局限某一个应用；最小存取单位，数据项</p><p>数据的<strong>共享度高</strong>，<strong>冗余性低</strong>，易<strong>扩充</strong>；<br>（共享程度：面向整个系统，多个用户、应用）</p><p>数据的<strong>独立性</strong>高；<br>（独立性：物理独立性（数据物理存储、应用程序）；逻辑独立性（数据库逻辑结构、应用程序）；保障（二级映像））</p><p>数据由<strong>数据库管理系统</strong>（DBMS）<strong>统一管理</strong>：安全性、完整性、并发控制、错误恢复（稍微了解概念，每一点在后面都会作为章节展开）</p><h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><p>数据模型：通俗概念；工具定位</p><p>数据模型的分类：</p><p>两类数据模型：概念模型（信息模型）&amp;逻辑模型和物理模型</p><p>概念模型的一种表示方法：实体-联系方法</p><p><strong>逻辑模型</strong>包括：<strong>层次、网状、关系、面向对象、对象关系模型</strong>（逻辑模型是常用的，其中的关系模型更是我们重点学习的，因为其可以用于DBMS的实现）；<em>它们都是常用的数据模型</em></p><p>物理模型定位：对数据的最底层抽象，数据在系统内部或磁盘磁带上的存储方式与存取方法</p><p><strong>数据模型的组成要素</strong>：</p><p><strong>数据结构</strong>：定义；对系统静态特性的描述</p><p><strong>数据操作</strong>：定义；操作类型（查询、更新：插入、删除、修改）；对系统动态特性的描述</p><p>数据的<strong>完整性约束条件</strong>：定义（一组完整性规则的集合）；目的（数据正确、有效、相容）<br><em>有效对应符合规定的条件，相容对应满足数据间的一致性</em></p><p>概念模型：</p><p>概念模型用途：信息世界建模</p><p>信息世界基本概念：实体（客观存在、可区别的事物）；属性（实体的特性）；码（<strong>唯一</strong>标识实体的<strong>属性集</strong>）；域（属性取值范围）；实体型；实体集；联系（事物内部、事物之间-属性间、实体集间）</p><p>联系的分类：一对一联系、一对多联系、多对多联系</p><p><strong>E-R图</strong>：基本图形表示；各类联系的表示；码的表示；联系可以有属性；<br>（注意多对多联系在E-R图中，联系的属性有什么，<strong>学生选课联系作为多对多联系的属性只有Grade</strong>）；</p><p>层次模型：</p><p>数据库系统中最早出现的数据模型</p><p>满足的基本条件：1）有且仅有一个结点没有双亲结点，根结点；2）除根结点，其它结点有且只有一个双亲</p><p>网状模型：</p><p>网状数据库系统的组织方式，网状模型；<em>层次模型是网状模型的特例</em></p><p>满足的基本条件：1）允许一个以上的结点无双亲；2）一个结点可以有多于一个双亲结点</p><p>关系模型：</p><p>关系数据库系统的组织方式，关系模型；<em>几乎与所有计算机厂商退出的DBMS都支持关系模型，伟大无需多言~</em></p><p>关系模型的数据结构：关系（对应一张表，元组的集合）；元组（表中的一行）；属性（表中的一列，有名字）；码（属性组，唯一确定元组）；域；分量（元组的一个属性值）；</p><p>关系模型的操作：查询、插入、删除、更新；<em>集合操作，操作对象与结果都是关系，即元组的集合</em></p><p>关系模型的完整性约束：实体完整性、参照完整性、用户定义的完整性</p><p>关系模型的存储结构：实体以及联系都用表来进行（这也是关系模型的优点，概念单一）；<em>突然出现实体、联系的描述，我的理解：概念模型完成了对信息的建模，现在使用逻辑模型中的关系模型让这些抽象的信息建模具有逻辑关系，这里的逻辑关系指的是面向计算机编程的抽象逻辑，其对立面是真实的物理情况，而非抽象信息建模之间的逻辑关系（在概念模型的阶段就完成了）</em></p><p>关系模型的缺点：存取路径对用户隐蔽，可能导致用户使用效率较低的查询<br>关系的描述：关系模式；</p><p>关系的规范化：必需确保；<em>最基本的规范条件是，关系的每一个分量是不可分的数据项，绝不允许表中有表。否则就是非规范关系</em></p><h3 id="数据库系统的结构"><a href="#数据库系统的结构" class="headerlink" title="数据库系统的结构"></a>数据库系统的结构</h3><p><strong>数据库系统的结构****：三级模式结构</strong>，外模式-模式-内模式，外模式&#x2F;模式映像（逻辑独立性），模式&#x2F;内模式映像（物理独立性）</p><p>模式：数据库中全体数据的逻辑结构和特征的描述；需要对型进行描述；相对稳定；反映数据结构和联系</p><p>外模式：<strong>用户能够看见的</strong>局部数据的逻辑结构和特征描述</p><p>内模式：数据<strong>物理结构和存储方式</strong>的描述</p><p>型：对数据结构及属性的说明；（类比实体型，都是类似于“类”的概念）</p><p>值：型的具体赋值</p><p>实例：将模式整体看作一个型，实例就是值；反映了数据库某一个时刻的状态</p><h3 id="数据库系统的组成"><a href="#数据库系统的组成" class="headerlink" title="数据库系统的组成"></a>数据库系统的组成</h3><p>组成：数据库DB、数据库管理系统（及开发工具）DBMS、应用系统、数据库管理员DBA</p><h3 id="小结重点"><a href="#小结重点" class="headerlink" title="小结重点"></a>小结重点</h3><p>数据库系统概述：1）数据库基本概念；2）数据管理的发展过程</p><p>数据模型：1）数据模型的三要素；2）概念模型，E-R模型；3）三种主要数据库模型（层次、网状、关系，当然关系最重要）</p><p>数据库系统的结构：1）三级模式结构；2）数据库系统两层映像系统结构</p><p>数据库系统的组成</p><h2 id="关系数据库"><a href="#关系数据库" class="headerlink" title="关系数据库"></a>关系数据库</h2><h3 id="关系数据结构及形式化定义"><a href="#关系数据结构及形式化定义" class="headerlink" title="关系数据结构及形式化定义"></a>关系数据结构及形式化定义</h3><h4 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h4><p>关系模型的数据结构：关系，在用户角度，关系是一张二维表，列对应属性，行对应元组</p><p>关系定义的前置知识：</p><ol><li><strong>域（Domain）</strong>：一组具有相同数据类型的值的集合</li><li><strong>笛卡尔积</strong>：给定一组域，其笛卡尔积为一个集合，其中的元素形式为(d1,d2,…,dn)，di为分量，是来自域Di的值，将所有域中的进行组合得到类似的元素，然后形成的集合就是笛卡尔积</li><li><strong>元组</strong>，2.中提到的元素就是元组</li><li>分量，元组的分量的值，简称分量</li></ol><p>于是，笛卡尔积可以表示为一个二维表，其中的每一行对应一个元组，每一列的值来自一个域</p><p><strong>关系</strong>：域D1、D2、…、Dn的笛卡尔积的子集，即在D1，D2，…，Dn上的关系，表示为R(D1,D2,…,Dn)，其中R就是关系名，而n可以叫做关系的目或度（n&#x3D;1时为单元关系，n&#x3D;2时为二元关系）</p><p>元组的表示：通常用t进行标识</p><p>关系的表示：可以将关系看作一个二维表，行对应元组，列对应域</p><p><strong>属性</strong>：属性的引入是类似给域取了一个名字，毕竟域作为一个值的集合本身并没有名字，我们给它取一个名字可以反映这组值代表的含义。（这也是我们通常更关注的东西，例如对于一列元组的字符串分量值，比起关心它们都是字符串，我们更关心它们的实际含义，例如它们都代表名字）</p><p>码：<br><em>后面的章节中有更加严谨的定义，这里看看就好</em>；</p><ol><li>候选码：关系中某一属性组的值能够唯一标识一个元组，则该属性组是候选码</li><li>全码：当一个关系的候选码是所有属性构成的属性组时，该属性组称为全码</li><li>主码：如果一个关系有多个候选码的时候，则选定一个作为主码（注意，候选码本身也可能是属性组）</li><li>主属性：候选码对应属性组中的各个属性都是主属性（主属性不是主码的属性）</li><li>非主属性：不包含在任何候选码中的属性，即非主属性</li></ol><p>三类关系：</p><ol><li>基本关系：基本表，实际存在的表</li><li>查询表</li><li>视图表：由基本表或其他视图表导出的表，是虚表，不对应实际存储的数据</li></ol><p>基本关系的性质：</p><ol><li>列是同质的（相同数据类型、性质）</li><li>不同列可以出自同一个Domain</li><li>行、列顺序无所谓</li><li>任意两个元组的候选码不能相同</li><li>分量必须取原子量，不可再分（不能表中有表）</li></ol><h4 id="关系模式"><a href="#关系模式" class="headerlink" title="关系模式"></a>关系模式</h4><p>关系模式实际上就是对关系的描述，关系模式是型，关系是值</p><p>关系模式形式化表示：R(U,D,DOM,F)</p><ol><li>R关系名</li><li>U属性名集合</li><li>D属性 来自的 域 的集合</li><li>DOM属性向域的映像集合</li><li>F属性间依赖关系集合</li></ol><p>关系模式常用表示：R(A1,A2,…,An)</p><ol><li>R是关系名</li><li>A1～An是属性名<br>（实际使用的时候通常将候选码写在前面，分别用下划线强调；如果是关系组形成的候选码则下划线不间断）</li></ol><p>关系模式是静态的、稳定的；关系是动态的、变化的</p><h4 id="关系数据库-1"><a href="#关系数据库-1" class="headerlink" title="关系数据库"></a>关系数据库</h4><p>定义：给定应用领域，所有实体及实体之间的联系 的关系 的集合 构成一个关系数据库<br><code>结合实验1进行理解</code></p><h3 id="关系操作"><a href="#关系操作" class="headerlink" title="关系操作"></a>关系操作</h3><p>常用操作分为两大类：</p><ol><li>查询</li><li>数据更新</li></ol><p>查询包括：<strong>1）选择；2）投影；3）并；4）差；5）笛卡尔积；6）连接；7）除；8）交</strong></p><p>注：<strong>上述前五种是基本操作</strong></p><p>数据更新包括：1）插入；2）删除；3）修改</p><p>关系操作的特点：操作的所有对象以及结果都是<strong>集合</strong>（这是很自然的，因为关系本身就是集合）</p><p>常用的关系数据库语言：</p><ol><li>关系代数语言ISBL</li><li>关系演算语言</li><li>具有1、2的双重的语言，如SQL</li></ol><h3 id="关系的完整性"><a href="#关系的完整性" class="headerlink" title="关系的完整性"></a>关系的完整性</h3><p>关系有三类完整性约束：</p><h4 id="实体完整性"><a href="#实体完整性" class="headerlink" title="实体完整性"></a>实体完整性</h4><p>实体完整性规则：一个或一组属性A是基本关系R的主属性，则A不能取空值</p><p>细节说明：</p><ol><li>实体完整性针对基本表（对应现实世界实体集合）</li><li>主码不可重复，让实体可区分</li><li>关系模型中主码作为唯一标识（这里已经不再强调候选码了，尽管其仍然存在）</li><li>主属性不能取空值</li></ol><h4 id="参照完整性"><a href="#参照完整性" class="headerlink" title="参照完整性"></a>参照完整性</h4><p>关系间的引用：由于实体 实体间的联系 都被抽象为关系，所以可能存在关系间的引用（尤其是在表示联系的时候，考虑一下SC和Student、Course就明白了）</p><p>外码：F是R的属性，且非主码  对应了S的主码   则F是R的外码</p><ol><li>R是参照关系</li><li>S是被参照关系</li></ol><p>注意：</p><ol><li>参照关系与被参照关系不一定是不同关系（班长的例子）</li><li>外码 与 对应的主码 一定在同一Domain</li><li>通常：1）若参照关系与被参照关系上同一关系，外码与对应主码不同名；2）若参照关系与被参照关系不是同一关系，外码与主码同名</li></ol><p>参照完整性约束：若属性是基本关系的外码，则其 或取空值 或等于对应主码的某个值</p><h4 id="用户定义的完整性约束"><a href="#用户定义的完整性约束" class="headerlink" title="用户定义的完整性约束"></a>用户定义的完整性约束</h4><p>结合实验2的表项自己的限制 or 表项之间的限制 理解即可</p><h3 id="关系代数"><a href="#关系代数" class="headerlink" title="关系代数"></a>关系代数</h3><p><em>这里的笔记只是一些基础概念，要结合试题进行练习，期末会考察10分</em></p><p>关系代数是一种具体的关系数据库语言，具备相应的关系操作（关系代数中称为关系运算），以及完整性约束？或许，总之在这一部分我们学习了一种具体的关系数据库语言，并且着重关注其中的关系运算部分。（后续还有关系演算、SQL标准语言）</p><h4 id="运算符的前置知识"><a href="#运算符的前置知识" class="headerlink" title="运算符的前置知识"></a>运算符的前置知识</h4><p>它们的作用主要是作为一种语言，来对下面的各个运算符进行定义</p><ol><li>关系$R$</li><li>元组$t$</li><li>属性$A$</li><li>元组的属性值$t[A_i]$</li><li>剩余属性组</li><li>$t_r$与$t_s$连接的新元组</li><li>象集$Z_x$，若属性Z、X是关系R的属性，则在R上象集$Z_x$是X属性值为x的元组的Z属性值的集合</li></ol><p>象集对于理解除运算很重要，其实就是属性值的集合，只是要明白这个属性值时如何取出来的</p><h4 id="集合运算符"><a href="#集合运算符" class="headerlink" title="集合运算符"></a>集合运算符</h4><p><strong>集合运算符：</strong></p><ol><li>并 $\cup$</li><li>交 $\cap$</li><li>差 $\sub$</li><li>笛卡尔积 $\times$</li></ol><p>并、交、差：若关系R、S进行前三种运算，则<strong>R、S具有的属性一定相同</strong><br>笛卡尔积：$R\times S$，运算规则类似双重for循环，对R的每一个元组，与S的每一个元组完成一次组合，生成一个新的元组，其各属性名为$R.XXX…S.YYY…$</p><h4 id="专门的关系运算符"><a href="#专门的关系运算符" class="headerlink" title="专门的关系运算符"></a>专门的关系运算符</h4><p><strong>专门的关系运算符：</strong></p><ol><li>选择 $\sigma_F$</li><li>投影 $\Pi_A$</li><li>连接 $\bowtie$（自然连接的符号）</li><li>除 $\div$</li></ol><p>前三个符号的说明：</p><ol><li>选择是单目运算符 运算时对每个元组 判断逻辑表达式F对真假 为真则选中保留进入结果表格</li><li>投影是单目运算符 运算时对整个关系 保留选定的属性（组）A 进入结果表格</li><li>连接符号是双目运算符 运算时对关系R的每个元组 进行类似笛卡尔积时的双重循环 但完成一对元组的连接并纳入结果表 条件是逻辑表达式F被满足（普通的连接符号在$\bowtie$下面有逻辑表达式F）</li></ol><p>对连接进行补充：</p><ol><li>自然连接 额外的条件是进行运算的两个关系<strong>一定有相同的属性（组）</strong>，连接条件默认是元组的相同属性（组）值，相同即连接</li><li>左外连接，以左边为准进行双重for循环的遍历，即使右侧没有出现满足条件的元组，可以让外层for循环，当前选中的左侧元组，也要保留该元组值，对应新元组的右侧关系属性值设置为NULL</li><li>右外连接，与左外连接类似，以右侧为标准（将右侧关系的元组放在双重for循环的外层）</li><li>外连接，左外连接与右外连接结果的并</li></ol><p>注：上面对for循环的描述只是为了大脑思考的时候便于理解，实际上把谁放在外层循环，先做后做都是等价的</p><p>涉及逻辑表达式的部分会有：<br>    1）<strong>算数比较符</strong>；<br>    2）<strong>逻辑运算符</strong>；</p><p><strong>关于除运算</strong>：</p><ol><li>R与S进行除运算的条件，R与S有相同的属性（组）</li><li>$R(X,Y)\div S(Y,Z)$的结果是以$X$的属性值，形成的元组的集合</li><li>满足条件的属性值，要求关系S的$Y$是R上象集$Y_x$的子集</li></ol><p>除运算的过程，对于R的每一个元组，找到其X属性值，然后看一看对应的象集$Y_x$，即同样具有该属性值的所有元组的所有Y值有哪些，如果这些值覆盖了S的所有Y值，那么该X属性值可以纳入结果。</p><h3 id="关系演算"><a href="#关系演算" class="headerlink" title="关系演算"></a>关系演算</h3><p>以数理逻辑的谓词演算为基础，主要是两种类型</p><ol><li>元组关系演算（ALPHA）</li><li>域关系演算（QBE）</li></ol><p>我们学习过的是元组关系演算</p><p>这一部分可以稍作了解，但是最重要的是明确——理解关系演算对SQL查询语句的执行很有帮助。</p><h2 id="数据库系统"><a href="#数据库系统" class="headerlink" title="数据库系统"></a>数据库系统</h2><h3 id="SQL概述"><a href="#SQL概述" class="headerlink" title="SQL概述"></a>SQL概述</h3><p><em>SQL语句拿不准的要写注释</em></p><p>SQL：结构化查语言，关系数据库的标准语言</p><p><strong>SQL的特点</strong>：</p><ol><li><strong>综合统一</strong>：DDL、DQL、DML、DCL集于一体</li><li><strong>高度非过程化</strong>：只需要注意做什么，无需关注怎么做</li><li><strong>面向集合的操作方式</strong>：操作的对象与结果都是元组的集合</li><li>同一种结构提供<strong>多种使用方式</strong>：<strong>交互式、嵌入式</strong>；<br> （多种功能，既是独立于言又是嵌入式语言）；</li><li><strong>语言简洁，易学易用</strong>：9个核心动词，完成核心功能（对应的就是<strong>DDL</strong> CREATE DROP ALTER、<strong>DQL</strong> SELECT、<strong>DML</strong> INSERT DELETE UPDATE、<strong>DCL</strong> GRANT REVOKE）<br><code>145 2 3</code></li></ol><p>注意理解<strong>非过程化</strong>、<strong>面向集合</strong></p><p>SQL对于关系模式数据库的支持：SQL的存储文件对应内模式、基本表对应模式、视图对应外模式，由SQL统一管理</p><ol><li>存储数据库组织关系数据库的内模式、物理结构对用户透明</li><li>基本表，对应SQL一个关系，本身独立存在</li><li>视图，数据库中只存放视图的定义，不存放视图对应的数据，视图是一个虚表</li></ol><h3 id="DDL语句"><a href="#DDL语句" class="headerlink" title="DDL语句"></a>DDL语句</h3><p>DDL：数据定义语言</p><p>在SQL的DDL语言如下</p><ol><li>CREATE</li><li>DROP</li><li>ALTER</li></ol><h4 id="模式DDL"><a href="#模式DDL" class="headerlink" title="模式DDL"></a>模式DDL</h4><p>这一部分了解就好，知道有一个模式SCHEMA的存在，类似于命名空间。</p><p>每一个基本表都属于某一个模式</p><p>一个模式可以包含多个基本表</p><h4 id="基本表DDL"><a href="#基本表DDL" class="headerlink" title="基本表DDL"></a>基本表DDL</h4><p><strong>创建基本表的基本范式</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">CREATE TABLE &lt;name &gt;</span><br><span class="line">(</span><br><span class="line">    &lt;col name &gt; &lt;data <span class="built_in">type</span> &gt; [列级完整性约束]</span><br><span class="line">    [, ...] [...]</span><br><span class="line">    [, 表级完整性约束]</span><br><span class="line">    [, ...]</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注：如果完整性约束涉及多个列，那必须定义在表级</p><p>在这一部分应该掌握的语句</p><ol><li>基本范式的最基础使用</li><li>常用的data type：CHAR(length) SMALLINT INT REAL DATE TIME</li><li>指定某一列为主码，指定多个列一起作为主码</li><li>指定某一列取值唯一</li><li>指定某一列不能为空值</li><li>指定外码</li></ol><p><strong>修改基本表的基本范式</strong></p><p>ALTER TABLE Student<br>DROP Sname <strong>UNIQUE</strong>;</p><p>ALTER TABLE Student<br>ADD Ssex CHAR(2) CHECK IN (‘F’,’M’);</p><p>ALTER TABLE Student<br>ALTER <strong>COLUMN</strong> Ssex CHAR(10);</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ALTER TABLE &lt;name &gt;</span><br><span class="line">[ADD &lt;col name&gt; &lt;data <span class="built_in">type</span>&gt; &lt;完整性约束&gt;] //增加新列</span><br><span class="line">[DROP &lt;col name&gt; &lt;完整性约束&gt;] //删除列，注意删除的时候要附上该列的完整性约束</span><br><span class="line">[ALTER COLUMN &lt;col name&gt; &lt;data <span class="built_in">type</span>&gt;]; //更改列的数据类型</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注：</p><ol><li>新增加的列在已有元组中默认为空值NULL</li><li>ADD有直接添加完整性约束的用法，类似<code>ADD UNIQUE(Cname)</code></li></ol><p><strong>删除基本表的基本范式</strong><br>    CASCADE&#x2F;RESTRICT</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">DROP TBALE &lt;name &gt;</span><br><span class="line">[CASCADE | RESTRICT];</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注：</p><ol><li>CASCADE对应级联删除，删除该表的同时其所有的依赖对象（FOREIGN KEY引用、VIEW…都会被一起删除）</li><li>RESTRICT，如果该表还有其他依赖的话则erro，否则删除</li></ol><h4 id="索引DDL"><a href="#索引DDL" class="headerlink" title="索引DDL"></a>索引DDL</h4><p><code>关于索引也是了解就好，知道有这个东西的存在</code></p><p>索引的目的：加快查询速度</p><p>索引的分类</p><ol><li>唯一索引</li><li>非唯一索引</li><li>聚簇索引</li></ol><p>索引是关系数据库的内部实现技术，属于内模式的范畴，常用的实现方式有B+树索引、HASH索引等</p><p>注：一个基本表上最多只能建立一个聚簇索引</p><h3 id="DQL语句"><a href="#DQL语句" class="headerlink" title="DQL语句"></a>DQL语句</h3><p>这一部分是数据查询语言，基本上都是在基本表上进行的</p><p><strong>基本范式：</strong></p><p>DISTINCT&#x2F;ALL;<br>ASC&#x2F;DESC;</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SELECT [DISTINCT|ALL]&lt;目标列表表达式 &gt; [,&lt;目标列表表达式&gt;...] </span><br><span class="line">FROM &lt;表名 or 视图名 &gt; [,&lt;表名 or 视图名 &gt;...]</span><br><span class="line">[WHERE &lt;条件表达式&gt;]</span><br><span class="line">[GROUP BY &lt;col name&gt;]</span><br><span class="line">[HAVING &lt;条件表达式&gt;]</span><br><span class="line">[ORDER BY &lt;col name&gt; [ASC|DESC]];</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="单表查询"><a href="#单表查询" class="headerlink" title="单表查询"></a>单表查询</h4><p><code>单表查询部分在逻辑上理解不困难，难点主要是掌握各种语句的用法，这里主要采用列举例题与对应知识点的形式，复习的时候要做到看到例题能够想到考察的知识点与对应的查询语句是什么</code></p><p>选择<strong>指定列</strong><br>    eg：查询学生表中的学号、姓名；</p><p>查询<strong>全部列</strong><br>    eg：查询学生表的信息；</p><p>查询<strong>经过计算的表达式</strong><br>    <strong>算数表达式</strong><br>        eg：查询学生的出生年份<br>    <strong>字符串常量</strong><br>        主要作用是对结果进行修饰，对应输入的字符串常量在结果中<strong>单独占一列</strong>，其相对于其他列的位置由查询语句确定，独占的一列从属性名到所有的属性值都是该字符串常量<br>    <strong>函数</strong>：LOWER、UPPER等（作用是对相应的属性列中的属性值，全部显示经过函数处理该属性值的结果）<br>        eg：查询学生姓名以及对应的所在院系，院系名称全部用小写<br>            <strong>时间操作有关函数？</strong><br>            1）当前日期&#x2F;时间：CURRENT_DATE&#x2F;CURRENT_TIME；<br>            2）时间的运算：<br>                <strong>提取时间直接运算</strong>：<br>                    EXTRACT(YEAR FROM CURRENT_DATE) - EXTRACT(YEAR FROM BitrhDate);<br>                <strong>使用时间间隔符</strong>：<br>                    CURRENT_DATE - INTERVAL ‘3’ YEAR&#x2F;MONTH&#x2F;DAY;&#x2F;&#x2F;字符数字代表对应的时间度量，后面的关键字用来指定年月日单位；<br>            3）计算两个日期的天数差：<br>                DATEDIFF(CURDATE,BirthDATE);&#x2F;&#x2F;MySQL语法；<br>    列别名：<strong>别名紧跟在属性名</strong>之后，不加逗号；（对比查询不同属性列时用逗号隔开）<br>        eg：查询所有学生的出生日期，并使用列别名让结果对用户更友好</p><p>选中表中的若干元组<br>    对查询结果去重与否<br>        SELECT DISTINCT&#x2F;ALL Sno…（缺省默认ALL）<br>    查询满足条件的元组<br>        WHERE<br>            比较：&#x3D; &gt; &lt; &gt;&#x3D; &lt;&#x3D; !&#x3D; &lt;&gt; !&gt; !&lt;<br>                eg：查询计算机专业的学生<br>            确定范围：<strong>BETWEEN AND&#x2F; NOT BETWEEN AND</strong><br>                eg：查询年龄在13到15的学生<br>            与集合的关系：<strong>IN&#x2F; NOT IN</strong><br>                eg：查询是计算机或信息技术或数学系的学生<br>            字符匹配：<strong>LIKE&#x2F; NOT LIKE</strong><br>                eg：查询姓刘的学生；查询姓欧阳并且全名三个字的学生<br>            空值：<strong>IS NULL&#x2F; IS NOT NULL</strong><br>            多重条件：<strong>AND&#x2F; OR&#x2F; NOT</strong></p><p>对<strong>查询结果排序</strong><br>    ORDER BY 指定排序参考的属性，<strong>默认ASC升序</strong>、DESC是降序<br>    当排序含有空值的时候，若为ASC空值会最后显示；若为DESC空值会最先显示（<strong>空值被作为了最大值</strong>）<br>    可以有<strong>多个排序条件</strong>（靠前的条件优先级更高，当靠前的条件对应的属性值是相同的时候则会使用下一个条件进一步排序；结果就好像每个元组被分为了一个个整体，并且整体内有序）<br>    eg：查询全体学生情况，结果按所在系的系号升序排序，同一系中的学生按年龄降序排序<br>        **OREDER BY Sdept (ASC), Sage DESC;**（ASC可以默认省略）；</p><p>对查询的属性列使用<strong>聚集函数</strong>（这里主要体现于<strong>用在SELECT之后</strong>）<br>    COUNT<br>        <strong>DISTINCT&#x2F; ALL是可选的</strong>，后者是默认的；<br>        COUNT的效果是统计查询到的元组的个数 or 某属性列值的个数，对应的结果是仅有一个数字属性的元组，代表原先有多少元组；<br>        所以COUNT一般是单独使用的；<br>        eg：查询学生的总人数；查询选修了课程的学生人数<br>            SELECT COUNT(<em>) FROM Student;<br>            SELECT COUNT(DISTINCT Sno) FROM SC;（**注意DISTINCT和COUNT的使用位置 和 实际的用法，</em>或指定具体的列**）；<br>    SUM<br>        <strong>DISTINCT&#x2F; ALL是可选的</strong>，前者是默认的；<br>        计算一列值的总和，要用于数值型的属性列<br>        eg：查询1号学生选修课程的总学分<br>    AVG<br>        <strong>DISTINCT&#x2F; ALL是可选的</strong>，前者是默认的；<br>        计算一列值的平均值，要用于数值型的属性列<br>        eg：计算1号学生的平均成绩<br>    MAX<br>        <strong>求一列中的最大值，一般用于数值型</strong><br>        eg：查询1号学生选修课程的最高分<br>    MIN<br>        <strong>求一列中的最小值，一般用于数值型</strong></p><p>分组查询<br>    GROUP BY语句，目的是为了让<strong>聚集函数可以更加细粒度地进行使用</strong><br>    一般不会单独使用，不会有视觉上的“分组效果”，如果要有的话应该使用多层排序<br>    两种用法：<br>        分组+聚集函数，聚集函数的作用效果上组内的所有元组<br>            eg：查询选修每个课程对应的学生人数<br>            SELECT <strong>DISTINCT</strong> Cno,COUNT(<em>)<br>            FROM SC<br>            GROUP BY Cno;<br>            注意：<br>                1）这里<strong>不需要使用DISTINCT</strong>，因为GROUP BY强制要求对于每一组在结果集合中只有一条数据，而这里使用的Cno以及聚集函数作为结果，对应分组条件，天然的每组就只有一条数据；<br>                2）如果SELECT语句中除了分组列和聚合函数（如COUNT(</em>)）之外，还有其他列，那么这些列可能来自分组内的不同行，这时可能需要使用聚合函数（如MAX, MIN, AVG等）来处理，否则在某些数据库系统中会报错（因为非分组列在分组后有多值，而结果集要求一行只能有一个值）。<br>        分组+聚集函数+筛选组，HAVING语句，以组为单位进行筛选<br>            eg：找出选修了5门及以上课程的学生学号<br>            （注意HAVING与WHERE的区别）<br>            SELECT Sno<br>            FROM Student<br>            GROUP BY Sno<br>            HAVING COUNT(*)&gt;&#x3D;5;</p><h4 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h4><p><code>要求与单表查询类似，只是要深入理解连接的作用与效果</code></p><p>各种<strong>连接查询</strong>的共同点<br>    在<strong>FROM</strong>之后有多个表<br>    如果表中有相同的属性的话，使用的时候要用<strong>TABLE_NAME.COL</strong>的形式<br>    在WHERE之后<strong>使用来自各表中的属性，规定连接条件</strong><br>    在脑海中考虑连接查询的过程，要先根据连接条件在脑子里有一个<strong>连接后的表的印象，然后将其考虑为单表，在其上进一步查询</strong></p><p>等值连接（自然连接）与非等值连接<br>    <strong>等值连接</strong><br>        在WHERE连接条件中，出现来自各表等属性满足“&#x3D;”关系<br>    <strong>自然连接</strong><br>        在等值连接的基础上，通过指定列手动实现；<br>        （连接条件是，相同的属性值相等）；<br>        （指定的列满足，在保留两个关系所有列的基础上，去掉重复的列）；<br>        eg：查询每个学生及其选修课的情况<br>    非等值连接（不常用）</p><p><strong>自身连接</strong><br>    一个表与自己连接，要求：<strong>给表取别名，用别名访问属性</strong>，这样才能区别开<br>    eg：查询一门课的先修课的先修课<br>    SELECT a.Cno, b.pre<br>    FROM Course a,Course b<br>    WHERE a.pre &#x3D; b.Cno;</p><p><strong>外连接</strong><br>    使用语句<strong>FROM ? LEFT OUTER JOIN ? ON (F)<strong>，这是左外连接，左边的是主表，F是外连接的条件；区别在于即使不满足条件的时候也会将主表保留下来，对应元组在连接后的表中没有的属性值置为空值<br>    类似的还有</strong>RIGHT OUTER JOIN</strong><br>    eg：查询每个学生及其选修课程（当然不能因为没选修课程而将对应的学生忽略）</p><p><strong>多表连接</strong><br>    FROM后跟有多个表名，对应的要在WHERE中注明连接条件<br>    考虑的时候，可以先考虑两个表连接成一张大表，在考虑这张大表与下一张表做对应的连接</p><h4 id="嵌套查询"><a href="#嵌套查询" class="headerlink" title="嵌套查询"></a>嵌套查询</h4><p><strong>查询块：</strong><br>    一个SELECT-FROM-WHERE语句作为一个完整的查询块（当然可以配套其他关键字使用）</p><p><strong>嵌套查询：</strong><br>    将<strong>一个查询块嵌套在另一个查询块</strong>的<strong>WHERE子句</strong>或者<strong>HAVING短语</strong>条件中<br>    eg：查询选修了课程名为IS的课程的学生的学号</p><p><strong>不相关子查询：</strong><br>    定义：子查询的查询条件不依赖于父查询<br>    处理：这种可以逐层考虑，因为各层查询基本上是独立的</p><p><strong>相关子查询</strong><br>    定义：子查询的条件依赖于父查询<br>    处理：<br>        1）这种考虑的时候通常，按上层查询的元组进行考虑，对于<strong>上层查询的每一个元组</strong>会<strong>做一次子查询</strong>；而元组则作为子查询可能用到的条件（就像将元组作为参数去调用作为函数的查询一样）<br>        2）上层查询和下层查询如果用到了同一关系，需要给关系取别名<br>    eg：查询学生选课记录中，学生高于自己选修课程的平均分的选课记录中的学号和课程号</p><p><strong>子查询的限制：</strong><br>    1）不能使用ORDER BY子句，因为ORDER BY子句只能对最终结果进行排序<br>    2）子查询一定要在比较符之后（写SQL语句的时候，不能头重脚轻）</p><p><strong>常见的嵌套查询：</strong><br>    1）带IN谓词的子查询<br>        应用场景：通常用于检查上层查询中的某个元组的某属性是否在一些满足特定条件的集合中，由于集合的构造逻辑比较复杂所以要用一个子查询来进行描述。<br>        eg：<br>            1）查询所有与刘晨同学在相同系进行学习的学生学号、姓名和年龄<br>            2）查询选修了“信息系统”这门课程的学生的学号和姓名<br>    2）带有比较运算符的子查询<br>        应用场景：<br>            一般是用于上层元组的可比较属性需要满足特定条件时，该条件的构造比较复杂所以用子查询描述；<br>            子查询要返回一个单值；<br>            需要使用IN的场景，并且子查询返回的是单值，可以用”&#x3D;”<br>        eg：<br>            查询每个学生超过他自己所有选修课程的平均成绩的课程号<br>    3）带有ANY（SOME）或ALL谓词的子查询<br>        应用场景：<br>            常与带有比较运算符的子查询一起用，使用ANY（SOME）or ALL来描述上层查询需要满足的更加复杂的条件<br>            ANY和SOME是等价的，只是两种记法。和比较运算符一起用的常见情况：<br>                1）&gt;ANY，大于子查询中某个值即可<br>                2）&gt;ALL，大于子查询中所有的值<br>                （其他比较类似，ANY要求有某个子查询的结果满足就可以视上层元组满足条件；ALL则要求子查询的所有结果都满足才行）<br>        eg：<br>            1）查询其他系中比计算机科学系所有学生年龄都小的学生姓名及年龄（比年龄最小的还小）<br>        注意：<br>            ANY和ALL可以实现的效果，也可以在带有比较运算符中运用MIN、MAX聚集函数来实现（语义上的等价，很好理解）<br>    4）带有EXISTS谓词的子查询<br>        应用场景：<br>            带有EXISTS谓词的子查询不会返回任何数据，只会返回true or false（子查询有数据 or 没有数据），作为对上层元组是否满足条件的判断；<br>            由于上述特点，所以其应用场景一般是相关子查询，要用上层查询的元组与子查询构造条件<br>        eg：<br>            1）查询所有选修了1号课程的学生姓名<br>            2）查询没有选修1号课程的学生姓名<br>            3）查询与刘晨在同一个系学习的学生<br>        注意：<br>            1）NOT EXISTS的用法和EXISTS类似，只是返回true、false的情况是反着的；<br>            2）由于使用EXISTS谓词不会关注其返回的信息，所以子查询通常用SELECT *；<br>            3）前面所有的子查询都可以用EXISTS实现</p><h3 id="DML语句"><a href="#DML语句" class="headerlink" title="DML语句"></a>DML语句</h3><p>对数据（元组）的操作<br>    <strong>插入数据</strong><br>        INSERT INTO … VALUES…<br>        （省略号处是表名和属性列；VALUES后要使用对应属性列的常量）<br>        注意：<br>            1）带子查询的插入数据：对应VALUES…部分由SELECT语句替换，该语句要返回与INTO后指定的各列一致的数据<br>        eg：<br>            1）将张成名的信息插入Student表<br>                INSERT INTO Student Sno,Sname,Sage,Ssex,Sdept<br>                VALUES (S001,’张成名’,18,’男’,’CS’);<br>            2）对于每一个系，求学生的平均年龄，插入表格中；对应属性（系名，平均年龄）<br>    修改数据<br>        UPDATE…（指定表名）<br>        SET…（设置列名对应的属性值，属性值可以是表达式）<br>        …（WHERE附加的条件）<br>        注意：<br>            1）附加的条件一般来说是必要的，否则就是对整列进行修改<br>            2）带子查询的修改，一般是将相关子查询用在WHERE中，构造较为复杂的修改判断条件<br>        eg：<br>            1）将学生200215121的年龄修改为22岁<br>            2）将计算机系全体学生成绩置0<br>    删除数据<br>        DELETE<br>        FROM…<br>        …（WHERE附加的条件）<br>        注意：<br>            1）与修改数据类似，在不附加条件的情况下会删除所有元组，但是表仍然存在<br>            2）子查询与修改不同的点，DELETE实际上是要用WHERE指定特定的删除对象的<br>            （通常是用WHERE条件指定候选码，从而删除指定的元组；毕竟是以元组为单位操作的，如果单独删除某列数据没有意义，这与UPDATE不同）<br>        eg：<br>            1）删除计算机系所有学生的选课记录<br>            2）删除计算机系所有学生的选课记录</p><h3 id="空值处理"><a href="#空值处理" class="headerlink" title="空值处理"></a>空值处理</h3><p>空值的产生<br>    1）插入<br>    2）修改</p><p>空值的判断<br>    1）IS NULL<br>    2）IS NOT NULL</p><p>空值的约束<br>    1）CREATE语句中若对属性列使用了NOT NULL、UNIQUE进行限制，不能取空值<br>    2）码属性不能为空值（PRIMARY KEY）</p><p>空值的运算<br>    1）有空值的算数运算为空值<br>    2）有空值的比较运算为UNKNOWN<br>    3）有空值的逻辑运算为True或FALSE或Unkonw：<br>        类似于：F&gt;U&gt;T(AND);T&gt;U&gt;F(AND);!U&#x3D;U</p><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p>视图<br>    定义：虚表，是从一个或几个基本表（或视图）导出的表，数据库中只存放其定义，不存放相应的数据<br>    注意：<br>        如果一个视图是从一个基本表导出来的，则它是<strong>行列子集视图</strong></p><p>视图定义<br>    CREATE VIEW …（不指定对应全部列 or 指定列）<br>    AS …（子查询，要与VIEW后的对应列相匹配）<br>    …<br>    （WITH CHECK OPTION，可选的，一般在子查询中存在WHERE语句的时候启用，启用后对视图的插入和修改会保证元组满足WHERE条件）<br>    注意：<br>        1）创建的时候可以基于多个表，只需在子查询中指定即可，但无论如何子查询返回的数据要与VIEW的属性列相匹配<br>        2）创建的时候也可以基于视图，子查询中对视图查询即可<br>        3）子查询中对属性列可以使用表达式；子查询中可以使用分组+聚集函数；都是为了满足视图的信息需要</p><p>删除视图<br>    DROP VIEW 视图名 …（是否用CASCADE）<br>    注意：<br>        1）对应删除了视图的定义<br>        2）如果该视图上导出了其他视图，要用CASCADE及联删除</p><p>查询视图<br>    与查询基本表相同</p><p>更新视图<br>    对视图使用INSERT、UPDATE、DELETE起头的语句，即视图的更新<br>    注意：<br>        1）行列子集视图可以进行更新<br>        2）常见的不能更新的视图：<br>            视图由两个以上基本表导出；<br>            视图上定义的视图不能更新；<br>            视图中的一个元组的数据对应来自基本表中的多个数据不能更新（这种情况可能由子查询有聚集函数、GROUP BY语句、DISTINCT短语…导致）</p><p>视图的作用：<br>    1）能够简化用户的操作<br>    2）使用户以多种视角看待同一数据<br>    3）对重构数据库提供了一定程度的逻辑独立性<br>    4）对机密数据提供安全保护<br>    5）更清晰地表达查询</p><h2 id="数据库安全性"><a href="#数据库安全性" class="headerlink" title="数据库安全性"></a>数据库安全性</h2><p><code>重点是数据库安全的策略、SQL授权语句</code></p><p>数据库安全性：数据库安全性是指保护数据库，防止不合法使用所造成的数据泄露、更改或破坏；</p><p>数据库安全性控制的常用方法：<br>    1）用户身份鉴别；<br>        地位：DBMS提供的最外层安全保护措施；<br>        含义：<br>            每个用户在系统中有一个用户标识，由用户名和用户标识号组成（user name 和 UID），对此标识进行鉴别，确定是否是对应用户；<br>        常用方法：<br>            静态口令，eg：密码；<br>            动态口令，eg：短信密码、动态令牌；<br>            生物特征，eg：指纹；<br>            智能卡，不可复制的硬件；<br>    2）多层存取控制；<br>        存取控制：<br>            机制组成：<br>                1）用户权限的定义；<br>                2）合法权限的检查；<br>        自主存取控制方法（DAC）；<br>            安全等级：C2，灵活<br>            实现方式：<br>                GRANT、REVOKE语句；<br>        强制存取控制方法（MAC）；<br>            安全等级：B1，严格<br>            适用于对数据由严格而固定密级分类的部分，例如军事部门、政府部门；<br>                方法：<br>                    主体：DBMS所管理的实际用户；<br>                    客体：各用户的进程；<br>                        eg：操作文件、基本表、索引、视图；<br>                    敏感度标记：<br>                        1）绝密；<br>                        2）机密；<br>                        3）可信；<br>                        4）公开；<br>                        注意：<br>                            1）主体与客体都有敏感度标记；<br>                            2）主体的称为：许可证级别；<br>                            3）客体的称为：密级；<br>                    规则：<br>                        1）读取：仅当主体许可证级别大于或等于对应客体的密级，才能让主体读取客体；<br>                        2）写入：仅当主题许可证级别等于对应客体时才能写入<br>                        3）同级读写，高级可读；<br>    3）审计；<br>        审计日志：<br>            保存用户的所有操作记录，DBA可以找到非法存取数据的人、时间、内容；<br>        用户级审计：<br>            针对自己创建的数据库表或视图进行审计；<br>        系统级审计：<br>            检测成功或失败的登陆要求；<br>            检测GRANT、REVOKE操作以及其他数据库级权限下的操作；<br>    4）视图；<br>        将要保密的数据对无权存取这些数据对用户隐藏起来，对数据提供一定程度的安全保护；<br>    5）数据加密；<br>        根据一定的算法将原始数据变换为不可直接识别的格式；<br>        存储加密、传输加密；</p><p>自主存取控制：<br>    GRANT语句的使用；<br>        1）一般用法；<br>        2）授权所有权限：GRANT ALL PRIVILEGES …<br>        3）授权给所有人：… TO PUBLIC；<br>        4）授权特定列：GRANT UPDATE(Sno) …<br>        5）授予人将相同权限授予出去的能力：… WITH GRANT OPTION;<br>    REVOKE语句的使用：<br>        1）一般用法；<br>        2）从所有用户收回：… FROM PUBLIC;<br>        3）级联收回：… FROM U5 CASCADE;<br>    角色：<br>        创建：<br>            CREATE ROLE &lt;角色名&gt;<br>    授予、回收权限：<br>        将角色名用在用户的位置；<br>    将角色授予其他角色或用户：<br>        将角色名用在权限的位置；<br>        可选的转授能力：<br>            [WITH ADMIN OPTION]</p><p>GRANT一般用法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GRANT &lt;权限 &gt;[,...]</span><br><span class="line">ON &lt;对象类型 &gt; &lt;对象名 &gt;[,...]</span><br><span class="line">TO &lt;USER &gt;[,...]</span><br><span class="line">[WITH GRANT OPTION]</span><br></pre></td></tr></table></figure><p>注意对象类型，因为不一定是基本表，也可以是视图等；</p><p>REVOKE一般用法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">REVOKE &lt;权限 &gt;[,...]</span><br><span class="line">ON &lt;对象类型 &gt; &lt;对象名 &gt;[,...]</span><br><span class="line">FROM &lt;用户 &gt;[,...];</span><br></pre></td></tr></table></figure><h2 id="数据库完整性"><a href="#数据库完整性" class="headerlink" title="数据库完整性"></a>数据库完整性</h2><p><code>实际上我们在前面的关系部分也有关系的完整性约束，尝试进行对比。</code></p><p>数据库完整性：<br>    定义：数据的正确、有效和相容；（<strong>也是数据库的一致性</strong>）；<br>        1）正确：数据要符合语义；<br>        2）有效：数据有有效期限；（eg，验证码过了时效就不能用了）；<br>        3）相容：同一关系同一元组，同一关系不同元组，不同关系不同元组，之间的数据一致性；<br>    面对的场景：<br>        1）合法用户合法操作；<br>        2）不合语义、不正确的数据；<br>    （注意与安全性的对比）；<br>    <strong>DBMS确保完整性的方法：</strong><br>        1）提供定义完整性约束条件的机制；<br>        2）提供完整性检查的方法；<br>        3）违约处理；<br>    包括：<br>        1）实体完整性约束；<br>        2）参照完整性约束；<br>        3）用户定义的完整性约束；</p><p>实体完整性：<br>    定义：若属性（组）是关系的主属性，则其不能为空；<br>    相关SQL语句：<br>        1）使用PRIMARY KEY进行实体完整性约束的定义；<br>        2）可以在列级别定义（创建表时直接定义在属性之后）；<br>        3）可以定义在表级别（创建表时定义在所有属性之后，定义要使用扩号）；<br>        eg：<br>            创建SC表，将Sno,Cno属性定义为码；<br>    完整性检查：<br>        1）插入或修改时检查主码值是不是唯一<br>        2）插入或修改时检查主属性是否为空；<br>    违约处理：<br>        1）如果主码不唯一则拒绝<strong>插入或修改</strong>；<br>        2）如果主属性为空则拒绝<strong>插入或修改</strong>；</p><p>参照完整性：<br>    外码：如果F是关系R到属性（组），但是F不是R的码，并且F与关系S到码Ks相对应，那么F就是关系R的外码；<br>        其中：<br>            1）R称为参照关系；<br>            2）S称为被参照关系；<br>    参照完整性定义：<br>        如果F是关系R的外码，并且与关系S的主码Ks相对应，那么F的取值，必须：<br>            1）或者为空值；<br>            2）或者为某个元组Ks的值；<br>    相关SQL语句：<br>        1）使用FOREIGN KEY(…) REFERENCEES 关系(…);<br>            （第一个括号中为指定为外码的属性，第二个括号中为在某关系上对应参照的属性）；<br>        2）参照完整性约束都是定义在表级的；<br>        eg：<br>            创建SC表，其中Cno参照Course(Cno)，Sno参照Student(Sno)；<br>    完整性检查：<br>        1）插入参照表的时候；<br>        2）修改参照表外码的时候；<br>        3）删除被参照表元组的时候；<br>        4）修改被参照表候选码的时候；<br>    违约处理：<br>        1）对于参照表的操作如果违反了参照完整性约束，直接拒绝操作；<br>        2）对于被参照表的操作如果违反了参照完整性约束：<br>            1）拒绝操作；<br>                eg：<br>                    1）（FOREIGN KEY(Sno) REFERENCE Student(Sno) ON UPDATE NO ACTION）；<br>            2）对被参照表级联修改&#x2F;删除；<br>                eg：<br>                    1）（FOREIGN KEY(Cno) REFERENCES Cource(Cno) ON UPDATE CASCADE;）<br>                    2）（FOREIGN KEY(Sno) REFERENCES Student(Sno) ON DELETE CASCADE;）<br>            3）对被参照表对应设置为空；<br>        涉及违约处理的SQL：<br>            FOREIGN KEY(…) REFERENCE 关系(…) ON 操作 NO ACTION&#x2F;CASCADE;<br>            （其中操作时UPDATE或DELETE）</p><p>用户定义的完整性约束：<br>    1）在属性上定义：<br>        1）NOT NULL 非空；<br>        2）UNIQUE 唯一；<br>        3）CHECK(…) 布尔表达式；<br>            eg：<br>                创建Student表，要求Sname唯一，Sage不能为空，Ssex只能为’男’或’女’；<br>    2）在元组上定义：<br>        使用CHECK进行定义，约束可以是一个属性的条件，或者多个属性之间的条件（取值相互约束）；<br>            eg：<br>                创建Student表，当学生Sage为’男’时，Sname不能以’Ms.’开头；<br>    违约处理：<br>        如果任何操作违反用户定义的完整性约束则拒绝；</p><p>完整性约束命名子句：<br>    SQL语句：<br>        CONSTRAINT &lt;完整性约束条件名&gt; &lt;完整性约束条件&gt;;<br>    其中条件可以是：<br>        NOT NULL&#x2F;UNQUE&#x2F;PRIMARY&#x2F;FROEIGN KEY&#x2F;CHECK等；<br>    （好处在于对于复杂的约束条件对构造，可以利用约束条件名对定义过的约束进行复用）</p><p>修改表中的完整性限制：<br>    ALTER语句（详情见前面“基本表的DDL语句，ALTER的用法，ADD的注意事项”）；</p><p>域的使用：<br>    创建一个DOMAIN类似创建了一个数据类型，后续创建基本表的时候属性的类型可以用域进行定义；<br>    SQL语句：<br>        CREATE DOMAIN 域名 CHECK(限制条件);<br>    优点是：使用域定义属性类型，自带约束条件；</p><h2 id="关系数据理论"><a href="#关系数据理论" class="headerlink" title="关系数据理论"></a>关系数据理论</h2><p>关系模式的形式化定义：<br>    R(D,DOM,U,F);<br>        1）R关系名；<br>        2）D域；<br>        3）DOM，U到D到映射；<br>        4）U，属性；<br>        5）F数据依赖；<br>    关系模式简化表示：<br>        R&lt;U,F&gt;；</p><p>完整性约束的表现形式；<br>    1）限定属性取值范围；<br>    2）属性值之间相互关联存在数据依赖的情况（主要是属性值相等的条件）；<br>    数据依赖：<br>        1）一个关系内部的属性之间的约束；<br>        2）不同关系之间的属性关系；<br>    数据依赖的类型：<br>        1）函数依赖；<br>        2）多值依赖；<br>        （其他，条件函数依赖等）</p><p>数据依赖造成的关系模式设计问题：<br>    1）问题背景：<br>        1）关系模式Student(Sno,Sname,Mname,Cno,Grade)；<br>        2）其中Mname是所在院系管理员的名字，一个院系只有一个；<br>    2）问题：<br>        1）删除异常，当某个院系的所有学生都毕业了，删除学生后，院系对应管理员也不清楚了；<br>        2）插入异常，当某个院系还没有学生的时候，但是管理员是确定的，可是不能插入；<br>        3）修改复杂，当院系的管理员更换的时候，对该院系所有学生的元组都要进行修改；<br>        4）数据冗余度大，每个学生元组中都记录了院系管理员的信息，数据冗余；<br>        注意：<br>            1）判断数据冗余的技巧是看两个条件，如果重复出现，并且对具体的元组删除一个没有影响，那就是冗余。<br>            （所以院系不是冗余，但是院系管理员是冗余）；<br>            2）修改复杂对应例子理解，并且修改复杂通常是和数据冗余一起出现的；<br>            3）删除异常、插入异常对应例子理解；<br>    3）总结：上面的Student关系不是好的关系，原因是某些不好的数据依赖，可以通过<strong>关系模式分解</strong>（后面会重点讨论，工具就是规范化理论），消除这些数据依赖；<br>    4）解决方法：规范化<br>        规范化理论是用来改造关系模式，通过分解关系模式来消除其中不合适的数据依赖，以解决插入异常、删除异常、更新异常和数据冗余问题。</p><p>函数依赖：<br>    基本概念：<br>        X函数确定Y；<br>        Y函数依赖X；<br>        X函数决定Y；<br>        $X \rightarrow Y$；<br>        定义：设R(U)是属性集U上的关系模式。X, Y是U的子集。若对于R(U)的任意一个可能的关系r，r中不可能存在两个元组在X上的属性值相等，而在Y上的属性值不等。<br>        注意：<br>        1）关系模式是结构，是不变的；<br>        2）关系是变化的，由具体有哪些元组确定，也就是说所有关系实例都要满足；<br>        3）函数依赖是语义范畴；<br>        4）在上面的函数依赖关系中X就是函数决定属性组（决定因素）<br>        5）X函数确定Y 且 Y函数确定X的记法（X与Y等价）；<br>        6）X不能函数确定Y的记法；<br>    平凡与非平凡：<br>        平凡函数依赖：如果Y是X的子集则函数依赖是平凡的；<br>        非平凡函数依赖：如果Y不是X的子集则函数依赖是非平凡的；<br>        注意：<br>            1）平凡的函数依赖是显然成立的；<br>            2）(Cpno)不是(Cno)的子集，属性组的集合成分是由属性来度量的，而不是属性的具体取值；<br>    完全与部分：<br>        完全函数依赖：对于属性组X的任何子集都不能函数确定Y；<br>        部分函数依赖：不是完全函数依赖；<br>        注意：<br>            相关的记法，在箭头上加F、P；<br>    传递函数依赖：<br>        1）X函数确定Y；<br>        2）Y不是X的子集；<br>        3）Y不能函数确定X；<br>        4）Y函数确定Z；<br>        5）Z不是Y的子集；<br>        （Y非平凡函数依赖于X，X不函数依赖于Y，Z非平凡函数依赖于Y）    </p><p>候选码：对于关系模式R(U)，U完全函数依赖于某个U的子集属性组K，则K是候选码；</p><p>主属性：候选码属性组中的属性都是主属性；</p><p>非主属性：不包含在任何候选码中的属性；</p><p>全码：U是候选码；</p><p>外码：R中属性组X并非R的码，但是是其他关系模式的码；</p><p>范式：<br>    定义：符合某一种级别的关系模式的集合，关系数据库的关系必须满足的要求，不同级别的范式有不同的要求；<br>    1）1NF<br>        定义：关系模式R的每个属性都是不可再分的数据项；<br>        注意：对关系模式最起码的要求，不满足不能称为关系数据库；<br>    2）2NF<br>        定义：1NF之上，每个<strong>非主属性</strong>完全函数依赖于候选码；<br>    3）3NF<br>        定义：2NF之上，不存在<strong>非主属性</strong>对候选码的传递函数依赖；<br>        （实际的定义没有2NF之上的表述，而是类似于不满足部分函数依赖的描述，但是少了一个Y是X的子集的条件，即只有部分函数依赖的四个条件，少的这个条件如果成立的话，则不满足2NF，所以应该是默认满足2NF）<br>        eg：S-L(Sno,Sdept,Sloc)，满足2NF，不满足3NF；<br>        （Sdept函数确定Sloc）<br>    4）BCNF<br>        定义：1NF之上，任何函数依赖的决定因素都必须包含码；<br>        注意：<br>            1）实际上是在3NF之上，消除了<strong>主属性</strong>对候选码的部分函数依赖和传递函数依赖；<br>        eg：<br>            1）STJ(S,T,J)满足3NF，不满足BCNF<br>                1）(S,J)-&gt;T，T-&gt;J<br>                （一个老师只能教一门课程，但是一门课程可以由不同的老师来教）<br>                2）候选码，S、J、T，<strong>没有非主属性</strong>，所以满足3NF；<br>                3）存在主属性对码的部分函数依赖(S,T)-&gt;J，所以不满足BCNF；<br>            2）SJP(S,J,P)满足BCNF；<br>                1）(S,J)-&gt;P，(J,P)-&gt;S；<br>                （一个学生一门课程有唯一一个名次，一个课程的一个名次也只能有一个学生（不考虑并列））<br>                2）候选码，S、J、P，<strong>没有非主属性</strong>，满足3NF；<br>                3）且所有函数依赖都包含码；<br>    注意<strong>这些例子对帮助理解和构造类似满足范式的关系很有帮助</strong>；<br>    判断满足四种范式的方法：<br>        1）1NF，略；<br>        2）2NF，找是否有非主属性部分函数依赖于某个码；<br>        3）3NF，找是否有非主属性传递函数依赖于某个码；<br>        4）BCNF，看是否所有的函数依赖决定因素都含有码；看是否有主属性部分&#x2F;传递函数依赖于码；<br>    3NF与BCNF的等价条件：<br>        <strong>当关系模式有且仅有一个候选码的时候，3NF与BCNF是等价的</strong>；</p><p>多值依赖<br>    定义：设R(U)是属性集U上的一个关系模式。X, Y, Z是U的子集，并且Z&#x3D;U-X-Y。关系模式R(U)中多值依赖 X-&gt;-&gt;Y成立，当且仅当对R(U)的任一关系r，给定一对(x, z)值，有一组Y的值，这组值仅仅决定于x值而与z值无关。<br>    <strong>针对例子理解</strong>：<br>        关系模式CTB(C,T,B)<br>        1）属性含义：C课程，T老师，B参考资料；<br>        2）条件：一门课程可以由多个老师讲授，他们必须使用相同的一套参考资料；<br>        3）注意：每个老师可以讲授不同的课程，每种参考书也可以供多门课程使用（因为这并不是重点）；<br>        存在的多值依赖：<br>            1）C-&gt;-&gt;T，对于给定一个课程，都有一组老师与其对应而与使用参考书的情况无关；<br>            （假如有一个老师使用的是和其他老师不同的参考书，那就不满足多值依赖了，因为根据参考书的情况会影响老师的情况）<br>            2）C-&gt;-&gt;B，对于给定一个课程，有一组参考书与之对应<br>    等价的定义：在R (U)的任一关系r中，如果存在元组t, s 使得t[X]&#x3D;s[X]，那么就必然存在元组w，v在r中，(w，v可以与s，t相同)，使得w[X] &#x3D; v[X] &#x3D; t[X]，而w[Y]&#x3D;t[Y]，w[Z]&#x3D;s[Z]，v[Y]&#x3D;s[Y]，v[Z]&#x3D;t[Z]（<strong>一句话：对于任意X属性组相等的元组s、t，交换s，t元组的Y值（X、Z值不改变）所得的两个新元组必在r中</strong>）；<br>        eg：<br>            1）对应到CBT到例子，对于(C,T1,B1)&#x2F;(C,T2,B2)，必然存在元组(C,T2,B1)&#x2F;(C,T1,B2)；<br>            2）但是如果有老师有用和别打老师不一样的教科书，在课程一样的时候，交换老师这一属性，得到课程-另一个老师-原老师独有的教科书，那这一元组显然是不存在的；<br>    平凡与非平凡：<br>        1）如果Z为空集，则多值依赖X-&gt;-&gt;Y是平凡的；<br>        2）否则是非平凡的；<br>    多值依赖的性质：<br>        1）对称性，X-&gt;-&gt;Y则X-&gt;-&gt;Z；<br>    4NF：对于每一个非平凡的多值依赖X-&gt;-&gt;Y，X中都包含候选码；<br>        注意：<br>            1）判断方法：在BCNF基础上，不允许有非平凡且非函数依赖的多值依赖；<br>            2）如果R满足4NF，则R满足BCNF；<br>    多值依赖的有效性与属性集的范围有关：<br>        1）如果X-&gt;-&gt;Y在U上成立，则在W上一定成立（W属性组包含X、Y属性组，且是U属性组的子集）；<br>        2）如果X-&gt;-&gt;Y在W上成立，则在U上不一定成立；<br>        （本质原因是前者减小了Z的范围，后者扩大了Z的范围，在大范围内成立在小范围内一定成立，反之不然）；<br>    多值依赖与函数依赖的区别：<br>        1）函数依赖X-&gt;Y成立，则对任何Y对子集Y’，X-&gt;Y’成立，但是换成多值依赖这是不行的；<br>        （本质上还是伴随着Y对减小，Z对范围可能扩大）<br>        2）函数依赖是多值依赖的特殊情况，若X-&gt;Y则X-&gt;-&gt;Y；<br>        （挺好理解的，对于函数依赖，X确定的时候Y的值也确定了，所以Z的值根本无所谓，因为根本没有X对应的其他Y值来体现Z的不同）；</p><p>从1NF、2NF、3NF、BCNF、4NF，规范化程度越来越高，但是不是规范化程度越高关系模式就越好；</p><p><strong>注意，BCNF、多值依赖，对应三个例子很重要：STJ&#x2F;SJP&#x2F;CTB</strong>；</p><p>Amstrong公理系统<br>    定义：对于满足一组函数依赖F 的关系模式R &lt;U, F&gt;，其任何一个关系r，若函数依赖X→Y都成立, (即r中任意两元组t，s，若t[X] &#x3D; s[X]，则t[Y]&#x3D;s[Y])，则称F逻辑蕴含X→Y。<br>    基本定律：<br>        1）自反律：若Y是X的子集，X是U的子集，则X-&gt;Y；<br>        2）增广律：若X-&gt;Y，Z是U的子集，则XZ-&gt;YZ<br>        （其中类似XZ的表达，可以理解为两个属性组拼成了一个大属性组）<br>        3）传递律：若X-&gt;Y，Y-&gt;Z则X-&gt;Z；<br>    推理规则：<br>        1）合并规则：若X-&gt;Y，X-&gt;Z则X-&gt;YZ；<br>        2）伪传递规则：若X-&gt;Y,WY-&gt;Z则WX-&gt;Z；<br>        3）分解规则：若X-&gt;Y且Z是Y的子集则X-&gt;Z；<br>        （三个推理规则从属性组的层面来说都很好理解）；<br>    <strong>定律与推理，得出的新函数依赖都被原来的函数依赖F所“蕴含”</strong>；<br>    Amstrong公理系统是<strong>有效的、完备的</strong>；<br>    极小函数依赖集：<br>        函数依赖集F为极小函数依赖集当且仅当：<br>            1）F中任意函数的右部只含有一个属性；<br>            2）F中不存在函数依赖X-&gt;A，使得F与F-{X-&gt;A}等价；<br>            3）F中不存在函数依赖X-&gt;A，使得X存在真子集Z，满足F-{X-&gt;A}并上{Z-&gt;A}与F等价；<br>                等价的含义：<br>                    1）函数依赖集F等价于G 等价于 F的闭包与G的闭包相等；<br>                    2）函数依赖集的闭包是函数依赖集所蕴含的函数依赖全体；<br>        （简单理解极小函数依赖集，在现有的函数依赖集中不断地去掉函数依赖，若去掉的函数依赖不能由剩下的导出，那么它就是必要的，保留所有必要的函数依赖，得到的就是极小函数依赖集）<br>        性质：<br>            1）每一个函数依赖集F均等价于一个极小函数依赖集Fm，Fm称为最小依赖集；<br>            2）F的最小依赖集Fm不是唯一的；<br>        极小化过程：<br>            找出F的最小依赖集Fm（基本上就是按照函数依赖集F的简单理解）；</p><p>模式分解：<br>    含义：<br>        1）将关系R分为几个关系，划分出的关系中的属性没有包含和被包含关系，且所有这些属性的并是关系R到属性；<br>        2）划分出的关系中的数据依赖，是关系R到数据依赖F在各关系所含属性上的投影；<br>    关系模式分解的标准（要求）：<br>        1）具有无损连接性：划分出的所有关系做自然连接，得到原始关系；<br>        2）保持函数依赖：F所蕴含的某个函数依赖，也一定由某个划分出的关系的数据依赖所蕴含；<br>        （典型的例如(Sno,Sname,Sdept,Mname)划分为(Sno,Sname,Sdept) (Sno,Mname)，这就丢失了Sdept-&gt;Mname）<br>        3）既具有无损连接性，又能保持函数依赖；<br>    注意：<br>        1）无损连接性可以保证信息不丢失；<br>        2）保持函数依赖可以减轻、解决异常情况；<br>        3）无损连接性和保持函数依赖是两个独立的性质，具备一个不一定具备另一个；<br>    (<em>模式分解和数据依赖带来的问题要一起考虑，融汇贯通</em>)</p><p>chase算法判断无损连接性：<br>    1）建立初始表；<br>        1）行对应关系，列对应属性；<br>        2）i行j列处，如果j对应属性在i对应关系中，则填aj，否则填bij；<br>    2）根据划分后的关系的函数依赖更新表格；<br>        1）“chase”操作，使用分解之前的原始函数依赖；<br>        2）对于每一个函数依赖Xi-&gt;Yi，检查决定项目Xi对应的列；<br>        3）找到Xi对应列，有相同元素的行w1 w2；<br>        4）找到Yi对应的列，这一列对应刚刚找到的行，即w1,Yi w2,Yi两个位置，更新为一样的；<br>        5）如果有一个是a?则全部更新为a?，否则全部更新为bmj，其中m取当前有的b?j，?的最小值；<br>    3）若出现a1、a2、…、an的行则具有无损连接性；<br>    <img src="https://raw.githubusercontent.com/Yes-ys/blog-images/main/DBS/p2.png" alt="chase算法例子"></p><h2 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h2><p>三类不一致性问题：<br>    丢失修改：<br>        1）定义：两个事务T1和T2读入同一数据并修改，T2的提交破坏了T1提交的结果，导致T1的修改丢失；<br>        2）为什么会出现这种情况：<br>    脏读：<br>        1）定义：事务T1修改某数据并写入磁盘，事务T2读取同一数据但是T1的修改因为某些原因被撤销，T1修改过的数据恢复原值T2读到的数据就与数据库中的数据不一致，T2读到的就是脏数据即不正确的数据；<br>        2）为什么会出现这种情况：<br>    不可重复读：<br>        1）定义：事务T1读取数据后，T2执行更新操作，使T1无法再现前一次的读取结果；<br>        2）为什么会出现这种情况：</p><p>两种基本锁：<br>    X锁：<br>        1）排他型锁，写锁；<br>        2）若事务T对数据对象A加上X锁，则只允许T读取和修改A，其他任何事物都不能再对A加任何类型的锁，直到T释放A上的锁；<br>        3）保证其他事务在T释放A上的锁之前，不能再读取和修改A；<br>    S锁：<br>        1）共享型锁，读锁；<br>        2）若事务T对数据对象加上S锁，则事务T可以读取A但是不能修改A，其他事务只能对A加S锁，不能加X锁，直到T释放A上的S锁；<br>        3）保证其他事务可以读A，但是T释放A上的S锁之前，不能对A做任何修改；</p><p>三级封锁协议：<br>    一级封锁协议：<br>        1）事务T在修改数据R之前必须对其加X锁，直到事务结束才释放；<br>        2）可以防止丢失修改，保证事务T是可恢复的；<br>    二级封锁协议：<br>        1）一级封锁协议的基础上，增加事务T在读取数据R之前必须先对其加S锁，读完之后即可释放S锁；<br>        2）可以防止丢失修改和脏读；<br>    三级封锁协议：<br>        1）一级封锁协议的基础上，增加事务T在读取数据R之前必须先对其加S锁，直到事务结束才释放；<br>        2）可以防止丢失修改、脏读和不可重复读；</p><p>可串行化调度：<br>    多个并发事务的执行结果是正确的，当且仅当其结果与按某一次序串行地执行这些事务时的结果相同；<br>    可串行性：<br>        1）是并发事务正确调度的准则；<br>        2）一个给定的并发调度，当且仅当它是可串行化的，才被认为是正确调度；<br>    eg：<br>        事务T1有操作A、B，事务T2有操作C，D；<br>        1）串行调度的结果：T1，T2（A，B，C，D）结果是a；<br>        2）某调度Sc（A，C，B，D），如果结果也是a，那么调度Sc是可串行化调度，是一个正确的调度；<br>        （当然Sc的结果如果是b，且调度T2，T1的顺序也是b，那么Sc也是一个可串行化调度）；</p><p>并发调度的冲突操作：<br>    指不同的事务对同一数据的读写操作和写写操作；<br>    例如：<br>        Ri(x),Wj(x);<br>        Wi(x),Wj(x);<br>    （其他操作不是冲突操作）；<br>    注意：<br>        冲突的两个操作和同一事务的两个操作都是不能交换的操作；</p><p>冲突可串行化调度：<br>    一个调度Sc在保证冲突操作的次序不变的情况下，通过交换两个事务的不冲突操作的次序得到另一个调度Sc‘，如果Sc‘是串行的，则称Sc是冲突可串行化调度；<br>    注意：<br>        1）如果一个调度是冲突可串行化的，则它一定是可串行化的；<br>    例如：<br>        1）事务T1有操作X1、S1，事务T2有操作S2，X2；<br>        2）有一个调度Sc（X1，S2，S1，X2）；<br>        3）由于S2，S1不是冲突的操作，交换它们的次序；<br>        4）得到调度（X1，S1，S2，X2），对应的调度就是T1，T2，这是串行的调度；<br>        5）所以Sc是冲突可串行化的调度；</p><p>对比：<br>    1）串行的调度，强调操作顺序，调度的操作的顺序就是各个事务顺序执行的顺序；<br>    2）可串行化的调度，强调结果，调度的操作结果和某种串行调度的结果相同；<br>    3）冲突可串行化的调度，强调操作顺序，修改不冲突的操作的顺序得到的新调度就是一个串行的调度；</p><p>死锁的诊断与解除：<br>    诊断：<br>        1）超时法：<br>            如果一个事务的等待时间超过了规定的时限，就认为发生了死锁；<br>            优点：实现简单；<br>            缺点：有可能误判，规定时间过长有可能无法及时诊断；<br>        2）事务等待图：<br>            1）事务等待图是一个有向图G&#x3D;(T,U);<br>            2）T是节点的集合，表示正在运行的事务；<br>            3）U是边的集合，代表事务等待的情况；<br>            4）若T1等待T2，则有一条边从T1指向T2；<br>            并发控制子系统周期性地生成事务等待图，检测事务。如果发现图中存在回路，则表示系统中出现了死锁。<br>    解除：<br>        1）选择一个处理死锁代价较小的事务，将其回滚；<br>        2）释放此事务持有的所有锁，使其他事务能够进行下去；</p><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><p><code>视每次作业的情况而定，我可能会在这里写我最初版的作业，最终提交则是在此之上加以改进；同时会附加一些我在完成作业的过程中学习到的知识</code></p><h3 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h3><p>习题1，描述数据、数据库、数据库管理系统、数据库系统的概念</p><ol><li>数据是用来描述事物的符号记录，是数据库中存储的基本对象。</li><li>数据库是长期存储在计算机内、有组织、可共享的大量数据的集合。</li><li>数据库管理系统是位于用户和操作系统之间的一层数据管理软件，和操作系统一样是计算机的基础软件，是一个大型且复杂的软件系统。</li><li>数据库系统是指在计算机系统中引入数据库后的系统。</li></ol><p>习题2，描述文件系统和数据库系统的区别和联系</p><ol><li>区别：主要在共享性、冗余度、结构化上，文件系统共享性差，冗余度高，记录内有结构但是整体无结构；数据库系统共享性好，冗余度低，整体结构化。</li><li>联系：数据库系统和文件系统都属于数据管理技术，并且前者是后者的继承与发展；在硬件实现方面它们都可以使用磁盘，处理方式上都支持联机实时处理与批处理，都是系统本身作为数据的管理者等等。</li></ol><p>习题8，描述数据模型的概念，作用及其包含的三个要素</p><ol><li>概念：数据模型是数据库中用于抽象、表示和处理现实世界中的数据和信息的工具，是现实世界的模拟，满足能比较真实地模拟现实世界、容易为人所理解、便于在计算机上实现这三个条件。</li><li>作用：用于抽象、表示和处理现实世界中的数据和信息。</li><li>三个要素：数据结构、数据操作以及数据的完整性约束。</li></ol><p><code>这个概念或许需要进一步明确一下</code></p><p>习题14，描述数据库系统的三级模式结构，并说明这种结构的优点是什么</p><ol><li>三级模式结构：主要是指内模式，模式，外模式的三级结构，其中内模式是数据物理结构和存储方式的描述，模式是全体数据的逻辑结构和特征描述，外模式是数据库用户能看见和使用的局部数据的逻辑结构和特征的描述；内模式与模式之间由，模式&#x2F;内模式映像连接。模式与外模式之间由外模式&#x2F;模式映像连接。</li><li>优点：使用了映像连接，在内模式修改的时候，同时修改模式&#x2F;内模式映像，可以确保物理独立性；在模式修改的时候，同时修改外模式&#x2F;模式映像，可以确保逻辑独立性。</li></ol><p>习题15，描述数据与程序的物理独立性和逻辑独立性。为什么是数据库系统具有较强的数据与程序的独立性。</p><ol><li>物理独立性：用户的应用与存储在磁盘上的数据库中的数据是相互独立的，当数据物理存储改变了，应用程序不用改变。</li><li>逻辑独立性：用户的应用程序与数据库的逻辑结构是相互独立的，数据的逻辑结构改变了，用户程序可以不变。</li><li>较好的数据与程序的逻辑独立性，是因为应用程序依据数据的外模式进行编写，当模式改变的时候，数据库管理员通过修改外模式&#x2F;模式映像，使外模式保持不变从而让应用程序不必修改。</li><li>较好的数据与程序的物理独立性，是因为当数据库的存储结构改变了，数据库管理员可以修改模式&#x2F;内模式映像，让模式保持不变，从而让应用程序不受影响。</li></ol><h2 id="SQL练习（创建、修改、删除）"><a href="#SQL练习（创建、修改、删除）" class="headerlink" title="SQL练习（创建、修改、删除）"></a>SQL练习（创建、修改、删除）</h2><h3 id="创建基本表"><a href="#创建基本表" class="headerlink" title="创建基本表"></a>创建基本表</h3><p>其基本语言规范是</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">CREATE TABLE &lt;表名&gt;</span><br><span class="line">(</span><br><span class="line">    &lt;列名&gt; &lt;数据类型&gt; [列级完整性约束],</span><br><span class="line">    &lt;列名&gt; &lt;数据类型&gt; [列级完整性约束],</span><br><span class="line">    [表级完整性约束]</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="eg5-建立学生数据表"><a href="#eg5-建立学生数据表" class="headerlink" title="eg5 建立学生数据表"></a>eg5 建立学生数据表</h4><p>要求：</p><ol><li>学号是主键</li><li>姓名不能重复</li><li>性别是一个汉字（对应旧版本mysql两个字符）</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">CREATE TABLE Student</span><br><span class="line">(</span><br><span class="line">    Sno CHAR(10) PRIMARY KEY,</span><br><span class="line">    Sname CHAR(20) UNIQUE,</span><br><span class="line">    Ssex CHAR(2),</span><br><span class="line">    Sage SMALLINT,</span><br><span class="line">    Sdept CHAR(20)</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="eg6-建立课程数据表"><a href="#eg6-建立课程数据表" class="headerlink" title="eg6 建立课程数据表"></a>eg6 建立课程数据表</h4><p>要求：</p><ol><li>课程号是主键CHAR(4)</li><li>课程名不允许为空</li><li>先修课是外码，参照的是自己的课程号属性</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">CREATE TABLE Course</span><br><span class="line">(</span><br><span class="line">    Cno CHAR(4) PRIMARY KEY,</span><br><span class="line">    Cname CHAR(40) NOT NULL,</span><br><span class="line">    Cpno CHAR(4),</span><br><span class="line">    Ccredit SMALLINT,</span><br><span class="line">    FOREIGN KEY (Cpno)</span><br><span class="line">    REFERENCES Course Cno</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>错误修正</strong>：<code>REFERENCES Course Cno</code>应该是<code>REFERENCES Course(Cno)</code></p><h4 id="eg7-建立选课表"><a href="#eg7-建立选课表" class="headerlink" title="eg7 建立选课表"></a>eg7 建立选课表</h4><p>要求：</p><ol><li>主键由两个Sno、Cno两个属性构成</li><li>Sno、Cno还分别是外键，参考前面两个表中的对应属性</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">CREATE TABLE SC</span><br><span class="line">(</span><br><span class="line">    Sno CHAR(10),</span><br><span class="line">    Cno CHAR(4),</span><br><span class="line">    Grade SMALLINT,</span><br><span class="line">    PRIMARY KEY (Sno,Cno),</span><br><span class="line">    FOREIGN KEY (Sno)</span><br><span class="line">    REFERENCES Student(Sno),</span><br><span class="line">    FOREIGN KEY (Cno)</span><br><span class="line">    REFERENCES Course(Cno)</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>注意创建主键为多个属性组合时的写法：</strong><code>PRIMARY KEY (Sno,Cno)</code></p><h3 id="修改基本表"><a href="#修改基本表" class="headerlink" title="修改基本表"></a>修改基本表</h3><p>基本规范如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ALTER TABLE &lt;表名&gt;</span><br><span class="line">[ADD &lt;列名&gt; &lt;数据类型&gt; [完整性约束]]</span><br><span class="line">[DROP &lt;列名&gt; &lt;数据类型&gt;]</span><br><span class="line">[ALTER COLUMN &lt;列名&gt; &lt;数据类型&gt;]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="eg8-向学生表增加入学时间"><a href="#eg8-向学生表增加入学时间" class="headerlink" title="eg8 向学生表增加入学时间"></a>eg8 向学生表增加入学时间</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ALTER TABLE Student</span><br><span class="line">ADD S_entrance DATA;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>错误修正：</strong>时间的数据类型应该是<code>DATE</code>而不是<code>DATA</code></p><h4 id="eg9-将学生表中的年龄属性转换为INT类型"><a href="#eg9-将学生表中的年龄属性转换为INT类型" class="headerlink" title="eg9 将学生表中的年龄属性转换为INT类型"></a>eg9 将学生表中的年龄属性转换为INT类型</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ALTER TABLE Student</span><br><span class="line">ALTER COLUMN Sage INT;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>注意以下事项</strong>：</p><ol><li>COLUMN的拼写</li><li>在MYSQL中似乎对列的修改不是ALTER，而是MODIFY，即<code>MODIFY COLUMN Sage INT;</code></li></ol><h2 id="SQL练习（查询）"><a href="#SQL练习（查询）" class="headerlink" title="SQL练习（查询）"></a>SQL练习（查询）</h2><h3 id="单表查询-1"><a href="#单表查询-1" class="headerlink" title="单表查询"></a>单表查询</h3><ol><li>选择表的若干列</li><li>选择表的若干元组</li><li>ORDER BY 子句</li><li>聚集函数</li><li>GROUP BY子句</li></ol><p><strong>关于GROUP BY，我本地的mysql和教材的SQL标准存在一些偏差</strong>：做如下记录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SELECT Sno</span><br><span class="line">FROM SC</span><br><span class="line">GROUP BY Sno;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面的查询语句本地的mysql显示的结果会自动去重，和我理解的按照Sno属性是否相同将对应元组放在一张表里面，而不改变元组的个数有一些不同；<strong>但是使用COUNT语句能够正确统计出各组元组的个数，和课本上一致。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SELECT Sno,Cno</span><br><span class="line">FROM SC</span><br><span class="line">GROUP BY Sno</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>本地上是会报错的，老师说按照课本的逻辑这应该是可以执行的，并且查询的结果会是没有分组的Sno、Cno</p><p><strong>总是，GROUP BY语句大多数时候还是配合聚集函数使用的，直接显示结果比较少</strong>。</p><h4 id="查询若干列"><a href="#查询若干列" class="headerlink" title="查询若干列"></a>查询若干列</h4><p>eg1 查询全体学生的姓名和学号</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SELECT Sname,Sno</span><br><span class="line">From Student;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>eg2 查询全体学生的姓名、学号和所在系</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SELECT Sname,Sno,Sdept</span><br><span class="line">FROM Student;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>eg3 查询全体学生的详细记录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SLECT * FROM Student;</span><br></pre></td></tr></table></figure><p><strong>查询若干列的时候，不仅可以直接查询，还可以查询经过计算的表达式</strong>，常用的表达式如下：</p><ol><li>算术表达式，例如<code>SELECT 2024 - Sage FROM Student;</code>，结果显示Sage列，并且每一个元组下的值都是2024-对应值</li><li>字符串常量，例如<code>SELECT &#39;birth of date&#39;,Birth,2024 - Sage FROM Student;</code>，结果会显示两列，在Sage列前会新增一列，名为Birth，其下的值均为字符串’birth of date’，第二列名为Sage，其下的值都是2024-Sage</li><li>函数，例如<code>SELECT LOWER(Sdept) FROM Student;</code>，结果显示Sdept列，结果是其下对应元组值中的字符串无论大小写均使用小写</li><li>列别名，规范<code>SELECT &lt;列名&gt; &lt;列别名&gt;</code>，显示的时候会自然将对应的列作别名显示</li></ol><p>eg4 查询全体学生的姓名及出生年份</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SELECT Sname,<span class="string">&#x27;birth of date:&#x27;</span> BIRTH,2025-Sage BIRTHDAY</span><br><span class="line">FROM Student;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>eg5 查询学生的姓名、出生年份和所在院系，要求小写字母表示所有系名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SELECT Sname,<span class="string">&#x27;birth of date:&#x27;</span> BIRTH,2025-Sage BIRTHDAY,LOWER(Sdept)</span><br><span class="line">FROM Student;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="选择表中的若干元组"><a href="#选择表中的若干元组" class="headerlink" title="选择表中的若干元组"></a>选择表中的若干元组</h4><p><strong>关于DISTINCT和ALL</strong>：如果没有规定DISTINCT，则默认为ALL，前者会消除重复行，后者会保留所有在原始基本表中查询到的满足条件的元组</p><p>eg6 查询选修了课程的学生学号</p><p>eg6思路：对于SC课程表查询Sno，并去重</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SELECT DISTINCT Sno</span><br><span class="line">FROM SC;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>注意：</strong><code>DISTINCT</code>出现的位置，不是在列名之后，否则就变成别名了</p><p><strong>关于选择元组常用的查询条件（比较）</strong>：</p><ol><li>比较：<code>&lt;, &gt;, =, !=, &lt;&gt;, !&gt;, !&lt;, NOT</code>，小于、大于、等于、不等于、不等于、不大于、不小于、否定布尔表达式（<code>NOT(布尔表达式)</code>常见用法）</li><li>确定范围：<code>BETWEEN AND, NOT BETWEEN AND</code></li><li>确定集合：<code>IN, NOT IN</code></li><li>字符匹配：<code>LIKE, NOT LIKE</code></li><li>空值：<code>IS NULL, IS NOT NULL</code></li><li>多重条件（逻辑运算）：<code>AND, OR, NOT</code></li></ol><p>eg7 查询计算机科学系全体学生的名单</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SELECT *</span><br><span class="line">FROM Student</span><br><span class="line">WHERE Sdept = <span class="string">&#x27;CS&#x27;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>eg8 查询所有年龄在20岁以下学生姓名及年龄</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SELECT Sname,Sage</span><br><span class="line">FROM Student</span><br><span class="line">WHERE Sage&lt;20;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>eg9 查询考试成绩有不及格的学生学号</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SELECT DISTINCT Sno</span><br><span class="line">FROM SC</span><br><span class="line">WHERE Grade&lt;60;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>关于选择元组常用的查询条件（确定范围）</strong>：<code>BETWEEN...AND...</code>和<code>NOT BETWEEN...AND...</code>，注意<code>BETWEEN...AND...</code>是包含边界的！</p><p>eg10 查询年龄在20~23岁之间的学生姓名、系别和年龄</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SELECT Sname,Sdept,Sage</span><br><span class="line">FROM Student</span><br><span class="line">WHERE Sage BETWEEN 20 AND 23;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>eg11 查询年龄不在20~23岁之间的学生姓名、系别和年龄</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SELECT Sname,Sdept,Sage</span><br><span class="line">FROM Student</span><br><span class="line">WHERE Sage NOT BETWEEN 20 AND 23;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>关于选择元组常用的查询条件（确定集合）</strong>：<code>IN &lt;值表&gt;</code>，<code>NOT IN &lt;值表&gt;</code>，例如，对于字符串的值，值表写法是<code>(&#39;1&#39;,&#39;2&#39;,&#39;3&#39;)</code></p><p>eg12 查询信息系IS、数学系MA和计算机科学系CS，学生姓名和系别</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SELECT Sname,Sdept</span><br><span class="line">FROM Student</span><br><span class="line">WHERE Sdept IN (<span class="string">&#x27;IS&#x27;</span>,<span class="string">&#x27;MA&#x27;</span>,<span class="string">&#x27;CS&#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>eg13 查询既不是信息系、数学系也不是计算机科学系的学生姓名和性别</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SELECT Sname,Ssex</span><br><span class="line">FROM Student</span><br><span class="line">WHERE Sdept NOT IN (<span class="string">&#x27;IS&#x27;</span>,<span class="string">&#x27;MA&#x27;</span>,<span class="string">&#x27;CS&#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>关于选择元组常用的查询条件（字符匹配）</strong>：</p><ol><li>基本的用法是<code>[NOT] LIKE &#39;&lt;匹配串&gt;&#39;</code>，值得注意的是匹配串中可以有通配符，有两种分别是：<code>%</code>和<code>_</code>，前者可以代表任意数量的任意字符，后者代表一个任意字符</li><li><code>ESCAPE &#39;&lt;转义字符&gt;&#39;</code>，指定的转义字符用于通配符前面，用来将通配符当作一个普通的字符，但是值得注意的是<strong>如果转义字符单独出现那么它只会被当作普通字符</strong>，这与一些常见语言的处理方式是不同的，不需要两个转义字符来表示其本身</li></ol><p>eg14 查询学号为200215121学生的详细情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SELECT *</span><br><span class="line">FROM Student</span><br><span class="line">WHERE Sno LIKE <span class="string">&#x27;200215121&#x27;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>eg15查询所有姓刘学生的姓名、学号和性别</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SELECT Sname,Sno,Ssex</span><br><span class="line">FROM Student</span><br><span class="line">WHERE Sname LIKE <span class="string">&#x27;刘%&#x27;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>eg16查询姓“欧阳”且全名为三个汉字的学生的姓名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SELECT Sname</span><br><span class="line">FROM Student</span><br><span class="line">WHERE Sname LIKE <span class="string">&#x27;欧阳__&#x27;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：实际上现在经过测试，MySQL做了适配，一个下划线就可以对应一个汉字字符，从前要用两个，是因为在编码的时候汉字有内外码，一个汉字对应两个字符长度</p><p>eg18 查询所有不姓刘的学生姓名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SELECT Sname</span><br><span class="line">FROM Student</span><br><span class="line">WHERE Sname NOT LIKE <span class="string">&#x27;刘%&#x27;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>eg19 查询DB_Design课程的课程号和学分</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SELECT Cno,Credit</span><br><span class="line">FROM Course</span><br><span class="line">WHERE Cname LIKE <span class="string">&#x27;DB\_Design&#x27;</span></span><br><span class="line">ESCAPE <span class="string">&#x27;\&#x27;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>eg20 查询以’DB_’开头，且倒数第3个字符为’i’的课程的详细情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SELECT *</span><br><span class="line">FROM Course</span><br><span class="line">WHERE Cname LIKE <span class="string">&#x27;DB\_%i__&#x27;</span></span><br><span class="line">ESCAPE <span class="string">&#x27;\&#x27;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>关于选择元组常用的查询条件（涉及空值）</strong>：使用语句<code>IS NULL</code>或<code>IS NOT NULL</code>，这里的<code>IS</code>不能够用<code>=</code>来代替，简单理解就是，<code>NULL</code>是一个对象而不是一个值</p><p>eg21 查询缺少成绩的学生的学号和相应的课程号</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SELECT Sno,Cno</span><br><span class="line">FROM SC</span><br><span class="line">WHERE Grade IS NULL;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>关于选择元组常用的查询条件（多重条件查询）</strong>：</p><ol><li>主要使用逻辑运算符AND和OR，用它们两个来连接布尔表达式（由各种查询条件构成的）</li><li>默认情况下AND的优先级高于OR的优先级，可以使用括号来改变优先级</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>csp习题集</title>
      <link href="/2025/09/04/csp%E4%B9%A0%E9%A2%98%E9%9B%86/"/>
      <url>/2025/09/04/csp%E4%B9%A0%E9%A2%98%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<p><code>这篇blog用来记录我练习ccf csp认证的时候做过的习题</code></p><h2 id="梦境巡查-第36次-task2"><a href="#梦境巡查-第36次-task2" class="headerlink" title="梦境巡查 第36次 task2"></a>梦境巡查 第36次 task2</h2><h2 id="缓存模拟-第36次-task3"><a href="#缓存模拟-第36次-task3" class="headerlink" title="缓存模拟 第36次 task3"></a>缓存模拟 第36次 task3</h2><p>大模拟题先整理信息：</p><ol><li>有N组缓存，每组缓存中有n块</li><li>内存块k，存储在k&#x2F;n组中，n个缓存块的任意一个</li><li>操作，读、写内存块，分为两种情况：1）k&#x2F;n组中存储了数据（某行），命中；2）k&#x2F;n组中没有数据（所有行），没有命中</li><li>命中，分为两种情况：1）读，无特殊处理；2）写，修改缓存行，标记对应内存块是修改了的，实际还没有改内存块</li><li>未命中，先进行载入，再按照命中处理</li><li>载入，1）如果k&#x2F;n组有未使用的，就载入未使用的位置；2）否则，按照LRU进行替换，如果内存块修改过要写回</li></ol><p>我的思路：</p><ol><li>对于N组，每组维护一个队列（队列中存储实际的内存块编号，以及该内存块是否修改过），队列的长度上限设置为n</li><li>未命中的时候，1）如果进行载入，队长小于n，直接将内存块入队即可（这里进行了读内存块）；2）如果进行替换，被替换的是队首元素，检查该元素是否被修改过，如果是（这里进行写内存块），然后再将内存块入队（这里进行了读内存块）</li><li>命中的时候，1）如果是读，修改队列，取出命中的元素，重新入队，其它元素相对位置不变；2）如果是写，在1）的基础上还要标记对应内存块被修改过</li></ol><h2 id="字符串变换-第35次CCF认证"><a href="#字符串变换-第35次CCF认证" class="headerlink" title="字符串变换 第35次CCF认证"></a>字符串变换 第35次CCF认证</h2><p>我的思路：</p><p>如果直接使用1个map存储映射的话，当查询的变换次数很大的时候肯定会超时，于是我想到了用两个key（char，int）映射到一个char，代表char变换int次的时候映射到的char。</p><p>具体的思路：</p><ol><li>定义一个struct，里面有char、int；定义map&lt;struct, char&gt;，将struct中的char变换int次后，映射到新的char</li><li>初始化的情况是struct(char,0) map&lt;struct,char&gt; &#x3D;&#x3D; char本身；然后根据映射函数，处理边界struct(char,1) map&lt;struct,char&gt; &#x3D;&#x3D; char(如果有映射就是新的，没有仍然保持自己)；注意初始化的时候还要考虑，原始字符串中字符可以映射到的字符</li><li>处理变换，如果某次查询是变换k次，那么从1变换到k，保存一路下来的结果，之后的查询只要小于k就可以直接一次变换即可。</li></ol><p>代码实现如下（考虑了一下，把struct换成tuple了，而且0的初始化是冗余的，直接从1开始了）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">map</span>&lt;tuple&lt;<span class="type">int</span>,<span class="type">char</span>&gt;, <span class="type">char</span>&gt; mp;</span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ini</span><span class="params">()</span> &#123;</span><br><span class="line"> getline(<span class="built_in">cin</span>, s);</span><br><span class="line"> <span class="type">int</span> t; </span><br><span class="line"> <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line"> getchar();<span class="comment">//吞回车</span></span><br><span class="line"> <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">  <span class="comment">//处理函数的映射，注意没有指明的映射映射到自己</span></span><br><span class="line">  <span class="built_in">string</span> ss;</span><br><span class="line">  getline(<span class="built_in">cin</span>, ss);</span><br><span class="line">  tuple&lt;<span class="type">int</span>, <span class="type">char</span>&gt; <span class="title function_">st1</span><span class="params">(<span class="number">1</span>, ss[<span class="number">1</span>])</span>;</span><br><span class="line">  mp[st1] = ss[<span class="number">2</span>]; </span><br><span class="line"></span><br><span class="line">  tuple&lt;<span class="type">int</span>, <span class="type">char</span>&gt; <span class="title function_">st2</span><span class="params">(<span class="number">1</span>, ss[<span class="number">2</span>])</span>;</span><br><span class="line">  <span class="keyword">if</span> (mp.find(st2) == mp.end())</span><br><span class="line">   mp[st2] = ss[<span class="number">2</span>];</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; s[i] != <span class="string">&#x27;#&#x27;</span>; i++) &#123;</span><br><span class="line">  <span class="comment">//检查源字符串中是否存在函数映射没有覆盖到的，若有则映射到自己</span></span><br><span class="line">  tuple&lt;<span class="type">int</span>, <span class="type">char</span>&gt; <span class="title function_">st</span><span class="params">(<span class="number">1</span>, s[i])</span>;</span><br><span class="line">  <span class="keyword">if</span> (mp.find(st) == mp.end())</span><br><span class="line">   mp[st] = s[i];</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> <span class="title function_">f</span><span class="params">(<span class="type">char</span> c,<span class="type">int</span> k)</span> &#123;</span><br><span class="line"> <span class="comment">//将c映射k次</span></span><br><span class="line"> <span class="type">char</span> res = c;</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">  tuple&lt;<span class="type">int</span>, <span class="type">char</span>&gt; <span class="title function_">st</span><span class="params">(<span class="number">1</span>, res)</span>;<span class="comment">//不断进行一次映射，进行k次</span></span><br><span class="line">  res = mp[st];</span><br><span class="line">  <span class="keyword">if</span> (i == <span class="number">1</span>)<span class="keyword">continue</span>;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="comment">//当进行i&gt;1次的时候，保存映射结果</span></span><br><span class="line">   tuple&lt;<span class="type">int</span>, <span class="type">char</span>&gt; st1(i, c);</span><br><span class="line">   mp[st1] = res;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">search</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="type">int</span> m;</span><br><span class="line"> <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line"> <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">  <span class="type">int</span> k;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; s[i] != <span class="string">&#x27;#&#x27;</span>; i++) &#123;</span><br><span class="line">   <span class="comment">//逐个处理字符映射</span></span><br><span class="line">   tuple&lt;<span class="type">int</span>, <span class="type">char</span>&gt; <span class="title function_">st</span><span class="params">(k, s[i])</span>;</span><br><span class="line">   <span class="keyword">if</span> (mp.find(st) == mp.end()) &#123;</span><br><span class="line">    <span class="comment">//如果没有，则进行映射处理</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f(s[i],k);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//如果有则直接输出</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; mp[st];</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27;#&#x27;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"> ini();</span><br><span class="line"> search();</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="补丁应用-第35次CCF认证-task3"><a href="#补丁应用-第35次CCF认证-task3" class="headerlink" title="补丁应用 第35次CCF认证 task3"></a>补丁应用 第35次CCF认证 task3</h2><p>大模拟题，先看信息：</p><p>关于diff输出的补丁</p><ol><li>一个块 or 多个块；块：若干行文本；文本：对文件的一处修改；</li><li>关于第一行文本：1）@@开头结尾；2）NN MM nn mm是1~9字符组成的字符串；0、1或多个字符；最终表示一个整数；第NN行开始修改；修改了MM行；“这处”修改从新文件nn行开始；“这处”修改在新文件中有mm行</li><li>关于随后的若干行文本：1）-开头是删除该行；2）+开头被添加该行；3）空格开头，该行未变化； -与空格开头的行 &#x3D; MM；+与空格开头的行 &#x3D; mm</li></ol><p>关于patch</p><ol><li>移除#开头的</li><li>@开始到下一个@之间未一个块；如果没有@开头补丁损坏</li></ol><p>对于每一个块</p><ol><li>检查第一行格式，如果不正确则补丁损坏</li></ol><p>如果补丁未损坏</p><ol><li>解析NN、MM、mm</li><li>检查NN大于等于前一个块 NN与MM之和，否则补丁损坏</li></ol><p>如果补丁未损坏</p><ol><li>其余行，是否有+、-、空格开头的行，否则补丁损坏</li></ol><p>未损坏</p><ol><li>-、空格开头的是源文件片段</li><li>片段行数是否与MM一致，否则补丁损坏</li></ol><p>未损坏</p><ol><li>提取+、空格开头的，作为新文件片段</li><li>片段行数是否与mm一致，否则补丁损坏</li></ol><p>如果所有块都通过检查，即补丁未损坏（补丁有多个块）</p><p>修改源文件操作：</p><p>检查是否存在整数d，使得</p><ol><li>对于第一块，源文件NN+d行开始的MM行，与第一块的“源文件”片段完全匹配；</li><li>对于非第一块，除了1）要满足的条件之外，还要满足NN+d，不小于前一个块的NN+MM之和；否则补丁损坏</li><li>如果存在多个d，取绝对值最小的，如果仍存在多个，取小于0的d</li></ol><p>找到d之后（对于每个块应该要找一个d）</p><ol><li>将原文件的第NN+d行开始的MM行替换为块的新文件内容</li></ol><h2 id="通讯延迟-第35次CCF认证-task4"><a href="#通讯延迟-第35次CCF认证-task4" class="headerlink" title="通讯延迟 第35次CCF认证 task4"></a>通讯延迟 第35次CCF认证 task4</h2><p>基本思路是根据覆盖情况建图，然后跑一个dijkstra算法</p><ol><li>遍历每一个基站，检查它覆盖范围内的结点，范围内的结点互相间可以有边，完成建图</li><li>dijkstra算法，从结点1到结点n的最短路</li></ol><p>关于建立图的方式：</p><p>对每一个基站，确定其四个边界点的范围；<br>    遍历每一个点，确定其是否在该范围内；对在该范围内的所有点，两两之间添加边</p><p>关于dijkstra算法</p><ol><li>选定初始结点，纳入起点集合（队列）；用vis标志其距离已经确定</li><li>起点集合队首元素出列，作为起点，更新其到各个结点的距离；选择距离最短的结点，（检查未被vis标志）纳入起点集合，并用vis标志其距离已经确定</li><li>直到所有可以选择的点都被纳入过起点集合 1）所有点都被纳入过了；2）未被纳入的点距离都是INF</li></ol><p>反复处理，直到所有结点都被纳入起点集合</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DFS&amp;DP刷题练习</title>
      <link href="/2025/09/01/DFS-DP%E5%88%B7%E9%A2%98%E7%BB%83%E4%B9%A0/"/>
      <url>/2025/09/01/DFS-DP%E5%88%B7%E9%A2%98%E7%BB%83%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p><code>在通过网上一些资料稍微系统学习了一下DFS相关的内容，还有初步接触了一些DP的基础知识之后，我开这篇blog用来记录我刷相关的练习题的思路</code></p><h2 id="打家劫舍-Ⅱ-leetcode213"><a href="#打家劫舍-Ⅱ-leetcode213" class="headerlink" title="打家劫舍 Ⅱ leetcode213"></a>打家劫舍 Ⅱ leetcode213</h2><p>第一版代码是错误的。</p><p>我的思路是，现在房屋形成了一个环，我可以任意枚举一个位置入手，把环剪开，此时还原成房屋是一排的情况，然后套用Ⅰ的dp模板就可以了。</p><p>这样做的问题在于，dp模板在新的一排房屋上，相当于状态树是从i+1的位置开始的，但是dp模板是套用在从0开始的。也就是说状态树结点上前后结点的值有严格的依赖，任意剪切环，形成的数组，从前往后的dp并不对应原始数据的状态树。</p><p>以下是第一版代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() == <span class="number">1</span>)<span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums.size() == <span class="number">2</span>)<span class="keyword">return</span> max(nums[<span class="number">1</span>],nums[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums.size() == <span class="number">3</span>)<span class="keyword">return</span> max(nums[<span class="number">2</span>],max(nums[<span class="number">1</span>],nums[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; nums.size();i++)&#123;</span><br><span class="line">            <span class="type">int</span> cnt = nums[i];</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> b1 = i,b2 = (i<span class="number">-1</span>+nums.size())%nums.size(),b3 = (i+<span class="number">1</span>)%nums.size();</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; t;</span><br><span class="line">            t.clear();</span><br><span class="line">            <span class="comment">// for(int j = 0;j &lt; nums.size();j++)</span></span><br><span class="line">            <span class="comment">//     if(j != b1&amp;&amp;j != b2&amp;&amp;j != b3)t.push_back(nums[j]); 这样简单粗暴的构造t没有考虑到环断开之后，首位相接的情况</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i+<span class="number">2</span>;j &lt; nums.size();j++)</span><br><span class="line">                t.push_back(nums[j]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; i<span class="number">-1</span>;j++)</span><br><span class="line">                t.push_back(nums[j]);</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(t.size() == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(ans &lt; t[<span class="number">0</span>]+cnt)ans = t[<span class="number">0</span>]+cnt;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(t.size() == <span class="number">2</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(ans &lt; max(t[<span class="number">0</span>],t[<span class="number">1</span>])+cnt) ans = max(t[<span class="number">0</span>],t[<span class="number">1</span>])+cnt;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> new_f,f0 = t[<span class="number">0</span>],f1 = t[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">2</span>;j &lt; t.size();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                new_f = max(f1,f0+t[j]);</span><br><span class="line">                f0 = f1;</span><br><span class="line">                f1 = new_f;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(new_f + cnt &gt; ans)ans = new_f + cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>正确的思路是只从第一个位置把环剪开，枚举偷第一个位置，不偷第一个位置；</p><p>我最开始想到从任意位置剪开环，其实是相当于在选不选的子集模板中，不从第一个数开始考虑，从任意的数字开始考虑。看似是为了“考虑所有情况”，实际上打乱了状态树的状态，按照从前往后依次考虑选不选本就能够把所有状态考虑进去。而这道题只是在此基础上多了一个，第一个位置要特殊考虑，它会衍生出两种情况，就第一个位置的特殊考虑而言已经完备，分别在两种情况中直接使用“从前往后选或不选”的思想，也是完备的，综合来看可以考虑所有情况，而不会打乱状态树，可以套用dp模板。否则只会像我的第一版思路，打乱了状态树，还套用dp模板，只会造成错误（这样的错误在某种程度上来说，就是我改变了某些房屋的位置，改变了它们的相邻关系。）</p><p>修改后的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() == <span class="number">1</span>)<span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums.size() == <span class="number">2</span>)<span class="keyword">return</span> max(nums[<span class="number">1</span>],nums[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums.size() == <span class="number">3</span>)<span class="keyword">return</span> max(nums[<span class="number">2</span>],max(nums[<span class="number">1</span>],nums[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> new_f = <span class="number">0</span>, f1 = <span class="number">0</span>, f0 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//选第一个房屋</span></span><br><span class="line">        <span class="comment">// f0 = nums[2+0], f1 = max(nums[2+0],nums[2+1]);</span></span><br><span class="line">        <span class="comment">// if(4 == nums.size() &amp;&amp; nums[0]+f0 &gt; ans)ans = nums[0]+f0;</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// for(int j = 2+2;j &lt; nums.size() - 1;j++)</span></span><br><span class="line">        <span class="comment">// &#123;</span></span><br><span class="line">        <span class="comment">//     new_f = max(f1,f0+nums[j]);</span></span><br><span class="line">        <span class="comment">//     f0 = f1;</span></span><br><span class="line">        <span class="comment">//     f1 = new_f;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// if(new_f+nums[0] &gt; ans) ans = new_f+nums[0]; 注意选第一个房屋不一定要偷第一个房屋，我的代码就错在了这里！</span></span><br><span class="line"></span><br><span class="line">        f0 = nums[<span class="number">0</span>],f1 = max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">2</span>;j &lt; nums.size()<span class="number">-1</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            new_f = max(f1,f0+nums[j]);</span><br><span class="line">            f0 = f1;</span><br><span class="line">            f1 = new_f;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(new_f &gt; ans) ans = new_f;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//不选第一个房屋</span></span><br><span class="line">        f0 = nums[<span class="number">1</span>+<span class="number">0</span>], f1 = max(nums[<span class="number">1</span>+<span class="number">0</span>],nums[<span class="number">1</span>+<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>+<span class="number">2</span>;j &lt; nums.size();j++)</span><br><span class="line">        &#123;</span><br><span class="line">            new_f = max(f1,f0+nums[j]);</span><br><span class="line">            f0 = f1;</span><br><span class="line">            f1 = new_f;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(new_f &gt; ans) ans = new_f;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我在写这版代码开始的时候又犯了一个错误，选第一间房屋的意思是要考虑第一间，而不是一定会偷第一间；实际上选第一间与否代表着参与递推计算的索引范围不同，也是考虑的房屋范围不同。但是确定了范围之后使用递推计算的过程，对应的才是考虑实际要不要偷的问题。</p><h2 id="删除并获得点数"><a href="#删除并获得点数" class="headerlink" title="删除并获得点数"></a>删除并获得点数</h2><p>题干：</p><p>给你一个整数数组 nums ，你可以对它进行一些操作。</p><p>每次操作中，选择任意一个 nums[i] ，删除它并获得 nums[i] 的点数。之后，你必须删除 所有 等于 nums[i] - 1 和 nums[i] + 1 的元素。</p><p>开始你拥有 0 个点数。返回你能通过这些操作获得的最大点数。</p><p>我的思路：</p><p>这道题和打家劫舍有一点像，不过其取走i处的元素后不能再取的并不直接是i-1，i+1处的元素，而是元素值等于nums[i]+1和nums[i]-1处的元素。</p><p>首先，我想尽量还原回打家劫舍的场景，看是否能套用模板。于是我想到了<strong>排序</strong>，排完序之后，对于ban掉的位置而言，根据元素值的+1、-1会比较接近直接根据下标值的+1、-1。</p><p>于是我考虑直接使用dfs的模板，回溯三问：</p><ol><li>当前问题考虑能从0~i位置获取到的最大值，当前操作，是否选择位置i的元素</li><li>子问题，如果选择了位置i的元素，那么考虑0<del>j位置获取到的最大值，其中j是从i-1开始，第一个不满足nums[j]+1 &#x3D;&#x3D; nums[i]的元素的下标；如果没有选择位置i的元素，那么考虑0</del>i-1位置能获取到的最大元素</li><li>子问题的操作，如果…，是否选择位置j的元素；如果…是否选择位置i-1处的元素</li></ol><p>然而上面存在一个问题，即第2步的时候：“对于j是，第一个不满足nums[j]+1 &#x3D;&#x3D; nums[i]的元素的下标”，如果nums[i] !&#x3D; nums[i-1]的话这是正确的，换言之，如果存在相同元素，那么索引范围的缩减会出现错误，误以为已经缩减成剔除了nums[j]+1 &#x3D;&#x3D; nums[i]对应的元素nums[j]，但实际上没有剔除。</p><p>所以为了回溯三问对应的思路是正确的，我们要确保没有相同元素的存在；又因为我们要取得最大值，所以你如果选择了一个nums[i]，那么剩下的相同值的元素你都应该选；于是我想到了用一个哈希表，以nums[i]为key，value存储所有值为nums[i]的元素的和；然后将nums更新，使得重复的元素只保留一个，再排序；最后套用回溯三问的思路即可。</p><p>代码实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; mp;</span><br><span class="line">    <span class="type">int</span> cnt[<span class="number">20000</span>];</span><br><span class="line">    <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">0</span>)<span class="keyword">return</span> mp[nums[<span class="number">0</span>]];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i<span class="number">-1</span>]+<span class="number">1</span> == nums[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(cnt[i] != <span class="number">-1</span>)<span class="keyword">return</span> cnt[i];</span><br><span class="line">                cnt[i] = max(dfs(i<span class="number">-1</span>,nums),dfs(i<span class="number">-2</span>,nums)+mp[nums[i]]);</span><br><span class="line">                <span class="keyword">return</span> cnt[i];</span><br><span class="line">            &#125;   </span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(cnt[i] != <span class="number">-1</span>)<span class="keyword">return</span> cnt[i];</span><br><span class="line">                cnt[i] = dfs(i<span class="number">-1</span>,nums)+mp[nums[i]];</span><br><span class="line">                <span class="keyword">return</span> cnt[i];</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">deleteAndEarn</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; nums.size();i++)</span><br><span class="line">            mp[nums[i]]+=nums[i];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; t;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it = mp.begin();it != mp.end();it++)</span><br><span class="line">            t.push_back(it-&gt;first);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; t.size();i++)cnt[i] = <span class="number">-1</span>;</span><br><span class="line">        sort(t.begin(),t.end());</span><br><span class="line">        <span class="keyword">return</span> dfs(t.size()<span class="number">-1</span>,t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="统计构造好字符串的方案数-leetcode-2466"><a href="#统计构造好字符串的方案数-leetcode-2466" class="headerlink" title="统计构造好字符串的方案数 leetcode 2466"></a>统计构造好字符串的方案数 leetcode 2466</h2><p>题干：</p><p>给你整数 zero ，one ，low 和 high ，我们从空字符串开始构造一个字符串，每一步执行下面操作中的一种：</p><ol><li>将 ‘0’ 在字符串末尾添加 zero  次。</li><li>将 ‘1’ 在字符串末尾添加 one 次。<br>以上操作可以执行任意次。</li></ol><p>如果通过以上过程得到一个 长度 在 low 和 high 之间（包含上下边界）的字符串，那么这个字符串我们称为 好 字符串。</p><p>请你返回满足以上要求的 不同 好字符串数目。由于答案可能很大，请将结果对 109 + 7 取余 后返回。</p><p>我的第一种思路，试一试dfs，枚举每次选zero还是选one即可，时间复杂度显然是$O(2^n)$，不出所料超时了…但是正确性是有保证的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans;</span><br><span class="line">    <span class="type">int</span> low,high,zero,one;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> M = <span class="number">1000000007</span>;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> len)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(len &gt; high)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(len &gt;= low)ans = (ans+<span class="number">1</span>)%M;</span><br><span class="line"></span><br><span class="line">        dfs(len+zero);</span><br><span class="line">        dfs(len+one);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">countGoodStrings</span><span class="params">(<span class="type">int</span> low, <span class="type">int</span> high, <span class="type">int</span> zero, <span class="type">int</span> one)</span> &#123;</span><br><span class="line">        this-&gt;low = low, this-&gt;high = high, this-&gt;zero = zero, this-&gt;one = one;</span><br><span class="line">        dfs(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>改进的思路是添加记忆化。换一个视角，其实这就是爬楼梯的翻版，每次可以选择爬zero或one阶，爬到x in [low,high]，的方案总和有多少。于是可以写出如下记忆化递归：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> M = <span class="number">1000000007</span>;</span><br><span class="line">    <span class="type">int</span> zero,one;</span><br><span class="line">    <span class="type">int</span> cnt[<span class="number">100001</span>];</span><br><span class="line">    <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> len)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//得到空串的方案数是1</span></span><br><span class="line">        <span class="keyword">if</span>(len &lt; <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(cnt[len] != <span class="number">-1</span>)<span class="keyword">return</span> cnt[len];</span><br><span class="line">        <span class="keyword">else</span> cnt[len] = (dfs(len-zero)+dfs(len-one))%M;</span><br><span class="line">        <span class="keyword">return</span> cnt[len];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">countGoodStrings</span><span class="params">(<span class="type">int</span> low, <span class="type">int</span> high, <span class="type">int</span> zero, <span class="type">int</span> one)</span> &#123;</span><br><span class="line">        this-&gt;zero = zero,this-&gt;one = one;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= high;i++)cnt[i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = low;i &lt;= high;i++)</span><br><span class="line">            ans = (ans + dfs(i))%M;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>有两个关键点</p><ol><li>递归的边界条件，dfs(i)代表爬i阶的方案数，所以dfs(0) &#x3D;&#x3D; 1，可以理解成爬0阶就是一种方案，或者理解为递归从i到0的时候，0是整个下台阶尝试成功的一条分支，所以返回1；而i&lt;0的情况就是尝试失败的分支，所以返回0</li><li>最后的ans累加的是dfs(i)，low&lt;&#x3D; i &lt;&#x3D;high，虽然我们的dfs(i)本身代表的是爬上i阶的方案，并且在cnt中进行了记忆化，但是对于i的不同初态，能够递归到的情况是不同的；所以不能直接dfs(high)，然后ans累加cnt[i]，i in [low, high]（例如low &#x3D; 4，high &#x3D; 5，zero &#x3D; 2，one &#x3D; 2，如果从high开始，dfs(4)并不会被递归到）</li></ol><p><strong>第二个关键点是我第一次遇见</strong>，这算是一种在递归中初态会影响后续分支选择的情况，值得着重注意。</p><h2 id="组合总和"><a href="#组合总和" class="headerlink" title="组合总和"></a>组合总和</h2><p>题干：</p><p>给你一个由 不同 整数组成的数组 nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数。（元素可以重复选取）</p><p>题目数据保证答案符合 32 位整数范围。</p><p>我的思路：仍然可以看成爬楼梯的变式，这次要爬的楼梯数是固定的，但是每次的选择有nums.size()种。dfs枚举每一次每一种选，然后加一个记忆化即可。基本上就是直接套板子了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cnt[<span class="number">1001</span>];</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i &lt; <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(cnt[i] != <span class="number">-1</span>)<span class="keyword">return</span> cnt[i];</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; nums.size();j++)</span><br><span class="line">                res += dfs(i - nums[j]);</span><br><span class="line">            cnt[i] = res;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">combinationSum4</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt;= target;i++)cnt[i] = <span class="number">-1</span>;</span><br><span class="line">        this-&gt;nums = nums;</span><br><span class="line">        <span class="keyword">return</span> dfs(target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="统计打字方案数"><a href="#统计打字方案数" class="headerlink" title="统计打字方案数"></a>统计打字方案数</h2><p>爬楼梯的变式，可以看成楼梯是由数字标定的不同种类，有这样几个关键的条件限制</p><ol><li>一次只能爬一种台阶</li><li>对于7、9标定的台阶，一次最多爬4阶；其它数字对应的台阶一次最多爬3阶</li></ol><p>在此基础上，从dfs(-1)开始，代表还没有爬任何一阶（因为string从0开始索引就代表第一阶了）；然后开始爬楼梯，使用check()检查当前位置可以爬几阶，例如可以爬3阶的时候就是dfs(i) &#x3D; dfs(i+1)+dfs(i+2)+dfs(i+3)，向下递归即可；边界条件是i &#x3D;&#x3D; str.length()-1，即i已经索引到了最后一个字符，也就是爬上了最高的台阶。</p><p>最后再引入一个记忆化即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="type">int</span> cnt[<span class="number">100001</span>];</span><br><span class="line">    <span class="type">int</span> tlen[<span class="number">100001</span>];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> i)</span>&#123;<span class="comment">//确定可以上几个台阶</span></span><br><span class="line">        <span class="type">int</span> len = <span class="number">1</span>;<span class="comment">//至少上一阶，不会有上0阶的情况，因为在dfs中以到最后一阶（i == str.length()-1）为边界条件</span></span><br><span class="line">        <span class="keyword">if</span>(len + i == str.length() - <span class="number">1</span>)<span class="keyword">return</span> len;<span class="comment">//上一阶就到最后一阶了</span></span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> t = str[i + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(t == <span class="string">&#x27;7&#x27;</span> || t == <span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(;(len + i != str.length())&amp;&amp;(str[len + i] == str[i + <span class="number">1</span>]);len++);</span><br><span class="line">            <span class="keyword">return</span> min(len<span class="number">-1</span>,<span class="number">4</span>);<span class="comment">//最多上4阶</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(;(len + i != str.length())&amp;&amp;(str[len + i] == str[i + <span class="number">1</span>]);len++);</span><br><span class="line">            <span class="keyword">return</span> min(len<span class="number">-1</span>,<span class="number">3</span>);<span class="comment">//最多上3阶</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == str.length()<span class="number">-1</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i &gt;= <span class="number">0</span> &amp;&amp; cnt[i] != <span class="number">-1</span>)<span class="keyword">return</span> cnt[i];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">-1</span>)len = check(i);</span><br><span class="line">        <span class="keyword">else</span> len = tlen[i];</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= len;j++)</span><br><span class="line">            res = (res + dfs(i+j))%<span class="number">1000000007</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(i &gt;= <span class="number">0</span>)cnt[i] = res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">countTexts</span><span class="params">(<span class="built_in">string</span> pressedKeys)</span> &#123;</span><br><span class="line">        this-&gt;str = pressedKeys;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; str.length();i++)cnt[i] = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; str.length()<span class="number">-1</span>;i++)</span><br><span class="line">            tlen[i] = check(i);</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但是这样记忆化搜索会被最后几个非常庞大的样例卡住，时间大概是擦边不能过的样子…</p><p>参考了题解之后，这道题应该直接用dp，虽然dp和记忆化搜索在一般情况下认为时间大差不差，但是这种时间擦边不能过的情况，记忆化搜索稍微比dp多出来的一点时间就成为掣肘的关键了。</p><p>改dp的思路：</p><ol><li>打标计算只有一类台阶的情况，爬到第i阶的时候有多少种方案</li><li>再中间台阶类型变换的时候使用乘法原理处理</li></ol><p>转移方程参考爬楼梯的模板dp[i] &#x3D; dp[i-1] + dp[i-2]，不难理解。 </p><p>代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> dp1[<span class="number">100001</span>];<span class="comment">//dp1[i]代表在全是一类台阶的情况下，爬到i的方案数</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> dp2[<span class="number">100001</span>];<span class="comment">//dp2[i]代表在全是二类台阶的情况下，爬到i的方案数</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> M = <span class="number">1000000007</span>;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">ini</span><span class="params">()</span>&#123;</span><br><span class="line">        dp1[<span class="number">0</span>] = <span class="number">1</span>,dp1[<span class="number">1</span>] = <span class="number">1</span>,dp1[<span class="number">2</span>] = <span class="number">2</span>,dp1[<span class="number">3</span>] = <span class="number">4</span>;<span class="comment">//不爬；1；11、2；3、12、21、111；</span></span><br><span class="line">        dp2[<span class="number">0</span>] = <span class="number">1</span>,dp2[<span class="number">1</span>] = <span class="number">1</span>,dp2[<span class="number">2</span>] = <span class="number">2</span>,dp2[<span class="number">3</span>] = <span class="number">4</span>;<span class="comment">//同上</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//提前打好dp表，后续直接用</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">4</span>;i &lt; <span class="number">100001</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp1[i] = (dp1[i<span class="number">-1</span>] + dp1[i<span class="number">-2</span>] + dp1[i<span class="number">-3</span>])%M;</span><br><span class="line">            dp2[i] = (dp2[i<span class="number">-1</span>] + dp2[i<span class="number">-2</span>] + dp2[i<span class="number">-3</span>] + dp2[i<span class="number">-4</span>])%M;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">countTexts</span><span class="params">(<span class="built_in">string</span> pressedKeys)</span> &#123;</span><br><span class="line">        ini();</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">1</span>;<span class="comment">//最后的答案爬完这种楼梯的方案数，中间要用乘法处理，因为楼梯的类型会变化，乘的就是一种类型的楼梯爬了几个台阶</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; pressedKeys.length();)&#123;</span><br><span class="line">            <span class="type">int</span> j;</span><br><span class="line">            <span class="keyword">for</span>(j = i+<span class="number">1</span>;j &lt; pressedKeys.length() &amp;&amp; pressedKeys[j] == pressedKeys[i];j++);<span class="comment">//注意边界情况，最后爬到最高的台阶应该是第pressedKeys.length()阶，而不是按照索引去减1；可以想想里面具体有多少字符</span></span><br><span class="line">            <span class="keyword">if</span>(pressedKeys[i] == <span class="string">&#x27;7&#x27;</span> || pressedKeys[i] == <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">                ans = (ans * dp2[j - i])%M;</span><br><span class="line">            <span class="keyword">else</span> ans = (ans * dp1[j - i])%M;</span><br><span class="line">            i = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这道题给我最大的感受是，对于边界条件的设置，以及不同索引下dp数组的含义 or dfs递归的状态 要有清楚的认识，这样才不会乱。我被索引绕得有点晕写了好久…</p><h2 id="统计各位数字都不同的数字个数"><a href="#统计各位数字都不同的数字个数" class="headerlink" title="统计各位数字都不同的数字个数"></a>统计各位数字都不同的数字个数</h2><p>题干：</p><p>给你一个整数 n ，统计并返回各位数字都不同的数字 x 的个数，其中 0 &lt;&#x3D; x &lt; 10n 。</p><p>示例 1：</p><p>输入：n &#x3D; 2<br>输出：91<br>解释：答案应为除去 11、22、33、44、55、66、77、88、99 外，在 0 ≤ x &lt; 100 范围内的所有数字。</p><p>这道题换一个视角来看，就是有0<del>9，十张卡片，按照要求抽1</del>n张卡，求对应所有的排列情况之和（即抽1张卡时的排列情况+2张卡时的排列情况+…）。可以直接使用全排列；由于抽卡的数量是1~n，所以问题状态树上的每一个结点都对应增加一种情况，而不是完成抽卡之后才统计为一种情况。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">1</span>;<span class="comment">//一位的情况下可以有一个单独的0</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> r)</span>&#123;<span class="comment">//i是当前抽的第几个数字，r是当前剩余的数字数量</span></span><br><span class="line">        <span class="keyword">if</span>(i == n)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt; r;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                ans++;</span><br><span class="line">                dfs(<span class="number">1</span>,r<span class="number">-1</span>);<span class="comment">//第一个数字不能是0</span></span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; r;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                ans++;</span><br><span class="line">                dfs(i+<span class="number">1</span>,r<span class="number">-1</span>);</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">countNumbersWithUniqueDigits</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        this-&gt;n = n;</span><br><span class="line">        dfs(<span class="number">0</span>,<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意点是</p><ol><li>上面写的dfs递归不涵盖n &#x3D;&#x3D; 0的情况，所以ans初始时置为1；</li><li>然后n &#x3D;&#x3D; 1的时候由于n &#x3D;&#x3D; 0抽掉了1，所以只剩9张卡；而当n &gt; 1的时候，高位数字不能为0，所以第一次抽也只有9张卡，于是统一在dfs中有一个特殊处理，即i &#x3D;&#x3D; 0的情况</li></ol><h2 id="最小路径和"><a href="#最小路径和" class="headerlink" title="最小路径和"></a>最小路径和</h2><p>题干：</p><p>给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p>说明：每次只能向下或者向右移动一步。</p><p>我的基本思路是这样的：</p><p>回溯三问：</p><ol><li>当前操作，是否选择要向右移动</li><li>当前子问题，要做k次选择，其中只能且必须选择i次向右，要求获得收益最少</li><li>子问题的下一个问题，情况1：如果选择了向右，那么还要做k-1次选择，只能且必须选择i-1次向右；如果没有选择向右，那么还要做k-1次选择，只能且必须选择i次向右</li></ol><p>关于边界条件：</p><ol><li>当i &#x3D;&#x3D; k的时候，剩余k次全部选择向右</li><li>当i &#x3D;&#x3D; 0的时候，剩余k此全部选择向下</li></ol><p>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; cnt;<span class="comment">//记录每一次的选择，1向右，0向下</span></span><br><span class="line">    <span class="type">int</span> memo[<span class="number">200</span>][<span class="number">400</span>];</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; grid;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">compute</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="number">0</span>,y = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> t = grid[x][y];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; cnt.size();i++)</span><br><span class="line">            <span class="keyword">if</span>(cnt[i] == <span class="number">1</span>)t += grid[x][++y];</span><br><span class="line">            <span class="keyword">else</span> t += grid[++x][y];</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == k)&#123;<span class="comment">//只能向右走了</span></span><br><span class="line">            <span class="keyword">if</span>(memo[i][k] != <span class="number">-1</span>)<span class="keyword">return</span> memo[i][k];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; k;j++)</span><br><span class="line">                cnt.push_back(<span class="number">1</span>);</span><br><span class="line">            <span class="type">int</span> res = compute();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; k;j++)</span><br><span class="line">                cnt.pop_back();</span><br><span class="line">            memo[i][k] = res;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;<span class="comment">//只能向下走了</span></span><br><span class="line">            <span class="keyword">if</span>(memo[i][k] != <span class="number">-1</span>)<span class="keyword">return</span> memo[i][k];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; k;j++)</span><br><span class="line">                cnt.push_back(<span class="number">0</span>);</span><br><span class="line">            <span class="type">int</span> res = compute();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; k;j++)</span><br><span class="line">                cnt.pop_back();</span><br><span class="line">            memo[i][k] = res;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(memo[i][k] != <span class="number">-1</span>)<span class="keyword">return</span> memo[i][k];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//选择向右走</span></span><br><span class="line">        cnt.push_back(<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> t1 = dfs(i<span class="number">-1</span>,k<span class="number">-1</span>);</span><br><span class="line">        cnt.pop_back();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//选择向下走</span></span><br><span class="line">        cnt.push_back(<span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> t2 = dfs(i,k<span class="number">-1</span>);</span><br><span class="line">        cnt.pop_back();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = min(t1,t2);</span><br><span class="line">        memo[i][k] = res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">minPathSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">200</span>;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; <span class="number">400</span>;j++)</span><br><span class="line">                memo[i][j] = <span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        this-&gt;grid = grid;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dfs(grid[<span class="number">0</span>].size()<span class="number">-1</span>,grid.size()+grid[<span class="number">0</span>].size()<span class="number">-2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但是这份代码出现了问题。</p><p>其实回溯三问的考量下的状态转移，以及递归的边界条件都没有问题，而状态是出现在记忆化上。</p><p><strong>来自deepseek的总结</strong>非常鞭辟入里</p><p>你的代码的基本思路是使用记忆化搜索（DFS + memoization），通过记录路径选择（<code>cnt</code> 向量）并在边界条件下计算完整路径和（<code>compute</code> 函数）。然而，错误的核心在于 <strong>记忆化设计不完整</strong>，导致在某些情况下错误地重用了记忆化值。具体原因如下：<br>记忆化键（memo[i][k]）不足以唯一标识状态</p><p>你的记忆化数组 memo[i][k] 使用两个参数：</p><ol><li>i：表示剩余需要向右走的步数。</li><li>k：表示总剩余步数（剩余向右步数 + 剩余向下步数）。</li></ol><p>在状态 (i, k) 下，理论上剩余路径是确定的（需要走 i 步向右和 k - i 步向下），但 (i, k) 没有捕获当前位置 (x, y) 或前缀路径的累积和。<br>问题在于，compute 函数计算的是 从起点 (0, 0) 开始的完整路径和，而不是从当前状态开始的剩余路径和。compute 使用全局 cnt 向量重建整个路径，但 cnt 包含了所有历史选择（从起点到当前点的路径）。因此：<br>相同的 (i, k) 状态可能从不同的位置 (x, y) 到达（例如，通过不同的路径前缀）。<br>由于起点到当前位置的前缀路径不同，compute 计算的完整路径和也会不同。<br>然而，你的记忆化只基于 (i, k) 存储结果，忽略了当前位置或前缀路径的影响。这会导致错误的重用：当从不同路径到达相同的 (i, k) 状态时，memo[i][k] 可能返回一个错误的完整路径和（该值依赖于之前计算时的前缀路径，而非当前路径）。</p><p>其实这本质上就是犯了我常犯的一个错误——<strong>将累积变量作为了参数传递</strong>，如果使用累积变量作为参数传递，通常是不能使用记忆化的；（看似我这里没有把它当作参数传递，但是本质上累积变量是到达边界的时候才进行计算的。）</p><p>进一步思考，我对于这个问题的考虑太过复杂了，其实没必要考虑“选择序列”是怎样的，直接将位置作为状态即可。</p><p>重新考虑回溯三问</p><ol><li>当前操作，在位置(x,y)，去到位置(x+1,y)还是位置(x,y+1)</li><li>当前子问题，在位置(x,y)，如何移动到终点，使得收益最小</li><li>当前子问题的下一个问题，1）在(x+1,y)如何移动到终点使得收益最小；2）在(x,y+1)如何移动到终点使得收益最小</li></ol><p>边界条件：</p><p>x &#x3D;&#x3D; g.size()-1 || y &#x3D;&#x3D; g.size()-1</p><p>状态转移：</p><p>dfs(x,y) &#x3D; min(dfs(x+1,y)+g[x+1][y],dfs(x,y+1)+g[x][y+1]) s.t. x !&#x3D; g.size()-1 &amp;&amp; y !&#x3D; g[0].size()-1<br>… s.t. x &#x3D;&#x3D; g.size()-1<br>… s.t. y &#x3D;&#x3D; g[0].size()-1</p><p>g[0][0]可以直接作为初始值，累加在答案上。</p><p>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> memo[<span class="number">200</span>][<span class="number">200</span>];</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; g;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == g.size() - <span class="number">1</span> &amp;&amp; y == g[<span class="number">0</span>].size() - <span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(memo[x][y] != <span class="number">-1</span>)<span class="keyword">return</span> memo[x][y];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(x == g.size() - <span class="number">1</span>)&#123;</span><br><span class="line">            memo[x][y] = dfs(x,y+<span class="number">1</span>) + g[x][y+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">return</span> memo[x][y];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(y == g[<span class="number">0</span>].size() - <span class="number">1</span>)&#123;</span><br><span class="line">            memo[x][y] = dfs(x+<span class="number">1</span>,y) + g[x+<span class="number">1</span>][y];</span><br><span class="line">            <span class="keyword">return</span> memo[x][y];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            memo[x][y] = min(dfs(x+<span class="number">1</span>,y) + g[x+<span class="number">1</span>][y],dfs(x,y+<span class="number">1</span>) + g[x][y+<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">return</span> memo[x][y];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">minPathSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">200</span>;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; <span class="number">200</span>;j++)</span><br><span class="line">                memo[i][j] = <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">        this-&gt;g =grid;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> g[<span class="number">0</span>][<span class="number">0</span>] + dfs(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这样才能明显的看见，累积变量是在递归状态转移的过程中累加的，而没有作为参数处理。‘</p><h2 id="将石头分散到网格图的最少移动次数"><a href="#将石头分散到网格图的最少移动次数" class="headerlink" title="将石头分散到网格图的最少移动次数"></a>将石头分散到网格图的最少移动次数</h2><p>题干：</p><p>给你一个大小为 3 * 3 ，下标从 0 开始的二维整数矩阵 grid ，分别表示每一个格子里石头的数目。网格图中总共恰好有 9 个石头，一个格子里可能会有 多个 石头。</p><p>每一次操作中，你可以将一个石头从它当前所在格子移动到一个至少有一条公共边的相邻格子。</p><p>请你返回每个格子恰好有一个石头的 最少移动次数 。</p><p>我的思路：</p><ol><li>预处理，统计重叠石头的存在位置（注意是统计重叠了的石头，例如一个位置有3个石头要统计两次）；统计没有石头的位置</li><li>对存在石头的位置进行全排列，与没有石头的位置一一匹配，计算每一种情况的移动次数</li><li>保留最少的移动次数</li></ol><p>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Pos</span>&#123;</span></span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="type">int</span> y;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Pos&gt; a;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Pos&gt; b;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">100000000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;Pos&gt;&amp; cmb)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cmb.size() == b.size())&#123;</span><br><span class="line">            <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; cmb.size();i++)&#123;</span><br><span class="line">                cnt += (<span class="built_in">abs</span>(cmb[i].x - b[i].x) + <span class="built_in">abs</span>(cmb[i].y - b[i].y));</span><br><span class="line">            &#125;</span><br><span class="line">            ans = min(ans, cnt);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; a.size();i++)&#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">Pos</span> <span class="title">t</span> =</span> a[i];</span><br><span class="line">            cmb.push_back(t);</span><br><span class="line">            a.erase(a.begin()+i);</span><br><span class="line">            dfs(cmb);</span><br><span class="line">            a.insert(a.begin()+i,t);</span><br><span class="line">            cmb.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">minimumMoves</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; <span class="number">3</span>;j++)</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="class"><span class="keyword">struct</span> <span class="title">Pos</span> <span class="title">t</span>;</span></span><br><span class="line">                    t.x = i,t.y = j;</span><br><span class="line">                    b.push_back(t);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(grid[i][j] &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> k = grid[i][j]<span class="number">-1</span>;k &gt; <span class="number">0</span>;k--)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">struct</span> Pos t;</span><br><span class="line">                        t.x = i,t.y = j;</span><br><span class="line">                        a.push_back(t);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;Pos&gt; t;</span><br><span class="line">        dfs(t);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度优先搜索整理</title>
      <link href="/2025/08/30/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E6%95%B4%E7%90%86/"/>
      <url>/2025/08/30/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p><code>这篇blog用来整理一些常见的可以使用深度优先搜索的问题模板</code></p><h2 id="写在最前面"><a href="#写在最前面" class="headerlink" title="写在最前面"></a>写在最前面</h2><p>在这篇blog中会高频地出现三个词汇，<strong>DFS、递归、回溯</strong>，实际上DFS与后二者的关联是十分密切的。</p><p>狭义上来说，DFS是在图上面做搜索的一种算法，它使用深度优先，依次处理各个结点。可以用<strong>递归函数的形式</strong>实现，也可以用<strong>循环+栈</strong>的形式实现。</p><p>但是从广义上来说，对于可以枚举状态的问题，问题的状态转移的过程本就可以<strong>抽象成一棵树</strong>，而树本质上就是一个特殊的图。当我们使用递归函数，搜索问题的各个状态的时候，就可以看作，我们是在一张“特殊的”图上，做DFS。</p><p><em>关于回溯与它们的联系，后面再进行补充</em>。</p><h2 id="基本范式"><a href="#基本范式" class="headerlink" title="基本范式"></a>基本范式</h2><p>DFS的模板框架如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function <span class="title function_">dfs</span><span class="params">(now_state)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(now_state == target_state)</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> ...;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(... enumerate new_state)&#123;</span><br><span class="line">        <span class="keyword">if</span>(new_state is valid)&#123;</span><br><span class="line">            vis[new_state] = ...;<span class="comment">//标记新状态被访问</span></span><br><span class="line">            dfs(new_state);</span><br><span class="line">            ? vis[new_state] = ...;<span class="comment">//是否需要恢复现场</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(have considered all condition)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来的部分分几个主要的大类型，每个题目里都会附上对应的练习与解答，结合题目进行总结。</p><h2 id="DFS无需回溯"><a href="#DFS无需回溯" class="headerlink" title="DFS无需回溯"></a>DFS无需回溯</h2><p>DFS无需回溯的情况是少</p><h3 id="红与黑-AcWing-1113"><a href="#红与黑-AcWing-1113" class="headerlink" title="红与黑 AcWing 1113"></a>红与黑 AcWing 1113</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> h,w;</span><br><span class="line"><span class="type">char</span> mp[<span class="number">21</span>][<span class="number">21</span>];</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> vis[<span class="number">21</span>][<span class="number">21</span>],<span class="type">int</span> posx,<span class="type">int</span> posy)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">4</span>;i++)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="keyword">switch</span>(i)&#123;</span><br><span class="line">   <span class="keyword">case</span> <span class="number">1</span>:&#123;</span><br><span class="line">    <span class="type">int</span> x = posx,y = posy<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(y &gt;= <span class="number">0</span> &amp;&amp; !vis[x][y] &amp;&amp; mp[x][y] == <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">     vis[x][y] = <span class="number">1</span>;</span><br><span class="line">     cnt++;</span><br><span class="line">     <span class="built_in">dfs</span>(vis,x,y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">case</span> <span class="number">2</span>:&#123;</span><br><span class="line">    <span class="type">int</span> x = posx,y = posy<span class="number">+1</span>;</span><br><span class="line">    <span class="keyword">if</span>(y &lt; w &amp;&amp; !vis[x][y] &amp;&amp; mp[x][y] == <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">     vis[x][y] = <span class="number">1</span>;</span><br><span class="line">     cnt++;</span><br><span class="line">     <span class="built_in">dfs</span>(vis,x,y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">case</span> <span class="number">3</span>:&#123;</span><br><span class="line">    <span class="type">int</span> x = posx<span class="number">-1</span>,y = posy;</span><br><span class="line">    <span class="keyword">if</span>(x &gt;= <span class="number">0</span> &amp;&amp; !vis[x][y] &amp;&amp; mp[x][y] == <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">     vis[x][y] = <span class="number">1</span>;</span><br><span class="line">     cnt++;</span><br><span class="line">     <span class="built_in">dfs</span>(vis,x,y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">case</span> <span class="number">4</span>:&#123;</span><br><span class="line">    <span class="type">int</span> x = posx<span class="number">+1</span>,y = posy;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; h &amp;&amp; !vis[x][y] &amp;&amp; mp[x][y] == <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">     vis[x][y] = <span class="number">1</span>;</span><br><span class="line">     cnt++;</span><br><span class="line">     <span class="built_in">dfs</span>(vis,x,y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="type">int</span> vis[<span class="number">21</span>][<span class="number">21</span>];</span><br><span class="line"> <span class="type">int</span> posx = <span class="number">0</span>,posy = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; h;i++)</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; w;j++)</span><br><span class="line">  &#123;</span><br><span class="line">   vis[i][j] = <span class="number">0</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//寻找起点</span></span><br><span class="line">   <span class="comment">//cout&lt;&lt;&quot;mp[i][j]:&quot;&lt;&lt;mp[i][j]&lt;&lt;endl;</span></span><br><span class="line">   <span class="keyword">if</span>(mp[i][j] == <span class="string">&#x27;@&#x27;</span>)posx = i,posy = j; </span><br><span class="line">  &#125;</span><br><span class="line"> vis[posx][posy] = <span class="number">1</span>;</span><br><span class="line"> cnt = <span class="number">1</span>;</span><br><span class="line"> <span class="built_in">dfs</span>(vis,posx,posy);</span><br><span class="line"> cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> string str;</span><br><span class="line"> <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">  cin&gt;&gt;w&gt;&gt;h;</span><br><span class="line">  <span class="keyword">if</span>(w == <span class="number">0</span> &amp;&amp; h == <span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; h;i++)</span><br><span class="line">   &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; w;j++)</span><br><span class="line">     cin&gt;&gt;mp[i][j];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//输入完成 </span></span><br><span class="line">   <span class="built_in">solve</span>();</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意点：</p><ol><li>关于不需要回溯，<strong>我的一个理解</strong>：由于在每次搜索到的状态，更改的全局变量只有vis数组，而这个更改正是必须的（我们需要一个DFS分支更改的vis影响另一个DFS分支，来确定当前点是否已经到达过了），所以不需要进行回溯。<em>需要回溯的一种情况是，一个分支修改的全局变量对另一个分支没有作用，另一个分支不能直接使用，要自己修改，那么在一个分支结束的时候就应该还原自己修改的全局变量</em></li><li>关于不需要回溯，<strong>另一种理解</strong>：在一个分支下到达的每一个点，在这个分支结束过后就可以抛弃了，因为我们只是统计点的数量不需要再回到这个点；但是需要回溯的情况，例如走迷宫，你在尝试一种路径的时候走过一系列点，这些点不能被抛弃，你在尝试其它路径的时候可能还会来到这些点，所以在每一条路径结束的时候，要将标记访问的vis数组进行还原（具体如何还原见后面的笔记）。</li><li>注意io上的细节实现，由于有多轮数据，所以每轮开始要注意相关变量的初始化</li></ol><h2 id="DFS与回溯"><a href="#DFS与回溯" class="headerlink" title="DFS与回溯"></a>DFS与回溯</h2><h3 id="ACW分成互质组"><a href="#ACW分成互质组" class="headerlink" title="ACW分成互质组"></a>ACW分成互质组</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; g[<span class="number">11</span>];</span><br><span class="line"><span class="type">int</span> num[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(x%y == <span class="number">0</span>)<span class="keyword">return</span> y;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">return</span> gcd(y,x%y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line"> <span class="comment">//检查是否可以把数字i放在第j组</span></span><br><span class="line"> <span class="keyword">if</span>(g[j].empty())<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> <span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>;k &lt; g[j].size();k++)&#123;</span><br><span class="line">   <span class="keyword">if</span>(gcd(num[i],g[j][k]) != <span class="number">1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> num_g,<span class="type">int</span> now)</span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(now == n)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="type">int</span> i = now;</span><br><span class="line"> <span class="comment">//i对应当前正在处理数字的索引 </span></span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; num_g;j++)<span class="comment">//把它尝试放入各组中</span></span><br><span class="line"> &#123;</span><br><span class="line">  <span class="keyword">if</span>(check(i,j))&#123;<span class="comment">//如果可以放入第j组 </span></span><br><span class="line">   g[j].push_back(num[now]);</span><br><span class="line">   <span class="keyword">if</span>(dfs(num_g, now+<span class="number">1</span>))<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   <span class="keyword">else</span> g[j].pop_back();<span class="comment">//尝试放入失败 </span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">  <span class="built_in">cin</span>&gt;&gt;num[i];</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> num_g = <span class="number">1</span>;num_g &lt;= n;num_g++)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="keyword">if</span>(dfs(num_g,<span class="number">0</span>))&#123;</span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;num_g&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125; </span><br><span class="line">  </span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现的思路是从小到大枚举可能的组数，用DFS暴力搜索，把每个数字依次放入每个组的情况。</p><p>本题总结：</p><ol><li>DFS的主线是依次处理每个数字，每处理一个数字就进入到下一个状态，当n个数字处理完毕就可以结束了，当前使用的组数就是最小的组数</li><li>一个反思，在写DFS的时候要想清楚，每层深入的时候，对应的实际意义是什么。这里就是处理过的数字的数量增加。我开始的时候没有想清楚在dfs的for循环外面还套了一层遍历所有数字的循环，不明所以…</li><li>这里就要注意<strong>恢复现场</strong>，即g[j].pop_back()，也是回溯的体现，当一条分支尝试失败了要还原状态。否则当前分支存入第j组的数字，在其它分支总也会存在，显然就会有问题…</li></ol><h3 id="子集模板-子集-leetcode78"><a href="#子集模板-子集-leetcode78" class="headerlink" title="子集模板 子集 leetcode78"></a>子集模板 子集 leetcode78</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; &gt;ans;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; cmb, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == len)&#123;</span><br><span class="line">            ans.push_back(cmb);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cmb.push_back(nums[i]);</span><br><span class="line">        dfs(cmb,i+<span class="number">1</span>);</span><br><span class="line">        cmb.pop_back();</span><br><span class="line"></span><br><span class="line">        dfs(cmb,i+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; subsets(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        len = nums.size();</span><br><span class="line">        this-&gt;nums = nums;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; t;</span><br><span class="line">        dfs(t,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这道题可以完美地体现写在blog开头的那段话，问题的状态就是一棵二叉树，递归就是在其上做深搜。同样，回溯体现在还原现场。</p><p>上面代码的此题思路是，从<strong>每个数字</strong>的角度出发，依次考虑选与不选，当所有的数字都被考虑过一遍，我们就可以得到一种答案的组合。</p><p><strong>另一种思路</strong>是从<strong>答案的角度</strong>出发，依次考虑选择哪些数字，每做出一次选择本身就得到了一种答案。</p><p>而对于这种思路，当我们考虑过下标为i的数字选择后会从当前层向下递归产生分支；而在当前层，我们还会考虑下标大于i的数字，例如i+1对应的数字，选择它后又从当前层向下递归产生分支（记作分支1）；要避免后一条分支（记作分支2）与分支1重复。</p><p>即对于(1,2)的原始数组，第一层选择1后，产生分支1向下递归选择2，形成(1,2)；我们要避免第一层选择2后产生分支2向下递归形成(2,1)（这是重复的）</p><p><strong>规避重复</strong>的一种思路是，每层向下递归的时候 只能选择 下标 大于当前层已选数字下标 的数字 从而形成下面图片的效果：</p><p><img src="/../_images/Algorithm1/DFS1.png" alt="MyAlgorithm"></p><p><a href="!https://www.bilibili.com/video/BV1mG4y1A7Gu?spm_id_from=333.788.videopod.sections&vd_source=80df09f481ef5f0671e5e0e35d02e33e">参考视频教程</a></p><p>我们也可以将这两种思路概括为：</p><ol><li>选或者不选的思路</li><li>选哪个的思路<br>（这是常用的dfs思路，后续的组合、排列都会用到）</li></ol><h3 id="子集模板应用-分割回文串-leetcode-131"><a href="#子集模板应用-分割回文串-leetcode-131" class="headerlink" title="子集模板应用 分割回文串 leetcode 131"></a>子集模板应用 分割回文串 leetcode 131</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="title function_">check</span><span class="params">(<span class="built_in">string</span> s)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>,j = s.length()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(;i &lt; s.length() &amp;&amp; j &gt;= <span class="number">0</span>;i++,j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] != s[j])<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; ans;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; cmb, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == len<span class="number">-1</span>)&#123;<span class="comment">//当执行到应该判断最后一个位置是否要切割的时候</span></span><br><span class="line">            <span class="built_in">string</span> s = str.substr(j+<span class="number">1</span>,i-j);</span><br><span class="line">            <span class="keyword">if</span>(check(s))&#123;</span><br><span class="line">                cmb.push_back(s);</span><br><span class="line">                ans.push_back(cmb);</span><br><span class="line">                cmb.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> s = str.substr(j+<span class="number">1</span>,i-j);</span><br><span class="line">        <span class="keyword">if</span>(check(s))&#123;</span><br><span class="line">            cmb.push_back(s);</span><br><span class="line">            dfs(cmb, i+<span class="number">1</span>,i);</span><br><span class="line">            <span class="comment">//回溯</span></span><br><span class="line">            cmb.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dfs(cmb,i+<span class="number">1</span>,j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//切割是把当前位置的字符串和上一次切割位置后的字符串切出来</span></span><br><span class="line"><span class="comment">//i是当前考虑是否要切割的位置</span></span><br><span class="line"><span class="comment">//j是上一次进行切割的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; partition(<span class="built_in">string</span> s) &#123;</span><br><span class="line">        this-&gt;len = s.length();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; t;</span><br><span class="line">        this-&gt;str = s;</span><br><span class="line">        dfs(t, <span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这道题的思路是考虑所有可以切割子串的位置的状态，每个位置有两种状态，切或者不切；问题的状态就变成了一棵二叉树，DFS在树上做搜索，但是将一个位置设置为“切”的状态，需要判断得到的新子串是否是回文串，如果是才能切；最后一个位置必须切。</p><h3 id="组合模板-组合-leetcode-78"><a href="#组合模板-组合-leetcode-78" class="headerlink" title="组合模板 组合 leetcode 78"></a>组合模板 组合 leetcode 78</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="type">int</span> k,n;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> cnt,<span class="type">int</span> i,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; cmb)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt == k)&#123;</span><br><span class="line">            ans.push_back(cmb);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i+<span class="number">1</span>;j &lt;= n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cmb.push_back(j);</span><br><span class="line">            dfs(cnt+<span class="number">1</span>,j,cmb);</span><br><span class="line">            cmb.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; combine(<span class="type">int</span> n, <span class="type">int</span> k) &#123;</span><br><span class="line">        this-&gt;k = k;</span><br><span class="line">        this-&gt;n = n;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; t;</span><br><span class="line">        dfs(<span class="number">0</span>,<span class="number">0</span>,t);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面代码的实现思路是，在子集模板的第二种思路（站在答案的视角，考虑每个数字的选择）下加入一个已选择数字数量的判定，当选择的数字数量达到k个的时候就将答案记录下来，并停止向下递归。</p><h4 id="关于组合问题的剪枝"><a href="#关于组合问题的剪枝" class="headerlink" title="关于组合问题的剪枝"></a>关于组合问题的剪枝</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span>(n-i+cnt &lt; k)<span class="keyword">return</span>;<span class="comment">//剩下可选的数字+已经选择的数字 &lt; 需要选择的数字，可以直接return，因为最后必定没有结果（剪枝）</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在dfs的for循环之前加入这个判断，如果满足条件，最后一定无法选出指定数量的数字，也就没有继续递归的必要了，可以提前结束当前分支。</p><h3 id="组合模板应用-组合总和Ⅲ-leetcode-216"><a href="#组合模板应用-组合总和Ⅲ-leetcode-216" class="headerlink" title="组合模板应用 组合总和Ⅲ leetcode 216"></a>组合模板应用 组合总和Ⅲ leetcode 216</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> k,n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> cnt,<span class="type">int</span> i,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; cmb)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt == k &amp;&amp; accumulate(cmb.begin(),cmb.end(),<span class="number">0</span>) == n)&#123;</span><br><span class="line">            ans.push_back(cmb);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">9</span>-i+cnt &lt; k)<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i+<span class="number">1</span>;j &lt;= <span class="number">9</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cmb.push_back(j);</span><br><span class="line">            dfs(cnt+<span class="number">1</span>,j,cmb);</span><br><span class="line">            cmb.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; combinationSum3(<span class="type">int</span> k, <span class="type">int</span> n) &#123;</span><br><span class="line">        this-&gt;k = k;</span><br><span class="line">        this-&gt;n = n;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; t;</span><br><span class="line">        dfs(<span class="number">0</span>,<span class="number">0</span>,t);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="关于剪枝"><a href="#关于剪枝" class="headerlink" title="关于剪枝"></a>关于剪枝</h4><p>这道题除了和组合模板一样的剪枝，还有根据n进行的剪枝。主要是两种情况</p><ol><li>当前已经选择的数字数量不足k，但是其和已经大于n，最后递归下去其和必定大于n，剪枝</li><li>剩下的所有数字加上当前选择的所有数字 之和 小于n，最后递归下去其和必定小于n，剪枝</li></ol><p>为了方便剪枝的实现，可以选择维护一个当前已选数字之和的变量now_sum，具体实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> k,n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> cnt,<span class="type">int</span> i,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; cmb,<span class="type">int</span> now_sum)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt == k &amp;&amp; now_sum == n)&#123;</span><br><span class="line">            ans.push_back(cmb);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">9</span>-i+cnt &lt; k)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(now_sum &gt; n)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(now_sum+(i+<span class="number">10</span>)*(<span class="number">9</span>-i)/<span class="number">2</span> &lt; n)<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i+<span class="number">1</span>;j &lt;= <span class="number">9</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cmb.push_back(j);</span><br><span class="line">            dfs(cnt+<span class="number">1</span>,j,cmb,now_sum+j);</span><br><span class="line">            cmb.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; combinationSum3(<span class="type">int</span> k, <span class="type">int</span> n) &#123;</span><br><span class="line">        this-&gt;k = k;</span><br><span class="line">        this-&gt;n = n;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; t;</span><br><span class="line">        dfs(<span class="number">0</span>,<span class="number">0</span>,t,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>一个总结：组合模板上的剪枝是围绕要选择k个数字进行的，这一题又有了新的要求即k个数字的和要为n。这些要求都可以看作问题的约束，也就是说我们这两道题的剪枝都是围绕问题的约束展开的。所以以后在思考递归的剪枝的时候，可以考虑<strong>问题状态树上，从当前递归层的状态出发，判断之后的状态是否可以满足最终问题的各个约束，如果不能满足，那么就停止向下递归。</strong></p><p>而我们之所以能做出这样判断的原因，是因为问题状态具有的一些性质在转移的过程中如何发展是可以推知的。<em>就像这道题，一共9个数，你每次只选比上一次选择的数字更大的数字，当你选择了i，接下来你可以选择的数字个数一定是9-i</em>，这就是可以推知的状态。</p><h3 id="组合模板应用-括号生成-leetcode-22"><a href="#组合模板应用-括号生成-leetcode-22" class="headerlink" title="组合模板应用 括号生成 leetcode 22"></a>组合模板应用 括号生成 leetcode 22</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> nl,<span class="type">int</span> nr,<span class="built_in">string</span>&amp; str)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nl + nr == (n&lt;&lt;<span class="number">1</span>))&#123;</span><br><span class="line">            ans.push_back(str);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nl &lt; nr)<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nl &lt; n)&#123;</span><br><span class="line">            str += <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">            dfs(nl+<span class="number">1</span>,nr,str);</span><br><span class="line">            str.erase(str.end()<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nr &lt; n)&#123;</span><br><span class="line">            str += <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">            dfs(nl,nr+<span class="number">1</span>,str);</span><br><span class="line">            str.erase(str.end()<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title function_">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        this-&gt;n = n;</span><br><span class="line">        <span class="built_in">string</span> str;</span><br><span class="line">        dfs(<span class="number">0</span>,<span class="number">0</span>,str);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我解决这道题的思考过程：</p><ol><li>基本方法是套用子集模板，我们一共有n个左括号、n个右括号可以用，需要选择2n个括号，根据选择的顺序形成str，直接dfs到底，然后判断括号是否有效</li><li>考虑剪枝，约束是括号有效，考虑是否存在一些选择情况对应的状态已经无效，并且之后的状态也一定无效。存在这样的选择情况，那就是右括号比左括号先选择。只要有这种情况出现就可以剪枝</li></ol><p>关于实现</p><ol><li>剪枝的实现是可以维护nl、nr来记录已经选择的左右括号的数量，一旦nl小于nr就剪枝。</li><li>并且我注意到，递归的结束条件可以用nl+nr &#x3D;&#x3D; 2*n来实现；且只要nl始终大于等于nr，左括号一定可以被右括号抵消，最终的情况一定有效，也就不需要递归结束时的有效判断了</li><li>结合1、2两点，套用dfs的模板就可以解决问题</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> nl,<span class="type">int</span> nr,<span class="built_in">string</span>&amp; str)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nl + nr == (n&lt;&lt;<span class="number">1</span>))&#123;</span><br><span class="line">            ans.push_back(str);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nl &lt; nr)<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nl &lt; n)&#123;</span><br><span class="line">            str += <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">            dfs(nl+<span class="number">1</span>,nr,str);</span><br><span class="line">            str.erase(str.end()<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nr &lt; n)&#123;</span><br><span class="line">            str += <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">            dfs(nl,nr+<span class="number">1</span>,str);</span><br><span class="line">            str.erase(str.end()<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title function_">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        this-&gt;n = n;</span><br><span class="line">        <span class="built_in">string</span> str;</span><br><span class="line">        dfs(<span class="number">0</span>,<span class="number">0</span>,str);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="全排列模板-全排列-leetcode-46"><a href="#全排列模板-全排列-leetcode-46" class="headerlink" title="全排列模板 全排列 leetcode 46"></a>全排列模板 全排列 leetcode 46</h3><p>模板的思路基础是<strong>子集模板的第二种思路</strong>，在子集模板中，我们为了避免重复的选择，规定在选择第i个数字之后 产生的递归分支上，只能选择第i+1及以后的数字；而全排列不需要避免这种重复的选择，或者说<strong>这种重复的选择对全排列而言正是必要的</strong>，因为对于排列而言，选择的顺序不同 但 含有的元素相同 的子集是不同的。</p><p>于是问题的关键在于，每个分支如何知道自己当前可以选择哪些数字。</p><p>我的思路是用一个vis数组来记录当前分支的<strong>父状态</strong>选择过的数字，这些数字是不能选的。而其它分支选择过的数字，自己的父状态没有选择过的数字，这些分支是可以选择的。</p><p>按照这个思路实现的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; vis;</span><br><span class="line">    </span><br><span class="line">    <span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; cmb)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == len)&#123;</span><br><span class="line">            ans.push_back(cmb);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                cmb.push_back(nums[i]); vis[i] = <span class="number">1</span>;</span><br><span class="line">                dfs(n+<span class="number">1</span>,cmb);</span><br><span class="line">                cmb.pop_back(); vis[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; permute(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        this-&gt;len = nums.size();</span><br><span class="line">        this-&gt;nums = nums;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; len;i++)</span><br><span class="line">            vis.push_back(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; cmb;</span><br><span class="line">        dfs(<span class="number">0</span>,cmb);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>参考教程的思路是<strong>维护一个可选数字</strong>的集合，这个集合可以起到取代我上面的vis数组的作用。并且这样显然好一些，因为使用vis数组，状态树上的每一个结点都会检查初始nums中的所有数组，虽然当不满足条件的时候，不会向下产生分支，但是在当前层的循环中枚举了很多不必要的情况。</p><p>我按照这个思路写的代码如下，但是使用到了vector的插入和删除操作，频繁的这样操作，或许增加的时间复杂度不会比我开始使用的vis好到哪里去？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; cmb,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty())&#123;</span><br><span class="line">            ans.push_back(cmb);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> t = nums[i];</span><br><span class="line">            cmb.push_back(t); nums.erase(nums.begin()+i);</span><br><span class="line">            dfs(cmb,nums);</span><br><span class="line">            cmb.pop_back(); nums.insert(nums.begin()+i,t);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; permute(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; cmb;</span><br><span class="line">        dfs(cmb,nums);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>实际上两种思路都是常见的做法，我的第一种思路在参考的教程中后面也提到了。</p><p><a href="!https://www.bilibili.com/video/BV1mY411D7f6?spm_id_from=333.788.videopod.sections&vd_source=80df09f481ef5f0671e5e0e35d02e33e">参考教程</a></p><h3 id="DFS与回溯综合练习-n皇后"><a href="#DFS与回溯综合练习-n皇后" class="headerlink" title="DFS与回溯综合练习 n皇后"></a>DFS与回溯综合练习 n皇后</h3><p>我的基本思路是用dfs枚举每个位置放置皇后的情况，每个位置可以放、可以不放；当一个位置放置后，该位置对应的行、列、两个对角线 不能再放置；维护一个vis二维数组来判断各个位置是否可以放置皇后。</p><p>实现代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; vis;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; ans;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> num,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; cmb,<span class="type">int</span> posx,<span class="type">int</span> posy,<span class="type">int</span> cnt)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num == n)&#123;</span><br><span class="line">            ans.push_back(cmb);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(cnt &lt; n-num)<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = posx;i &lt; n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = posy;j &lt; n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(vis[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">                    cmb[i][j] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//ban</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>;k &lt; n;k++)</span><br><span class="line">                        vis[i][k]++,vis[k][j]++;</span><br><span class="line">                    vis[i][j]--;<span class="comment">//重复ban了一次</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> ki = i+<span class="number">1</span>,kj = j+<span class="number">1</span>;ki &lt; n&amp;&amp;kj &lt; n;ki++,kj++)</span><br><span class="line">                        vis[ki][kj]++;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> ki = i<span class="number">-1</span>,kj = j<span class="number">-1</span>;ki &gt;= <span class="number">0</span>&amp;&amp;kj &gt;= <span class="number">0</span>;ki--,kj--)</span><br><span class="line">                        vis[ki][kj]++;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> ki = i+<span class="number">1</span>,kj = j<span class="number">-1</span>;ki &lt; n&amp;&amp;kj &gt;= <span class="number">0</span>;ki++,kj--)</span><br><span class="line">                        vis[ki][kj]++;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> ki = i<span class="number">-1</span>,kj = j+<span class="number">1</span>;ki &gt;= <span class="number">0</span>&amp;&amp;kj &lt; n;ki--,kj++)</span><br><span class="line">                        vis[ki][kj]++;</span><br><span class="line">                    </span><br><span class="line">                    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> ki = <span class="number">0</span>;ki &lt; n;ki++)</span><br><span class="line">                        <span class="keyword">for</span>(<span class="type">int</span> kj = <span class="number">0</span>;kj &lt; n;kj++)</span><br><span class="line">                            <span class="keyword">if</span>(vis[ki][kj] == <span class="number">0</span>)sum++;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>(posy &lt; n)</span><br><span class="line">                        dfs(num+<span class="number">1</span>,cmb,posx,posy+<span class="number">1</span>,sum);</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(posy == n<span class="number">-1</span>)</span><br><span class="line">                        dfs(num+<span class="number">1</span>,cmb,posx+<span class="number">1</span>,<span class="number">0</span>,sum);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//recover，这样写可能会错误的恢复已经被其它皇后ban掉的位置，将修改为1改做++</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>;k &lt; n;k++)</span><br><span class="line">                        vis[i][k]--,vis[k][j]--;</span><br><span class="line">                    vis[i][j]++;<span class="comment">//重复recover了一次</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> ki = i+<span class="number">1</span>,kj = j+<span class="number">1</span>;ki &lt; n&amp;&amp;kj &lt; n;ki++,kj++)</span><br><span class="line">                        vis[ki][kj]--;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> ki = i<span class="number">-1</span>,kj = j<span class="number">-1</span>;ki &gt;= <span class="number">0</span>&amp;&amp;kj &gt;= <span class="number">0</span>;ki--,kj--)</span><br><span class="line">                        vis[ki][kj]--;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> ki = i+<span class="number">1</span>,kj = j<span class="number">-1</span>;ki &lt; n&amp;&amp;kj &gt;= <span class="number">0</span>;ki++,kj--)</span><br><span class="line">                        vis[ki][kj]--;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> ki = i<span class="number">-1</span>,kj = j+<span class="number">1</span>;ki &gt;= <span class="number">0</span>&amp;&amp;kj &lt; n;ki--,kj++)</span><br><span class="line">                        vis[ki][kj]--;</span><br><span class="line">                    cmb[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">                </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; solveNQueens(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; t;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; n;j++)</span><br><span class="line">                t.push_back(<span class="number">0</span>);</span><br><span class="line">            vis.push_back(t);</span><br><span class="line">        &#125;   </span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; cmb;</span><br><span class="line">        <span class="built_in">string</span> str;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">            str+=<span class="string">&quot;.&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">            cmb.push_back(str);</span><br><span class="line">        this-&gt;n = n;</span><br><span class="line">        dfs(<span class="number">0</span>,cmb,<span class="number">0</span>,<span class="number">0</span>,n*n);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>记录几个出现的问题：</p><ol><li>开始的时候我标记位置是否能放，能放是将vis[i][j]置为1，能放是将这个元素置为0。这样做的问题在于：一个皇后恢复现场的时候，可能把其它皇后置为不能放置的位置给恢复成能放了； <strong>解决的方法</strong>是，可以放置设置为0，每放一个皇后对应不能放置的位置+1，恢复的时候-1即可，这样每个皇后对现场的操作都被保存了下来作为是否能放的参照</li><li>开始的时候我写dfs中的for循环，每一层都是从i&#x3D;0，j&#x3D;0开始枚举的，这样的话每一层都会重复考虑之前已经考虑过的位置，这是错误的。<strong>解决的方法</strong>是记录好当前位置的下标，进入下一层递归的时候设置下一次开始遍历的初始位置是当前位置的下一个位置</li><li>解决1、2两个问题之后，代码的正确性已经得到保证了，但是现在的问题是时间复杂度太高了…，当n&#x3D;&#x3D;9的时候会TLE</li></ol><h3 id="全排列模板-n皇后"><a href="#全排列模板-n皇后" class="headerlink" title="全排列模板 n皇后"></a>全排列模板 n皇后</h3><p>对于上述dfs枚举每个格子的<strong>改进的方法</strong>，涉及n皇后的一个性质，那就是<strong>每一行、每一列一定有一个皇后</strong>。</p><p>这个性质不难证明，假设有一行没有皇后，那么剩下n-1行要放n个皇后，肯定有一行有两个皇后，与条件矛盾；列是同理的</p><p>于是我们可以考虑使用一个数组col[i]来表示第i行在哪一列放置了Q，即在第col[i]列放置了Q，<strong>理解这个数组很关键！</strong></p><p>于是，我们最终放置好的棋盘就可以单纯用col数组来表示。并且满足条件的情况下，其中一定有4个元素。</p><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">col[<span class="number">4</span>] = &#123;<span class="number">1</span>，<span class="number">3</span>，<span class="number">0</span>，<span class="number">2</span>&#125;<span class="comment">//n==4的一种放置方案</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们现在可以把问题变成：我们要在数字0<del>n-1中，选出一种k&#x3D;n个数字的排列。由于一共就0</del>n-1个数字，所以得到排列还原回棋盘上的情况，意味着<strong>列一定不会冲突</strong>；而我们按照行来进行枚举，那么<strong>行也一定不会冲突</strong>；再者，在dfs的时候我们是从行0，枚举到行n-1，那么<strong>左下、右下的对角线一定不会冲突</strong></p><p>于是问题就变成了全排列模板上的变式，改变了的点是：</p><ol><li>在完成排列，退出递归的时候，我们要把得到的col数组还原回字符串向量（题意中用于表示棋盘），这是一个简单的模拟问题</li><li>在挑选加入排列的数字的时候，我们要进行check，考虑当前选择的数字，对应放置到棋盘上的Q，其左上、右上是否已经有Q了，如果有了就不能放置，也就是不能选择这个数字；否则可以选择</li></ol><p>具体的代码实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; ans;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//x是当前处理的行号，y是当前选择的数字，即x行希望放置Q的列号</span></span><br><span class="line">    <span class="type">bool</span> <span class="title function_">check</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp;col, <span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">        <span class="comment">//只需要检查左上和右上有没有皇后，因为按行递归，下面的行必定还没放置Q</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = x<span class="number">-1</span>,j1 = y<span class="number">-1</span>,j2 = y+<span class="number">1</span>;i &gt;= <span class="number">0</span>;i--,j1--,j2++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(col[i] == j1 || col[i] == j2)<span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; col, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(col.size() == n)&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; cmb;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">                <span class="built_in">string</span> str;</span><br><span class="line">                str.clear();</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; n;j++)</span><br><span class="line">                    <span class="keyword">if</span>(j == col[i])str+=<span class="string">&quot;Q&quot;</span>;</span><br><span class="line">                    <span class="keyword">else</span> str+=<span class="string">&quot;.&quot;</span>;</span><br><span class="line">                cmb.push_back(str);</span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(cmb);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; nums.size();j++)<span class="comment">//全排列的模板，nums中存有待选数字</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(check(col, col.size(), nums[j]))&#123;</span><br><span class="line">                <span class="type">int</span> t = nums[j];</span><br><span class="line">                col.push_back(nums[j]); nums.erase(nums.begin()+j);</span><br><span class="line">                dfs(col, nums);</span><br><span class="line">                col.pop_back(); nums.insert(nums.begin()+j,t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; solveNQueens(<span class="type">int</span> n) &#123;</span><br><span class="line">        this-&gt;n = n;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)nums.push_back(i);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; col;</span><br><span class="line">        dfs(col,nums);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>实际上check函数可以再利用棋盘上的一个性质，那就是从(i,j)出发，对于任意右上的位置(k,l)，i+j &#x3D;&#x3D; k+l恒成立；对于任意左上的位置(k,l)，i-j &#x3D;&#x3D; k-l恒成立。</p><p>于是可以这样写</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">check</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; col, <span class="type">int</span> x,<span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = x<span class="number">-1</span>;i &gt;= <span class="number">0</span>;i--)</span><br><span class="line">        <span class="keyword">if</span>(x+y == i+col[i] || x-y == i-col[i])<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>进一步优化对角线是否合法的检查，如果可以用i+j以及i-j来判断，那么我们不如直接使用两个bool数组，分别对应左上、右上；对于左上要使用i-j+n-1（避免索引出现负数），右上的索引可以直接使用i+j</p><p>这样check的O(n)就变成了O(1)，这是一种常见的哈希表优化的思想。</p><p>优化后的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; ans;</span><br><span class="line">    <span class="type">bool</span> diag1[<span class="number">20</span>];</span><br><span class="line">    <span class="type">bool</span> diag2[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// //x是当前处理的行号，y是当前选择的数字，即x行希望放置Q的列号</span></span><br><span class="line">    <span class="comment">// bool check(vector&lt;int&gt;&amp;col, int x,int y)&#123;</span></span><br><span class="line">    <span class="comment">//     //只需要检查左上和右上有没有皇后，因为按行递归，下面的行必定还没放置Q</span></span><br><span class="line">    <span class="comment">//     for(int i = x-1,j1 = y-1,j2 = y+1;i &gt;= 0;i--,j1--,j2++)&#123;</span></span><br><span class="line">    <span class="comment">//        if(col[i] == j1 || col[i] == j2)return false; </span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     return true;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; col, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(col.size() == n)&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; cmb;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">                <span class="built_in">string</span> str;</span><br><span class="line">                str.clear();</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; n;j++)</span><br><span class="line">                    <span class="keyword">if</span>(j == col[i])str+=<span class="string">&quot;Q&quot;</span>;</span><br><span class="line">                    <span class="keyword">else</span> str+=<span class="string">&quot;.&quot;</span>;</span><br><span class="line">                cmb.push_back(str);</span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(cmb);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; nums.size();j++)<span class="comment">//全排列的模板，nums中存有待选数字</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(diag1[nums[j]+col.size()] &amp;&amp; diag2[nums[j]-col.size()+n<span class="number">-1</span>])&#123;</span><br><span class="line">                <span class="type">int</span> t = nums[j];</span><br><span class="line">                diag1[nums[j]+col.size()] = <span class="literal">false</span>;diag2[nums[j]-col.size()+n<span class="number">-1</span>] = <span class="literal">false</span>;</span><br><span class="line">                col.push_back(nums[j]); nums.erase(nums.begin()+j);</span><br><span class="line">                dfs(col, nums);</span><br><span class="line">                col.pop_back(); nums.insert(nums.begin()+j,t);</span><br><span class="line">                diag1[nums[j]+col.size()] = <span class="literal">true</span>;diag2[nums[j]-col.size()+n<span class="number">-1</span>] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; solveNQueens(<span class="type">int</span> n) &#123;</span><br><span class="line">        this-&gt;n = n;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)nums.push_back(i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">20</span>;i++)diag1[i] = <span class="literal">true</span>,diag2[i] = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; col;</span><br><span class="line">        dfs(col,nums);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="DFS与记忆化"><a href="#DFS与记忆化" class="headerlink" title="DFS与记忆化"></a>DFS与记忆化</h2><h3 id="打家劫舍-leetcode-198"><a href="#打家劫舍-leetcode-198" class="headerlink" title="打家劫舍 leetcode 198"></a>打家劫舍 leetcode 198</h3><h4 id="打家劫舍-基础递归"><a href="#打家劫舍-基础递归" class="headerlink" title="打家劫舍 基础递归"></a>打家劫舍 基础递归</h4><p>这道题可以使用选或不选的递归思路，从后向前考虑。如果第i个房间选择了，那么第i-1个就不能选，紧接着从第i-2个继续考虑；如果第i个房间不选，紧接着从第i-1个继续考虑；于是很自然的就可以画出问题的状态树是怎样的，在此之上进行递归。</p><p>而我们的目标是最终的结果最大，所以考虑的时候应该是dfs(i) &#x3D; max(dfs(i-1),dfs(i-2)+nums[i])</p><p>在上面的思路上有了第一版代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> num)</span>&#123;<span class="comment">//从后向前考虑，i表示当前考虑的房间</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span>) <span class="keyword">return</span> num;</span><br><span class="line">        <span class="keyword">return</span> max(dfs(i<span class="number">-1</span>,num),dfs(i<span class="number">-2</span>,num+nums[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums)</span> &#123;</span><br><span class="line">        this-&gt;nums = nums;</span><br><span class="line">        <span class="keyword">return</span> dfs(nums.size()<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="打家劫舍-递归-记忆化-记忆化搜索"><a href="#打家劫舍-递归-记忆化-记忆化搜索" class="headerlink" title="打家劫舍 递归+记忆化&#x3D;记忆化搜索"></a>打家劫舍 递归+记忆化&#x3D;记忆化搜索</h4><p>遗憾的是，每层递归几乎都会展开两层，时间复杂度为$O(2^n)$，会TLE</p><p>我们可以注意到，在问题的状态树中，存在这样的结构：</p><p><img src="/../_images/Algorithm1/DFS2.png" alt="状态树"></p><p><a href="!https://www.bilibili.com/video/BV1Xj411K7oF?spm_id_from=333.788.videopod.sections&vd_source=80df09f481ef5f0671e5e0e35d02e33e">参考资料</a></p><p>这意味着我们进行了重复计算（<strong>通过观察状态树的分支情况，是我们判断是否可以进行记忆化处理的一种标注</strong>）</p><p>优化后的状态树是这样的，每层递归的小分支可以忽略不记，时间复杂度直接变成了O(n)<br><img src="/../_images/Algorithm1/DFS3.png" alt="优化后的状态树"></p><p>具体的优化方法是，我们可以使用一个数组或者一个哈希表，来保存在某分支上第一次计算dfs(i)的结果，然后在其它分支要计算dfs(i)的时候，先检查是否已经计算过了，如果计算过了可以直接调用。</p><p>我写的初版记忆化代码是这样的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cnt[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> num)</span>&#123;<span class="comment">//从后向前考虑，i表示当前考虑的房间</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span>) <span class="keyword">return</span> num;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(cnt[i] != <span class="number">-1</span>)<span class="keyword">return</span> cnt[i];</span><br><span class="line">        <span class="type">int</span> res = max(dfs(i<span class="number">-1</span>,num),dfs(i<span class="number">-2</span>,num+nums[i]));</span><br><span class="line">        cnt[i] = res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums)</span> &#123;</span><br><span class="line">        this-&gt;nums = nums;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">100</span>;i++)cnt[i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> dfs(nums.size()<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但是得出的结果是错误的。一个重要的原因是<strong>记忆化的依据是问题的状态</strong>，我们要把一个状态的结果保存下来，就像我们开始说的，要把dfs(i)的计算结果保存下来，这里的i就可以看作一个<strong>状态变量</strong>，来对一层递归进行唯一的标定。</p><p>而我代码中将累加变量num，当作参数来处理，num也变成了一个状态变量，而且它的值通常是难以估计的（随着测试输入的值有着巨大的变化），如果硬要考虑num也是一个状态，可以使用二维数组来存储记忆的结果，但是这会让空间开销变得很大（甚至超范围）。</p><p><strong>累加变量本身是可以作返回值处理的</strong>，不用当作参数跟着传递，修改的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cnt[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i)</span>&#123;<span class="comment">//从后向前考虑，i表示当前考虑的房间</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(cnt[i] != <span class="number">-1</span>)<span class="keyword">return</span> cnt[i];</span><br><span class="line">        <span class="type">int</span> res = max(dfs(i<span class="number">-1</span>),dfs(i<span class="number">-2</span>)+nums[i]);</span><br><span class="line">        cnt[i] = res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums)</span> &#123;</span><br><span class="line">        this-&gt;nums = nums;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">100</span>;i++)cnt[i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> dfs(nums.size()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>简单总结一下，一般情况下我习惯将dfs的累加变量当作参数处理，尤其是在退出的时候，使用最后累积的参数来更新我的答案；但是如果要实现记忆化，通常这种累积的参数应该通过返回值来进行处理，即存在明显的递归中“归”这一操作；而当累加变量当作参数处理的时候，实际上我的dfs返回通常是void，没有下层向上层的反馈，只有递归到边界的时候对全局变量的操作，所以没有“归”这一操作</p><h4 id="打家劫舍-自顶向下的记忆化搜索-自下向上-DP"><a href="#打家劫舍-自顶向下的记忆化搜索-自下向上-DP" class="headerlink" title="打家劫舍 自顶向下的记忆化搜索-&gt;自下向上 &#x3D; DP"></a>打家劫舍 自顶向下的记忆化搜索-&gt;自下向上 &#x3D; DP</h4><p>我们可以进一步观察状态树</p><p><img src="/../_images/Algorithm1/DFS4.png" alt="优化后的状态树"></p><p>从状态树来看，自上向下计算的过程中，我们总是在较上层提前计算了dfs(i)的结果 并存储起来 留给下层又遇到dfs(i)的时候使用的。</p><p>例如，在上面的状态树中，2、1、0这些右侧的分支点，是第一次调用dfs(2),dfs(1),dfs(0)的点，然后再左侧又遇到dfs(2),dfs(1),dfs(0)的时候是直接使用 较上层的 右侧分支点 第一次计算时保存的结果。</p><p>现在我们希望不保存这些结果，将空间复杂度从O(n)优化到O(1)，该如何做？</p><p>答案很显然了，我们可以自下向上计算状态结点上的值，只使用临时变量存储必要的值，并不断更新这些临时变量。站在记忆化的角度理解就是，我们是有保存dfs(i)的结果，但是没有保存全部结果，我们只存储了O(1)个对之后计算有需要的结果，并抛弃了不需要的结果；从临时变量来看，我们就是不断地用之后的计算需要的结果存入临时变量，覆盖掉了不再需要的结果。</p><p>从状态树上来看，我们计算dfs(2)的时候需要dfs(1),dfs(0)，计算dfs(3)的时候需要dfs(2),dfs(1)但不再需要dfs(0)，计算dfs(4)的时候需要dfs(3),dfs(2)，但不再需要dfs(1),dfs(0)。由此可以看出，计算dfs(i)的时候，实际需要的是dfs(i-1),dfs(i-2)</p><p>于是我们将dfs改记作dp，于是我们有了递推公式dp(i) &#x3D; max(dp(i-1),dp(i-2)+nums[i])；再结合边界条件dp(0) &#x3D; nums[0]，dp(1) &#x3D; max(nums[0],nums[1])，就可以开始递推填表了，这就是动态规划。</p><p>当然仅仅这样的自下向上，我们还没有完成空间复杂度的优化，因为我们使用了O(n)的递推数组。完全的优化是只使用O(1)的临时变量递推，这类似于我们在1维的dp数组上滚动处理，同样也类似于背包问题中，把二维的表格优化为一维的滚动数组（$O(n^2)$到O(n)的空间复杂度优化）。</p><p>在一维数组上的滚动处理，我们只需要3个临时变量f1、f2、f3。</p><ol><li>f1 &#x3D; nums[0], f2 &#x3D; max(nums[1], nums[0]) 状态0、状态1</li><li>f3 &#x3D; max(f2,f1+nums[2]) 状态2 &#x3D; max(状态1,状态0+nums[2])</li><li>f1 &#x3D; max(f3,f2+nums[3]) 状态3 &#x3D; max(状态2,状态1+nums[3])</li><li>f2 &#x3D; max(f1,f3+nums[4])</li></ol><p>最终结果就在f2中，上面的f1、f2、f3再反复使用的时候被赋予了不同状态的值，要注意区别。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() == <span class="number">1</span>)<span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums.size() == <span class="number">2</span>)<span class="keyword">return</span> max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> f[<span class="number">3</span>] = &#123;nums[<span class="number">0</span>],max(nums[<span class="number">1</span>],nums[<span class="number">0</span>]),<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt; nums.size();i++)</span><br><span class="line">            f[i%<span class="number">3</span>] = max(f[(i<span class="number">-1</span>)%<span class="number">3</span>],f[(i<span class="number">-2</span>)%<span class="number">3</span>]+nums[i]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> f[(nums.size()<span class="number">-1</span>)%<span class="number">3</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意：</p><ol><li>f是用来存储dfs的结果的，初始化要存储dfs(0)和dfs(1)，而dfs(1)并不是nums[1]，而是max(nums[1],nums[0])，我开始犯了这个错误</li><li>通过取模来实现三个临时变量不断互换位置更新的操作的这种实现方法需要留意，多多测试，想清楚怎么变化的，也是一种套路</li></ol><p>关于注意的第二点，也可以枚举nums中的数字，然后使用一种易读性更强的写法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> new_f,f0 = nums[<span class="number">0</span>],f1 = max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt; nums.size();i++)</span><br><span class="line">&#123;</span><br><span class="line">    new_f = max(f1,f0+nums[i]);</span><br><span class="line">    f0 = f1;</span><br><span class="line">    f1 = new_f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图的数据结构与算法</title>
      <link href="/2025/08/30/%E5%9B%BE%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
      <url>/2025/08/30/%E5%9B%BE%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p><code>这篇blog用来整理图有关的数据结构与算法的知识</code></p><h2 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h2><h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><p>邻接矩阵本质上就是一个二维数组，分为两种情况</p><ol><li>无权图，m[i][j] &#x3D;&#x3D; 1代表vi有到vj的边；否则为0，代表不存在这样的边</li><li>有权图，元素为inf代表两点间不存在边，否则存在，且对应元素值为权重</li></ol><p>从数据结构上来说，有向无向图没有区别，都是二维数组，且均适用于上面描述的两种情况。只是无向图有m[i][j] &#x3D;&#x3D; m[j][i]恒成立的性质</p><h3 id="链式前向星"><a href="#链式前向星" class="headerlink" title="链式前向星"></a>链式前向星</h3><p>本质上是数组实现的静态邻接表</p><p>掌握的关键在于记住三个点</p><ol><li>使用到的数据结构即其含义</li><li>初始化的方式</li><li>加边的方式</li></ol><p><em>下面分别进行描述</em>：</p><p>数据结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> head[]<span class="comment">//一维数组，head[i]代表 vi 的最后一条边在edge中的索引 起一个指针的作用</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> to;<span class="comment">//当前边指向的结点编号 对应可以用作head的索引 兼具标识结点编号和类似指针的两重作用</span></span><br><span class="line">    <span class="type">int</span> next;<span class="comment">//同一结点 当前边的 上一条边在edge中的索引 起一个指针的作用</span></span><br><span class="line">    <span class="type">int</span> w;<span class="comment">//当前边的权重</span></span><br><span class="line">&#125;edge[]<span class="comment">//一维数组，表示一条边</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这种数据结构的特点是，边本身是没有编号的；也不像邻接矩阵那样，可以直观的知道某条边介于哪两点之间。但是通过遍历点来遍历边，是能够得到这些信息的。</p><p>初始化与加边的方式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> maxmn;</span><br><span class="line"><span class="type">int</span> m,n,cnt;</span><br><span class="line"><span class="type">int</span> head[maxmn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> to,next,w;</span><br><span class="line">&#125;edge[maxmn];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ini</span><span class="params">()</span>&#123;</span><br><span class="line">    cnt = <span class="number">0</span>;<span class="comment">//注意cnt用于全局管理边的索引，初始化为0</span></span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)head[i] = <span class="number">-1</span>;<span class="comment">//结点初始时都没有指向任何边 代表边索引的值初始化为-1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> from,to,w;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;from&gt;&gt;to&gt;&gt;w;</span><br><span class="line">        add_edge(from,to,w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">add_edge</span><span class="params">(<span class="type">int</span> from,<span class="type">int</span> to,<span class="type">int</span> w)</span>&#123;</span><br><span class="line">    edge[cnt].to = to;</span><br><span class="line">    edge[cnt].w = w;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这三行是理解加边操作的关键</span></span><br><span class="line">    edge[cnt].next = head[from];<span class="comment">//让新加的边指向 结点的上一条边</span></span><br><span class="line">    head[from] = cnt;<span class="comment">//让结点指向 新加的边</span></span><br><span class="line">    cnt++;<span class="comment">//全局管理边的索引</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="链式前向星的遍历"><a href="#链式前向星的遍历" class="headerlink" title="链式前向星的遍历"></a>链式前向星的遍历</h4><p>前面提到了这种存图方法在以点为基础，进行遍历的时候，是可以遍历所有的边，并得到边的完整信息（起点、终点、权重）的。下面进行展示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    ini();<span class="comment">//参考前面的代码，假设我们初始化好了一个链式前向星存储的图</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = head[i];j != <span class="number">-1</span>;j = edge[j].next)<span class="comment">//当j==-1成立时，对应遍历完了点v的所有边 前面初始化为-1的作为边界条件的作用 就是类似使用的</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;当前边在edge中的索引：&quot;</span>:j&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;from:&quot;</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;to:&quot;</span>&lt;&lt;edge[j].to&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;w:&quot;</span>&lt;&lt;edge[j].w&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//注意j的更新操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，我认为<strong>数据结构的含义是记忆的重点，记住之后其它操作根据理解是可以写出的</strong>。</p><h2 id="图上的DFS（判断两个点是否连通）"><a href="#图上的DFS（判断两个点是否连通）" class="headerlink" title="图上的DFS（判断两个点是否连通）"></a>图上的DFS（判断两个点是否连通）</h2><p>这里使用链式前向星实现，目的是对于输入的两个点u、v，判断是否连通（从一个点可以到达令一个点）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> maxmn = <span class="number">10000</span>;</span><br><span class="line"><span class="type">int</span> n,m,cnt = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> head[maxmn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> to,next,w;</span><br><span class="line">&#125;edge[maxmn];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ini_graph</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">        head[i] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        add_edge(u,v,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">add_edge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span>&#123;</span><br><span class="line">    edge[cnt].to = v;</span><br><span class="line">    edge[cnt].w = <span class="number">1</span>;</span><br><span class="line">    edge[cnt].next = head[u];</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> u,v;<span class="comment">//需要判断是否连通的两点</span></span><br><span class="line"><span class="type">bool</span> flag = <span class="literal">false</span>;<span class="comment">//结果标志</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>* vis, <span class="type">int</span> now_pos)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(flag) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历当前点的边，对每一条可行的边进行递归，实现dfs</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = head[now_pos];i != <span class="number">-1</span>;i = edge[i].next)&#123;</span><br><span class="line">        <span class="comment">//判断是否到达目标结点</span></span><br><span class="line">        <span class="keyword">if</span>(edge[i].to == v)&#123;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(vis[edge[i].to] == <span class="number">0</span>)&#123;</span><br><span class="line">            vis[edge[i].to] = <span class="number">1</span>;</span><br><span class="line">            dfs(vis, edge[i].to);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">solve</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> vis[maxmn];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)vis[i] = <span class="number">0</span>;<span class="comment">//初始化一个标记访问的数组</span></span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v;</span><br><span class="line">    vis[u] = <span class="number">1</span>;<span class="comment">//注意标记初始点已经被访问（来自chatgpt的纠错）</span></span><br><span class="line">    dfs(vis, u);</span><br><span class="line">    <span class="keyword">if</span>(flag)<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;u可达于v&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;不可达！&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    ini_graph();</span><br><span class="line">    solve();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h2><h2 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h2>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杂七杂八的小算法</title>
      <link href="/2025/08/29/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E7%9A%84%E5%B0%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2025/08/29/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E7%9A%84%E5%B0%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p><code>在平常练习算法题的过程中，有的题目常常涉及到使用一些基本的小算法作为整个解决方案中的一部分，例如gcd、进制转换，乃至KMP等等，我用这篇blog对这些小算法。我在这篇blog中对它们做一个综合的整理。</code></p><h2 id="gcd"><a href="#gcd" class="headerlink" title="gcd"></a>gcd</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(x%y == <span class="number">0</span>)<span class="keyword">return</span> y;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">return</span> gcd(y,x%y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>辗转相除法求最大公约数</p><h2 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h2><h2 id="lcm"><a href="#lcm" class="headerlink" title="lcm"></a>lcm</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">lcm</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> x*y/gcd(x,y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用最大公约数求最小公倍数</p><h2 id="Fibonacci"><a href="#Fibonacci" class="headerlink" title="Fibonacci"></a>Fibonacci</h2><p>这一部分从Fibonacci数列的计算出发，使用递归&amp;递归+记忆化的方式实现。</p><p>目的是展示递归改记忆化递归的基本思想。</p><h2 id="string数字转换为int数字"><a href="#string数字转换为int数字" class="headerlink" title="string数字转换为int数字"></a>string数字转换为int数字</h2>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法题常用库中的工具</title>
      <link href="/2025/08/29/%E7%AE%97%E6%B3%95%E9%A2%98%E5%B8%B8%E7%94%A8%E5%BA%93%E4%B8%AD%E7%9A%84%E5%B7%A5%E5%85%B7/"/>
      <url>/2025/08/29/%E7%AE%97%E6%B3%95%E9%A2%98%E5%B8%B8%E7%94%A8%E5%BA%93%E4%B8%AD%E7%9A%84%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<p><code>在过去的算法竞赛中，我常常接触到一些库中的工具，例如函数、容器、类等等，但是总是零零散散的，记忆也不是很牢，每次都是用到了现查。于是我用这篇blog做一个简单的整理</code></p><h2 id="头文件algorithm"><a href="#头文件algorithm" class="headerlink" title="头文件algorithm"></a>头文件algorithm</h2><h3 id="max-函数"><a href="#max-函数" class="headerlink" title="max()函数"></a>max()函数</h3><p>在 C++ 中，max 函数是一个非常实用的函数，用于比较两个或更多数值并返回其中的最大值。这个函数定义在 algorithm 头文件中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span> <span class="comment">// 引入algorithm头文件以使用max函数</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> max_value = <span class="built_in">std</span>::max(a, b); <span class="comment">// 使用max函数比较a和b，并将结果存储在max_value中</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Max value is: &quot;</span> &lt;&lt; max_value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，std::max(a, b) 将返回 a 和 b 中的较大值，并将结果存储在 max_value 中。</p><h3 id="sort-函数"><a href="#sort-函数" class="headerlink" title="sort()函数"></a>sort()函数</h3><h2 id="头文件cmath"><a href="#头文件cmath" class="headerlink" title="头文件cmath"></a>头文件cmath</h2><h3 id="取整函数"><a href="#取整函数" class="headerlink" title="取整函数"></a>取整函数</h3><p>round()</p><p>ceil()</p><p>floor()</p><h2 id="字符串相关"><a href="#字符串相关" class="headerlink" title="字符串相关"></a>字符串相关</h2><h3 id="strcpy"><a href="#strcpy" class="headerlink" title="strcpy"></a>strcpy</h3><h3 id="substr"><a href="#substr" class="headerlink" title="substr"></a>substr</h3><h3 id="getline"><a href="#getline" class="headerlink" title="getline"></a>getline</h3><p>通常的使用方式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a;</span><br><span class="line"><span class="built_in">cin</span>.ignore();<span class="comment">//处理回车</span></span><br><span class="line">getline(<span class="built_in">cin</span>,str);</span><br></pre></td></tr></table></figure><p>注意在使用getline读取一行信息之前，如果输入有回车，要使用cin.ignore()来处理回车</p><h3 id="erase"><a href="#erase" class="headerlink" title="erase"></a>erase</h3><ol><li>basic_string &amp; erase(size_type pos&#x3D;0, size_type n&#x3D;npos);即erase（pos，n）;从给定起始位置pos处开始删除, 删除n个字符, 返回值修改后的string对象引用。比如erase(0,1)就是删除第一个字符。</li><li>iterator erase(const_iterator position)即erase（positon），删除迭代器位置处的单个字符(position是个string类型的迭代器), 并返回下个元素的迭代器。<br>如果position 不是迭代器位置，则删除该位置及之后的所有字符。</li><li>iterator erase(const_iterator first, const_iterator last)即erase（first，last）；删除迭代器（first, last)区间的所有字符（first和last都是迭代器）,返回一个指向被删除的最后一个元素的下一个字符的迭代器.</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="built_in">string</span> str = <span class="string">&quot;hello the world!&quot;</span>;</span><br><span class="line"> <span class="built_in">string</span> str1 = <span class="string">&quot;hello the world!&quot;</span>;</span><br><span class="line"> <span class="built_in">string</span> str2 = <span class="string">&quot;hello the world!&quot;</span>;</span><br><span class="line"> <span class="built_in">string</span> str3 = <span class="string">&quot;hello the world!&quot;</span>;</span><br><span class="line"> <span class="built_in">string</span> str4 = <span class="string">&quot;hello the world!&quot;</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/****************第1种用法:earse(pos,n)**************************/</span></span><br><span class="line"> str.erase(<span class="number">6</span>, <span class="number">2</span>);   </span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;&lt;&quot;</span> &lt;&lt; str &lt;&lt; <span class="string">&quot;&gt;&quot;</span> &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// &lt;hello e world!&gt;    </span></span><br><span class="line"> <span class="comment">/****************第2种用法:earse(position)***********************/</span></span><br><span class="line"> str1.erase(<span class="number">8</span>);  <span class="comment">//如果pos不是迭代器位置，则删除该位置及之后的所有字符</span></span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;&lt;&quot;</span> &lt;&lt; str1 &lt;&lt; <span class="string">&quot;&gt;&quot;</span> &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">//  &lt;hello th&gt;</span></span><br><span class="line"> </span><br><span class="line"> str2.erase(str2.begin()); <span class="comment">//如果pos是迭代器，则</span></span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;&lt;&quot;</span> &lt;&lt; str2 &lt;&lt; <span class="string">&quot;&gt;&quot;</span> &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">//  &lt;ello the world!&gt;</span></span><br><span class="line"> <span class="comment">/****************第3种用法:earse(fist,last)**********************/</span></span><br><span class="line"> str3.erase(str3.begin() + <span class="number">3</span>, str3.end()<span class="number">-3</span>);</span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;&lt;&quot;</span> &lt;&lt; str3 &lt;&lt; <span class="string">&quot;&gt;&quot;</span> &lt;&lt; <span class="built_in">endl</span>;     <span class="comment">// &lt;helld!&gt;</span></span><br><span class="line"> str4.erase(str4.begin() + <span class="number">3</span>, str4.end());</span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;&lt;&quot;</span> &lt;&lt; str4 &lt;&lt; <span class="string">&quot;&gt;&quot;</span> &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">//  &lt;hel&gt;</span></span><br><span class="line"> system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>资料来自于：<br><a href="!https://blog.csdn.net/weixin_42258743/article/details/120751188">CSDN</a></p><h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><h3 id="vector在指定位置插入元素"><a href="#vector在指定位置插入元素" class="headerlink" title="vector在指定位置插入元素"></a>vector在指定位置插入元素</h3><p>使用vector类的内置方法，insert</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> it = numbers.begin() + <span class="number">3</span>; <span class="comment">// 指定插入位置</span></span><br><span class="line">    numbers.insert(it, <span class="number">4</span>); <span class="comment">// 在位置 3 插入元素 4</span></span><br><span class="line">    numbers.insert(it, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;); <span class="comment">// 在位置 3 插入多个元素 4, 5, 6</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After insertion: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> num : numbers) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="vector在指定位置删除元素"><a href="#vector在指定位置删除元素" class="headerlink" title="vector在指定位置删除元素"></a>vector在指定位置删除元素</h3><p>使用vector类的内置方法，erase</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> it = numbers.begin() + <span class="number">2</span>; <span class="comment">// 指定删除位置</span></span><br><span class="line">    numbers.erase(it); <span class="comment">// 删除位置 2 的元素</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> start = numbers.begin() + <span class="number">2</span>; <span class="comment">// 指定起始删除位置</span></span><br><span class="line">    <span class="keyword">auto</span> end = numbers.begin() + <span class="number">5</span>;   <span class="comment">// 指定结束删除位置</span></span><br><span class="line">    numbers.erase(start, end); <span class="comment">// 删除从位置 2 到位置 5 的元素</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After deletion: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> num : numbers) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>关于vector插入与删除的总结，相同点是都可以使用迭代器进行，并且在操作一个元素的时候都是使用一个迭代器来指定操作元素的位置；在操作多个元素的时候插入还是使用一个迭代器，删除使用两个迭代器来指定区间。</p><p>插入，是插入于指定迭代器的位置，原本位置及之后的元素，均向后挪动（挪动多少取决于你插入元素的多少）<br>删除，删除指定位置的元素，或指定区间的元素</p><p>注意begin()获取的迭代器对应位置是首元素，end()迭代器对应位置是尾元素的下一位</p><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><h2 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h2><h2 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h2><h2 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h2><p>双端队列，支持队列的基本操作。但是是用push_front, pop_back</p><p>另外还有push_back, pop_front</p><p>还支持从任意位置删除元素，与vector类似，使用erase()即可</p><p>并且可以使用at()方法便捷地访问元素值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 使用 at() 方法访问元素</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\n使用 at() 方法访问元素:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; dq.size(); ++i) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;dq.at(&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;) = &quot;</span> &lt;&lt; dq.at(i) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这样的方法便捷地访问deque的值</p><h2 id="accumulate"><a href="#accumulate" class="headerlink" title="accumulate"></a>accumulate</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;numeric&gt;</span><span class="comment">//accumulate函数在numeric库中</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; b = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> sum_a = accumulate(a,a+<span class="number">10</span>,<span class="number">0</span>);</span><br><span class="line"><span class="type">int</span> sum_b = accumulate(b.begin(),b.end(),<span class="number">0</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意accumulate最后一个参数是必要的，含义是在累加指定迭代器范围的容器中的元素后，加上第三个元素，并且按照第三个元素的数据类型返回求和结果。</p><p>所以即使不用额外的累加，也需要使用第三个元素，int型的时候，第三个元素通常置0即可。</p><h2 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h2><p>元组的使用：设置值&amp;获取值</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划基础</title>
      <link href="/2025/08/29/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%9F%BA%E7%A1%80/"/>
      <url>/2025/08/29/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p><code>之前零零散散地接触过一些动态规划的问题，用这篇blog来稍微系统性的记录一下</code></p><h2 id="动态规划的基本步骤"><a href="#动态规划的基本步骤" class="headerlink" title="动态规划的基本步骤"></a>动态规划的基本步骤</h2><ol><li>定义数组的基本含义（模板或是灵感）</li><li>找到数组元素间的关系（dp的递推式，模板或是灵感）</li><li>找到边界的初始值（基本含义定义好了这个通常不难）</li><li>递推填表得到需要的元素（结合初始值以及递推式，考虑应该如何进行递推填表，确保新填一个元素需要用到其它元素的时候，其它元素的值已经被填过了）</li></ol><h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><h3 id="01背包（二维解法）"><a href="#01背包（二维解法）" class="headerlink" title="01背包（二维解法）"></a>01背包（二维解法）</h3><p>问题描述：有n种物品，每种物品只有一个。每个物品有自己的重量和价值。有一个给定容量的背包，问这个背包最多能装的最大价值是多少。</p><h4 id="step1"><a href="#step1" class="headerlink" title="step1"></a>step1</h4><p>定义数组元素的含义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j]<span class="comment">//背包容量为j时，考虑1~i种物品，所能承载的最大价值</span></span><br></pre></td></tr></table></figure><h4 id="step2"><a href="#step2" class="headerlink" title="step2"></a>step2</h4><p>于是我们可以有如下递推式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i<span class="number">-1</span>][j-weight[i]] + val[i])</span><br></pre></td></tr></table></figure><p>因为从前i-1种物品考虑到第i种物品，只有两种情况：</p><ol><li>拿第i种物品，那么前i-1种物品还剩下的可用容量是j-weight[i]，根据数组元素的意义，有dp[i][j] &#x3D; max(dp[i-1][j-weight[i]] + val[i])</li><li>不拿第i种物品，前i-1种物品剩下的可用容量是j，根据数组元素的意义，有dp[i][j] &#x3D; dp[i-1][j]</li></ol><p>所以取两种情况中较大的一者，就是dp[i][j]的结果。<strong>注意，第一种情况应该满足条件j&gt;&#x3D;weight[i]，这是显然成立的，于变成而言不满足这个条件数组会发生越界，于实际意义而言，你要装下物品i，意味着你的背包容量至少要大于等于w[i]</strong></p><h4 id="step3"><a href="#step3" class="headerlink" title="step3"></a>step3</h4><p>不难发现边界条件的初始值是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="number">0</span>][any_j] == <span class="number">0</span> &amp;&amp; dp[any_i][j] == <span class="number">0</span></span><br></pre></td></tr></table></figure><h4 id="step4"><a href="#step4" class="headerlink" title="step4"></a>step4</h4><p>根据递推关系式，我们发现在填元素dp[i][j]的时候，使用到的元素的1、2维索引一定分别小于i、j，于是按照最简单的从左往右，从上往下填表即可。</p><h4 id="例题与代码实现-01背包（二维解法）"><a href="#例题与代码实现-01背包（二维解法）" class="headerlink" title="例题与代码实现 01背包（二维解法）"></a>例题与代码实现 01背包（二维解法）</h4><p>洛谷：P1060 [NOIP 2006 普及组] 开心的金明</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">ll m,n;</span><br><span class="line">ll v[<span class="number">26</span>],w[<span class="number">26</span>];</span><br><span class="line">ll dp[<span class="number">26</span>][<span class="number">30001</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i++)</span><br><span class="line"> &#123;</span><br><span class="line">  ll t;</span><br><span class="line">  <span class="built_in">cin</span>&gt;&gt;v[i]&gt;&gt;t;</span><br><span class="line">  w[i] = v[i];</span><br><span class="line">  v[i]*=t;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i++)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= n;j++)</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="keyword">if</span>(j &gt;= w[i])dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i<span class="number">-1</span>][j-w[i]]+v[i]);</span><br><span class="line">   <span class="keyword">else</span> dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">cout</span>&lt;&lt;dp[m][n];</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="01背包（一维解法）"><a href="#01背包（一维解法）" class="headerlink" title="01背包（一维解法）"></a>01背包（一维解法）</h3><p>根据上面的状态转移式，我们可以发现在填表的过程中，<strong>每新的一行，仅仅依赖于上一行的数据</strong>，所以我们可以考虑使用1维表格。</p><p>即数组dp[j]，在二维表格的意义基础上描述对应元素的意义是：当前你正在更新行的元素数据，例如更新到第i行后，那么dp[j]对应就是dp[i][j]。当然这只是粗略的描述。</p><p>实际上，假设你当前正在更新第i行，并考虑更新dp[j]，在其更新之前，其对应的应该是dp[i-1][j]，更新完成后才是dp[i][j]。<strong>理解这一点很关键</strong>，有如下两点原因。</p><ol><li>dp[i][j]更新只依赖于i-1行的数据，而根据这个更新过程，i-1行的数据是可以同时被保存于这个一维表格的，那么只使用这个一维表格是可能的；</li><li>由于dp[i][j]的更新，从列上来看，其依赖的有1）dp[i][j-1]，在dp[j]于第i行更新中没有完成时，其代表的就是第i-1行的元素，所以dp[i-1][j]可以在需要时从表格中获取；2）dp[i-1][j-w[i]]，这就要求在dp[j]于第i行更新时，任何小于j的列k（0&lt;&#x3D; k &lt; j）没有完成更新，即dp[k]还保存的i-1行的元素，<strong>所以我们要从后往前更新表格</strong></li></ol><p>在第2点的基础上，只要我们从后往前更新1维表格，就可以确保<strong>表格中每个数据更新的时候，其需要的数据都存在于表格中（关键点）</strong>，于是使用一维数组替换二维数组是可行的。</p><p><em>这也是一般的dp需要考虑填表的方式的原因，你知道了递推式，你需要考虑如何递推才能满足，在求解一个元素的时候其它需要的元素一定是已经求解过了。</em></p><h4 id="例题与代码实现-01背包（一维解法）"><a href="#例题与代码实现-01背包（一维解法）" class="headerlink" title="例题与代码实现 01背包（一维解法）"></a>例题与代码实现 01背包（一维解法）</h4><p>洛谷：P1060 [NOIP 2006 普及组] 开心的金明</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line">ll m,n;</span><br><span class="line">ll v[<span class="number">26</span>],w[<span class="number">26</span>];</span><br><span class="line">ll dp[<span class="number">30001</span>];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i++)</span><br><span class="line"> &#123;</span><br><span class="line">  ll t;</span><br><span class="line">  <span class="built_in">cin</span>&gt;&gt;v[i]&gt;&gt;t;</span><br><span class="line">  w[i] = v[i];</span><br><span class="line">  v[i]*=t;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i++)</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> j = n;j &gt;= <span class="number">0</span>;j--)<span class="comment">//注意从后往前递推</span></span><br><span class="line">   <span class="keyword">if</span>(j &gt;= w[i])dp[j] = max(dp[j],dp[j-w[i]]+v[i]);</span><br><span class="line">   <span class="comment">//else dp[j] = dp[j]，对应的就是dp[j] = dp[j-1]，当然没有写的必要 </span></span><br><span class="line"> <span class="built_in">cout</span>&lt;&lt;dp[n];</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h3><p>01背包之所以叫01背包，是因为对于每种物品只有1个，或选或不选；而完全背包唯一区别于01背包的一点就是，每一种可以选择的物品都是无限的。</p><p>采用与01背包相同的dp数组定义，可以想到以下递推式</p><p>即考虑前i种物品时对于第i种物品，考虑选择其数量为0到正无穷的情况，对此进行枚举</p><p>$dp[i][j] &#x3D; max^∞_{k&#x3D;0}(dp[i - 1][j - k<em>w[i]]+ k</em>v[i])$</p><p>当然对于每一次枚举，我们有终止条件</p><p>$j&#x2F;k &gt; w[i]$</p><p>但是这样的算法复杂度是$n^3$，通常会TLE</p><p>可以考虑优化</p><p>$dp[i][j] &#x3D; max(dp[i-1][j],dp[i][j-w[i]]+v[i])$</p><p>这里涉及两个情况</p><ol><li>不拿第i种物品的时候$dp[i][j] &#x3D; dp[i-1][j]$显然成立</li><li>拿第i种物品的时候，拿1件物品i时的值，已经由$dp[i][j-2*w[i]]$更新过了，依次类推，拿任意件物品i（至于边界情况，拿尽可能多）对应的情况都被考虑在其中了。而$dp[i][j-w[i]]$的更新一定在$dp[i][j]$之前（直接考虑顺序递推），所以可行。</li></ol><p>上面的第二点，从朴素一点的角度，可以从你定义好数组的含义之后，填表更新的过程来理解，填$dp[i][j-w[i]]$的时候，根据状态转移方程的情况2，就需要考虑$dp[i][j-2*w[i]]$，而后者一定是比前者先填好的。</p><h4 id="例题与代码实现"><a href="#例题与代码实现" class="headerlink" title="例题与代码实现"></a>例题与代码实现</h4><p>第37次CCF CSP认证 Task2 机器人饲养指南</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line">ll n,m;</span><br><span class="line">ll v[<span class="number">101</span>];</span><br><span class="line">ll w[<span class="number">101</span>];</span><br><span class="line">ll dp[<span class="number">101</span>][<span class="number">100001</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i++)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="built_in">cin</span>&gt;&gt;v[i];</span><br><span class="line">  w[i] = i;</span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i++)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= n;j++)</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="keyword">if</span>(j &gt;= w[i])dp[i][j] = max(dp[i<span class="number">-1</span>][j],dp[i][j-w[i]]+v[i]);<span class="comment">//记住转移方程，其它按部就班即可</span></span><br><span class="line">   <span class="keyword">else</span> dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="built_in">cout</span>&lt;&lt;dp[m][n];</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这道题就是一个完全背包的模板，理解题意还原到完全背包，苹果的数量就是容量，投喂的数量就是物品的重量，投喂数量对应的受益就是物品的价值。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>联邦学习基础知识</title>
      <link href="/2025/08/25/%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2025/08/25/%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p><code>我正在学习一个用来跑PFL算法的代码框架，读代码的同时用这篇blog记录一些有关联邦学习的基础知识；以及一些python、pytorch的知识</code></p><h2 id="数据集划分的平衡与不平衡"><a href="#数据集划分的平衡与不平衡" class="headerlink" title="数据集划分的平衡与不平衡"></a>数据集划分的平衡与不平衡</h2><h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h3><p>在联邦学习中，平衡和不平衡主要指数据量上的分布情况：</p><p>平衡数据（Balanced Data）：每个客户端拥有的数据量大致相同。例如，如果有10个客户端和1000个数据样本，那么每个客户端分配到的数据约为100条。</p><p>不平衡数据（Unbalanced Data）：不同客户端拥有的数据量差别很大。例如，10个客户端中，某些客户端可能分配到300条数据，而另一些可能只有10条。这种情况在实际场景中很常见，比如边缘设备中，每台设备的用户数量或活跃度可能不同，导致本地数据量差异。</p><h3 id="影响"><a href="#影响" class="headerlink" title="影响"></a>影响</h3><p>平衡与不平衡的影响：</p><p>平衡的数据划分更容易训练，且模型收敛更快。</p><p>不平衡的数据划分会导致联邦学习中的“客户端漂移”问题，即全局模型更倾向于数据量大的客户端，而忽略数据量较小的客户端。</p><h2 id="人为划分IID-or-Non-IID的数据集"><a href="#人为划分IID-or-Non-IID的数据集" class="headerlink" title="人为划分IID or Non-IID的数据集"></a>人为划分IID or Non-IID的数据集</h2><h3 id="IID划分方法"><a href="#IID划分方法" class="headerlink" title="IID划分方法"></a>IID划分方法</h3><p>将整个数据集随机打乱后，均匀划分到每个客户端。</p><p>例如，MNIST 数据集有 60000 张图片，可以随机将它们分成 10 份，每份 6000 张，分配给 10 个客户端。</p><h3 id="Non-IID划分方法"><a href="#Non-IID划分方法" class="headerlink" title="Non-IID划分方法"></a>Non-IID划分方法</h3><p>常见的方法：</p><ol><li>按类别划分：MNIST 有 10 个类别，可以让每个客户端只拥有 1-2 个类别的数据。例如，客户端 A 拥有类别 0 和 1 的数据，客户端 B 拥有类别 2 和 3 的数据。</li><li>狄利克雷分布（Dirichlet Distribution）：通过狄利克雷分布生成权重，控制每个客户端拥有的类别比例</li><li>数量不平衡：对每个客户端分配不同数量的数据，进一步增加数据分布的不均衡性。</li></ol><h3 id="狄利克雷划分法（Non-IID）"><a href="#狄利克雷划分法（Non-IID）" class="headerlink" title="狄利克雷划分法（Non-IID）"></a>狄利克雷划分法（Non-IID）</h3><h4 id="关于狄利克雷分布"><a href="#关于狄利克雷分布" class="headerlink" title="关于狄利克雷分布"></a>关于狄利克雷分布</h4><p>狄利克雷分布是一种概率分布，用于生成一组非负数，使它们的和为 1。它常用于 Non-IID 数据划分中，控制每个客户端拥有数据类别的比例。</p><p>狄利克雷分布是一种“分布的分布” (a distribution on probability distribution) ，由两个参$\mathcal{G}_0,\alpha$ 确定，即$\mathcal{G} \sim DP(\alpha,\mathcal{G}_0)$，$\alpha$是分布参数(concentration or scaling parameter)，其值越大，分布越接近于均匀分布，其值越小，分布越concentrated。$\mathcal{G}_0$是基分布(base distribution)。</p><p>具体步骤：</p><ol><li>假设有 $K$ 个类别，客户端数为 $N$，狄利克雷分布的超参数为 $\alpha$。</li><li>对于每个客户端 $i$，从狄利克雷分布中采样一个向量 $p_i$，表示该客户端对 $K$ 个类别的偏好。</li><li>根据 $p_i$分配数据样本。例如，如果某个客户端 $i$ 的 $p_i &#x3D; [0.7, 0.2, 0.1]$，则它的样本中 70% 来自类别 1，20% 来自类别 2，10% 来自类别 3。</li><li>调整 $\alpha$ 值，可以控制 Non-IID 的程度：$\alpha$ 越小，每个客户端的类别分布差异越大（更偏向 Non-IID）。$\alpha$ 越大，类别分布差异越小（更接近 IID）。</li></ol><h3 id="其它一些划分方式（Non-IID）"><a href="#其它一些划分方式（Non-IID）" class="headerlink" title="其它一些划分方式（Non-IID）"></a>其它一些划分方式（Non-IID）</h3><ol><li>固定类别划分：每个客户端只分配特定的类别。例如，客户端 A 只分到类别 0，客户端 B 只分到类别 1。适用于模拟极端 Non-IID 分布。</li><li>聚类划分：对数据集进行聚类，将每个聚类的数据分配给一个客户端。这种方法可以模拟数据具有某种特定模式的情况。</li><li>概率抽样：给每个客户端分配不同的类别概率分布，然后根据概率分布抽样数据。比如，客户端 A 的类别分布是 [0.9, 0.1, 0.0]，客户端 B 的类别分布是 [0.3, 0.3, 0.4]。</li><li>基于地理或时间划分：按照数据生成的时间或地理位置来划分数据。例如，某些客户端的数据来自特定地区，模拟真实场景下的数据分布。</li></ol><h3 id="数据的异质性-Heterogeneity"><a href="#数据的异质性-Heterogeneity" class="headerlink" title="数据的异质性(Heterogeneity)"></a>数据的异质性(Heterogeneity)</h3><p>指的是Non-IID and unbalanced</p><h3 id="客户端漂移"><a href="#客户端漂移" class="headerlink" title="客户端漂移"></a>客户端漂移</h3><p>由于数据分布的差异，每个客户端的本地模型更新（梯度）可能会在方向和大小上有所不同。当这些更新被聚合时，可能会导致全局模型更新的方向和大小并不是所有客户端所需要的最佳方向。这种现象称为客户端漂移。</p><h3 id="CUDA"><a href="#CUDA" class="headerlink" title="CUDA"></a>CUDA</h3><p>CUDA（Compute Unified Device Architecture）是由 NVIDIA 开发的并行计算平台和编程模型。它允许开发者使用 NVIDIA 显卡（GPU）进行通用计算，即不仅仅用于图形处理，还可以用于科学计算、机器学习、深度学习等大量需要并行计算的任务。</p><p>通常cuda设备就是指GPU</p><h2 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h2><h3 id="Py的for循环"><a href="#Py的for循环" class="headerlink" title="Py的for循环"></a>Py的for循环</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, train_data <span class="keyword">in</span> <span class="built_in">enumerate</span>(trainloader, <span class="number">0</span>):</span><br><span class="line">    trainset.data, trainset.targets = train_data</span><br></pre></td></tr></table></figure><p>enumerate函数返回一个(索引，值)的元组，_是常用的占位符（我们知道这里有值，但是我们不使用），这里_存储的是索引值；train_data是由Dataloader将原始的数据集对象分批后得到的新的“数据集对象列表”trainloader中的元素，作为enumerate元组的值，其是一个数据集对象。</p><p>上面的赋值语句是将一个数据集对象train_data（本身是一个元组）中的两个元素，分别赋值给数据集对象trainset的两个属性元素。</p><h3 id="Py，range函数"><a href="#Py，range函数" class="headerlink" title="Py，range函数"></a>Py，range函数</h3><p>range(n)，生成一个迭代器，依次返回0，1，2，3，…，n-1</p><h3 id="Py，np-array函数"><a href="#Py，np-array函数" class="headerlink" title="Py，np.array函数"></a>Py，np.array函数</h3><p>numpy库中的array函数用于将输入的数据转换为一个NumPy数组，该数组是一种高效的多维数组对象，提供了许多用于数学和科学计算的功能。</p><h3 id="Py迭代器"><a href="#Py迭代器" class="headerlink" title="Py迭代器"></a>Py迭代器</h3><p>在Python中，迭代器是一种遵循迭代协议的对象，具有 iter() 和 next() 方法。迭代器允许程序员遍历一个集合，如列表或字符串，一次访问一个元素。生成器是一种特殊的迭代器，它使用 yield 关键字在每次迭代时返回值，而不是一次性返回所有值。</p><h4 id="一种迭代器的实现方式"><a href="#一种迭代器的实现方式" class="headerlink" title="一种迭代器的实现方式"></a>一种迭代器的实现方式</h4><p>把一个类作为一个迭代器使用需要在类中实现两个方法 __iter__() 与 __next__() 。</p><p>如果你已经了解的面向对象编程，就知道类都有一个构造函数，Python 的构造函数为__init__(), 它会在对象初始化的时候执行。</p><p>__iter__() 方法返回一个特殊的迭代器对象， 这个迭代器对象实现了 __next__() 方法并通过 StopIteration 异常标识迭代的完成。</p><p>__next__() 方法（Python 2 里是 next()）会返回下一个迭代器对象。</p><p><em>一个具体的例子：</em></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyNumbers</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="variable language_">self</span>.a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">self</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">    x = <span class="variable language_">self</span>.a</span><br><span class="line">    <span class="variable language_">self</span>.a += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"> </span><br><span class="line">myclass = MyNumbers()</span><br><span class="line">myiter = <span class="built_in">iter</span>(myclass)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(myiter))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(myiter))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(myiter))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(myiter))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(myiter))</span><br></pre></td></tr></table></figure><p><em>输出结果是：</em></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><h3 id="Py使用布尔数组索引元素"><a href="#Py使用布尔数组索引元素" class="headerlink" title="Py使用布尔数组索引元素"></a>Py使用布尔数组索引元素</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">idxs = np.array(<span class="built_in">range</span>(<span class="built_in">len</span>(dataset_label)))</span><br><span class="line">idx_for_each_class = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_classes):</span><br><span class="line">    idx_for_each_class.append(idxs[dataset_label == i])</span><br></pre></td></tr></table></figure><p>其中idxs是一个索引数组。</p><p>dataset_label &#x3D;&#x3D; i会生成一个布尔数组，对于dataset_label中的元素等于i的，该元素的位置对应布尔数组中True元素的位置，布尔数组中其它位置元素是False。例如，dataset_label &#x3D; [1, 2, 1, 2, 1]，i &#x3D; 1；那么对应布尔数组为[True, False, True, False, True]</p><p>idxs[dataset_label &#x3D;&#x3D; i]使用布尔数组进行索引，将布尔数组中为True的元素的位置对应到idxs中元素的位置。例如，idxs &#x3D; [1, 2, 3, 4, 5]，根据前面的布尔数组，返回[1, 3, 5]</p><h3 id="Py列表生成式"><a href="#Py列表生成式" class="headerlink" title="Py列表生成式"></a>Py列表生成式</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class_num_per_client = [class_per_client <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(num_clients)]</span><br></pre></td></tr></table></figure><p>其中[class_per_client for _ in range(num_clients)]是一个列表生成式；</p><p>用range迭代num_clients次，每次迭代的过程中添加一个元素为class_per_client；</p><p>最终得到一个长度为num_clients，每个元素都是class_per_client的列表；</p><p>实际意义是创建一个列表，其中每个元素代表每个客户端拥有的类别数量</p><h3 id="Py列表截取"><a href="#Py列表截取" class="headerlink" title="Py列表截取"></a>Py列表截取</h3><p>常见的列表截取操作如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a[start:stop] <span class="comment"># 从索引start开始到索引stop-1结束</span></span><br><span class="line">a[start:] <span class="comment"># 从索引start开始到列表末尾</span></span><br><span class="line">a[:stop] <span class="comment"># 从列表开头到索引stop-1结束</span></span><br><span class="line">a[:] <span class="comment"># 获取整个列表</span></span><br></pre></td></tr></table></figure><p>又如</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">selected_clients = selected_clients[:<span class="built_in">int</span>(np.ceil((num_clients/num_classes)*class_per_client))]</span><br></pre></td></tr></table></figure><p>np.ceil的作用告诉向上取整，再用int()转换为整数，又从0截取到stop-1</p><h3 id="Py，利用enumerate的for循环"><a href="#Py，利用enumerate的for循环" class="headerlink" title="Py，利用enumerate的for循环"></a>Py，利用enumerate的for循环</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> idx, train_dict <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_data):  <span class="comment"># 这种循环的作用是idx是train_data的索引，train_dict是train_data的元素（即存有训练数据的字典）</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(train_path + <span class="built_in">str</span>(idx) + <span class="string">&#x27;.npz&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        np.savez_compressed(f, data=train_dict)</span><br></pre></td></tr></table></figure><p>enumerate返回一个元组(index, element)的迭代器，常用于for index, element in enumerate(list)的循环中</p><h3 id="Py，argparse模块"><a href="#Py，argparse模块" class="headerlink" title="Py，argparse模块"></a>Py，argparse模块</h3><p>argparse 模块是 Python 标准库中的一个模块，它用于解析命令行参数。通过 argparse，我们可以方便地从命令行中获取参数并将其传递给程序。</p><h4 id="argparse的用法"><a href="#argparse的用法" class="headerlink" title="argparse的用法"></a>argparse的用法</h4><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parser = argparse.ArgumentParser()  <span class="comment"># 这是创建一个新的 ArgumentParser 对象，用于处理命令行参数。</span></span><br><span class="line">parser.add_argument(<span class="string">&#x27;-go&#x27;</span>, <span class="string">&quot;--goal&quot;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="string">&quot;test&quot;</span>, </span><br><span class="line">                    <span class="built_in">help</span>=<span class="string">&quot;The goal for this experiment&quot;</span>)</span><br></pre></td></tr></table></figure><p>add_argument 方法用于定义程序可以接受的命令行参数，在上面的例子中：</p><ol><li>-go 和 –goal 是参数的名称（短名称和长名称）。</li><li>type&#x3D;str 指定参数的类型为字符串。</li><li>default&#x3D;”test” 指定参数的默认值。</li><li>help 提供该参数的帮助信息，会在使用 –help 时显示。</li></ol><p>类似的参数定义方法：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">parser.add_argument(<span class="string">&#x27;-dev&#x27;</span>, <span class="string">&quot;--device&quot;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="string">&quot;cuda&quot;</span>,</span><br><span class="line">                    choices=[<span class="string">&quot;cpu&quot;</span>, <span class="string">&quot;cuda&quot;</span>])</span><br><span class="line">parser.add_argument(<span class="string">&#x27;-did&#x27;</span>, <span class="string">&quot;--device_id&quot;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="string">&quot;0&quot;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;-data&#x27;</span>, <span class="string">&quot;--dataset&quot;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="string">&quot;MNIST&quot;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;-itk&#x27;</span>, <span class="string">&quot;--itk&quot;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">4000</span>,</span><br><span class="line">                    <span class="built_in">help</span>=<span class="string">&quot;The iterations for solving quadratic subproblems&quot;</span>)</span><br></pre></td></tr></table></figure><p>最后解析参数，得到一个Namespace对象，用来访问各个参数</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">args = parser.parse_args()</span><br></pre></td></tr></table></figure><p>parse_args 方法会解析命令行参数，并返回一个包含参数值的 Namespace 对象。可以通过 args 对象来访问这些参数，例如 args.goal、args.device 等。</p><p>综合来看，argparse的主要用法就是<strong>创建对象，定义参数，解析参数</strong></p><h3 id="Py张量"><a href="#Py张量" class="headerlink" title="Py张量"></a>Py张量</h3><p>一般是指用于数值计算的高效多维数组，可能是一个比较抽象的概念。</p><p>具体而言Py内置的list、Numpy库的Numpy数组或者Pytorch中的tensor，在某种程度上都可以被称为张量；但是在一些特定的情况下，张量或许特指后面两者</p><h3 id="Py，Dataloader"><a href="#Py，Dataloader" class="headerlink" title="Py，Dataloader"></a>Py，Dataloader</h3><p>在 PyTorch 中，DataLoader 是一个非常常用的类，用于包装数据集，提供批量加载数据的功能。</p><p>主要作用：</p><ol><li>批量加载数据: 根据指定的 batch_size 从数据集中加载数据。</li><li>打乱数据: 如果 shuffle&#x3D;True，在每个 epoch 开始时打乱数据。</li><li>多线程加载: 通过 num_workers 参数（未在此代码段中指定），可以并行加载数据，提高数据加载速度。</li><li>迭代接口: DataLoader 实现了 Python 迭代器协议，可以在训练循环中方便地使用 for batch in dataloader 这样的语法。</li></ol><p>例子：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset, DataLoader</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleDataset</span>(<span class="title class_ inherited__">Dataset</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, data</span>):</span><br><span class="line">        <span class="variable language_">self</span>.data = data</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(<span class="variable language_">self</span>.data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, idx</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.data[idx]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设 read_client_data 返回一个 SimpleDataset 对象</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_client_data</span>(<span class="params">dataset, client_id, is_train, few_shot</span>):</span><br><span class="line">    <span class="keyword">return</span> SimpleDataset([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, batch_size=<span class="number">3</span></span>):</span><br><span class="line">        <span class="variable language_">self</span>.batch_size = batch_size</span><br><span class="line">        <span class="variable language_">self</span>.dataset = <span class="literal">None</span></span><br><span class="line">        <span class="variable language_">self</span>.<span class="built_in">id</span> = <span class="literal">None</span></span><br><span class="line">        <span class="variable language_">self</span>.few_shot = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">load_test_data</span>(<span class="params">self, batch_size=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="keyword">if</span> batch_size == <span class="literal">None</span>:</span><br><span class="line">            batch_size = <span class="variable language_">self</span>.batch_size</span><br><span class="line">        test_data = read_client_data(<span class="variable language_">self</span>.dataset, <span class="variable language_">self</span>.<span class="built_in">id</span>, is_train=<span class="literal">False</span>, few_shot=<span class="variable language_">self</span>.few_shot)</span><br><span class="line">        <span class="keyword">return</span> DataLoader(test_data, batch_size, drop_last=<span class="literal">False</span>, shuffle=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 MyClass 加载数据</span></span><br><span class="line">my_class = MyClass()</span><br><span class="line">dataloader = my_class.load_test_data()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> batch <span class="keyword">in</span> dataloader:</span><br><span class="line">    <span class="built_in">print</span>(batch)</span><br></pre></td></tr></table></figure><p>例子将会输出</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tensor([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">tensor([<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line">tensor([<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line">tensor([<span class="number">10</span>])</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习（联邦学习） </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PFLNash</title>
      <link href="/2025/08/17/PFL-SRDP/"/>
      <url>/2025/08/17/PFL-SRDP/</url>
      
        <content type="html"><![CDATA[<p><code>一些有意思的东西</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习（联邦学习） </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PFL2</title>
      <link href="/2025/08/06/PFL2/"/>
      <url>/2025/08/06/PFL2/</url>
      
        <content type="html"><![CDATA[<p><code>这篇blog用来记录我读的第二篇有关联邦学习的文献，其中也使用了nash bargaining game</code></p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="Representation-Collapse-Entanglement"><a href="#Representation-Collapse-Entanglement" class="headerlink" title="Representation Collapse Entanglement"></a>Representation Collapse Entanglement</h3><p>表示崩塌纠缠：这是指在联邦无监督学习（FUSL）过程中，由于某个本地模型的表示崩塌（即该模型的特征表示不再具有区分度），会影响到全局模型和其他本地模型的表示能力。这种崩塌会导致整个系统的表示能力下降，使得模型在处理非独立同分布（non-IID）数据时效果不佳。</p><h3 id="Flexible-Uniform-Regularizer"><a href="#Flexible-Uniform-Regularizer" class="headerlink" title="Flexible Uniform Regularizer"></a>Flexible Uniform Regularizer</h3><p>FUR：灵活均匀正则化器，这是FedU2方法中的一个组件，旨在每个客户端上避免表示崩塌。通过均匀分散样本，使得模型的表示不集中在特定区域，从而保持特征空间的多样性。通过强制模型学习到更加均匀分布的特征，FUR可以防止表示崩塌，提高模型的泛化能力。</p><h3 id="Efficient-Unified-Aggregator"><a href="#Efficient-Unified-Aggregator" class="headerlink" title="Efficient Unified Aggregator"></a>Efficient Unified Aggregator</h3><p>EUA：高效统一聚合器，这是FedU2方法中的另一个组件，部署在服务器端，用于在聚合客户端模型时促进统一的表示空间。该聚合器通过约束客户端模型的更新，确保各客户端模型在特征空间上的一致性。</p><h3 id="Inactivated-neurons"><a href="#Inactivated-neurons" class="headerlink" title="Inactivated neurons"></a>Inactivated neurons</h3><p>非活化神经元：：在人工神经网络（如深度学习模型）中，某些神经元可能在特定输入或训练阶段不被激活。激活函数（如ReLU、Sigmoid等）会根据输入值决定某个神经元是否被激活。</p><h3 id="Unbalanced-Optimal-Transport-Divergence"><a href="#Unbalanced-Optimal-Transport-Divergence" class="headerlink" title="Unbalanced Optimal Transport Divergence"></a>Unbalanced Optimal Transport Divergence</h3><p>非平衡最优传输散度：是一种测量分布之间差异的方法，特别适用于处理具有不同质量或总质量不守恒的分布。它是传统最优传输（Optimal Transport, OT）理论的扩展，传统最优传输通常假设两个分布具有相同的总质量，这样可以通过寻找最优运输计划来最小化从一个分布到另一个分布的“运输成本”。非平衡最优传输散度放宽了传统最优传输的总质量守恒假设，允许处理不同质量或存在质量损失的分布。它引入了一个正则项来惩罚质量的创建和销毁，从而可以在更广泛的应用场景中使用。</p><p>在FUR中的应用：最小化客户端数据与均匀随机样本（如来自同一球形高斯分布的样本）之间的非平衡最优传输散度。FUR强制每个客户端的数据分布更接近一个统一的参考分布，从而避免了表示崩塌并促进更均匀的特征表示。</p><p>注意：在最小化非平衡最优传输散度的过程中，通常并不会直接删除客户端的数据点，而是通过调整模型的训练过程来使数据的特征表示与统一的参考分布对齐。这是通过优化目标函数和引入正则化项来实现的，而不是通过直接修改原始数据。</p><p>具体实现方法：在训练过程中，优化目标函数时会加入非平衡最优传输散度作为正则化项。这一项会惩罚客户端数据分布与参考分布之间的差异。</p><p>公式：假设 $\mathcal{L}$ 是原始损失函数，$\text{UOT}(P, Q)$ 是非平衡最优传输散度项，那么新的优化目标可以表示为：<br>$\mathcal{L}_{\text{total}} &#x3D; \mathcal{L} + \lambda \cdot \text{UOT}(P, Q)$</p><h2 id="翻译"><a href="#翻译" class="headerlink" title="翻译"></a>翻译</h2><p>divergent 不同的，分歧的；（级数）发散的</p><p>suppress 抑制；封锁；压制</p><p>decorrelate 去相关</p><p>discrepant 有差异的；矛盾的</p><p>threshold 阈；门槛</p><p>deviation 偏离</p><p>dual 双重的</p>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习（联邦学习） </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PFL</title>
      <link href="/2025/07/29/PFL/"/>
      <url>/2025/07/29/PFL/</url>
      
        <content type="html"><![CDATA[<p><code>这篇blog用于记录我阅读论文《 Improve global generalization for personalized federated learning within a Stackelberg game》过程中学习到的一些基础知识。</code></p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="PFL"><a href="#PFL" class="headerlink" title="PFL"></a>PFL</h3><p>个性化联邦学习：在联邦学习(FL)的基础上， PFL的目标是为每个客户端训练一个个性化模型，适应每个客户端的特定数据分布和需求。PFL适用于各客户端数据分布差异较大，且每个客户端需要一个定制化模型的场景。<strong>不同于FL训练一个全局共享的模型，希望是该模型在所有客户端上表现良好。</strong></p><h4 id="PFL分类"><a href="#PFL分类" class="headerlink" title="PFL分类"></a>PFL分类</h4><p>“Towards Personalized Federated Learning”一文将个性化联邦学习（PFL）分为两类：</p><ol><li>全局模型个性化（Global Model Personalization）：第一阶段，训练一个共享的全局FL模型；第二阶段，在本地的数据上进行额外的训练，达到适应个性化的目的。在这一类模型中，关注与第一阶段全局FL模型在non-IID数据上的训练能力。</li><li>学习个性化模型（Learning Personalized Model）：在训练阶段，就达到模型个性化的效果。个人理解：区别于上种二阶段的PFL，这一类方法在一阶段就实现了PFL（但这样理解的话似乎把Regularization based的方法归入architecture更合理）。</li></ol><p><a href="https://zhuanlan.zhihu.com/p/497934969">参考资料</a></p><h2 id="词汇"><a href="#词汇" class="headerlink" title="词汇"></a>词汇</h2>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习（联邦学习） </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Joint Local Relational Augmentation and Global Nash Equilibrium for Federated Learning with Non-IID Data</title>
      <link href="/2025/07/16/Joint-Local-Relational-Augmentation-and-Global-Nash-Equilibrium-for-Federated-Learning-with-Non-IID-Data/"/>
      <url>/2025/07/16/Joint-Local-Relational-Augmentation-and-Global-Nash-Equilibrium-for-Federated-Learning-with-Non-IID-Data/</url>
      
        <content type="html"><![CDATA[<p><code>这篇blog用于记录我学习一篇有关运用Nash博弈解决联邦学习有关问题的论文时，学习到的相关知识</code></p><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="Federated-Learning"><a href="#Federated-Learning" class="headerlink" title="Federated Learning"></a>Federated Learning</h3><h4 id="基本架构"><a href="#基本架构" class="headerlink" title="基本架构"></a>基本架构</h4><p>联邦学习的基本架构是Server和Clients</p><p>Server通常没有数据，可以有一些用于评估模型的数据，但是在普通联邦学习中Server没有任何数据</p><p>Clients持有实际的训练数据，Clients的数量取决于有多少分布式的数据要参与训练。Clients会在各自的本地数据集上进行实际训练。</p><p>服务器和客户端都拥有自己的模型副本，前者的称为全局模型，后者的称为局部模型。</p><h4 id="训练过程"><a href="#训练过程" class="headerlink" title="训练过程"></a>训练过程</h4><ol><li>服务器初始化全局模型参数</li><li>将该参数发送给客户端</li><li>客户端在本地进行训练，训练较短时间，通常是一个周期（所以不一定达到收敛）</li><li>客户端将改进后的模型参数发送回服务器，服务器收到五个模型参数，考虑不同的权重，进行聚合</li><li>检查是否收敛，否则重复步骤2</li></ol><p>更加规范化的表述是</p><p>1） Initialization:<br>Server initializes the global model</p><p>2） Communication Round:</p><p>For each communication round:<br> Server sends the global model to participating clients</p><p> Each client receives the global model</p><p>3）Client Training and Model Update:<br>For each participating client:</p><p> Client trains the received model on its local dataset</p><p> Client sends its locally updated model to the server</p><p>4） Model Aggregation:<br>Server aggregates the updated models received from all clients using Aggregation Algorithm (for instance, FedAvg)</p><p>5） Convergence Check:<br>If convergence criteria are met, end the FL process</p><p>If not, proceed to the next communication round (step 2)</p><h3 id="non-IID-data"><a href="#non-IID-data" class="headerlink" title="non-IID data"></a>non-IID data</h3><p>在联邦学习（Federated Learning, FL）的背景下，non-IID数据是指数据不是独立同分布（Independent and Identically Distributed, IID）的。IID数据假设每一条数据都是相互独立的，并且来自相同的分布。这种假设在很多传统的机器学习方法中是成立的，但在联邦学习中通常不成立</p><h4 id="可能的原因"><a href="#可能的原因" class="headerlink" title="可能的原因"></a>可能的原因</h4><p>数据来源的异质性：在联邦学习中，数据是分布在不同的客户端（如不同的用户设备）上的。每个客户端的数据可能由于用户的行为、兴趣、地理位置、设备类型等因素不同，从而导致数据分布的差异。</p><p>分布不均衡：某些客户端可能拥有更多的数据，而其他客户端可能只有少量的数据。数据的量级和类别在不同客户端之间可能是高度不均衡的。</p><p>标签分布差异：某些客户端可能只包含特定类别的数据，而其他客户端可能包含不同类别的数据。这种情况下，每个客户端的数据标签分布也是不同的。</p><h3 id="Intra-client-inconsistencies-And-Inter-client-inconsistencies"><a href="#Intra-client-inconsistencies-And-Inter-client-inconsistencies" class="headerlink" title="Intra-client inconsistencies And Inter-client inconsistencies"></a>Intra-client inconsistencies And Inter-client inconsistencies</h3><p>Intra-client Inconsistencies客户端内部不一致性 指的是单个客户端内部的数据分布问题，主要包括以下几个方面：</p><p>数据不平衡：单个客户端内部的不同类别的数据分布可能非常不均衡。例如，某个客户端可能有大量的类别A的数据，但只有少量的类别B的数据。这种不平衡会导致模型在训练过程中对某些类别的泛化能力不足。</p><p>数据稀疏性：客户端内部可能存在数据量不足的问题，特别是对于一些罕见类别的数据，这会影响模型的训练效果和泛化能力。</p><p>数据噪声：客户端内部的数据可能包含噪声或错误标注，这会影响模型的准确性和稳定性。</p><p>Inter-client Inconsistencies客户端之间不一致性 指的是不同客户端之间的数据分布差异，包括以下几个方面：</p><p>数据分布差异：不同客户端的数据可能来自不同的分布。例如，一个客户端可能主要包含城市环境下的数据，而另一个客户端可能主要包含农村环境下的数据。这种分布差异会导致全局模型在不同客户端上的表现不一致。</p><p>标签分布差异：不同客户端的数据类别分布可能不同。例如，一个客户端可能主要关注某些特定类别，而另一个客户端可能关注完全不同的类别。这会导致全局模型难以在所有客户端上都表现良好。</p><p>数据量差异：一些客户端可能拥有大量的数据，而其他客户端可能数据量很少。这种数据量差异也会影响全局模型的训练效果。</p><h3 id="Local-Relational-Augmentation"><a href="#Local-Relational-Augmentation" class="headerlink" title="Local Relational Augmentation"></a>Local Relational Augmentation</h3><p>LRA（局部关系增强）模块的目标是解决客户端内部的不一致性问题。</p><p>数据增强：通过生成或变换现有数据，使得每个客户端的数据分布更加均衡和丰富。这有助于改进模型在少数类别数据上的表现。</p><p>关系建模：在客户端内部建立数据样本之间的关系网络，利用这些关系来增强模型的学习过程。例如，可以通过图神经网络（Graph Neural Networks, GNN）来捕捉数据样本之间的相似性和相关性，从而提升模型的泛化能力。</p><p>摘一段原文的内容：</p><p>LRA first computes the similarity among a batch of data samples, and finds the neighbors of data samples based on the similarity.</p><p>Then LRA enhances the data feature representation via attentive message passing among the neighbors of data samples.</p><p>Besides, LRA conducts contrastive discrimination to maintain the representations correspondence before and after augmentation, for the same sample.</p><h3 id="Global-Nash-Equilibrium"><a href="#Global-Nash-Equilibrium" class="headerlink" title="Global Nash Equilibrium"></a>Global Nash Equilibrium</h3><p>GNE模块的目标是解决客户端之间的不一致性问题。纳什均衡在博弈论中是指在某种策略组合下，没有任何参与者能够通过单方面改变自己的策略来获得更好的结果。</p><p>摘一段原文的内容</p><p>Specifically, GNE collects the updating deviations from different clients to server.</p><p>Then GNE not only seeks a global optimization direction that maximizes the consistency among discrepant local model deviations, but also maintains clients’ optimizations towards their local optimums.</p><h4 id="在联邦学习中，全局纳什均衡的常见作用"><a href="#在联邦学习中，全局纳什均衡的常见作用" class="headerlink" title="在联邦学习中，全局纳什均衡的常见作用"></a>在联邦学习中，全局纳什均衡的常见作用</h4><p>平衡客户端贡献：在模型更新过程中，使各个客户端的贡献达到一种平衡状态，即没有任何一个客户端的更新会对全局模型产生过度的偏差。</p><p>优化全局模型：通过博弈论的方法，找到一种策略组合，使得全局模型在各个客户端的数据分布上都能表现良好。这可能涉及到权重调整、梯度校正等技术。</p><h3 id="representation"><a href="#representation" class="headerlink" title="representation"></a>representation</h3><p>“representation” 通常指的是数据在模型内部某一层次上的表达方式或特征表示。</p><p>特征表示（Feature Representation）：在深度学习模型中，输入数据（如图像、文本、音频等）经过多个层的变换后，每一层都会生成不同的特征表示。这些特征表示是原始数据在模型内部的抽象和高维度表示，能够捕捉到数据的关键特征和模式。</p><p>隐层表示（Hidden Layer Representation）：在神经网络中，隐层（即非输入层和非输出层）会生成中间表示，这些表示是原始输入数据通过网络层级传递和变换后的结果。这些隐层表示在分类、聚类或其他任务中具有重要作用。</p><p>嵌入表示（Embedding Representation）：在自然语言处理（NLP）等领域，词嵌入（如Word2Vec、GloVe）是常见的表示形式，它们将高维的稀疏数据（如单词的一个热编码）映射到低维的稠密向量空间中，从而捕捉词与词之间的语义关系。</p><h3 id="SLIM-method"><a href="#SLIM-method" class="headerlink" title="SLIM method"></a>SLIM method</h3><p>Sparse Linear Methods (SLIM) 是一种在推荐系统中广泛应用的技术，旨在通过稀疏线性模型来挖掘项目与项目之间的关系。SLIM 的核心思想是通过学习一个稀疏的线性权重矩阵来捕捉项目之间的相似性，从而提高推荐的准确性和效率。</p><h4 id="相关基本概念"><a href="#相关基本概念" class="headerlink" title="相关基本概念"></a>相关基本概念</h4><p>稀疏性（Sparsity）：SLIM 假设推荐系统中的大多数项目之间并没有直接的关联，只有少数项目之间存在显著的相似性。因此，SLIM 通过稀疏矩阵来表示这种稀疏性，从而减少计算复杂度和存储需求。</p><p>线性模型（Linear Model）：SLIM 使用线性模型来表示项目与项目之间的关系。具体来说，它通过一个线性组合来预测用户对一个项目的评分，该组合是基于用户对其他相关项目的评分加权得到的。</p><p>低秩性（Low-Rankness）：SLIM 还利用了数据的低秩特性，假设项目之间的关系可以用一个低秩矩阵来近似。这种低秩性有助于捕捉数据中的潜在结构和模式。</p><h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><p>构建相似度矩阵：首先，SLIM 构建一个项目与项目之间的相似度矩阵，可以基于统计相似性（如皮尔逊相关系数）来计算。</p><p>学习稀疏线性权重：然后，SLIM 通过优化算法学习一个稀疏的线性权重矩阵。这个矩阵的每个元素表示一个项目对另一个项目的线性关系权重。</p><p>预测评分：最后，使用学习到的权重矩阵和用户的历史评分数据，SLIM 可以预测用户对未评分项目的评分。</p><h3 id="Pearson-Correlation-Matrix"><a href="#Pearson-Correlation-Matrix" class="headerlink" title="Pearson Correlation Matrix"></a>Pearson Correlation Matrix</h3><p>皮尔逊相关矩阵（Pearson Correlation Matrix） 是一种用于度量数据集中各个变量之间线性关系强度的矩阵。它通过皮尔逊相关系数来衡量不同变量（或数据样本）之间的相关性。相关系数的值范围从 -1 到 +1，其中：</p><p>+1 表示完全正相关，即两个变量的变化方向完全一致。</p><p>0 表示没有线性相关性，即两个变量之间没有任何线性关系。</p><p>-1 表示完全负相关，即两个变量的变化方向完全相反。</p><h4 id="皮尔逊相关系数的计算公式"><a href="#皮尔逊相关系数的计算公式" class="headerlink" title="皮尔逊相关系数的计算公式"></a>皮尔逊相关系数的计算公式</h4><p>皮尔逊相关系数（$r$）的计算公式为：</p><p>$r &#x3D; \frac{\sum (X_i - \bar{X})(Y_i - \bar{Y})}{\sqrt{\sum (X_i - \bar{X})^2 \sum (Y_i - \bar{Y})^2}}$</p><p>其中：</p><p>$X_i$和 $Y_i$分别是样本 $X$ 和 $Y$ 的第 $i$ 个观测值；<br>$\bar{X}$和 $\bar{Y}$分别是样本 $X$ 和 $Y$ 的均值。</p><h4 id="皮尔逊相关矩阵的应用"><a href="#皮尔逊相关矩阵的应用" class="headerlink" title="皮尔逊相关矩阵的应用"></a>皮尔逊相关矩阵的应用</h4><p>特征选择：在机器学习中，相关矩阵可以帮助识别高度相关的特征，进而去除冗余的特征，从而提升模型的性能。</p><h3 id="Frobenius-norm"><a href="#Frobenius-norm" class="headerlink" title="Frobenius norm"></a>Frobenius norm</h3><p>弗罗贝尼乌斯范数：一种用于衡量矩阵大小的范数，计算方法是将矩阵中所有元素的平方和开平方。</p><h3 id="KKT-conditions"><a href="#KKT-conditions" class="headerlink" title="KKT conditions"></a>KKT conditions</h3><p>KKT条件（Karush-Kuhn-Tucker Conditions）是非线性规划问题的一组必要条件，用于找到约束优化问题的最优解。</p><p>对于一个优化问题：</p><p>$\begin{aligned}<br>&amp; \min f(\mathbf{x}), \<br>&amp; \text{subject to} \ g_i(\mathbf{x}) \leq 0, \ i &#x3D; 1, \ldots, m, \<br>&amp; \ \ \ \ \ \ \ \ \ \ \ \ \ h_j(\mathbf{x}) &#x3D; 0, \ j &#x3D; 1, \ldots, p,<br>\end{aligned}$</p><p>KKT条件包括以下几个部分：</p><p>拉格朗日函数：</p><p>构造拉格朗日函数 $L(\mathbf{x}, \mathbf{\lambda}, \mathbf{\mu})$：<br>$L(\mathbf{x}, \mathbf{\lambda}, \mathbf{\mu}) &#x3D; f(\mathbf{x}) + \sum_{i&#x3D;1}^{m} \lambda_i g_i(\mathbf{x}) + \sum_{j&#x3D;1}^{p} \mu_j h_j(\mathbf{x})$</p><p>Stationarity（驻点条件）：</p><p>$\frac{\partial L(\mathbf{x}, \mathbf{\lambda}, \mathbf{\mu})}{\partial \mathbf{x}} &#x3D; 0$</p><p>Primal Feasibility（原始可行性）：</p><p>$g_i(\mathbf{x}) \leq 0, \quad i &#x3D; 1, \ldots, m$</p><p>$h_j(\mathbf{x}) &#x3D; 0, \quad j &#x3D; 1, \ldots, p$</p><p>Dual Feasibility（对偶可行性）：</p><p>$\lambda_i \geq 0, \quad i &#x3D; 1, \ldots, m$</p><p>Complementary Slackness（互补松弛性）：</p><p>$\lambda_i g_i(\mathbf{x}) &#x3D; 0, \quad i &#x3D; 1, \ldots, m$</p><h2 id="词汇"><a href="#词汇" class="headerlink" title="词汇"></a>词汇</h2><p>decentralized：分散管理的</p><p>discrepant：有差异的；矛盾的</p><p>deviation：偏离；偏差</p><p>distributed：分布式的</p><p>paradigm：典范</p><p>unified：一致的</p><p>simultaneously：同时的</p><p>hinder：阻碍</p><p>variance：分歧，不一致；方差（统计学）</p><p>empirical：经验主义的</p><p>conventionally：照惯例</p><p>distinguishable：可辨识的</p><p>sparse：稀少的</p><p>refine：精炼；改善</p><p>contamination：污染</p><p>alleviate：减轻，缓和</p><p>contrastive：对比的</p>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习（联邦学习） </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Reforcement learning入门</title>
      <link href="/2025/07/13/Reforcement-learning%E5%85%A5%E9%97%A8/"/>
      <url>/2025/07/13/Reforcement-learning%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p><code>这篇blog用于记录我进行强化学习入门时学习到的基础知识</code></p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>一些基本要素：</p><ol><li>Agent：进行“学习”的主体，会通过学习到的经验与环境交互，并在与环境交互的过程中进一步学习。</li><li>Environment：Agent交互的对象，客观存在，例如智能驾驶捕捉到的一张图片</li><li>State：Agent观察当前自己所处环境，获取到的局部环境信息</li><li>Action：Agent根据State结合自己以往的经验做出的行动，行动会改变Environment（Action可能是离散值，也可能是连续值，处理方法是不同的）</li><li>Reward：Agent执行Action改变Environment后，Environment给到Agent的反馈，可以用于反映Action的好坏，同时为Agent累积“经验”</li></ol><p>进一步，关于Reward的作用：<br>例如将Agent当作一个neural network，其经验就是权重参数θ，坏的Action应该产生一个Reward将θ向“反向”调节，好的Action应该产生一个Reward将θ向“正向”调节。</p><h3 id="基本的工作流程"><a href="#基本的工作流程" class="headerlink" title="基本的工作流程"></a>基本的工作流程</h3><p>强化学习算法的基本工作流程就是，根据Environment产生State输入Agent，Agent做出Action，改变Environment，获得Reward，反馈调整Agent，不断重复。直到满足退出条件</p><h3 id="关于计算机眼中的环境"><a href="#关于计算机眼中的环境" class="headerlink" title="关于计算机眼中的环境"></a>关于计算机眼中的环境</h3><p>通常情况下，计算机眼中的环境是一张图像。</p><p>例如，环境就是各种可能的画面，State就是当前捕捉到的画面，State输入给Agent(NN)，然后由Agent(NN的参数与结构)计算产生Action(决策，或是各种决策的概率)；进一步，也可以理解成State是由画面经过GNN处理后的特征信息…</p><h3 id="强化学习的一个关键问题"><a href="#强化学习的一个关键问题" class="headerlink" title="强化学习的一个关键问题"></a>强化学习的一个关键问题</h3><p>通过前面的基本概念，看似只需要训练一个输入为State，输出为Action的神经网络就可以了，但是事实并非如此。</p><p>因为本质上，这个神经网络不是一个纯粹的有监督学习，并非用于分类与回归的网络，处理的数据没有标签，对于每一个State处理后得到的Action无法立刻得知True or False（类比分类），没有办法直接地对神经网络的参数进行更新，取而代之的是产生一个Good or Bad的Reward，我们最终的目标总是要去最大化这个Reward。（当然，以一个游戏做类比，在进行一系列Action后，我们最终能够得知游戏的结果是胜利或失败，对应True or False，所以说不是纯粹的有监督学习）。</p><p>所以强化学习算法的关键是要有对于每种Action给出合理Reward的方案，并且要有根据Reward去更新模型参数的方案。</p><p>关于<strong>强化学习对比深度学习</strong>例如给出老虎的图片做分类</p><p>深度学习可以用CNN去提取特征，然后根据当前模型参数计算出分类标签，根据估计的标签和真实标签的差异情况，计算损失，根据损失更新模型参数，就完成了一次学习。</p><p>而强化学习对于给出的图片是先由Agent，得出Action，然后有Action与Reward，再去想办法更新模型参数。</p><p>所以，<strong>如何训练一个网络，可以根据Action和Reward进行更新</strong>是强化学习最关键的问题。</p><h2 id="PPO-Proximal-Policy-Optimization-算法"><a href="#PPO-Proximal-Policy-Optimization-算法" class="headerlink" title="PPO(Proximal Policy Optimization)算法"></a>PPO(Proximal Policy Optimization)算法</h2><h3 id="介绍背景"><a href="#介绍背景" class="headerlink" title="介绍背景"></a>介绍背景</h3><p>此部分根据一个飞船降落的小游戏，介绍PPO算法，这个小游戏是一个下降的飞船，玩家应该根据left or right去操作飞船的左右行动，最终让飞船落地时在两个小旗帜中间，即降落在正确的位置。</p><h3 id="再次从深度学习的视角看"><a href="#再次从深度学习的视角看" class="headerlink" title="再次从深度学习的视角看"></a>再次从深度学习的视角看</h3><p>关于神经网络NN（θ）</p><ol><li>输入：使用NN神经网络，输入是当前游戏的图片</li><li>输出：两个Action，左或右</li></ol><p>如果我们使用深度学习，看起来这是一个二分类的问题，很简单。如果说θ作为权重参数会控制，对于每一张图片的分类结果，左或右，代表应该怎样玩。那么我们最终的目标应该是求出一个合适的θ，可以对每一张图片给出合理的决策，其中可以用到梯度下降等等一些常见的方法。</p><p>但是，我们不得不面临一些非常困难的问题，标签（tag）、梯度（gradient）、损失函数（loss function）应该怎样去确定，这是强化学习需要考虑的问题。</p><p>因为不是每一步Action都有一个对应的“正确的”tag，告诉我们的决策是否正确，我们每轮训练，只有一系列的Action，以及最终的一个结果，胜利或失败（或许可以称为tag），那么我们应该如何去定义损失函数？<strong>这就是PPO算法考虑的关键问题，即目标函数的定义方法&amp;如何进行求解</strong></p><h3 id="PPO算法"><a href="#PPO算法" class="headerlink" title="PPO算法"></a>PPO算法</h3><h4 id="episod"><a href="#episod" class="headerlink" title="episod"></a>episod</h4><p>一个完整的过程，其中具有许多的State，Agent根据每个State做出Action，改变环境在此处即根据Action进入下一个State，直到停止的退出条件即完成了一个episod。</p><h4 id="常见的退出条件"><a href="#常见的退出条件" class="headerlink" title="常见的退出条件"></a>常见的退出条件</h4><p>max_step，最大迭代次数，Agent最多只能进行max_step次Action的产生，完成后退出episod；其它退出条件，对于具体的游戏可能需要设置不同的退出条件，例如此处就是飞机落到地面上，episod就完成了。</p><h4 id="整个生命周期的奖励"><a href="#整个生命周期的奖励" class="headerlink" title="整个生命周期的奖励"></a>整个生命周期的奖励</h4><p>$R &#x3D; \sum^{T}_{t&#x3D;1} r_t$，如果考虑退出条件为设置max_step &#x3D; 1000，那么对于Action（$a_1, a_2, \dots, a_1000$），有Reward（$r_1, r_2, \dots, r_1000$），求和后即整个episod的Reward(R)。</p><p>奖励可以类比于标签（用于衡量每次Action的好坏），在一些简单的实验中我们可以使用openAI的工具包gym，其中按照一些经典的小游戏的游戏规则，会<strong>给定好每种Action的Reward</strong>。</p><p>奖励是由当前一步的Action与State共同决定的，预先确定好后，作为游戏规则是不能改变的</p><p>（当然奖励的设置仍然是强化学习的关键，只是在这一部分，对于PPO算法的学习，我们更加关注于<strong>神经网络的设置、目标函数的定义、参数更新的方法</strong>）</p><h4 id="一次游戏的记录结果"><a href="#一次游戏的记录结果" class="headerlink" title="一次游戏的记录结果"></a>一次游戏的记录结果</h4><p>即每一步的状态与行动（trajectory），$\tau &#x3D; {s_1,a_1,s_2,a_2,\dots,s_T,a_T}$（在此基础上，我们需要考虑如何给出每一步的行动，让总的奖励达到最大，即训练一个网络模型$\pi_\theta(a_t|s_t)$，其输入是状态State，输出是Action，由所有的模型参数来根据输入决定输出，训练参数的目标是要让奖励尽可能的大）</p><p>游戏记录的表达式是：</p><p>$p_theta(s_1,a_1,\dots,s_T,a_T) &#x3D; p(s_1)\prod^{T}<em>{t&#x3D;1}\pi_\theta(a_t|s_t)p(s</em>{t+1}|s_t,a_t)$</p><p>含义是得到游戏记录，初始状态是$s_1$执行action，$a_1$，切换到状态，$s_2$执行action，$a_2$，…切换到状态$s_T$执行action，$a_T$的概率是：初始状态是$s_1$的概率连乘上模型在该状态下给出对应action的概率和根据游戏规则，在当前状态下执行相应action后切换到下一对应状态的概率</p><h4 id="Action的产生与作用"><a href="#Action的产生与作用" class="headerlink" title="Action的产生与作用"></a>Action的产生与作用</h4><p>关于Action的产生$p_\theta(a_t|s_t)$，由当前状态确定某一行为的概率，对应Action产生的概率，是模型输出的结果，同时是我们应该关注的问题</p><p>关于Action的作用，$p(s_{t+1}|s_t,a_t)$在某一状态下做出某Action，会切换到下一个状态，这是根据游戏的规则确定的，与我们的模型无关</p><h4 id="一般的强化学习算法的目标与训练过程"><a href="#一般的强化学习算法的目标与训练过程" class="headerlink" title="一般的强化学习算法的目标与训练过程"></a>一般的强化学习算法的目标与训练过程</h4><p>我们的目标是得到一个合适的模型参数 $\theta^{*} &#x3D; argmax_\theta E_{\tau \sim p_\theta(\tau)}[\sum_t r(s_t,a_t)]$</p><p><em>相关理解：</em></p><p>其中$p_\theta(\tau)$表示在策略$\pi_\theta$下，产生轨迹$\tau$的概率分布，即$p_\theta(\tau)$是轨迹 $\tau$ 的概率，其依赖于策略的参数$\theta$。</p><p>在优化目标 $\theta^{*} &#x3D; \arg\max_\theta E_{\tau \sim p_\theta(\tau)}\left[\sum_t r(s_t, a_t)\right]$中，$E_{\tau \sim p_\theta(\tau)}$表示在策略 $\pi_\theta$下，对所有可能的轨迹 $\tau$ 进行期望（期望值的计算）。具体来说，$\tau \sim p_\theta(\tau)$这个下标的含义是：轨迹 $\tau$ 是根据策略 $\pi_\theta$产生的。也就是说，我们考虑的是在当前策略 $\pi_\theta$下，每个轨迹 $\tau$ 出现的概率，并对其累计奖励 $\sum_t r(s_t, a_t)$进行加权平均（即期望值）。</p><p>进一步，根据大数定律</p><p>$E_{\tau \sim p_\theta(\tau)} \approx \frac{1}{N}\sum_{i}\sum_{t}r(s_{i,t},a_{i,t})$其中$N$趋近于$∞$，我们将该期望记作$\mathcal{J}_\theta$</p><p>或者是，期望的展开</p><p>这里直接将$\pi_\theta$记作$\tau$的分布概率，将$\tau$对应的奖励，即刚才的$\sum_t r(s_t, a_t)$记作$r(\tau)$，对期望展开如下:</p><p>$\mathcal{J}(\theta) &#x3D; E_{\tau \sim \pi_\theta(\tau)}[r(\tau)] &#x3D; \int \pi_\theta(\tau)r(\tau)d\tau$</p><p>在期望展开的基础上，我们计算对于参数的梯度</p><p>$\nabla_\theta \mathcal{J}<em>\theta &#x3D; \int \nabla_\theta \pi_\theta (\tau)r(\tau)d\tau &#x3D; \int \pi_\theta(\tau)\nabla_\theta log\pi_\theta(\tau)r(\tau)d\tau &#x3D; E</em>{\tau \sim \pi_\theta(\tau)}[\nabla_\theta log \pi_{\theta}(\tau)r(\tau)]$</p><p>最后，再使用大数定律展开</p><p>$\nabla_\theta \mathcal{J}(\theta) \approx \frac{1}{N}\sum^{N}<em>{i&#x3D;1}(\sum^{T}</em>{t&#x3D;1}\nabla_\theta log \pi_{\theta}(a_{i,t}|s_{i,t}))(\sum^T_{t&#x3D;1}r(s_{i,t},a_{i,t}))$</p><p>注意，这里把得到轨迹$\tau$的概率展开了，把其对应的奖励也展开了</p><p>我们训练的过程就是使用<strong>梯度上升</strong>更新参数，对应为：</p><p>$\theta$ &lt;- $\theta + \alpha \nabla_\theta \mathcal{J}(\theta)$</p><h2 id="蒙特卡洛方法"><a href="#蒙特卡洛方法" class="headerlink" title="蒙特卡洛方法"></a>蒙特卡洛方法</h2><h3 id="Motivating-example"><a href="#Motivating-example" class="headerlink" title="Motivating example"></a>Motivating example</h3><p>Q：我们如何能够不依赖于模型，进行一些预测<br>A：最简单的思想就是，Monte Carlo estimation</p><h4 id="一个例子——抛掷硬币"><a href="#一个例子——抛掷硬币" class="headerlink" title="一个例子——抛掷硬币"></a>一个例子——抛掷硬币</h4><p>定义一个变量$X$，如果正面朝上则$X &#x3D; 1$，否则$X &#x3D; -1$，我们现在要考虑的是如何计算期望$E(X)$</p><p>显然，当我们拥有一个模型（概率分布）的时候，即$X \sim p(X), p(X&#x3D;1)&#x3D;0.5, P(X&#x3D;-1)&#x3D;0.5$，那么我们可以根据期望的定义$E(X) &#x3D; \sum_x xp(x)$快速地求出均值。</p><p>但是当我们没有这个模型的时候呢？即Model-free的情况</p><p>Monte Carlo estimation：进行多次实验，用平均数近似期望</p><p>$E(X) &#x3D; \frac{1}{n}\sum^n_{i&#x3D;1}x_i$</p><p>数学上的支撑就是我们的大数定律（Law of Large Numbers）</p><p>我们知道state value、action value的定义本身就是期望expectations，所以后续我们会用Mente Carlo在Model free的条件下去求state value、action value，并得出相应的策略</p><h3 id="MC-Basic"><a href="#MC-Basic" class="headerlink" title="MC Basic"></a>MC Basic</h3><p>Key quesition：How to convert the policy iteration algorithm to be model-free</p><h4 id="Policy-Iteration"><a href="#Policy-Iteration" class="headerlink" title="Policy Iteration"></a>Policy Iteration</h4><p>策略迭代（Policy Iteration）是强化学习中的一种经典算法，用于解决马尔可夫决策过程（MDP）问题。其目标是找到一个最优策略，使得在该策略下的长期累积奖励最大化。策略迭代由两个主要步骤组成：策略评估（Policy Evaluation）和策略提升（Policy Improvement）。</p><p>策略迭代的步骤</p><p>初始化</p><p>初始化一个任意策略 $\pi$。</p><p>策略评估（Policy Evaluation）</p><p>在策略评估阶段，我们计算当前策略 $\pi$ 的状态价值函数 $V^{\pi}(s)$<br>，即在策略 $\pi$ 下，从状态 $s$ 开始的期望累积奖励。</p><p>通过贝尔曼期望方程迭代地更新 $V^{\pi}(s)$<br>：<br>$  V^{\pi}(s) &#x3D; \sum_{a} \pi(a|s) \sum_{s’} P(s’|s,a) [R(s,a,s’) + \gamma V^{\pi}(s’)]$</p><p>其中，$P(s’|s,a)$是从状态 $s$ 执行动作 $a$ 转移到状态 $s’$的概率，$R(s,a,s’)$是从状态 $s$ 执行动作 $a$ 并转移到状态 $s’$所得到的奖励， $\gamma$ 是折扣因子。</p><p>策略提升（Policy Improvement）</p><p>在策略提升阶段，我们使用当前价值函数 $V^{\pi}(s)$来改进策略 $\pi$。<br>通过贪心策略提升来生成一个新的策略 $\pi’$，使得在每个状态下选择使得期望累积奖励最大的动作：</p><p>$  \pi’(s) &#x3D; \arg\max_{a} \sum_{s’} P(s’|s,a) [R(s,a,s’) + \gamma V^{\pi}(s’)]<br> $</p><p>检查收敛<br>如果新的策略 $\pi’$等于旧的策略 $\pi$（即策略不再变化），则策略迭代过程结束，当前策略即为最优策略。</p><p>否则，更新策略 $\pi \ne \pi’$，继续迭代。</p><h4 id="key-point"><a href="#key-point" class="headerlink" title="key point"></a>key point</h4><p>在Policy Iteration的策略提升过程中，实际上我们不止考虑一个针对当前state的最优action，而是会考虑一系列action，即最优的策略，可以写作：</p><p>$\pi’(s) &#x3D; argmax_\pi \sum_a \pi(a|s) [\sum_r p(r|s,a)r + \gamma \sum_{s’}p(s’|s,a)v_{\pi_k}(s’)] &#x3D; argmax_\pi \sum_a \pi(a|s)q_{\pi_k}(s,a), s \in S$</p><p>问题的关键就在于$q_{\pi_k}(s,a)$这个状态动作值函数，而$\pi(a|s)$为状态s下采取动作a的概率，这在mento carlo考虑的场景下是已知的</p><p>我们回到状态值函数的定义</p><p>$q_{\pi_k}(s,a) &#x3D; E[G_t|S_t &#x3D; s,At &#x3D; a]$</p><p>其中$G_t$是状态s下做出动作a后的累积的奖励；可以看到其本质是一个期望，所以可以用mento carlo的方法来估计它</p><h4 id="具体求解"><a href="#具体求解" class="headerlink" title="具体求解"></a>具体求解</h4><p>1）从任意状态$(s,a)$出发，根据当前策略$\pi_k$，生成一个episode</p><p>2）返回episode的累积奖励$g(s,a)$，这里$g(s,a)$本质上就是状态值函数期望函数中的变量$G_t$的一个采样（sample）</p><p>3）进行多轮采样，令$q_{\pi_k}(s,a) &#x3D; \frac{1}{N}\sum^{N}_{i&#x3D;1}g^{(i)}(s,a)$</p><p>得到了$q_{\pi_k}(s,a)$之后，我们就可以和policy iteration中的第二步一样，去根据这个状态值函数，更新我们的最优策略。<strong>所以mento carlo与policy iteration两者最大的不同就在于值函数的求解，policy iteration不是model-free的，相关的概率是已知的，可以直接根据期望的定义求解，而mento carlo做不到。</strong></p><h2 id="奖励设置"><a href="#奖励设置" class="headerlink" title="奖励设置"></a>奖励设置</h2><p><code>这一部分介绍有关栅格迷宫问题可以使用的奖励设置</code></p><h3 id="目标导向"><a href="#目标导向" class="headerlink" title="目标导向"></a>目标导向</h3><p>当智能体成功到达目标位置时，给予一个较大的正奖励；反之，每一步移动没有到达目标点，可以给予一个较小的负奖励。</p><p>从而让智能体更快地到达目标位置。</p><h3 id="常见的惩罚"><a href="#常见的惩罚" class="headerlink" title="常见的惩罚"></a>常见的惩罚</h3><ol><li>智能体试图移动到不可到达的位置，给予负奖励，防止撞墙</li><li>智能体重复访问同一位置的时候，给予负奖励，防止重复访问</li></ol><h3 id="其它设置"><a href="#其它设置" class="headerlink" title="其它设置"></a>其它设置</h3><p>距离奖励，每步靠近目标给予正奖励；远离目标给予负奖励<br>探索奖励，进入没有探索过的区域给予正奖励，但是逐渐收敛</p>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习（强化学习） </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fairness-Aware Meta-Learning via Nash Bargaining</title>
      <link href="/2025/07/06/Fairness-Aware-Meta-Learning-via-Nash-Bargaining/"/>
      <url>/2025/07/06/Fairness-Aware-Meta-Learning-via-Nash-Bargaining/</url>
      
        <content type="html"><![CDATA[<p><code>这篇blog用于记录我阅读的一篇将传统的Game中的方法应用到学习中的论文</code></p><h2 id="论文理解"><a href="#论文理解" class="headerlink" title="论文理解"></a>论文理解</h2><p>思路：</p><ol><li>经典的Meta-learning的框架</li><li>Meta-learning在learning with fairness中的运用（框架、典型的方法）</li><li>经典方法中存在的问题 &amp; 使用 NBS的改进</li></ol><h3 id="Meta-learning的框架"><a href="#Meta-learning的框架" class="headerlink" title="Meta-learning的框架"></a>Meta-learning的框架</h3><p>在解决机器学习的过程中对于不同group的公平性问题的时候，会使用sensitive-attributed validation set来训练调整模型的参数，这个过程与常规的训练过程相结合通常被套入一个meta-learning framework中。</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><code>用于记录阅读过程中，遇到的新的、不熟悉的概念</code></p><h3 id="Group-level-fairness"><a href="#Group-level-fairness" class="headerlink" title="Group-level fairness"></a>Group-level fairness</h3><p>群体级公平性： 群体级公平性是指在机器学习模型中确保不同群体（如性别、种族、年龄等）在预测结果上受到公平对待。具体来说，这意味着模型的性能（如准确率、误报率等）在不同群体之间应该尽可能一致，避免某些群体受到系统性的偏见或歧视。例如，在招聘系统中，不同性别的候选人应该有相似的通过率，而不是系统性地偏向某一性别。</p><h3 id="Fairness-objectives"><a href="#Fairness-objectives" class="headerlink" title="Fairness objectives"></a>Fairness objectives</h3><p>公平性目标：公平性目标是指在模型训练和评估过程中设定的具体指标，用来衡量和改进模型的公平性。</p><p>常见的公平性目标有：</p><ol><li>Demographic parity：模型的预测结果应该在不同群体之间均匀分布。</li><li>Equalized odds：在不同群体中，模型的假正率和假负率应该相同。</li><li>Equal opportunity：对于实际正类样本，不同群体的真正率应该相同。</li></ol><p>补充：<br>Demographically balanced validation set（人口统计学平衡的验证集）：指在机器学习模型的验证过程中，确保验证集中的数据在人口统计学特征（例如：性别、年龄、种族、收入水平、地理位置等）上具有均衡性。这种平衡的目标是使得模型能够在不同群体之间表现一致，从而避免模型在某些群体上产生偏差或不公平的表现。</p><h3 id="Sensitive-attributed-validation-set"><a href="#Sensitive-attributed-validation-set" class="headerlink" title="Sensitive attributed validation set"></a>Sensitive attributed validation set</h3><p>敏感属性验证集：敏感属性验证集是指包含敏感属性（如性别、种族、年龄等）的数据集，用于评估模型在这些属性上的表现和公平性。通过在验证集上测试模型的表现，可以确定模型是否对某些群体存在偏见，并据此调整模型参数以提升公平性。例如，如果发现模型在不同种族上的准确率差异较大，可以通过调整模型来减少这种差异。</p><h3 id="Meta-learning-framework"><a href="#Meta-learning-framework" class="headerlink" title="Meta-learning framework"></a>Meta-learning framework</h3><p>元学习：指的是“学习如何学习”，即通过学习算法在多个任务上的表现，来调整和优化学习过程本身。在机器学习中，元学习框架通常用于设计模型，帮助它们更好地适应新任务，或者从不同任务中学习出更泛化的知识。</p><p>元学习框架：通过一个高层的学习过程，动态地调整模型的参数，以便满足公平性目标。这种框架让机器学习模型不仅仅是对一个固定任务进行学习，还能调整自己的学习策略，以实现更好的公平性目标。</p><h4 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h4><p>为什么需要Meta-learning</p><p>神经网络在进行猫、狗的图像识别的时候，可能需要数以千计的图片用于训练模型的参数，最终对于新给出的图片神经网络才能给出正确的结果。类比人类的小孩子，在没有见过任何动物的情况下，可能也需要见过许多猫猫狗狗才能正确区分这两种动物。</p><p>在此基础上，出现了一只驴子，人类小孩可以结合以前对于识别猫狗的经验，来观察驴子的特征，通过这一只驴子，在未来就可能正确的识别出新的驴子；但是对于神经网络而言无法做到。</p><p>Meta-learning的目的就是想赋予神经网络这样的能力——基于过去的学习经验，对于新的学习任务，进行一个快速的学习。</p><h4 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h4><p>基本机器学习算法流程：</p><ol><li>Data1，例如(x, y)，x是特征，y是label，将它们输入模型</li><li>Traning1，对Loss求gradient，迭代</li><li>Model1，直到收敛，得到一组权重，对应就是Model1</li></ol><p><em>算法描述：</em></p><p>For all $\mathcal{T}_i$ do<br>Evaluate $\nabla_\theta \mathcal{L}(\mathcal{T}_i, f_\theta)$ with respect to $K$ examples.<br>Compute adapted parameters with gradient descent:<br>$\theta’_i &#x3D; \theta - \alpha \nabla_\theta \mathcal{L}(\mathcal{T}_i, f_\theta)$<br>end for</p><p>实际上这就是Meta learning的inner part，在此基础上加上outer part就是完整的元学习框架。</p><p><em>算法描述：</em></p><p>Require：$p(\mathcal{T})$: distribution over tasks<br>Require: $\alpha, \beta$: step size hyperparameters</p><ol><li>randomly initialize $\theta$</li><li>while not done do</li><li>Sample batch of tasks $\mathcal{T}_i$~$p(\mathcal{T})$</li><li>for all $\mathcal{T}_i do$</li><li>Evaluate $\nabla_\theta \mathcal{L}(\mathcal{T}_i, f_\theta)$ with respect to $K$ examples.  </li><li>Compute adapted parameters with gradient descent:<br>$\theta’_i &#x3D; \theta - \alpha \nabla_\theta \mathcal{L}(\mathcal{T}_i, f_\theta)$  </li><li>end for</li><li>Update $\theta$&lt;-$\theta - \beta \nabla_{\theta} \sum_{\mathcal{T}<em>i ~ p(\mathcal{T})}\mathcal{L}</em>{\mathcal{T}<em>i}(f</em>{\theta’_{i}})$</li><li>end while</li></ol><p>元学习有两个loop，inner loop对应for，outer loop对应while</p><p>inner loop会从很多个模型挑出几个进行训练，$\theta_i$就对应第i个模型（训练器）</p><p>$p(\mathcal{T})$就是所有的Task<br>$\alpha, \beta$是学习率，前者是对每个模型学习的学习率，后者是元学习的学习率</p><p>Update $\theta$&lt;-$\theta - \beta \nabla_{\theta} \sum_{\mathcal{T}<em>i ~ p(\mathcal{T})}\mathcal{L}</em>{\mathcal{T}<em>i}(f</em>{\theta’_{i}})$是最关键的一步，结合inner loop中的所有loss，定义新的loss，再求梯度，用来更新$\theta$。其体现出的是元学习模型是要学习各种小模型的平均能力。</p><p>其好处是你最终得到的$\theta$（对应的各种weights），可以用于作为未来你要训练的用于一个新的任务的小模型时$\theta_{new}$的初始值（新的任务与过去的各种小模型对应的任务相似），这样由于初始的权重天然对应各种小模型的平均能力，其在学习的过程中可以很快地收敛，加快训练速度。</p><h3 id="Hypergradient"><a href="#Hypergradient" class="headerlink" title="Hypergradient"></a>Hypergradient</h3><p>超梯度： 在元学习中，<strong>超梯度（hypergradient）</strong>是指对学习过程本身的梯度进行计算。简单来说，元学习需要优化的目标不仅仅是模型的参数（如权重），还包括学习规则或算法本身的参数（例如学习率）。</p><p>超梯度冲突：在元学习过程中，当不同的子群体（如不同性别或种族的群体）需要不同的调整来实现公平性目标时，这些调整可能会产生冲突。例如，为了在某个群体上实现某个公平性目标，可能需要对模型的某个参数进行特定的调整，但对另一个群体却可能会产生不利影响，导致不同的公平性目标之间无法兼容。这样的冲突会导致模型优化过程的不稳定，甚至可能使得模型的性能和公平性都受到影响。</p><h3 id="validation-loss"><a href="#validation-loss" class="headerlink" title="validation loss"></a>validation loss</h3><p>验证损失：在验证集上评估模型性能时计算得到的损失值。它衡量了模型在验证集上的预测误差。通常来说，训练过程中，我们希望看到训练损失（training loss）和验证损失（validation loss）都逐渐降低，这表明模型在不断学习和提高性能。</p><p>损失（loss）：是模型预测结果与实际标签之间差异的度量。它通常表示为一个数值，表示模型在进行预测时的“错误程度”。常见的损失函数有均方误差（MSE）、交叉熵损失（Cross-Entropy Loss）等。</p><p>验证集：一个与训练集和测试集不同的数据集，通常用于在训练过程中对模型进行评估和调优。验证集用于检查模型的泛化能力——即模型能否在没有见过的数据上表现良好。</p><p>注：<strong>如果验证损失开始增加，而训练损失继续降低，可能表明模型在训练数据上过拟合，即模型学习了训练数据中的噪声和不相关的细节，而不是学到了一般性的规律。</strong></p><h3 id="social-context-of-a-learning-system"><a href="#social-context-of-a-learning-system" class="headerlink" title="social context of a learning system"></a>social context of a learning system</h3><p>Environment： 在传统的机器学习中，环境通常指的是模型与之交互并从中获取数据的外部系统或空间。例如，在强化学习中，智能体（agent）通过与环境交互来学习和优化其决策策略。在这个语境下，“环境”通常被视为一个相对抽象的、无差别的对象，包含了所有外部因素，模型仅通过这些因素进行训练。</p><p>Scarcity：稀缺性指的是资源（如时间、金钱、机会等）在社会中是有限的。在机器学习系统的社交背景下，稀缺性涉及到社会资源的分配问题，如何在有限的资源中做出选择，尤其是在多个利益相关方或群体之间进行权衡。</p><p>Conflict：冲突指的是在社会环境中，由于利益、目标或观点的差异，可能会出现对立或争执。在机器学习中，这个概念可以指不同利益相关者之间（如不同用户、群体、公司等）在使用技术时可能产生的矛盾与对立。例如，算法可能会在某些群体之间造成不平等，从而引发冲突。</p><p>Social norms：社会规范是指在某一社会群体中广泛接受和遵守的行为标准和价值观。它们定义了个体之间的行为预期。例如，公平性和诚信可能是许多社会群体的核心规范。机器学习系统在部署时需要考虑这些社会规范，以避免做出违反社会价值观的决策。</p><p>Communication：在机器学习的社会背景中，沟通通常指的是人与人、人与机器之间的信息交换。在机器学习系统中，沟通可能涉及模型与用户或开发者之间的反馈机制，以及如何有效地传达模型的意图、预测和决策。</p><p>Trust： 信任是指个体或群体对系统、技术或他人的可靠性和诚实性的信念。在机器学习系统中，信任至关重要，尤其是在人们需要依赖算法做出决策时。例如，如果用户不信任推荐系统或自动驾驶车辆的决策，那么这些系统的使用将受到限制。信任的缺失可能导致模型的抵制或不使用。</p><p>Fairness：公平性是指在决策或资源分配过程中，各方是否受到平等对待。机器学习中的公平性问题通常与算法可能对特定群体或个体产生不公正的偏见有关。例如，性别、种族、年龄等因素可能影响模型的预测结果。解决机器学习中的公平性问题，通常需要确保不同群体在模型中的待遇是平等的，避免不必要的偏见和歧视。</p><h3 id="Bi-level-optimization"><a href="#Bi-level-optimization" class="headerlink" title="Bi-level optimization"></a>Bi-level optimization</h3><p>双层优化：一种优化问题，其中的优化过程分为两个层级：上层优化和下层优化。每一层都有自己的优化目标和约束条件，而下层优化的解通常会影响上层优化的目标函数。</p><p>上层优化：这是优化问题的“外层”或“主层”，目标是优化一个总体目标，这通常是由下层优化问题的解所决定的。</p><p>下层优化：这是优化问题的“内层”或“子问题”，其目标是最小化或最大化一个局部目标。这个问题通常是通过上层优化问题中的参数来定义的，或者说下层优化问题的解是上层优化问题的约束之一。</p><p>在元学习中的应用：假设我们有一个双层优化问题，其中上层优化的目标是选择最优的模型参数，而下层优化则通过训练模型来优化模型的性能。这种结构常见于元学习（Meta-learning）和模型调优等问题中。例如，在元学习中，上层优化可能是学习一个优化策略，而下层优化则是针对特定任务的参数优化。</p><p>形式化：<br>双层优化问题通常可以用以下数学表达式来表示：</p><p>上层问题（Outer problem）：<br>$  \min_{\theta} , F(\theta, \mathbf{z}^*(\theta))$</p><p>其中，$\theta$ 是上层优化的决策变量，$\mathbf{z}^*(\theta)$<br>  是下层优化问题的最优解，它依赖于$\theta$。</p><p>下层问题（Inner problem）：<br>$  \min_{\mathbf{z}} , G(\mathbf{z}, \theta)$</p><p>其中，$\mathbf{z}$ 是下层优化的决策变量，$G(\mathbf{z}, \theta)$ 是下层优化问题的目标函数，$\theta$ 是从上层优化传递下来的参数。</p><h3 id="minibatch"><a href="#minibatch" class="headerlink" title="minibatch"></a>minibatch</h3><p>在机器学习和深度学习中，一种将大型数据集分割成较小的子集进行训练的方法。这种方法可以加速训练过程，同时减少计算资源的需求。</p><h2 id="词汇"><a href="#词汇" class="headerlink" title="词汇"></a>词汇</h2><p>aggregation：聚合</p><p>monotonic：单调的</p><p>steer：引导</p><p>navigate the issue：解决</p><p>validation：验证</p><p>emerging applications：新兴应用</p><p>lump：整合、混淆</p><p>deployment：部署</p><p>amplification：扩大、引申</p><p>clarity：清晰</p><p>align with：保持一致</p><p>address：解决</p><p>integrate：整合、合并</p><p>disparity：不一致</p><p>demographic：具有某种特征的群体；人口的</p><p>epochs：迭代次数</p><p>prevalence：流行、普遍存在</p><p>intrinsic：固有的</p><p>alignment issues：不一致问题</p><p>be derived by：由…推导出</p><p>untenable：站不住脚的</p><p>circumvent：回避</p><p>consensus：共识</p><p>intermediate：居中的、中等程度的</p><p>feasible：可行的、很可能会发生的</p>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习（元学习） </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拜占庭将军问题与计算机系统的一致性</title>
      <link href="/2025/05/25/%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%B0%86%E5%86%9B%E9%97%AE%E9%A2%98%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7/"/>
      <url>/2025/05/25/%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%B0%86%E5%86%9B%E9%97%AE%E9%A2%98%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="拜占庭将军问题是什么（它阐述了什么）？"><a href="#拜占庭将军问题是什么（它阐述了什么）？" class="headerlink" title="拜占庭将军问题是什么（它阐述了什么）？"></a>拜占庭将军问题是什么（它阐述了什么）？</h2><p>对于n个将军，将一个视为指挥将军，其它n-1个视作它的副将，指挥将军会向所有副将发送命令。在此基础上，拜占庭将军问题就是考虑一种算法，确保1）所有忠诚的副将将遵守相同的命令；2）如果指挥将军是忠诚的，则每个忠诚的副将都必须遵循他发送的命令。</p><h2 id="如何确保忠诚的将军能够达成一致的行动计划？"><a href="#如何确保忠诚的将军能够达成一致的行动计划？" class="headerlink" title="如何确保忠诚的将军能够达成一致的行动计划？"></a>如何确保忠诚的将军能够达成一致的行动计划？</h2><p>对于只能使用口头消息的时候，在叛徒数少于总数的三分之一的时候，忠诚的将军能够按照下面的方法达成一致的行动：我们将第一个发送决策值的将军看错指挥官；在0个叛徒时，指挥官将决策值传递给副将，副将根据接收到的消息，或默认的撤退，直接做出对应的决策；在m个叛徒时，副将们递归地充当新的指挥官，向其它副将传递决策的值，每递归一次认为叛徒数减少一个；所有递归完成后，最终每位将军都会从其它将军哪里收到一系列决策，从这些决策中采取占多数的作为自己的决策即可。</p><p>对于使用带签名消息时可以解决任意叛徒数的情况。将军之间每一次发送信息的时候都附带上自己的签名，这样的话只要出现了篡改信息（B收到A签名的Attack，收到A签名+C签名的Rtreat，C是叛徒）或发送误导信息（B收到C签名的Attack，A收到C签名的Rtreat，C是叛徒）的情况，可以直接判断出谁是判断。排除或减少一定数量的叛徒之后，就可以进一步协商达成一致的行动。</p><h2 id="拜占庭将军问题的解决方案能够应用于哪些计算机领域？"><a href="#拜占庭将军问题的解决方案能够应用于哪些计算机领域？" class="headerlink" title="拜占庭将军问题的解决方案能够应用于哪些计算机领域？"></a>拜占庭将军问题的解决方案能够应用于哪些计算机领域？</h2><p>其解决方案主要应用于确保计算机系统的可靠性。尤其是存在故障组件，向系统的不同部分发送冲突信息的情况。具体的相关领域，可以是我们课堂上了解到的，用于确保分布式系统的一致性，用于保障区块链和加密货币中交易的有效性和账本的一致性等等的要求高可靠性的场景。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式的原子性与一致性</title>
      <link href="/2025/05/25/%E5%88%86%E5%B8%83%E5%BC%8F%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7%E4%B8%8E%E4%B8%80%E8%87%B4%E6%80%A7/"/>
      <url>/2025/05/25/%E5%88%86%E5%B8%83%E5%BC%8F%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7%E4%B8%8E%E4%B8%80%E8%87%B4%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p><code>一次计算机系统工程导论的习题</code></p><h2 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h2><p>选择：A</p><p>因为小明的客户端到S3之间的网络经常停止工作，每次几分钟，而根据伪代码，在更新S3服务器上的信息的时候，while循环会一直尝试直到rpc_OK被置为true为止。所以CLENTWRITE通常需要花费几分钟（S3导致的）或更长的时间（可能不排除S1、S2也有出问题的可能性），去更新服务器。</p><h2 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h2><p>返回：Breakfast</p><p>因为在系统没有故障的时候，该分布式系统的一致性是有得到保障的，根据题目中串行执行的代码，读取到的内容会是最后一次写入的内容，对应为Breakfast。</p><h2 id="问题三"><a href="#问题三" class="headerlink" title="问题三"></a>问题三</h2><p>选择：AB</p><p>对于A，如果客户端计算机是在已经完成最后一次CLENTWRITE操作中对部分服务器的更新，那么当使用CLIENTREAD的时候就可能出现A的结果。</p><p>对于B，如果是在CLIENTWRITE (0,11, “Talk to Frans at 11”)刚刚完成的时候，发生了重启，那么使用CLIENTREAD就可能出现B的结果。</p><p>对于C，Breakfast at 10意味着最后一次更新服务器已经部分完成，这与 Free at 11是矛盾的。</p><p>对于D，与C同理，存在矛盾。</p><h2 id="问题四"><a href="#问题四" class="headerlink" title="问题四"></a>问题四</h2><p>选择：ABD</p><p>对于A，如果所有服务器顺利更新，对应为A的结果</p><p>对于B，如果客户端重启前已经顺利执行完CLIENTWRITE (0,10,”Talk to Frans at 10”)，对应为B的结果。</p><p>对于C，CLIENTWRITE (0,10, “Breakfast at 10”)至少已经对部分服务器完成了更新，这意味着CLIENTWRITE (0,11, “Talk to Frans at 11”)已经对服务器完成了更新，那么不应该出现Free at 11，所以C错误</p><p>对于D，如果CLIENTWRITE (0,10,”Talk to Frans at 10”)只是对部分服务器完成更新例如S1、S2，那么S3中对应保存的仍然是Free at 10。当执行CLIENTREAD的时候，如果第一次从S1或S2顺利读取了结果，但是第二次S1、S2的网络出现了问题，从S3读取了结果，则可能出现这样的情况。</p><h2 id="问题五"><a href="#问题五" class="headerlink" title="问题五"></a>问题五</h2><p>选择：ACD</p><p>对于A，如果所有更新与读取都正常，那么得到的会是A的结果。</p><p>对于B，在第二次读取的时候还没有尝试过“Z”的写入，不会读取到“Z”，故错误。</p><p>对于C，如果第二次更新尝试没有一个服务器成功更新，其它操作均正常，则可能得到C的结果。</p><p>对于D，如果第一次更新均正常，第二次更新部分正常例如S1被更新，第三次没有成功更新任何服务器。第一次读取正常，第二次读取从S1读取到了结果，第三次读取从S2或S3读取到结果，则可能出现这样的情况。</p><h2 id="问题六"><a href="#问题六" class="headerlink" title="问题六"></a>问题六</h2><p>选择：A</p><p>因为小明原本的系统在CLIENTWRITE的时候对每个服务器使用了while循环来确保rpc_OK&#x3D;true，这意味着要么对服务器完成更新，要么客户端一直执行CLIENTWRITE。所以如果顺利读取到三个结果，只能是正确的结果，即A对应的结果，其它情况都不可能出现。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>毛概复习</title>
      <link href="/2025/05/18/%E6%AF%9B%E6%A6%82%E5%A4%8D%E4%B9%A0/"/>
      <url>/2025/05/18/%E6%AF%9B%E6%A6%82%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p><code>用于记录我线上练习时遇到的知识点，以供日后复习的时候对照书本查看</code><br><code>毛概与习概的复习思路都是先线上练习，记录知识点，期末的时候对照书本查看小题，同时背诵大题</code><br><code>复习的时候要注意可能的题目变形</code></p><h2 id="第二阶段题库"><a href="#第二阶段题库" class="headerlink" title="第二阶段题库"></a>第二阶段题库</h2><h3 id="二十届三中全会"><a href="#二十届三中全会" class="headerlink" title="二十届三中全会"></a>二十届三中全会</h3><p>1</p><blockquote><p>2024年7月15至18日，二十届三中全会在北京举行。全会指出，到<strong>2029</strong>年，完成《决定》提出的改革任务。</p></blockquote><p>2</p><blockquote><p>二十届三中全会提出，要健全因地制宜发展新质生产力体制机制，推动<strong>技术革命性突破</strong>，<strong>生产要素创新性配置</strong>和<strong>产业深度转型升级</strong>。<br>（没有实体经济数字化，可以想想，确实实体经济难道一定要数字化吗？有的经济可能本身就不适合数字化…）</p></blockquote><p>3</p><blockquote><p>党的二十届三中全会指出，<strong>坚持系统观念</strong>处理好经济和社会、政府和市场、效率和公平、活力和秩序、发展和安全等重大关系，增强改革系统性、整体性、协同性。<br>（坚持系统观念可以帮助处理一系列重大关系）</p></blockquote><p>4</p><blockquote><p>二十届三中全会指出，推动生产关系和生产力、上层建筑和经济基础、治理体系和治理能力更好相适应，为中国式现代化提供强大动力和制度<br>保证。（<strong>错误</strong>）</p></blockquote><p>5</p><blockquote><p>中国式现代化的鲜明标志是开放（<strong>正确</strong>）</p></blockquote><h3 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h3><p>1</p><blockquote><p>下列属于邓小平南方谈话终提出的重要论断的有<br>1）要提倡科学，靠科学才有希望<br>2）革命是解放生产力，改革也是解放生产力<br>3）“三个有利于”标准<br>4）社会主义可以搞市场经济</p></blockquote><p>2</p><blockquote><p>2000年的宪法修正案正式将邓小平理论载入宪法（<strong>错误</strong>）</p></blockquote><p>3</p><blockquote><p>党的十七大把科学发展观确立为党必须长期坚持的指导思想（<strong>错误</strong>）</p></blockquote><p>4</p><blockquote><p>邓小平在<strong>党的十二大</strong>上提出“走自己的道路，建设有中国特色的社会主义”的论断，中国特色社会主义成为了党的全部理论和实践创新主题。</p></blockquote><p>5</p><blockquote><p>新世纪新阶段，我国进入<strong>发展关键期、改革攻坚期和矛盾凸显期</strong>，经济社会发展呈现一系列新的阶段性特征。<br>（没有开放活跃期）</p></blockquote><p>6</p><blockquote><p>中国特色社会主义理论体系形成时期的时代主题是<strong>和平与发展</strong></p></blockquote><h3 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h3><p>1</p><blockquote><p>邓小平指出社会主义的本质是<br>1）解放生产力，发展生产力<br>2）消灭剥削，消除两极分化<br>3）最终达到共同富裕<br><strong>没有以经济建设为中心</strong></p></blockquote><p>2</p><blockquote><p>1978年12月召开的党的十一届三中全会，做出了以下重大决策<br>1）重新确立了解放思想、实事求是的思想路线<br>2）批评了“两个凡是”的错误方针<br>3）确定把党和国家的工作重点转移到社会主义现代化建设上来的战略决策<br><strong>因为是“决策”，所以没有“提高了对科学社会主义的认识”</strong></p></blockquote><p>3</p><blockquote><p>发展社会主义市场经济是当代中国的鲜明标志和活力源泉，是决定中国命运的关键一招（<strong>错误</strong>）</p></blockquote><p>4</p><blockquote><p>邓小平认为和平是东西问题，发展是南北问题（<strong>正确</strong>）</p></blockquote><p>5</p><blockquote><p>1997年党的十五大指出不发达的社会生产力水平是中国最大的实际（<strong>错</strong>）</p></blockquote><p>6</p><blockquote><p>党的十四大把<strong>建立社会主义市场经济体制</strong>作为我国经济体制改革的目标</p></blockquote><p>7</p><blockquote><p>在社会主义的依靠力量上，<strong>人民群众</strong>是我们党的力量源泉和胜利之本</p></blockquote><p>8</p><blockquote><p>为了更好实现“三步走”的现代化发展战略，邓小平提出了以重点带动全局的思想。1982年他提出了三个战略重点，包括了<strong>农业、能源和交通、教育和科学</strong><br>（没有文化与技术、工业与金融）</p></blockquote><p>9</p><blockquote><p>以经济建设为中心是改变我国不发达现状的需要，也体现了社会主义奋斗精神。（<strong>错误</strong>）<br>（我国的现状不是不发达，人民日益增长的…）</p></blockquote><h3 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h3><p>1</p><blockquote><p>贯彻“三个代表”重要思想，关键在<strong>坚持与时俱进</strong><br>(或许核心在执政为民)</p></blockquote><p>2</p><blockquote><p>坚持中国共产党的领导，就是要<br>1）2）3）4）</p></blockquote><p>3</p><blockquote><p>社会主义的根本任务是<strong>发展社会生产力</strong><br>（不是实现共同富裕）</p></blockquote><p>4</p><blockquote><p>建设社会主义政治文明，最根本的就是要<strong>坚持党的领导、人民当家作主和依法治国的有机统一。</strong></p></blockquote><p>5</p><blockquote><p>江泽民强调，我们想做事，做工作，想得对不对，做得好不好，根本的衡量尺度就是<br>1）2）3）4） 人民…</p></blockquote><p>6</p><blockquote><p>党的领导是人民当家做主和依法治国的根本保证（<strong>正确</strong>）</p></blockquote><p>7</p><blockquote><p>推进党的建设新的伟大工程，重点是加强<strong>党的执政能力建设</strong></p></blockquote><p>8</p><blockquote><p>始终做到“三个代表”，是我们党的<strong>立党之本、执政之基和力量之源</strong><br>（没有兴国之要）</p></blockquote><h3 id="第八章"><a href="#第八章" class="headerlink" title="第八章"></a>第八章</h3><p>1</p><blockquote><p><strong>科学技术</strong>是先进生产力的集中体现和主要标志</p></blockquote><p>2</p><blockquote><p>以<strong>科学发展</strong>为主题，是时代的要求，关系改革开放和现代化建设全局</p></blockquote><p>3</p><blockquote><p><strong>自主创新</strong>是科技发展的灵魂，是一个民族发展的不竭动力，是支撑国家崛起的筋骨</p></blockquote><p>4</p><blockquote><p>坚持统筹兼顾，妥善处理社会主义事业重大关系，包括<br>1）统筹城乡发展<br>2）统筹区域发展<br>3）统筹经济社会发展<br>4）统筹国内发展和对外开放<br>5）统筹人与自然和谐发展</p></blockquote><p>5</p><blockquote><p><strong>扩大内需</strong>是我国经济社会发展的基本立足点和长期战略方针，也是调整经济结构的首要任务。</p></blockquote><p>6</p><blockquote><p><strong>建设生态文明</strong>关系人民福祉，关乎民族未来的长远大计</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 大学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nash-MTL（代码实现）</title>
      <link href="/2025/05/16/Nash-MTL/"/>
      <url>/2025/05/16/Nash-MTL/</url>
      
        <content type="html"><![CDATA[<p><code>这篇blog用于记录我阅读Nash-MTL算法基于python的implemention，其中存在大量使用pytorch、tensorflow的地方，这些是我之前几乎没有接触过的东西，所以同时我也会进行相关的记录，进行学习。</code></p><h2 id="Readme"><a href="#Readme" class="headerlink" title="Readme"></a>Readme</h2><p><code>整篇blog从Nash-MTL开源项目的Readme文档开始，可以帮助我了解整个项目的文件组织结构。</code></p><h3 id="conda"><a href="#conda" class="headerlink" title="conda"></a>conda</h3><p>在Python中，conda 是一个开源的包管理器和环境管理器，它主要用于安装和管理Python包以及创建和管理虚拟环境。</p><h4 id="什么是包管理器和环境管理器"><a href="#什么是包管理器和环境管理器" class="headerlink" title="什么是包管理器和环境管理器"></a>什么是包管理器和环境管理器</h4><p>通过查阅资料，我现在通俗的理解是：</p><ol><li>包&#x2F;库，项目开发过程中用到的封装好的<strong>编程语言（或第三方）预置代码</strong></li><li>环境，当前项目所基于的所有包&#x2F;库的总称，是<strong>项目的外部依赖</strong></li></ol><h4 id="一个困惑"><a href="#一个困惑" class="headerlink" title="一个困惑"></a>一个困惑</h4><p>我之前一直有这样的困惑：为什么Py的各种包不能像C++的库一样，一次下载，可以在任何项目文件中使用；就例如numpy而言，每次我都需要在新的项目目录中通过pip重新下载，然后再导入到文件。</p><p>这次我查阅了相关资料，了解到：</p><ol><li><p>C++和Python本身对包管理“如何依赖”的设计就不同，C++ 没有官方统一的包管理工具，依赖通常由系统包管理器（如 apt、brew）或手动安装到系统目录。这种设计<strong>适合系统级工具</strong>，但容易导致版本冲突；Python 通过虚拟环境（如 venv、conda）为每个项目创建独立的依赖环境，避免全局污染。这是为了解决 Python 生态中<strong>广泛存在</strong>的依赖版本冲突问题。</p></li><li><p>C++的标准库（如STL）是语言规范的一部分，与编译器深度绑定。因此具有特权地位，它们的实现（如 libstdc++ 或 libc++）随编译器安装，因此无需额外管理。但是第三方的库（如OpenCV）仍需手动管理，其使用方式更接近 Python 的第三方包。所以并非C++不需要额外的包管理就可以一次安装随意使用，而是我目前的学识并没有接触到需要包管理的地方。</p></li><li><p>Python 标准库与第三方包的平等性，如 os、sys虽然随解释器预装，但第三方包（如 numpy）在导入机制上与标准库完全平等。</p></li><li><p>Python的虚拟环境使得包不能直接全局复用，但是这并非强制的，如果不使用虚拟环境，第三方包会被安装到全局 site-packages，所有项目共享。但这会导致：不同项目依赖的版本冲突；无权限修改全局环境（例如在服务器上）。因此，<strong>虚拟环境是 Python 社区的最佳实践</strong>，而非技术限制。</p></li></ol><h3 id="项目的文件组织"><a href="#项目的文件组织" class="headerlink" title="项目的文件组织"></a>项目的文件组织</h3><p>整个nash-mtl下包含两个主要dir</p><ol><li>experiments，其中包含了3个MTL任务文件相关代码</li><li>methods，其中包含了可以用于处理MTL任务的算法代码</li></ol><p>二者的关系，experiments中<code>trainer.py</code>是任务入口，对于每一个任务，我们可以指定一个methods中的算法来解决。</p><p>于是，<strong>接下来我打算从toy任务入手，先阅读任务文件代码，再阅读methods中Nash-MTL算法部分的代码</strong></p><h2 id="packages：torch"><a href="#packages：torch" class="headerlink" title="packages：torch"></a>packages：torch</h2><h3 id="clamp"><a href="#clamp" class="headerlink" title="clamp"></a>clamp</h3><p>在 PyTorch 中，torch.clamp 是一个非常实用的函数，主要用于对张量中的元素进行截断（clamping），将其限制在一个指定的区间范围内。</p><p>原型</p><blockquote><p>torch.clamp(input, min&#x3D;None, max&#x3D;None) → Tensor</p></blockquote><p>input<br>类型：Tensor<br>需要进行截断操作的输入张量。</p><p>min<br>类型：float 或 None（默认值）<br>指定张量中元素的最小值。小于 min 的元素会被截断为 min 值。<br>如果设置为 None，则表示不限制最小值。</p><p>max<br>类型：float 或 None（默认值）<br>指定张量中元素的最大值。大于 max 的元素会被截断为 max 值。<br>如果设置为 None，则表示不限制最大值。</p><p>返回值<br>返回一个新的张量，其中元素已经被限制在 ([min, max]) 的范围内。<br>原张量不会被修改（函数是非原地操作），除非使用 torch.clamp_ 以进行原地操作。</p><p>参考资料来源：<br><a href="https://blog.csdn.net/shizheng_Li/article/details/144432030">CSDN</a></p><h3 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h3><p>torch.stack() 是一个非常有用的函数，用于沿着指定的维度（dim）将多个张量（Tensor）合并成一个新的张量。它可以把一个包含多个张量的序列（比如一个列表或元组）按照给定的维度拼接成一个新的张量。</p><p>原型</p><blockquote><p>torch.stack(tensors, dim&#x3D;0, out&#x3D;None)→ Tensor</p></blockquote><p>tensors: 一个包含多个张量的序列（例如列表或元组）。这些张量必须具有相同的形状（即，除了要拼接的维度外，其他所有维度的大小必须相同）。<br>dim: 沿着哪个维度进行拼接。dim 参数决定了新张量的形状以及拼接方向。这个参数的值可以是负数，表示从最后一个维度开始倒数。<br>out: 可选，指定输出张量。如果没有提供，函数会自动生成一个新的张量。</p><p>补充：关于dim，假设原始的tensor.size() &#x3D; ([x,y,z])，参与拼接的tensor共有a个，dim&#x3D;0，1，2，3的结果分别为：</p><ol><li>tensor.size() &#x3D; ([a,x,y,z])</li><li>tensor.size() &#x3D; ([x,a,y,z])</li><li>tensor.size() &#x3D; ([x,y,a,z])</li><li>tensor.size() &#x3D; ([x,y,z,a])</li></ol><p>相应的tensor的“形状”也会有所改变，但是其中包含的信息却是没有改变的，而dim &#x3D; 0是比较容易理解也是比较常用的</p><p><a href="https://blog.csdn.net/qq_40507857/article/details/119854085">CSDN</a></p><h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h3><p>在给定维度上拼接输入序列 tensors 中的张量。所有张量除了拼接维度外必须具有相同的形状，或者是一个大小为 (0,) 的一维空张量。</p><p>原型</p><blockquote><p>torch.cat(tensors, dim&#x3D;0, *, out&#x3D;None) → Tensor</p></blockquote><p>tensors (Tensor 序列) – 提供的非空张量除了拼接维度外必须具有相同的形状。</p><p>dim (int, 可选) – 拼接张量的维度</p><p>out (Tensor, 可选) – 输出张量。</p><p>示例</p><pre><code>&gt;&gt;&gt; x = torch.randn(2, 3)&gt;&gt;&gt; xtensor([[ 0.6580, -1.0969, -0.4614],    [-0.1034, -0.5790,  0.1497]])&gt;&gt;&gt; torch.cat((x, x, x), 0)tensor([[ 0.6580, -1.0969, -0.4614],    [-0.1034, -0.5790,  0.1497],    [ 0.6580, -1.0969, -0.4614],    [-0.1034, -0.5790,  0.1497],    [ 0.6580, -1.0969, -0.4614],    [-0.1034, -0.5790,  0.1497]])&gt;&gt;&gt; torch.cat((x, x, x), 1)tensor([[ 0.6580, -1.0969, -0.4614,  0.6580, -1.0969, -0.4614,  0.6580,     -1.0969, -0.4614],    [-0.1034, -0.5790,  0.1497, -0.1034, -0.5790,  0.1497, -0.1034,     -0.5790,  0.1497]])</code></pre><p>注意其与stack的区别，它不会增加新的维度，而是在指定的维度上将所有的tensor拼接到一起</p><h3 id="torch-autograd-grad"><a href="#torch-autograd-grad" class="headerlink" title="torch.autograd.grad()"></a>torch.autograd.grad()</h3><p><a href="https://zhuanlan.zhihu.com/p/279758736">知乎</a></p><h2 id="Experiment：toy"><a href="#Experiment：toy" class="headerlink" title="Experiment：toy"></a>Experiment：toy</h2><h3 id="train-py"><a href="#train-py" class="headerlink" title="train.py"></a>train.py</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> wandb</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">from</span> argparse <span class="keyword">import</span> ArgumentParser</span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> experiments.toy.problem <span class="keyword">import</span> Toy</span><br><span class="line"><span class="keyword">from</span> experiments.toy.utils <span class="keyword">import</span> plot_2d_pareto</span><br><span class="line"><span class="keyword">from</span> experiments.utils <span class="keyword">import</span> (</span><br><span class="line">    common_parser,</span><br><span class="line">    extract_weight_method_parameters_from_args,</span><br><span class="line">    set_logger,</span><br><span class="line">)</span><br><span class="line"><span class="keyword">from</span> methods.weight_methods <span class="keyword">import</span> WeightMethods</span><br><span class="line"></span><br><span class="line">set_logger()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">method_type, device, n_iter, scale</span>):</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 选定MTL参数θ更新方法</span></span><br><span class="line">    weight_methods_parameters = extract_weight_method_parameters_from_args(args)</span><br><span class="line">    n_tasks = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 确定任务函数</span></span><br><span class="line">    F = Toy(scale=scale)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 用于描述优化过程的损失函数变化的轨迹</span></span><br><span class="line">    all_traj = <span class="built_in">dict</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># the initial positions（初始参数）</span></span><br><span class="line">    inits = [</span><br><span class="line">        torch.Tensor([-<span class="number">8.5</span>, <span class="number">7.5</span>]),</span><br><span class="line">        torch.Tensor([<span class="number">0.0</span>, <span class="number">0.0</span>]),</span><br><span class="line">        torch.Tensor([<span class="number">9.0</span>, <span class="number">9.0</span>]),</span><br><span class="line">        torch.Tensor([-<span class="number">7.5</span>, -<span class="number">0.5</span>]),</span><br><span class="line">        torch.Tensor([<span class="number">9</span>, -<span class="number">1.0</span>]),</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i, init <span class="keyword">in</span> <span class="built_in">enumerate</span>(inits):</span><br><span class="line">        <span class="comment"># init对应每个初始参数，i用于索引轨迹存储在all_traj中的位置</span></span><br><span class="line">        traj = []</span><br><span class="line">        x = init.clone()</span><br><span class="line">        x.requires_grad = <span class="literal">True</span></span><br><span class="line">        x = x.to(device)</span><br><span class="line"></span><br><span class="line">        method = WeightMethods(</span><br><span class="line">            method=method_type,</span><br><span class="line">            device=device,</span><br><span class="line">            n_tasks=n_tasks,</span><br><span class="line">            **weight_methods_parameters[method_type],</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 优化器初始化，确定了其要同时优化x（任务的参数）、具体method的参数；lr是学习率</span></span><br><span class="line">        optimizer = torch.optim.Adam(</span><br><span class="line">            [</span><br><span class="line">                <span class="built_in">dict</span>(params=[x], lr=<span class="number">1e-3</span>),</span><br><span class="line">                <span class="built_in">dict</span>(params=method.parameters(), lr=args.method_params_lr),</span><br><span class="line">            ],</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> tqdm(<span class="built_in">range</span>(n_iter)):</span><br><span class="line">            traj.append(x.cpu().detach().numpy().copy())</span><br><span class="line"></span><br><span class="line">            optimizer.zero_grad()</span><br><span class="line">            f = F(x, <span class="literal">False</span>) <span class="comment"># 计算损失函数</span></span><br><span class="line">            <span class="comment"># 根据选定方法，“反向传播”更新参数，我在复现时用的nashmtl</span></span><br><span class="line">            _ = method.backward( </span><br><span class="line">                losses=f,</span><br><span class="line">                shared_parameters=(x,),</span><br><span class="line">                task_specific_parameters=<span class="literal">None</span>,</span><br><span class="line">                last_shared_parameters=<span class="literal">None</span>,</span><br><span class="line">                representation=<span class="literal">None</span>,</span><br><span class="line">            )</span><br><span class="line">            optimizer.step()</span><br><span class="line"></span><br><span class="line">        all_traj[i] = <span class="built_in">dict</span>(init=init.cpu().detach().numpy().copy(), traj=np.array(traj))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> all_traj</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    parser = ArgumentParser(</span><br><span class="line">        <span class="string">&quot;Toy example (modification of the one in CAGrad)&quot;</span>, parents=[common_parser]</span><br><span class="line">    )</span><br><span class="line">    parser.set_defaults(n_epochs=<span class="number">35000</span>, method=<span class="string">&quot;nashmtl&quot;</span>, data_path=<span class="literal">None</span>)</span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">&quot;--scale&quot;</span>, default=<span class="number">1e-1</span>, <span class="built_in">type</span>=<span class="built_in">float</span>, <span class="built_in">help</span>=<span class="string">&quot;scale for first loss&quot;</span></span><br><span class="line">    )</span><br><span class="line">    parser.add_argument(<span class="string">&quot;--out-path&quot;</span>, default=<span class="string">&quot;outputs&quot;</span>, <span class="built_in">type</span>=Path, <span class="built_in">help</span>=<span class="string">&quot;output path&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&quot;--wandb_project&quot;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="literal">None</span>, <span class="built_in">help</span>=<span class="string">&quot;Name of Weights &amp; Biases Project.&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&quot;--wandb_entity&quot;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="literal">None</span>, <span class="built_in">help</span>=<span class="string">&quot;Name of Weights &amp; Biases Entity.&quot;</span>)</span><br><span class="line">    args = parser.parse_args()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> args.wandb_project <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        wandb.init(project=args.wandb_project, entity=args.wandb_entity, config=args)</span><br><span class="line"></span><br><span class="line">    out_path = args.out_path</span><br><span class="line">    out_path.mkdir(parents=<span class="literal">True</span>, exist_ok=<span class="literal">True</span>)</span><br><span class="line">    logging.info(<span class="string">f&quot;Logs and plots are saved in: <span class="subst">&#123;out_path.as_posix()&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    device = torch.device(<span class="string">&quot;cpu&quot;</span>)</span><br><span class="line">    all_traj = main(</span><br><span class="line">        method_type=args.method, device=device, n_iter=args.n_epochs, scale=args.scale</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># plot</span></span><br><span class="line">    ax, fig, legend = plot_2d_pareto(trajectories=all_traj, scale=args.scale)</span><br><span class="line"></span><br><span class="line">    title_map = &#123;</span><br><span class="line">        <span class="string">&quot;nashmtl&quot;</span>: <span class="string">&quot;Nash-MTL(Ours)&quot;</span>,</span><br><span class="line">        <span class="string">&quot;cagrad&quot;</span>: <span class="string">&quot;CAGrad&quot;</span>,</span><br><span class="line">        <span class="string">&quot;mgda&quot;</span>: <span class="string">&quot;MGDA&quot;</span>,</span><br><span class="line">        <span class="string">&quot;pcgrad&quot;</span>: <span class="string">&quot;PCGrad&quot;</span>,</span><br><span class="line">        <span class="string">&quot;ls&quot;</span>: <span class="string">&quot;LS&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    ax.set_title(title_map[args.method], fontsize=<span class="number">25</span>)</span><br><span class="line">    plt.savefig(</span><br><span class="line">        out_path / <span class="string">f&quot;<span class="subst">&#123;args.method&#125;</span>.png&quot;</span>,</span><br><span class="line">        bbox_extra_artists=(legend,),</span><br><span class="line">        bbox_inches=<span class="string">&quot;tight&quot;</span>,</span><br><span class="line">        facecolor=<span class="string">&quot;white&quot;</span>,</span><br><span class="line">    )</span><br><span class="line">    plt.close()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> wandb.run <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        wandb.log(&#123;<span class="string">&quot;Pareto Front&quot;</span>: wandb.Image((out_path / <span class="string">f&quot;<span class="subst">&#123;args.method&#125;</span>.png&quot;</span>).as_posix())&#125;)</span><br><span class="line"></span><br><span class="line">        wandb.finish()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="problem-py"><a href="#problem-py" class="headerlink" title="problem.py"></a>problem.py</h3><p>该模块代码如下</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#这个模型定义了两个损失函数（或目标函数） f1 和 f2，它们是输入变量 $x = [x_1, x_2]$的非线性函数，并允许计算梯度信息。</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="comment">#nn 是 PyTorch 中用于构建神经网络的模块，包括 Module、常用的层（如 Linear、Conv2d 等）和常用的损失函数等。</span></span><br><span class="line">LOWER = <span class="number">0.000005</span></span><br><span class="line"><span class="comment">#定义一个常量 LOWER，用于在计算中对一些值进行下限裁剪。这个常量用于避免对数计算中的负值或零（log(0)），从而防止梯度爆炸或 NaN 问题。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Toy</span>(nn.Module):</span><br><span class="line">    <span class="comment">#定义了一个名为 Toy 的类，继承自 PyTorch 中的 nn.Module。nn.Module 是所有神经网络模块的基类，提供了很多通用功能，如参数注册、反向传播等。</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, scale=<span class="number">1.0</span>, scale_both_losses=<span class="number">1.0</span></span>):</span><br><span class="line">        <span class="built_in">super</span>(Toy, <span class="variable language_">self</span>).__init__()</span><br><span class="line">        <span class="variable language_">self</span>.centers = torch.Tensor([[-<span class="number">3.0</span>, <span class="number">0</span>], [<span class="number">3.0</span>, <span class="number">0</span>]])</span><br><span class="line">        <span class="variable language_">self</span>.scale = scale</span><br><span class="line">        <span class="variable language_">self</span>.scale_both_losses = scale_both_losses</span><br><span class="line">    <span class="comment"># centers 属性，是一个 2x2 的张量，代表两个中心点的坐标 [-3.0, 0] 和 [3.0, 0]。</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x, compute_grad=<span class="literal">False</span></span>):</span><br><span class="line">        x1 = x[<span class="number">0</span>]</span><br><span class="line">        x2 = x[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        f1 = torch.clamp((<span class="number">0.5</span> * (-x1 - <span class="number">7</span>) - torch.tanh(-x2)).<span class="built_in">abs</span>(), LOWER).log() + <span class="number">6</span></span><br><span class="line">        f2 = torch.clamp((<span class="number">0.5</span> * (-x1 + <span class="number">3</span>) + torch.tanh(-x2) + <span class="number">2</span>).<span class="built_in">abs</span>(), LOWER).log() + <span class="number">6</span></span><br><span class="line">        c1 = torch.clamp(torch.tanh(x2 * <span class="number">0.5</span>), <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        f1_sq = ((-x1 + <span class="number">7</span>).<span class="built_in">pow</span>(<span class="number">2</span>) + <span class="number">0.1</span> * (-x2 - <span class="number">8</span>).<span class="built_in">pow</span>(<span class="number">2</span>)) / <span class="number">10</span> - <span class="number">20</span></span><br><span class="line">        f2_sq = ((-x1 - <span class="number">7</span>).<span class="built_in">pow</span>(<span class="number">2</span>) + <span class="number">0.1</span> * (-x2 - <span class="number">8</span>).<span class="built_in">pow</span>(<span class="number">2</span>)) / <span class="number">10</span> - <span class="number">20</span></span><br><span class="line">        c2 = torch.clamp(torch.tanh(-x2 * <span class="number">0.5</span>), <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        f1 = f1 * c1 + f1_sq * c2</span><br><span class="line">        f1 *= <span class="variable language_">self</span>.scale</span><br><span class="line">        f2 = f2 * c1 + f2_sq * c2</span><br><span class="line"></span><br><span class="line">        f = torch.stack([f1, f2]) * <span class="variable language_">self</span>.scale_both_losses</span><br><span class="line">        <span class="keyword">if</span> compute_grad:</span><br><span class="line">            g11 = torch.autograd.grad(f1, x1, retain_graph=<span class="literal">True</span>)[<span class="number">0</span>].item()</span><br><span class="line">            g12 = torch.autograd.grad(f1, x2, retain_graph=<span class="literal">True</span>)[<span class="number">0</span>].item()</span><br><span class="line">            g21 = torch.autograd.grad(f2, x1, retain_graph=<span class="literal">True</span>)[<span class="number">0</span>].item()</span><br><span class="line">            g22 = torch.autograd.grad(f2, x2, retain_graph=<span class="literal">True</span>)[<span class="number">0</span>].item()</span><br><span class="line">            g = torch.Tensor([[g11, g21], [g12, g22]])</span><br><span class="line">            <span class="keyword">return</span> f, g</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> f</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">batch_forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        x1 = x[:, <span class="number">0</span>]</span><br><span class="line">        x2 = x[:, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        f1 = torch.clamp((<span class="number">0.5</span> * (-x1 - <span class="number">7</span>) - torch.tanh(-x2)).<span class="built_in">abs</span>(), LOWER).log() + <span class="number">6</span></span><br><span class="line">        f2 = torch.clamp((<span class="number">0.5</span> * (-x1 + <span class="number">3</span>) + torch.tanh(-x2) + <span class="number">2</span>).<span class="built_in">abs</span>(), LOWER).log() + <span class="number">6</span></span><br><span class="line">        c1 = torch.clamp(torch.tanh(x2 * <span class="number">0.5</span>), <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        f1_sq = ((-x1 + <span class="number">7</span>).<span class="built_in">pow</span>(<span class="number">2</span>) + <span class="number">0.1</span> * (-x2 - <span class="number">8</span>).<span class="built_in">pow</span>(<span class="number">2</span>)) / <span class="number">10</span> - <span class="number">20</span></span><br><span class="line">        f2_sq = ((-x1 - <span class="number">7</span>).<span class="built_in">pow</span>(<span class="number">2</span>) + <span class="number">0.1</span> * (-x2 - <span class="number">8</span>).<span class="built_in">pow</span>(<span class="number">2</span>)) / <span class="number">10</span> - <span class="number">20</span></span><br><span class="line">        c2 = torch.clamp(torch.tanh(-x2 * <span class="number">0.5</span>), <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        f1 = f1 * c1 + f1_sq * c2</span><br><span class="line">        f1 *= <span class="variable language_">self</span>.scale</span><br><span class="line">        f2 = f2 * c1 + f2_sq * c2</span><br><span class="line"></span><br><span class="line">        f = torch.cat([f1.view(-<span class="number">1</span>, <span class="number">1</span>), f2.view(-<span class="number">1</span>, <span class="number">1</span>)], -<span class="number">1</span>) * <span class="variable language_">self</span>.scale_both_losses</span><br><span class="line">        <span class="keyword">return</span> f</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Nash-MTL"><a href="#Nash-MTL" class="headerlink" title="Nash-MTL"></a>Nash-MTL</h3><p>该类的目标是通过一个优化问题来计算每个任务的权重（alpha），从而实现加权多任务学习。具体来说，该方法使用的是一个基于纳什均衡的算法来计算任务之间的加权关系。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NashMTL</span>(<span class="title class_ inherited__">WeightMethod</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params"></span></span><br><span class="line"><span class="params">        self,</span></span><br><span class="line"><span class="params">        n_tasks: <span class="built_in">int</span>, <span class="comment">#任务数量</span></span></span><br><span class="line"><span class="params">        device: torch.device, <span class="comment">#设备类型</span></span></span><br><span class="line"><span class="params">        max_norm: <span class="built_in">float</span> = <span class="number">1.0</span>, <span class="comment">#最大范数，用于梯度裁剪</span></span></span><br><span class="line"><span class="params">        update_weights_every: <span class="built_in">int</span> = <span class="number">1</span>, <span class="comment">#更新任务权重的频率</span></span></span><br><span class="line"><span class="params">        optim_niter=<span class="number">20</span>, <span class="comment">#优化器的迭代次数</span></span></span><br><span class="line"><span class="params">    </span>):</span><br><span class="line"></span><br><span class="line">        <span class="built_in">super</span>(NashMTL, <span class="variable language_">self</span>).__init__(</span><br><span class="line">            n_tasks=n_tasks,</span><br><span class="line">            device=device,</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 这是规范的Py成员变量的定义方法（不需要显示声明，直接在__init__中用self.variable赋值即可）</span></span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.optim_niter = optim_niter</span><br><span class="line">        <span class="variable language_">self</span>.update_weights_every = update_weights_every</span><br><span class="line">        <span class="variable language_">self</span>.max_norm = max_norm</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.prvs_alpha_param = <span class="literal">None</span> <span class="comment"># 上次更新的权重参数，赋值为None供后续使用</span></span><br><span class="line">        <span class="variable language_">self</span>.normalization_factor = np.ones((<span class="number">1</span>,)) <span class="comment"># 单一元素为1的素质，标准化处理用</span></span><br><span class="line">        <span class="variable language_">self</span>.init_gtg = <span class="variable language_">self</span>.init_gtg = np.eye(<span class="variable language_">self</span>.n_tasks) <span class="comment"># 对应后面的GTG，这里初始化为了单位矩阵</span></span><br><span class="line">        <span class="variable language_">self</span>.step = <span class="number">0.0</span></span><br><span class="line">        <span class="variable language_">self</span>.prvs_alpha = np.ones(<span class="variable language_">self</span>.n_tasks, dtype=np.float32) <span class="comment"># 上次更新的权重，初始化为全1的数组，初始权重相同</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此方法用于判断是否满足停止条件。具体而言，它检查以下几种情况：</p><ol><li>alpha_param 为 None。</li><li>当前的 gtg 与 alpha_t 计算结果的范数小于某个阈值。</li><li>当前的 alpha_param 与 prvs_alpha_param 之间的范数小于某个阈值。</li></ol><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_stop_criteria</span>(<span class="params">self, gtg, alpha_t</span>):</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        (<span class="variable language_">self</span>.alpha_param.value <span class="keyword">is</span> <span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">or</span> (np.linalg.norm(gtg @ alpha_t - <span class="number">1</span> / (alpha_t + <span class="number">1e-10</span>)) &lt; <span class="number">1e-3</span>)</span><br><span class="line">        <span class="keyword">or</span> (</span><br><span class="line">            np.linalg.norm(<span class="variable language_">self</span>.alpha_param.value - <span class="variable language_">self</span>.prvs_alpha_param.value)</span><br><span class="line">            &lt; <span class="number">1e-6</span></span><br><span class="line">        )</span><br><span class="line">    )  </span><br></pre></td></tr></table></figure><p>这个方法是优化的核心，目标是求解 alpha_t，即各个任务的权重。优化过程使用了一个迭代的方法，每次通过求解优化问题来更新 alpha_t，直到满足停止条件为止。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solve_optimization</span>(<span class="params">self, gtg: np.array</span>):</span><br><span class="line">    <span class="variable language_">self</span>.G_param.value = gtg <span class="comment"># </span></span><br><span class="line">    <span class="variable language_">self</span>.normalization_factor_param.value = <span class="variable language_">self</span>.normalization_factor <span class="comment"># 对应使用的标准化因子，方便计算机处理</span></span><br><span class="line"></span><br><span class="line">    alpha_t = <span class="variable language_">self</span>.prvs_alpha</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 这里使用了迭代求解优化，warm_start=True让求解器利用前一次迭代的解来加速收敛，是一种求解器的使用方法，区别于论文中CCP方法迭代使用alpha，CCP的迭代是接触prvs_*参数来完成的</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="variable language_">self</span>.optim_niter):</span><br><span class="line">        <span class="variable language_">self</span>.alpha_param.value = alpha_t</span><br><span class="line">        <span class="variable language_">self</span>.prvs_alpha_param.value = alpha_t</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>: <span class="comment"># 前面在_init_optim_problem中定义了优化问题，这里进行求解</span></span><br><span class="line">            <span class="variable language_">self</span>.prob.solve(solver=cp.ECOS, warm_start=<span class="literal">True</span>, max_iters=<span class="number">100</span>)</span><br><span class="line">        <span class="keyword">except</span>: <span class="comment"># 求解器更新参数发生溢出时的异常处理</span></span><br><span class="line">            <span class="variable language_">self</span>.alpha_param.value = <span class="variable language_">self</span>.prvs_alpha_param.value</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>._stop_criteria(gtg, alpha_t):</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        alpha_t = <span class="variable language_">self</span>.alpha_param.value</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> alpha_t <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="variable language_">self</span>.prvs_alpha = alpha_t</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">self</span>.prvs_alpha</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此方法计算线性化的 phi_alpha，用于优化问题的目标函数中。具体的计算过程涉及到 G_param 和 alpha_param 的线性运算。</p><p>这里 prvs_phi_tag 对应的是在点 $\alpha^{(\tau)}$<br>  处的梯度 $\nabla \phi(\alpha^{(\tau)})$<br> ，其中：</p><p>$\frac{1}{\alpha^{(\tau)}}$是对 $\log(\alpha_i)$的导数</p><p>$\frac{1}{G \alpha^{(\tau)}} G$是对 $\log(\beta_i)$的导数</p><p>实际上在这里$\tilde{\phi_\tau}(\alpha) &#x3D; \phi(\alpha^{(\tau)})+\nabla \phi(\alpha^{(\tau)})^T(\alpha-\alpha^{(\tau)})$，只考虑了$\nabla \phi(\alpha^{(\tau)})^T(\alpha-\alpha^{(\tau)})$，因为前面是一个常数项，不影响优化的结果。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_calc_phi_alpha_linearization</span>(<span class="params">self</span>):</span><br><span class="line">    G_prvs_alpha = <span class="variable language_">self</span>.G_param @ <span class="variable language_">self</span>.prvs_alpha_param</span><br><span class="line">    prvs_phi_tag = <span class="number">1</span> / <span class="variable language_">self</span>.prvs_alpha_param + (<span class="number">1</span> / G_prvs_alpha) @ <span class="variable language_">self</span>.G_param</span><br><span class="line">    phi_alpha = prvs_phi_tag @ (<span class="variable language_">self</span>.alpha_param - <span class="variable language_">self</span>.prvs_alpha_param)</span><br><span class="line">    <span class="keyword">return</span> phi_alpha</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此方法初始化优化问题，具体地说，使用 cvxpy 来定义一个凸优化问题。优化目标是最小化一个由加权任务损失和线性化项构成的目标函数。</p><p>参考论文中的公式：</p><p>$G^TG\alpha &#x3D; 1&#x2F;\alpha$</p><p>$\beta_i(\alpha) &#x3D; g_i^TG\alpha$</p><p>$\phi_i(\alpha) &#x3D; log(\alpha_i) + log(\beta_i),\phi(\alpha) &#x3D; \sum_i \phi_i(\alpha)$</p><p>$min_\alpha \sum_i\beta_i(\alpha) + \phi(\alpha),s.t. \forall i,-\phi_i(\alpha)&lt;0,\alpha_i&gt;0$</p><p>$\tilde{\phi_\tau}(\alpha) &#x3D; \phi(\alpha^{(\tau)})+\nabla \phi(\alpha^{(\tau)})^T(\alpha-\alpha^{(\tau)})$</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_init_optim_problem</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="comment"># 创建一个形状为 (self.n_tasks,) 的非负变量 alpha_param，代表各任务的权重。</span></span><br><span class="line">    <span class="variable language_">self</span>.alpha_param = cp.Variable(shape=(<span class="variable language_">self</span>.n_tasks,), nonneg=<span class="literal">True</span>)</span><br><span class="line">    <span class="variable language_">self</span>.prvs_alpha_param = cp.Parameter(</span><br><span class="line">        shape=(<span class="variable language_">self</span>.n_tasks,), value=<span class="variable language_">self</span>.prvs_alpha</span><br><span class="line">    )</span><br><span class="line">    <span class="comment"># 创建一个形状为 (self.n_tasks, self.n_tasks) 的参数 G_param，初始化为梯度协方差矩阵 self.init_gtg。</span></span><br><span class="line">    <span class="variable language_">self</span>.G_param = cp.Parameter(</span><br><span class="line">        shape=(<span class="variable language_">self</span>.n_tasks, <span class="variable language_">self</span>.n_tasks), value=<span class="variable language_">self</span>.init_gtg</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 标准化用，但是从数学意义上来说没有什么意义，或许与计算机的数据处理有关（例如增强代码的鲁棒性、稳定性和可维护性...）</span></span><br><span class="line">    <span class="variable language_">self</span>.normalization_factor_param = cp.Parameter(</span><br><span class="line">        shape=(<span class="number">1</span>,), value=np.array([<span class="number">1.0</span>])</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 线性化项</span></span><br><span class="line">    <span class="variable language_">self</span>.phi_alpha = <span class="variable language_">self</span>._calc_phi_alpha_linearization()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 每个列向量对应论文中的βi，这里将其组成的矩阵，后续使用sum对应就是目标中的所有βi求和</span></span><br><span class="line">    G_alpha = <span class="variable language_">self</span>.G_param @ <span class="variable language_">self</span>.alpha_param <span class="comment"># gtg alpha</span></span><br><span class="line">    constraint = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="variable language_">self</span>.n_tasks):</span><br><span class="line">        constraint.append(</span><br><span class="line">            -cp.log(<span class="variable language_">self</span>.alpha_param[i] * <span class="variable language_">self</span>.normalization_factor_param)</span><br><span class="line">            - cp.log(G_alpha[i])</span><br><span class="line">            &lt;= <span class="number">0</span></span><br><span class="line">        )</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 优化目标</span></span><br><span class="line">    obj = cp.Minimize(</span><br><span class="line">        cp.<span class="built_in">sum</span>(G_alpha) + <span class="variable language_">self</span>.phi_alpha / <span class="variable language_">self</span>.normalization_factor_param</span><br><span class="line">    )</span><br><span class="line">    <span class="variable language_">self</span>.prob = cp.Problem(obj, constraint)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此方法计算加权损失。首先计算每个任务的梯度（即 grads），然后计算梯度的协方差矩阵 GTG。使用 solve_optimization 方法求解最优的任务权重 alpha。最终返回加权损失和任务权重。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_weighted_loss</span>(<span class="params"></span></span><br><span class="line"><span class="params">    self,</span></span><br><span class="line"><span class="params">    losses,</span></span><br><span class="line"><span class="params">    shared_parameters,</span></span><br><span class="line"><span class="params">    **kwargs,</span></span><br><span class="line"><span class="params"></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Parameters</span></span><br><span class="line"><span class="string">    ----------</span></span><br><span class="line"><span class="string">    losses :</span></span><br><span class="line"><span class="string">    shared_parameters : shared parameters</span></span><br><span class="line"><span class="string">    kwargs :</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns</span></span><br><span class="line"><span class="string">    -------</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    extra_outputs = <span class="built_in">dict</span>()</span><br><span class="line">    <span class="keyword">if</span> <span class="variable language_">self</span>.step == <span class="number">0</span>: <span class="comment"># 步数为0，初始化优化任务</span></span><br><span class="line">        <span class="variable language_">self</span>._init_optim_problem()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">self</span>.step % <span class="variable language_">self</span>.update_weights_every) == <span class="number">0</span>: <span class="comment"># 记录更新步数</span></span><br><span class="line">        <span class="variable language_">self</span>.step += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#  对每个任务的损失计算相对于共享参数的梯度，并将梯度展平成一维向量后存储在 grads 字典中。</span></span><br><span class="line">        grads = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i, loss <span class="keyword">in</span> <span class="built_in">enumerate</span>(losses):</span><br><span class="line">            g = <span class="built_in">list</span>(</span><br><span class="line">                torch.autograd.grad(</span><br><span class="line">                    loss,</span><br><span class="line">                    shared_parameters,</span><br><span class="line">                    retain_graph=<span class="literal">True</span>,</span><br><span class="line">                )</span><br><span class="line">            )</span><br><span class="line">            grad = torch.cat([torch.flatten(grad) <span class="keyword">for</span> grad <span class="keyword">in</span> g])</span><br><span class="line">            grads[i] = grad</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 梯度矩阵 G: 将所有任务的梯度堆叠成一个矩阵。</span></span><br><span class="line">        G = torch.stack(<span class="built_in">tuple</span>(v <span class="keyword">for</span> v <span class="keyword">in</span> grads.values()))</span><br><span class="line">        <span class="comment"># 梯度协方差矩阵 GTG: 计算梯度矩阵的自乘，得到梯度协方差矩阵。</span></span><br><span class="line">        GTG = torch.mm(G, G.t())</span><br><span class="line">        <span class="comment"># 标准化因子: 计算 GTG 的范数，并用其标准化 GTG。</span></span><br><span class="line">        <span class="variable language_">self</span>.normalization_factor = (</span><br><span class="line">            torch.norm(GTG).detach().cpu().numpy().reshape((<span class="number">1</span>,))</span><br><span class="line">        )</span><br><span class="line">        GTG = GTG / <span class="variable language_">self</span>.normalization_factor.item()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 采用优化的方法，在GTG的基础上求解各个损失函数的权重alpha</span></span><br><span class="line">        alpha = <span class="variable language_">self</span>.solve_optimization(GTG.cpu().detach().numpy())</span><br><span class="line">        alpha = torch.from_numpy(alpha)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="variable language_">self</span>.step += <span class="number">1</span></span><br><span class="line">        alpha = <span class="variable language_">self</span>.prvs_alpha</span><br><span class="line">    <span class="comment"># 这里我猜测是作者考虑到为了加快模型的训练可以，简单地通过在某些步数的时候，不按照正常的流程求权重，而是直接使用上次的权重；但是实际上没有这样做，因为update_weights_every是被设置为1的，无论step为多少，总是会按正常步骤更新alpha</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 按照得到的权重alpha计算加权损失函数，供backward()使用</span></span><br><span class="line">    weighted_loss = <span class="built_in">sum</span>([losses[i] * alpha[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(alpha))])</span><br><span class="line">    extra_outputs[<span class="string">&quot;weights&quot;</span>] = alpha</span><br><span class="line">    <span class="keyword">return</span> weighted_loss, extra_outputs</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backward</span>(<span class="params"></span></span><br><span class="line"><span class="params">        self,</span></span><br><span class="line"><span class="params">        losses: torch.Tensor,</span></span><br><span class="line"><span class="params">        shared_parameters: <span class="type">Union</span>[</span></span><br><span class="line"><span class="params">            <span class="type">List</span>[torch.nn.parameter.Parameter], torch.Tensor</span></span><br><span class="line"><span class="params">        ] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">        task_specific_parameters: <span class="type">Union</span>[</span></span><br><span class="line"><span class="params">            <span class="type">List</span>[torch.nn.parameter.Parameter], torch.Tensor</span></span><br><span class="line"><span class="params">        ] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">        last_shared_parameters: <span class="type">Union</span>[</span></span><br><span class="line"><span class="params">            <span class="type">List</span>[torch.nn.parameter.Parameter], torch.Tensor</span></span><br><span class="line"><span class="params">        ] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">        representation: <span class="type">Union</span>[<span class="type">List</span>[torch.nn.parameter.Parameter], torch.Tensor] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">        **kwargs,</span></span><br><span class="line"><span class="params">    </span>) -&gt; <span class="type">Tuple</span>[<span class="type">Union</span>[torch.Tensor, <span class="literal">None</span>], <span class="type">Union</span>[<span class="type">Dict</span>, <span class="literal">None</span>]]:</span><br><span class="line">        loss, extra_outputs = <span class="variable language_">self</span>.get_weighted_loss(</span><br><span class="line">            losses=losses, <span class="comment"># 当前各损失函数</span></span><br><span class="line">            shared_parameters=shared_parameters, <span class="comment"># 确定待求梯度的损失函数的变量</span></span><br><span class="line">            **kwargs,</span><br><span class="line">        ) <span class="comment"># 得到加权后的损失函数，额外参数是各损失函数的权重信息</span></span><br><span class="line">        loss.backward() <span class="comment"># 对加权损失函数求梯度，从而确定更新方向，以供优化器更新参数使用（optimize.step()）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># make sure the solution for shared params has norm &lt;= self.eps</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.max_norm &gt; <span class="number">0</span>:</span><br><span class="line">            torch.nn.utils.clip_grad_norm_(shared_parameters, <span class="variable language_">self</span>.max_norm)</span><br><span class="line"></span><br><span class="line"><span class="comment">#在训练过程中，backward 方法用于执行反向传播。它调用 get_weighted_loss 来计算加权损失，并使用 loss.backward() 进行梯度计算。如果 max_norm 大于 0，则会对梯度进行裁剪。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> loss, extra_outputs</span><br></pre></td></tr></table></figure><h3 id="result"><a href="#result" class="headerlink" title="result"></a>result</h3><p><img src="/../_images/result.png" alt="Nash-MTL" title="Nash-MTL"></p><h3 id="My-Test"><a href="#My-Test" class="headerlink" title="My_Test"></a>My_Test</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy.optimize <span class="keyword">import</span> minimize</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 模型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleLinearModel</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, input_dim, output_dim</span>):</span><br><span class="line">        <span class="variable language_">self</span>.W = np.random.randn(input_dim, output_dim)</span><br><span class="line">        <span class="variable language_">self</span>.b = np.random.randn(output_dim)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">predict</span>(<span class="params">self, X</span>):</span><br><span class="line">        <span class="keyword">return</span> X @ <span class="variable language_">self</span>.W + <span class="variable language_">self</span>.b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 损失函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task_loss</span>(<span class="params">model, X, y_true</span>):</span><br><span class="line">    y_pred = model.predict(X)</span><br><span class="line">    <span class="keyword">return</span> np.mean((y_pred - y_true) ** <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义两个任务的数据，这里作为简单的测试，我使用的随机生成</span></span><br><span class="line">np.random.seed(<span class="number">0</span>)</span><br><span class="line">X = np.random.randn(<span class="number">100</span>, <span class="number">2</span>)</span><br><span class="line">y_A = X @ np.array([<span class="number">2</span>, -<span class="number">3</span>]) + <span class="number">1</span> + <span class="number">0.1</span> * np.random.randn(<span class="number">100</span>)</span><br><span class="line">y_B = X @ np.array([-<span class="number">1</span>, <span class="number">4</span>]) - <span class="number">2</span> + <span class="number">0.1</span> * np.random.randn(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化模型</span></span><br><span class="line">model = SimpleLinearModel(input_dim=<span class="number">2</span>, output_dim=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算每个任务的梯度</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compute_gradients</span>(<span class="params">model, X, y_A, y_B</span>):</span><br><span class="line">    epsilon = <span class="number">1e-5</span></span><br><span class="line">    initial_loss_A = task_loss(model, X, y_A)</span><br><span class="line">    initial_loss_B = task_loss(model, X, y_B)</span><br><span class="line"></span><br><span class="line">    grad_W_A = np.zeros_like(model.W)</span><br><span class="line">    grad_b_A = np.zeros_like(model.b)</span><br><span class="line">    grad_W_B = np.zeros_like(model.W)</span><br><span class="line">    grad_b_B = np.zeros_like(model.b)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(model.W.size):</span><br><span class="line">        model.W.flat[i] += epsilon</span><br><span class="line">        grad_W_A.flat[i] = (task_loss(model, X, y_A) - initial_loss_A) / epsilon</span><br><span class="line">        grad_W_B.flat[i] = (task_loss(model, X, y_B) - initial_loss_B) / epsilon</span><br><span class="line">        model.W.flat[i] -= epsilon</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(model.b.size):</span><br><span class="line">        model.b.flat[i] += epsilon</span><br><span class="line">        grad_b_A.flat[i] = (task_loss(model, X, y_A) - initial_loss_A) / epsilon</span><br><span class="line">        grad_b_B.flat[i] = (task_loss(model, X, y_B) - initial_loss_B) / epsilon</span><br><span class="line">        model.b.flat[i] -= epsilon</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (grad_W_A, grad_b_A), (grad_W_B, grad_b_B)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算Nash Bargaining Solution</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">nash_bargaining_solution</span>(<span class="params">grad_A, grad_B</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">objective</span>(<span class="params">x</span>):</span><br><span class="line">        grad_W = x[<span class="number">0</span>] * grad_A[<span class="number">0</span>] + x[<span class="number">1</span>] * grad_B[<span class="number">0</span>]</span><br><span class="line">        grad_b = x[<span class="number">0</span>] * grad_A[<span class="number">1</span>] + x[<span class="number">1</span>] * grad_B[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> - np.<span class="built_in">sum</span>(grad_W ** <span class="number">2</span> + grad_b ** <span class="number">2</span>)  <span class="comment"># Minimize the negative of the combined gradient norms</span></span><br><span class="line"></span><br><span class="line">    constraints = &#123;</span><br><span class="line">        <span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;eq&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;fun&#x27;</span>: <span class="keyword">lambda</span> x: np.<span class="built_in">sum</span>(x) - <span class="number">1</span>  <span class="comment"># x_A + x_B = 1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bounds = [(<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, <span class="number">1</span>)]</span><br><span class="line">    x0 = [<span class="number">0.5</span>, <span class="number">0.5</span>]</span><br><span class="line"></span><br><span class="line">    result = minimize(objective, x0, bounds=bounds, constraints=constraints)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> result.success:</span><br><span class="line">        <span class="keyword">return</span> result.x</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;Optimization failed&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行一次更新</span></span><br><span class="line">(grad_W_A, grad_b_A), (grad_W_B, grad_b_B) = compute_gradients(model, X, y_A, y_B)</span><br><span class="line">nash_weights = nash_bargaining_solution((grad_W_A, grad_b_A), (grad_W_B, grad_b_B))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新模型参数</span></span><br><span class="line">learning_rate = <span class="number">0.01</span></span><br><span class="line">model.W -= learning_rate * (nash_weights[<span class="number">0</span>] * grad_W_A + nash_weights[<span class="number">1</span>] * grad_W_B)</span><br><span class="line">model.b -= learning_rate * (nash_weights[<span class="number">0</span>] * grad_b_A + nash_weights[<span class="number">1</span>] * grad_b_B)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;Updated W: <span class="subst">&#123;model.W&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;Updated b: <span class="subst">&#123;model.b&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Experiment-quantum-chemistry"><a href="#Experiment-quantum-chemistry" class="headerlink" title="Experiment: quantum_chemistry"></a>Experiment: quantum_chemistry</h2><p>整个实验是基于QM9数据集中的原子-分子数据，训练了一个神经网络，用来根据分子的特征（原子个数、原子特征、原子之间的化学键连接情况、化学键的性质特征…），来对分子的性质进行一个预测。</p><h3 id="QM9"><a href="#QM9" class="headerlink" title="QM9"></a>QM9</h3><p>QM9数据集：一个广泛使用的化学分子数据集，主要用于机器学习和深度学习领域的化学和材料科学研究。它包含了约 134,000 个小分子的详细信息，每个分子包含的属性和标签数量丰富，是研究分子性质和行为的宝贵资源。</p><p>实验中的数据使用PyTorch Geometric框架来对原始数据进行预处理，转换为图格式的数据，得到数据集供我们使用。</p><h4 id="数据对象"><a href="#数据对象" class="headerlink" title="数据对象"></a>数据对象</h4><p>在 PyTorch Geometric 中，每个数据对象是 torch_geometric.data.Data 类型的实例</p><p>包含以下属性：</p><ol><li>x：节点特征矩阵（形状为 [num_nodes, num_node_features]）。</li><li>edge_index：边索引矩阵（形状为 [2, num_edges]），其中每列表示一条边的起始节点和终止节点。</li><li>edge_attr：边特征矩阵（形状为 [num_edges, num_edge_features]，可选）。</li><li>y：目标属性或标签（形状为 [num_targets]，可选）。</li><li>pos：节点的三维坐标（形状为 [num_nodes, 3]，可选）。</li><li>z：节点的原子序数（形状为 [num_nodes]）。</li><li>idx：分子索引。</li><li>name：分子名称（数据集中的标识）。</li></ol><p><strong>test的输出信息：Data(x&#x3D;[5, 11], edge_index&#x3D;[2, 8], edge_attr&#x3D;[8, 4], y&#x3D;[1, 11], pos&#x3D;[5, 3], idx&#x3D;[1], name&#x3D;’gdb_1’, z&#x3D;[5])</strong></p><h3 id="train-py-1"><a href="#train-py-1" class="headerlink" title="train.py"></a>train.py</h3><h4 id="main"><a href="#main" class="headerlink" title="main"></a>main</h4><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params"></span></span><br><span class="line"><span class="params">    data_path: <span class="built_in">str</span>,</span></span><br><span class="line"><span class="params">    batch_size: <span class="built_in">int</span>,</span></span><br><span class="line"><span class="params">    device: torch.device,</span></span><br><span class="line"><span class="params">    method: <span class="built_in">str</span>,</span></span><br><span class="line"><span class="params">    weight_method_params: <span class="built_in">dict</span>,</span></span><br><span class="line"><span class="params">    lr: <span class="built_in">float</span>,</span></span><br><span class="line"><span class="params">    method_params_lr: <span class="built_in">float</span>,</span></span><br><span class="line"><span class="params">    n_epochs: <span class="built_in">int</span>,</span></span><br><span class="line"><span class="params">    targets: <span class="built_in">list</span> = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">    scale_target: <span class="built_in">bool</span> = <span class="literal">True</span>,</span></span><br><span class="line"><span class="params">    main_task: <span class="built_in">int</span> = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params"></span>):</span><br><span class="line">    <span class="comment"># 模型初始化，训练的是一个网络，其中任务的数量n_tasks对应输出头的个数；num_features是输入数据的特征维度，这里设置为11对应quantum_chemistry数据集中一个分子的相关性质的量化指标有11个；dim确定了隐层的维度；（相关细节在model.py）</span></span><br><span class="line">    <span class="comment"># to(device)可以将模型移动到指定的计算设备，保存相关数据并执行计算操作</span></span><br><span class="line">    dim = <span class="number">64</span></span><br><span class="line">    model = Net(n_tasks=<span class="built_in">len</span>(targets), num_features=<span class="number">11</span>, dim=dim).to(device)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 数据转换和加载（相关细节在utils.py）</span></span><br><span class="line">    transform = T.Compose([MyTransform(targets), Complete(), T.Distance(norm=<span class="literal">False</span>)])</span><br><span class="line">    dataset = QM9(data_path, transform=transform).shuffle()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 拆分数据集</span></span><br><span class="line">    test_dataset = dataset[:<span class="number">10000</span>]</span><br><span class="line">    val_dataset = dataset[<span class="number">10000</span>:<span class="number">20000</span>]</span><br><span class="line">    train_dataset = dataset[<span class="number">20000</span>:]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果需要，进行目标值的归一化</span></span><br><span class="line">    std = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> scale_target:</span><br><span class="line">        mean = train_dataset.data.y[:, targets].mean(dim=<span class="number">0</span>, keepdim=<span class="literal">True</span>)</span><br><span class="line">        std = train_dataset.data.y[:, targets].std(dim=<span class="number">0</span>, keepdim=<span class="literal">True</span>)</span><br><span class="line">        dataset.data.y[:, targets] = (dataset.data.y[:, targets] - mean) / std</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建数据加载器</span></span><br><span class="line">    test_loader = DataLoader(</span><br><span class="line">        test_dataset, batch_size=batch_size, shuffle=<span class="literal">False</span>, num_workers=<span class="number">0</span></span><br><span class="line">    )</span><br><span class="line">    val_loader = DataLoader(</span><br><span class="line">        val_dataset, batch_size=batch_size, shuffle=<span class="literal">False</span>, num_workers=<span class="number">0</span></span><br><span class="line">    )</span><br><span class="line">    train_loader = DataLoader(</span><br><span class="line">        train_dataset, batch_size=batch_size, shuffle=<span class="literal">True</span>, num_workers=<span class="number">0</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 初始化多任务学习的权重方法</span></span><br><span class="line">    weight_method = WeightMethods(</span><br><span class="line">        method,</span><br><span class="line">        n_tasks=<span class="built_in">len</span>(targets),</span><br><span class="line">        device=device,</span><br><span class="line">        **weight_method_params[method],</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置优化器，并为模型和权重方法参数设置不同的学习率</span></span><br><span class="line">    optimizer = torch.optim.Adam(</span><br><span class="line">        [</span><br><span class="line">            <span class="built_in">dict</span>(params=model.parameters(), lr=lr),</span><br><span class="line">            <span class="built_in">dict</span>(params=weight_method.parameters(), lr=method_params_lr),</span><br><span class="line">        ],</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 学习率调度器</span></span><br><span class="line">    scheduler = torch.optim.lr_scheduler.ReduceLROnPlateau(</span><br><span class="line">        optimizer, mode=<span class="string">&quot;min&quot;</span>, factor=<span class="number">0.7</span>, patience=<span class="number">5</span>, min_lr=<span class="number">0.00001</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 训练循环</span></span><br><span class="line">    epoch_iterator = trange(n_epochs)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 用于保存最佳验证损失、最佳测试损失及其变化量的变量，初始值设为正无穷大。</span></span><br><span class="line">    best_val = np.inf</span><br><span class="line">    best_test = np.inf</span><br><span class="line">    best_test_delta = np.inf</span><br><span class="line">    best_val_delta = np.inf</span><br><span class="line">    <span class="comment"># 用于保存最佳测试结果的变量</span></span><br><span class="line">    best_test_results = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> epoch_iterator:</span><br><span class="line">        lr = scheduler.optimizer.param_groups[<span class="number">0</span>][<span class="string">&quot;lr&quot;</span>] <span class="comment"># 从学习率调度器（scheduler）中获取当前学习率</span></span><br><span class="line">        <span class="keyword">for</span> j, data <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_loader):  <span class="comment"># 遍历训练数据加载器（train_loader）</span></span><br><span class="line">            model.train() </span><br><span class="line"></span><br><span class="line">            data = data.to(device)</span><br><span class="line">            optimizer.zero_grad()</span><br><span class="line"></span><br><span class="line">            out, features = model(data, return_representation=<span class="literal">True</span>) <span class="comment"># 模型前向传播，进行估计</span></span><br><span class="line"></span><br><span class="line">            losses = F.mse_loss(out, data.y, reduction=<span class="string">&quot;none&quot;</span>).mean(<span class="number">0</span>) <span class="comment"># 估计结果与真实结果的平方误差作为损失函数</span></span><br><span class="line"></span><br><span class="line">            loss, extra_outputs = weight_method.backward(</span><br><span class="line">                losses=losses,</span><br><span class="line">                shared_parameters=<span class="built_in">list</span>(model.shared_parameters()),</span><br><span class="line">                task_specific_parameters=<span class="built_in">list</span>(model.task_specific_parameters()),</span><br><span class="line">                last_shared_parameters=<span class="built_in">list</span>(model.last_shared_parameters()),</span><br><span class="line">                representation=features,</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">            optimizer.step()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 在验证集和测试集上评估模型（细节在def evaluate中）</span></span><br><span class="line">        val_loss_dict = evaluate(model, val_loader, std=std, scale_target=scale_target)</span><br><span class="line">        test_loss_dict = evaluate(</span><br><span class="line">            model, test_loader, std=std, scale_target=scale_target</span><br><span class="line">        )</span><br><span class="line">        val_loss = val_loss_dict[<span class="string">&quot;avg_loss&quot;</span>]</span><br><span class="line">        val_delta = val_loss_dict[<span class="string">&quot;delta_m&quot;</span>]</span><br><span class="line">        test_loss = test_loss_dict[<span class="string">&quot;avg_loss&quot;</span>]</span><br><span class="line">        test_delta = test_loss_dict[<span class="string">&quot;delta_m&quot;</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 根据验证集性能更新最佳结果</span></span><br><span class="line">        <span class="keyword">if</span> method == <span class="string">&quot;stl&quot;</span>: <span class="comment"># 单任务学习</span></span><br><span class="line">            best_val_criteria = val_loss_dict[<span class="string">&quot;avg_task_losses&quot;</span>][main_task] &lt;= best_val</span><br><span class="line">        <span class="keyword">else</span>: <span class="comment"># 多任务学习</span></span><br><span class="line">            best_val_criteria = val_delta &lt;= best_val_delta <span class="comment"># 判断是否需要更新最佳结果，验证集上delta_m是否小于最好的delta_m</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> best_val_criteria:</span><br><span class="line">            best_val = val_loss</span><br><span class="line">            best_test = test_loss</span><br><span class="line">            best_test_results = test_loss_dict</span><br><span class="line">            best_val_delta = val_delta</span><br><span class="line">            best_test_delta = test_delta</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 每个epoch记录日志</span></span><br><span class="line">        epoch_iterator.set_description(</span><br><span class="line">            <span class="string">f&quot;epoch <span class="subst">&#123;epoch&#125;</span> | lr=<span class="subst">&#123;lr&#125;</span> | train loss <span class="subst">&#123;losses.mean().item():<span class="number">.3</span>f&#125;</span> | val loss: <span class="subst">&#123;val_loss:<span class="number">.3</span>f&#125;</span> | &quot;</span></span><br><span class="line">            <span class="string">f&quot;test loss: <span class="subst">&#123;test_loss:<span class="number">.3</span>f&#125;</span> | best test loss <span class="subst">&#123;best_test:<span class="number">.3</span>f&#125;</span> | best_test_delta <span class="subst">&#123;best_test_delta:<span class="number">.3</span>f&#125;</span>&quot;</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> wandb.run <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            wandb.log(&#123;<span class="string">&quot;Learning Rate&quot;</span>: lr&#125;, step=epoch)</span><br><span class="line">            wandb.log(&#123;<span class="string">&quot;Train Loss&quot;</span>: losses.mean().item()&#125;, step=epoch)</span><br><span class="line">            wandb.log(&#123;<span class="string">&quot;Val Loss&quot;</span>: val_loss&#125;, step=epoch)</span><br><span class="line">            wandb.log(&#123;<span class="string">&quot;Val Delta&quot;</span>: val_delta&#125;, step=epoch)</span><br><span class="line">            wandb.log(&#123;<span class="string">&quot;Test Loss&quot;</span>: test_loss&#125;, step=epoch)</span><br><span class="line">            wandb.log(&#123;<span class="string">&quot;Test Delta&quot;</span>: test_delta&#125;, step=epoch)</span><br><span class="line">            wandb.log(&#123;<span class="string">&quot;Best Test Loss&quot;</span>: best_test&#125;, step=epoch)</span><br><span class="line">            wandb.log(&#123;<span class="string">&quot;Best Test Delta&quot;</span>: best_test_delta&#125;, step=epoch)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 根据验证集性能调整学习率</span></span><br><span class="line">        scheduler.step(</span><br><span class="line">            val_loss_dict[<span class="string">&quot;avg_task_losses&quot;</span>][main_task]</span><br><span class="line">            <span class="keyword">if</span> method == <span class="string">&quot;stl&quot;</span></span><br><span class="line">            <span class="keyword">else</span> val_delta</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 脚本入口点</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 参数解析器设置</span></span><br><span class="line">    parser = ArgumentParser(<span class="string">&quot;QM9&quot;</span>, parents=[common_parser])</span><br><span class="line">    parser.set_defaults(</span><br><span class="line">        data_path=<span class="string">&quot;dataset&quot;</span>,</span><br><span class="line">        lr=<span class="number">1e-3</span>,</span><br><span class="line">        n_epochs=<span class="number">300</span>,</span><br><span class="line">        batch_size=<span class="number">120</span>,</span><br><span class="line">        method=<span class="string">&quot;nashmtl&quot;</span>,</span><br><span class="line">    )</span><br><span class="line">    parser.add_argument(<span class="string">&quot;--scale-y&quot;</span>, default=<span class="literal">True</span>, <span class="built_in">type</span>=str2bool)</span><br><span class="line">    parser.add_argument(<span class="string">&quot;--wandb_project&quot;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="literal">None</span>, <span class="built_in">help</span>=<span class="string">&quot;Name of Weights &amp; Biases Project.&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&quot;--wandb_entity&quot;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="literal">None</span>, <span class="built_in">help</span>=<span class="string">&quot;Name of Weights &amp; Biases Entity.&quot;</span>)</span><br><span class="line">    args = parser.parse_args()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置随机种子以确保可重复性</span></span><br><span class="line">    set_seed(args.seed)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果指定了项目，则初始化Weights &amp; Biases</span></span><br><span class="line">    <span class="keyword">if</span> args.wandb_project <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        wandb.init(project=args.wandb_project, entity=args.wandb_entity, config=args)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 提取权重方法的参数</span></span><br><span class="line">    weight_method_params = extract_weight_method_parameters_from_args(args)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取计算设备（CPU或GPU）</span></span><br><span class="line">    device = get_device(gpus=args.gpu)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 运行主训练和评估函数</span></span><br><span class="line">    main(</span><br><span class="line">        data_path=args.data_path,</span><br><span class="line">        batch_size=args.batch_size,</span><br><span class="line">        device=device,</span><br><span class="line">        method=args.method,</span><br><span class="line">        weight_method_params=weight_method_params,</span><br><span class="line">        lr=args.lr,</span><br><span class="line">        method_params_lr=args.method_params_lr,</span><br><span class="line">        n_epochs=args.n_epochs,</span><br><span class="line">        targets=targets,</span><br><span class="line">        scale_target=args.scale_y,</span><br><span class="line">        main_task=args.main_task,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 完成Weights &amp; Biases运行</span></span><br><span class="line">    <span class="keyword">if</span> wandb.run <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        wandb.finish()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="evaluate"><a href="#evaluate" class="headerlink" title="evaluate"></a>evaluate</h4><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">evaluate</span>(<span class="params">model, loader, std, scale_target</span>): <span class="comment"># 评估模型；数据加载其；标准差；bool值</span></span><br><span class="line">    model.<span class="built_in">eval</span>() <span class="comment"># 模型切换为评估模式</span></span><br><span class="line">    data_size = <span class="number">0.0</span></span><br><span class="line">    task_losses = <span class="number">0.0</span> <span class="comment"># 用来累计各个任务的总损失</span></span><br><span class="line">    <span class="keyword">for</span> i, data <span class="keyword">in</span> <span class="built_in">enumerate</span>(loader):</span><br><span class="line">        data = data.to(device)</span><br><span class="line">        out = model(data)</span><br><span class="line">        <span class="keyword">if</span> scale_target:</span><br><span class="line">            task_losses += F.l1_loss(</span><br><span class="line">                out * std.to(device), data.y * std.to(device), reduction=<span class="string">&quot;none&quot;</span></span><br><span class="line">            ).<span class="built_in">sum</span>(</span><br><span class="line">                <span class="number">0</span></span><br><span class="line">            )  <span class="comment"># 平均绝对误差（MAE），考虑了先按标准差进行放缩</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            task_losses += F.l1_loss(out, data.y, reduction=<span class="string">&quot;none&quot;</span>).<span class="built_in">sum</span>(<span class="number">0</span>)  <span class="comment"># 平均绝对误差（MAE）</span></span><br><span class="line">        data_size += <span class="built_in">len</span>(data.y)</span><br><span class="line"></span><br><span class="line">    model.train()</span><br><span class="line"></span><br><span class="line">    avg_task_losses = task_losses / data_size <span class="comment"># 平均任务损失</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将误差从电子伏特（eV）转换为毫电子伏特（meV）</span></span><br><span class="line">    avg_task_losses = avg_task_losses.detach().cpu().numpy()</span><br><span class="line">    avg_task_losses[multiply_indx] *= <span class="number">1000</span> <span class="comment"># multiply_indx定义于utils中，或许是索引了单位是eV的物理化学量</span></span><br><span class="line"></span><br><span class="line">    delta_m = delta_fn(avg_task_losses)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dict</span>(</span><br><span class="line">        avg_loss=avg_task_losses.mean(), <span class="comment"># 所有任务平均损失</span></span><br><span class="line">        avg_task_losses=avg_task_losses, <span class="comment"># 每个任务的平均损失</span></span><br><span class="line">        delta_m=delta_m, <span class="comment"># MTL模型在各个任务上的平均相对误差百分比，基于STL模型的基准表现。这个百分比表示MTL模型相较于STL基准的整体性能提升或退步。</span></span><br><span class="line">    )</span><br></pre></td></tr></table></figure><h3 id="model-py"><a href="#model-py" class="headerlink" title="model.py"></a>model.py</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 这个类定义了一个用于量子化学任务的神经网络模型，并使用了图神经网络（GNN）的相关模块来处理图结构数据。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Net</span>(torch.nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, n_tasks, num_features=<span class="number">11</span>, dim=<span class="number">64</span></span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="variable language_">self</span>.n_tasks = n_tasks</span><br><span class="line">        <span class="variable language_">self</span>.dim = dim</span><br><span class="line">        <span class="variable language_">self</span>.lin0 = torch.nn.Linear(num_features, dim) <span class="comment"># 初始化了一个线性层，用来把输入数据维度从num_features转换为dim</span></span><br><span class="line"></span><br><span class="line">        nn = Sequential(Linear(<span class="number">5</span>, <span class="number">128</span>), ReLU(), Linear(<span class="number">128</span>, dim * dim)) <span class="comment"># 序列模块，用来生成卷积核的权重（使用到一个有序容器，其中包含两个线性层和一个ReLU层）</span></span><br><span class="line">        <span class="comment"># 在 GNN 中，卷积核用于在图结构上进行卷积操作。它们会在图的每个节点及其邻居节点之间滑动，聚合和更新节点特征。卷积核在 GNN 中的作用类似于在图像处理中提取局部特征，但其操作对象是节点及其邻居。其形状可以是多维的，如d×d，其中d是节点特征的维度。</span></span><br><span class="line">        <span class="comment"># 卷积核的权重（Weights of Convolutional Kernel）是卷积核中的元素值。它们是模型训练过程中需要学习的参数。卷积核的权重直接影响卷积操作的结果，从而影响特征提取的效果。</span></span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.conv = NNConv(dim, dim, nn, aggr=<span class="string">&quot;mean&quot;</span>) <span class="comment"># NNConv卷积层，输入输出维度都是dim；使用nn生成的权重进行卷积操作；使用平均聚合</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># GRU（门控循环单元）处理图卷积后的数据，qa其是一种循环神经网络（RNN），用于处理序列数据。GRU 可以捕捉长程依赖，避免梯度消失问题。</span></span><br><span class="line">        <span class="variable language_">self</span>.gru = GRU(dim, dim)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Set2Set 是一种图池化方法，用于将图节点的表示聚合成固定大小的图表示。</span></span><br><span class="line">        <span class="variable language_">self</span>.set2set = Set2Set(dim, processing_steps=<span class="number">3</span>)</span><br><span class="line">        <span class="comment"># 这个线性层将 Set2Set 的输出转换为 dim 维度。</span></span><br><span class="line">        <span class="variable language_">self</span>.lin1 = torch.nn.Linear(<span class="number">2</span> * dim, dim)</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>._init_task_heads() <span class="comment"># 动态创建与任务数量对应的输出层</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 动态创建多个任务头（输出头），每个任务头是一个线性层，将 dim 维度转换为1维输出，对应的是所预测化学分子的相关性质，具体在utils.py中有定义。</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_init_task_heads</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="variable language_">self</span>.n_tasks):</span><br><span class="line">            <span class="built_in">setattr</span>(<span class="variable language_">self</span>, <span class="string">f&quot;head_<span class="subst">&#123;i&#125;</span>&quot;</span>, torch.nn.Linear(<span class="variable language_">self</span>.dim, <span class="number">1</span>))</span><br><span class="line">        <span class="comment"># task_specific是一个 ModuleList，包含所有任务头</span></span><br><span class="line">        <span class="variable language_">self</span>.task_specific = torch.nn.ModuleList(</span><br><span class="line">            [<span class="built_in">getattr</span>(<span class="variable language_">self</span>, <span class="string">f&quot;head_<span class="subst">&#123;i&#125;</span>&quot;</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="variable language_">self</span>.n_tasks)]</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 前向传播方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, data, return_representation=<span class="literal">False</span></span>):</span><br><span class="line">        <span class="comment"># 第一层线性变换和激活，输入是结点特征data.x矩阵</span></span><br><span class="line">        out = F.relu(<span class="variable language_">self</span>.lin0(data.x))</span><br><span class="line">        h = out.unsqueeze(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 图卷积和GRU层</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">            m = F.relu(<span class="variable language_">self</span>.conv(out, data.edge_index, data.edge_attr))</span><br><span class="line">            out, h = <span class="variable language_">self</span>.gru(m.unsqueeze(<span class="number">0</span>), h)</span><br><span class="line">            out = out.squeeze(<span class="number">0</span>)</span><br><span class="line">        <span class="comment"># data.edge_index是边索引矩阵（通常是2×edges_num的张量），决定了图中哪些点之间有信息的传递；data.edgea_attr是边特征矩阵（通常是edges_num×edge_features_num的张量），边的特征在信息传递的过程中可能会被使用</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Set2Set池化</span></span><br><span class="line">        out = <span class="variable language_">self</span>.set2set(out, data.batch)</span><br><span class="line">        features = F.relu(<span class="variable language_">self</span>.lin1(out))</span><br><span class="line">        logits = torch.cat(</span><br><span class="line">            [<span class="built_in">getattr</span>(<span class="variable language_">self</span>, <span class="string">f&quot;head_<span class="subst">&#123;i&#125;</span>&quot;</span>)(features) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="variable language_">self</span>.n_tasks)], dim=<span class="number">1</span></span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">if</span> return_representation:</span><br><span class="line">            <span class="keyword">return</span> logits, features</span><br><span class="line">        <span class="keyword">return</span> logits</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 返回模型中共享层的参数迭代器</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">shared_parameters</span>(<span class="params">self</span>) -&gt; Iterator[torch.nn.parameter.Parameter]:</span><br><span class="line">        <span class="keyword">return</span> chain(</span><br><span class="line">            <span class="variable language_">self</span>.lin0.parameters(),</span><br><span class="line">            <span class="variable language_">self</span>.conv.parameters(),</span><br><span class="line">            <span class="variable language_">self</span>.gru.parameters(),</span><br><span class="line">            <span class="variable language_">self</span>.set2set.parameters(),</span><br><span class="line">            <span class="variable language_">self</span>.lin1.parameters(),</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 返回任务头（最后输出的线性层）的参数迭代器</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">task_specific_parameters</span>(<span class="params">self</span>) -&gt; Iterator[torch.nn.parameter.Parameter]:</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.task_specific.parameters()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 返回最后一层共享层的参数迭代器</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">last_shared_parameters</span>(<span class="params">self</span>) -&gt; Iterator[torch.nn.parameter.Parameter]:</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.lin1.parameters()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="utils-py"><a href="#utils-py" class="headerlink" title="utils.py"></a>utils.py</h3><h4 id="target"><a href="#target" class="headerlink" title="target"></a>target</h4><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">qm9_target_dict = &#123;</span><br><span class="line">    <span class="number">0</span>: <span class="string">&quot;mu&quot;</span>,</span><br><span class="line">    <span class="number">1</span>: <span class="string">&quot;alpha&quot;</span>,</span><br><span class="line">    <span class="number">2</span>: <span class="string">&quot;homo&quot;</span>,</span><br><span class="line">    <span class="number">3</span>: <span class="string">&quot;lumo&quot;</span>,</span><br><span class="line">    <span class="number">5</span>: <span class="string">&quot;r2&quot;</span>,</span><br><span class="line">    <span class="number">6</span>: <span class="string">&quot;zpve&quot;</span>,</span><br><span class="line">    <span class="number">7</span>: <span class="string">&quot;U0&quot;</span>,</span><br><span class="line">    <span class="number">8</span>: <span class="string">&quot;U&quot;</span>,</span><br><span class="line">    <span class="number">9</span>: <span class="string">&quot;H&quot;</span>,</span><br><span class="line">    <span class="number">10</span>: <span class="string">&quot;G&quot;</span>,</span><br><span class="line">    <span class="number">11</span>: <span class="string">&quot;Cv&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># for \Delta_m calculations</span></span><br><span class="line"><span class="comment"># -------------------------</span></span><br><span class="line"><span class="comment"># DimeNet uses the atomization energy for targets U0, U, H, and G.</span></span><br><span class="line">target_idx = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">11</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Report meV instead of eV.</span></span><br><span class="line">multiply_indx = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"></span><br><span class="line">n_tasks = <span class="built_in">len</span>(target_idx)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="MyTransform"><a href="#MyTransform" class="headerlink" title="MyTransform"></a>MyTransform</h4><p>MyTransform的主要作用是在加载 QM9 数据集时选择并提取感兴趣的目标属性（y）</p><p>其用作QM9类，torch_geometric.datasets.QM9(root, transform&#x3D;None, pre_transform&#x3D;None, pre_filter&#x3D;None)，其中的transform参数，应用于每个数据对象的变换函数或变换序列。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyTransform</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, target: <span class="built_in">list</span> = <span class="literal">None</span></span>):</span><br><span class="line">        <span class="keyword">if</span> target <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            target = torch.tensor([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">11</span>])  <span class="comment"># removing 4</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            target = torch.tensor(target)</span><br><span class="line">        <span class="variable language_">self</span>.target = target</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, data</span>):</span><br><span class="line">        <span class="comment"># Specify target.</span></span><br><span class="line">        data.y = data.y[:, <span class="variable language_">self</span>.target]</span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Compelete"><a href="#Compelete" class="headerlink" title="Compelete"></a>Compelete</h4><p>Complete 类的主要作用是将原始的图数据转换为完全图，以便更好地捕获全局信息和特征。通过添加所有可能的边，并保留原有的边特征，这种转换为某些图神经网络模型的训练和评估提供了便利。</p><p>其用作QM9类，torch_geometric.datasets.QM9(root, transform&#x3D;None, pre_transform&#x3D;None, pre_filter&#x3D;None)，其中的pre_transform参数，应用于预处理数据对象的变换函数，仅在数据集下载和处理时运行一次。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Complete</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, data</span>):</span><br><span class="line">        device = data.edge_index.device</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 创建所有节点的组合（即完整连接），通过将图补全为完全图，每个节点都与其他所有节点相连。这有助于捕获全局的结构信息，特别是当你需要计算节点之间的距离或集成全局特征时。</span></span><br><span class="line">        row = torch.arange(data.num_nodes, dtype=torch.long, device=device)</span><br><span class="line">        col = torch.arange(data.num_nodes, dtype=torch.long, device=device)</span><br><span class="line"></span><br><span class="line">        row = row.view(-<span class="number">1</span>, <span class="number">1</span>).repeat(<span class="number">1</span>, data.num_nodes).view(-<span class="number">1</span>)</span><br><span class="line">        col = col.repeat(data.num_nodes)</span><br><span class="line">        edge_index = torch.stack([row, col], dim=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        edge_attr = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> data.edge_attr <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># 复制现有边特征到新的完全图中，保留原有的边特征，并将其复制到新的完全图中，确保节点之间的连接信息不丢失。</span></span><br><span class="line">            idx = data.edge_index[<span class="number">0</span>] * data.num_nodes + data.edge_index[<span class="number">1</span>]</span><br><span class="line">            size = <span class="built_in">list</span>(data.edge_attr.size())</span><br><span class="line">            size[<span class="number">0</span>] = data.num_nodes * data.num_nodes</span><br><span class="line">            edge_attr = data.edge_attr.new_zeros(size)</span><br><span class="line">            edge_attr[idx] = data.edge_attr</span><br><span class="line">        <span class="comment"># 移除自环，移除自环以减少噪声，有助于某些模型的训练和性能提升。</span></span><br><span class="line">        edge_index, edge_attr = remove_self_loops(edge_index, edge_attr)</span><br><span class="line">        data.edge_attr = edge_attr</span><br><span class="line">        data.edge_index = edge_index</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="delta-fn"><a href="#delta-fn" class="headerlink" title="delta_fn"></a>delta_fn</h4><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># stl results</span></span><br><span class="line">BASE = np.array(</span><br><span class="line">    [</span><br><span class="line">        <span class="number">0.0671</span>,</span><br><span class="line">        <span class="number">0.1814</span>,</span><br><span class="line">        <span class="number">60.576</span>,</span><br><span class="line">        <span class="number">53.915</span>,</span><br><span class="line">        <span class="number">0.5027</span>,</span><br><span class="line">        <span class="number">4.539</span>,</span><br><span class="line">        <span class="number">58.838</span>,</span><br><span class="line">        <span class="number">64.244</span>,</span><br><span class="line">        <span class="number">63.852</span>,</span><br><span class="line">        <span class="number">66.223</span>,</span><br><span class="line">        <span class="number">0.07212</span>,</span><br><span class="line">    ]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">SIGN = np.array([<span class="number">0</span>] * n_tasks)</span><br><span class="line">KK = np.ones(n_tasks) * -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delta_fn</span>(<span class="params">a</span>):</span><br><span class="line">    <span class="keyword">return</span> (KK ** SIGN * (a - BASE) / BASE).mean() * <span class="number">100.0</span>  <span class="comment"># *100 for percentage</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h3><ol><li>MR的计算？</li><li>训练的结束？（论文中提到了根据验证集的评估情况，提前结束训练）</li><li>$\Delta_m$%的含义？（MTL 模型在各个任务上的平均相对误差百分比，基于 STL 模型的基准表现。这个百分比表示 MTL 模型相较于 STL 基准的整体性能提升或退步。）</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习（MTL） </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式计算框架MapReduce</title>
      <link href="/2025/05/15/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97%E6%A1%86%E6%9E%B6MapReduce/"/>
      <url>/2025/05/15/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97%E6%A1%86%E6%9E%B6MapReduce/</url>
      
        <content type="html"><![CDATA[<p><code>这篇blog用于记录我在学习计算机系统工程导论时所做的一次实验。我阅读了一篇论文，其介绍了一种名为MapReduce的模型，它通过键值对来拆解任务同时并行地处理子任务，达到了提高数据吞吐率从而降低时延提高性能的效果。</code></p><h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><p>主要实验目的如下：</p><ol><li>通过实验，理解MapReduce框架的基本原理，掌握MapReduce框架的Map阶段和Reduce阶段的执行流程，以及数据的划分、传输和聚合过程，具备使用MapReduce进行简单的分布式数据处理，并能通过进一步自学进行更为复杂的分布式数据处理，从而掌握使用MapReduce进行大数据处理的基本系统设计能力。</li><li>通过程序验证，理解性能优化中的并发技术对时延和吞吐率的影响，掌握用并发技术提升系统性能的设计思想。</li><li>通过观察分析，理解系统的可并行性与不可并行性的差异，理解工程实践中的并行不完备问题，通过思考该问题，训练理解和处理工程实践冲突和设计实现差异的思维能力。</li><li>通过实验准备和作业提交过程中的论文查阅（MapReduce2004），<br>逐步掌握外文专业文献的检索、学习和应用能力。</li></ol><h2 id="实验过程与习题"><a href="#实验过程与习题" class="headerlink" title="实验过程与习题"></a>实验过程与习题</h2><h3 id="2-1-WordCount"><a href="#2-1-WordCount" class="headerlink" title="2.1 WordCount"></a>2.1 WordCount</h3><h4 id="问题1：WordCount的-init-方法的参数是maptask和reducetask，简单地解释一下这两个变量都控制了什么？"><a href="#问题1：WordCount的-init-方法的参数是maptask和reducetask，简单地解释一下这两个变量都控制了什么？" class="headerlink" title="问题1：WordCount的__init__方法的参数是maptask和reducetask，简单地解释一下这两个变量都控制了什么？"></a>问题1：WordCount的__init__方法的参数是maptask和reducetask，简单地解释一下这两个变量都控制了什么？</h4><p>maptask指定了Map阶段的并行任务数（原始数据分块数），在MapReduce模型中会将数据先进行分块处理，然后在每一块上运行一个Map任务，所以这个参数也间接决定了每一个Map任务需要处理的数据量大小。</p><p>reducetask指定了Reduce阶段的并行任务数（中间数据分区数），在模型中会先对Map任务处理完成的中间键值对数据进行分区，在每一个区上运行一个Reduce任务，这个参数也间接决定了每个Reduce任务需要处理的数据量大小。</p><p>由run方法中线程池使用了这两个参数来启动线程可知，如下图所示。</p><p>如图1所示</p><h4 id="问题2：简要解释调用run如何触发对WordCount实例的map和reduce方法的调用"><a href="#问题2：简要解释调用run如何触发对WordCount实例的map和reduce方法的调用" class="headerlink" title="问题2：简要解释调用run如何触发对WordCount实例的map和reduce方法的调用"></a>问题2：简要解释调用run如何触发对WordCount实例的map和reduce方法的调用</h4><p>WordCount类继承了MapReduce类，使用<code>wc.run()</code>调用了run方法；</p><p>在run方法中使用<code>Pool</code>创建了进程池，并添加了相应的进程数量；</p><p>根据maptask、reducetask启动了相应数量的Map和Reduce任务，对应为<code>doMap()</code>和<code>doReduce()</code>函数；（这两个函数相当于MapReduce模型中map和reduce工作结点在调用用户的Map、Reduce函数前所进行的预处理操作）</p><p>在doMap函数中调用了<code>Map()</code>，在doReduce函数中调用了<code>Reduce()</code>即WordCount实例的map和reduce方法；</p><p>综上，通过run触发了WordCount实例的map和reduce方法的调用。</p><p>doMap、doReduce调用Map、Reduce的位置如下图所示。</p><p>如图2所示</p><h3 id="Map和Reduce"><a href="#Map和Reduce" class="headerlink" title="Map和Reduce"></a>Map和Reduce</h3><h4 id="问题3：WordCount中map方法的参数keyvalue和value代表什么？"><a href="#问题3：WordCount中map方法的参数keyvalue和value代表什么？" class="headerlink" title="问题3：WordCount中map方法的参数keyvalue和value代表什么？"></a>问题3：WordCount中map方法的参数keyvalue和value代表什么？</h4><p>keyvalue代表了当前处理的数据块对应的文本起始位置在整个文本文件中的偏移量。</p><p>因为<code>keyvalue = f.readline()</code>，而前面进行Split处理的时候，将整个文本文件按块分割为了多个中间文件，中间文件的起始行由<code>f.write(str(i) + &quot;\n&quot;)</code>记录了当前的偏移<code>i</code>。</p><p>value代表了当前处理数据块对应的文本数据。</p><p>因为<code>value = f.read()</code>，读取了相应的文本数据赋值给value。</p><p>keyvalue、value的赋值情况如下图所示</p><p>如图3所示</p><h4 id="问题4：WordCount中reduce方法的参数key和keyvalues代表什么？"><a href="#问题4：WordCount中reduce方法的参数key和keyvalues代表什么？" class="headerlink" title="问题4：WordCount中reduce方法的参数key和keyvalues代表什么？"></a>问题4：WordCount中reduce方法的参数key和keyvalues代表什么？</h4><p>每个reduce任务会将自己处理的数据区的键值对按照键聚集起来形成集合，并进行排序。</p><p>key代表了当前处理的是第几个键值对集合，keyvalues代表了当前处理的键值对集合中的各个键值对。</p><p>注：这里使用“集合”只是形象的表述，由于单词计数的任务特征，实际上同一键值对集合中的各个“元素”都是完全相同的键值对，<code>(str,1)</code>，所以这里的“集合”并不具有“互异性”</p><p>key、keyvalues的赋值情况如下图所示。</p><p>如图4所示</p><h3 id="Map和Reduce的并行"><a href="#Map和Reduce的并行" class="headerlink" title="Map和Reduce的并行"></a>Map和Reduce的并行</h3><h4 id="问题5：doMap有多少调用，doReduce有多少调用？为什么？"><a href="#问题5：doMap有多少调用，doReduce有多少调用？为什么？" class="headerlink" title="问题5：doMap有多少调用，doReduce有多少调用？为什么？"></a>问题5：doMap有多少调用，doReduce有多少调用？为什么？</h4><p>doMap有maptask次调用，doReduce有reducetask次调用。</p><p>因为在run方法中，通过线程池的map函数分别按照<code>range(0,self.maptask)</code>和<code>range(0,self.reducetask)</code>分发了maptask个doMap调用、reducetask个doReduce调用。</p><h4 id="问题6：假设有足够的内核，哪些调用是并行运行的？"><a href="#问题6：假设有足够的内核，哪些调用是并行运行的？" class="headerlink" title="问题6：假设有足够的内核，哪些调用是并行运行的？"></a>问题6：假设有足够的内核，哪些调用是并行运行的？</h4><p>假设内核是足够的，所有的doMap调用是并行的、所有的doReduce调用是并行的；doMap与doReduce两种调用之间是串行的。</p><p>因为doMap由线程池管理的线程一一调用，doReduce同理；而在所有doMap完成之后才开始由线程池管理调用。</p><h4 id="问题7：对于maptask和reducetask参数的值，哪一个影响到了程序的运行时间？为什么有的参数不会对程序的运行时间产生影响？（可以通过在代码中创建开始时间和结束时间来计算程序运行时间）"><a href="#问题7：对于maptask和reducetask参数的值，哪一个影响到了程序的运行时间？为什么有的参数不会对程序的运行时间产生影响？（可以通过在代码中创建开始时间和结束时间来计算程序运行时间）" class="headerlink" title="问题7：对于maptask和reducetask参数的值，哪一个影响到了程序的运行时间？为什么有的参数不会对程序的运行时间产生影响？（可以通过在代码中创建开始时间和结束时间来计算程序运行时间）"></a>问题7：对于maptask和reducetask参数的值，哪一个影响到了程序的运行时间？为什么有的参数不会对程序的运行时间产生影响？（可以通过在代码中创建开始时间和结束时间来计算程序运行时间）</h4><p>maptask和reducetask的值理论上都会影响到程序运行的时间。如果有其中之一不会对程序的运行时间产生影响，我认为原因是当前这个参数并非程序运行时间的瓶颈所在。例如当reducetask决定Reduce阶段才是任务执行的瓶颈的时候，增加maptask的数量并不会显著加快程序运行的时间，例如下图中的<strong>2个maptask，2个reducetask和4个maptask，2个reducetask</strong>情况下的对照，可以说明这个问题。</p><p>图5（2个maptask，2个reducetask运行情况）</p><p>图6（4个maptask，2个reducetask运行情况）</p><p>图7（2个maptask，4个reducetask运行情况）</p><p>图8（4个maptask，4个reducetask运行情况）</p><p>图9（8个maptask，8个reducetask运行情况）</p><h2 id="遇到的问题及解决办法"><a href="#遇到的问题及解决办法" class="headerlink" title="遇到的问题及解决办法"></a>遇到的问题及解决办法</h2><p>在进行本次实验的过程中，我主要遇到了以下几个问题：</p><ol><li><p>在探究WordCount中Map方法的参数keyvalue的时候，我不太理解这个参数存在的意义。虽然通过Split分割文本时，记录了相应的偏移，再在doMap阶段将偏移读入了keyvalue，最终在调用用户的Map的时候将keyvalue传递给了Map方法，但是Map方法并没有使用到keyvalue。所以起初，我认为这个参数没必要存在。后来，我与同学进行了一些讨论，我们发现在MapReduce的文献中，描述该模型的工作规范时，有类似这样的陈述“被分配 map 任务的工作节点读取对应输入分片的内容。它从输入数据中解析出键&#x2F;值对，并将每个对传递给用户定义的 Map 函数。Map 函数产生的中间键&#x2F;值对被缓存在内存中。”于是，我们认为，此处的keyvalue、value对应的正是map任务工作结点解析产生的键值对，后续Map函数将在value中进一步解析产生中间键值对。于是，我们认为此处虽然没有用到keyvalue，但是这是<strong>模型的思想所在</strong>，应当予以规范地保留。</p></li><li><p>在探究问题7的时候，对于maptask、reducetask的大小和任务执行的快慢，似乎有一些合不上，因为起初我认为应该两个任务分配得越多，并行越多，执行越快。但是可以看到在8个maptask，8个reducetask的情况下，执行时间却是最慢的。于是我查阅相关资料，了解到，这可能有以下几种原因：1）与我的内核数有关，如果系统内核数小于进程数，则会带来频繁地上下文切换，进一步增大时延（这或许就是为什么分配任务数最多的时候，反而最慢的原因）2）Map阶段的输出需要传递给Reduce阶段，如果并行的任务数增加，可能带来更加频繁地数据交换，从而造成I&#x2F;O瓶颈，增大时延（这可能是我单独增大reducetask时，运行变慢的原因）3）最后这个原因比较有趣，我开始完全没有考虑过，即任务之间的负载均衡问题，如果分配数量过多，可能导致有的任务几乎没有数据处理，但是仍然占用了相关的计算机资源，在资源有限的情况下，实际工作的任务分配到的资源减少，同样也会造成执行时间变慢。</p></li></ol><h2 id="课后实验与思考（选做）"><a href="#课后实验与思考（选做）" class="headerlink" title="课后实验与思考（选做）"></a>课后实验与思考（选做）</h2><p>我在原始代码的基础上，新增了一个ReverseIndex类用于替代原来的WordCount类，并在其中添加了类似于先前的Map、Reduce方法。Map方法的主要更改是形成的键值对是(word,offset)，而不再是用于计数的(word,1)，在Reduce中会对中间键值对进行处理，返回的是一个(word,sorted(list))，list中是同一word的各个offset，并且按照从小到大进行了排序。最后再简单处理一下结果，按照word的字典序（a~z），输出前二十组(word,sorted(list))。得到如下图所示的结果。</p><p>结果如图10所示</p><h2 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h2><p>通过本次实验，在阅读MapReduce文献的基础上，我进一步地理解了这个模型的工作方式，其通过Map、Reduce来便捷地实现任务的并行是模型思想的核心所在，尤其是理解了先前阅读文献时不太理解的map工作阶段、reduce工作阶段和用户的Map、Reduce函数之间的关系以及具体是怎样工作的。此外我还学习到了一些有关Python的知识，例如线程池管理下的简单的多线程编程，还有有关Python类之间继承关系与函数复用的知识。最后我通过课后实验与思考，增强了自己的Python编码能力，同时进一步熟悉了MapReduce的工作方式，收获颇丰。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MapReduce</title>
      <link href="/2025/05/11/MapReduce/"/>
      <url>/2025/05/11/MapReduce/</url>
      
        <content type="html"><![CDATA[<p><code>这篇blog用于记录，我在学习计算机系统工程导论，有关性能的章节时，阅读的一篇叫做MapReduce的论文</code></p><h2 id="工程师提出MapReduce的编程模型和实现，他们的性能目标是什么？"><a href="#工程师提出MapReduce的编程模型和实现，他们的性能目标是什么？" class="headerlink" title="工程师提出MapReduce的编程模型和实现，他们的性能目标是什么？"></a>工程师提出MapReduce的编程模型和实现，他们的性能目标是什么？</h2><p>他们的性能目标是通过MapReduce实现大规模数据专用计算的自动并行化，使得缺少并行与分布式系统经验的程序员可以轻松利用大规模分布式系统资源，从而突破数据处理的时延这一性能瓶颈。</p><h2 id="Google是怎么通过实现去满足这些目标的？"><a href="#Google是怎么通过实现去满足这些目标的？" class="headerlink" title="Google是怎么通过实现去满足这些目标的？"></a>Google是怎么通过实现去满足这些目标的？</h2><p>MapReduce程序主要有用户部分和库部分，前者根据用户的业务逻辑需要在后者的基础上进行编写，而相关的并行化、容错、本地优化和负载均衡的细节被隐藏在后者中。整个系统的工作流程是：MapReduce库分割输入文件为较小块，并启动程序运行于机器集群之上；主结点根据块的分割情况，将map、reduce任务分配给各个机器处理；map任务通过用户的MAP函数建立相应的键值对；reduce任务将map任务处理的结果进行排序从而组合相同键，再通过用户的Reduce进行处理。这样的程序系统可以运行于廉价的PC集群之上，可以显著减少时延。</p><p>基于此，Google使用MapReduce程序来进行自己业务要求的实现：重写了生成Google网页搜索服务所需数据结构的生产索引、生成流行查询报告的数据提取、用于新实验和产品的网页属性提取等等。</p><h2 id="MapReduce为什么选择这样实现，而没有走其它技术道路？"><a href="#MapReduce为什么选择这样实现，而没有走其它技术道路？" class="headerlink" title="MapReduce为什么选择这样实现，而没有走其它技术道路？"></a>MapReduce为什么选择这样实现，而没有走其它技术道路？</h2><p>因为许多类型的问题都可以轻松地用MapReduce这种模型进行表示，从而被并行化地计算，所以其泛用性很好；基于这种模型的处理方式具有很强的可拓展性，考虑增加相应的工作结点，就可以用较低的代价换取较高的性能提升，通过合适的Map、Reduce函数也可以带来更加个性化的工作方式；这样的实现充分考虑了故障的可能，以及潜在的风险，并设计了相对应的处理方式，使得其可靠性较强，这一点从文献中提供的相关数据也可以看出。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文精读：基于博弈论的复任务学习</title>
      <link href="/2025/05/08/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB%EF%BC%9A%E5%9F%BA%E4%BA%8E%E5%8D%9A%E5%BC%88%E8%AE%BA%E7%9A%84%E5%A4%8D%E4%BB%BB%E5%8A%A1%E5%AD%A6%E4%B9%A0/"/>
      <url>/2025/05/08/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB%EF%BC%9A%E5%9F%BA%E4%BA%8E%E5%8D%9A%E5%BC%88%E8%AE%BA%E7%9A%84%E5%A4%8D%E4%BB%BB%E5%8A%A1%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p><code>这篇文献的原名是《Multi-Task Learning as a Bargaining Game》，这是我第一次尝试直接通篇阅读英文原文的文献，中间或许会遇到许多困难。我通过这篇blog来记录阅读的过程中遇到的概念，以及简单地对文章整体的脉络进行梳理。最终我希望对论文提到的算法进行复现，这篇blog将会是一个参考。</code></p><h2 id="概念部分"><a href="#概念部分" class="headerlink" title="概念部分"></a>概念部分</h2><p><code>这一部分用于记录阅读时遇到的概念型词汇，并做一些补充解释。困难在于，有的词汇我并不清楚是否是概念型的专业词汇，亦或是只需理解表面含义的词汇...</code></p><h3 id="gradients"><a href="#gradients" class="headerlink" title="gradients"></a>gradients</h3><p>梯度，包含某函数相对自身所有自变量的偏导数。</p><p>对于损失函数$L$梯度$\nabla L$，描述损失函数在参数空间中变化率最快的方向。</p><p>在机器学习中，训练的模型时常需要最小化损失函数，这时常用的方法就是梯度下降算法，通过计算损失函数的梯度，模型可以知道应该如何调整参数，从而减小预测误差。</p><p>梯度冲突，一个任务的梯度指示减小参数，另一个梯度指示增加参数，相互矛盾，最终得不出一个较好的结果。</p><h3 id="multiple-MTL-benchmarks"><a href="#multiple-MTL-benchmarks" class="headerlink" title="multiple MTL benchmarks"></a>multiple MTL benchmarks</h3><p>指的是多个被广泛认可的基准测试数据集或任务，这些任务用于评估多任务学习模型的性能。这些基准测试可以涵盖不同的应用领域，如自然语言处理、计算机视觉、语音识别等。</p><p>benchmark本意是基准</p><ol><li><p>QM9：QM9是一个化学分子数据集，主要用于分子性质预测任务。它包含了约13万条小分子的数据，每个分子都由其原子结构表示，同时提供了9个分子性质的标签（例如，分子的能量、分子的极化率、分子的稳定性等）。这些性质是通过量子力学计算方法（例如密度泛函理论，DFT）得到的。在化学领域，QM9数据集被广泛用于评估各种机器学习模型在分子性质预测任务上的表现。这个数据集是一个相对复杂的回归问题，用于测试模型在不同分子特征下的泛化能力。</p></li><li><p>MT10：MT10数据集是一个多任务学习（MTL）基准数据集，通常用于多任务学习研究的测试。它包含了10个任务，这些任务可以是不同的机器学习任务（例如，分类任务、回归任务等），目标是评估模型在同时处理多个任务时的表现。每个任务都共享一些特征，但每个任务有不同的输出目标，因此适合用于测试多任务学习方法的性能。</p></li></ol><h3 id="Cooperative-bargaining-game"><a href="#Cooperative-bargaining-game" class="headerlink" title="Cooperative bargaining game"></a>Cooperative bargaining game</h3><p>合作博弈，是一种博弈论中的模型，旨在分析参与者如何在合作的情况下进行资源分配或达成协议。</p><p>在多任务学习（MTL）的上下文中，将梯度组合视为一个合作博弈意味着：</p><ol><li>多个任务：每个任务可以看作一个玩家，它们通过共享知识和信息来提高整体性能。</li><li>梯度组合：不同任务的梯度可以被看作是不同玩家的“要求”，通过合作来找到一个能有效结合这些梯度的方式，从而优化模型的表现。</li><li>协商一致：通过合作博弈的方法，任务之间可以“协商”如何平衡彼此的梯度，以减少冲突并提高整体性能。</li></ol><h3 id="Proportionally-fair"><a href="#Proportionally-fair" class="headerlink" title="Proportionally fair"></a>Proportionally fair</h3><p>（按比例公平）是一个博弈论和分配理论中的概念，主要用于描述一种资源分配或收益分配的方法。在这种分配方式下，任何替代方案的平均相对变化都是负的，这意味着在分配中没有任何参与者会因为其他参与者的利益而遭受显著的损失。</p><p>用于MTL中可以：避免主导效应，通过按比例公平的更新，可以确保没有单一任务的梯度（特别是那些较大的梯度）主导更新过程。这可以防止某个任务的影响过大，导致模型在其他任务上的性能下降。<br><strong>Nash bargaining solution就是一种按比例公平的方法</strong></p><h3 id="convex"><a href="#convex" class="headerlink" title="convex"></a>convex</h3><p>convex，字面含义是凸性</p><p>凸集：<br>一个集合 $C$ 被称为 凸集，如果对于集合中的任意两个点 $x_1$和 $x_2$，连接这两个点的线段上的所有点也都在集合 $C$ 中。在数学上可以表示为：</p><p>$\forall x_1, x_2 \in C, \forall \lambda \in [0, 1], \quad \lambda x_1 + (1 - \lambda) x_2 \in C$</p><p>凸函数：<br>一个函数 $f: \mathbb{R}^n \to \mathbb{R}$被称为 凸函数，如果其定义域是一个凸集，并且对于任意的 $x_1, x_2$和 $\lambda \in [0, 1]$，都有：<br>$f(\lambda x_1 + (1 - \lambda) x_2) \leq \lambda f(x_1) + (1 - \lambda) f(x_2)$<br>这表示函数的图形在任意两个点之间的连线不会低于函数的值，换句话说，函数呈一个“碗”的形状。<strong>这与我在大一选修工科数学分析学到的相同，当时老师强调了凸有两种含义，显然这里是下凸上凹的那一种。</strong></p><p>凸性的性质：<br>局部极小值即全局极小值：对于凸函数，如果在某一点有局部极小值，那么该点也是全局极小值。这是凸优化中非常重要的性质。</p><p>非凸的情况：<br>与凸函数相对的是 非凸函数，这些函数可能存在多个局部极小值，这使得优化过程更为复杂。在非凸情况下，找到全局最优解可能更具挑战性。</p><h3 id="帕累托最优"><a href="#帕累托最优" class="headerlink" title="帕累托最优"></a>帕累托最优</h3><p>多目标优化中解的支配关系：如果解$x$支配$x’$则，$x$在$(l_1,l_2,…,l_k)$的目标函数向量上，有1个或多个分量的结果优于$x’$。</p><p>Pareto Optimal：如果在多目标任务的定义域中对于解$x$没有支配自己的其它解，则称该解为帕累托最优</p><p>Local Pareto Optimal：在定义域的子集开集中的帕累托最优，称为帕累托局部最优</p><p>Pareto Stationary：如果解空间中一个点$x$是帕累托静止点，那么在该点上对于多目标对应的各个函数存在梯度凸组合为0。这意味着在该点的所有目标函数的梯度（导数）在某种程度上是平衡的，没有明显的“倾斜”方向可以改进所有目标。</p><p><strong>Pareto stationarity 是 Pareto optimality 的必要条件，但不是充分条件。这意味着一个点如果是 Pareto 最优的，那么它必须是 Pareto stationary 的，但反过来则不一定成立。</strong></p><p>凸组合：是指在数学和优化中，利用给定点的加权平均来形成新点的一种方法。具体来说，给定一组点 $x_1, x_2, \ldots, x_n$和对应的非负权重 $\lambda_1, \lambda_2, \ldots, \lambda_n$，如果这些权重的总和为 1，即</p><p>$\lambda_1 + \lambda_2 + \ldots + \lambda_n &#x3D; 1$<br><strong>注意这些权重都是非负的</strong></p><p>那么我们可以定义一个凸组合 $x$ 为：</p><p>$x &#x3D; \lambda_1 x_1 + \lambda_2 x_2 + \ldots + \lambda_n x_n$</p><p>凸组合的几何意义：在几何上，凸组合可以被视为在给定点之间的“插值”。例如，在二维空间中，两个点的凸组合会形成这两个点之间的线段，而三个点的凸组合则会形成这三点构成的三角形内部的所有点。</p><p>在多目标优化中，凸组合常用于表示不同目标之间的权衡。</p><h3 id="一些衡量MTL模型性能的指标"><a href="#一些衡量MTL模型性能的指标" class="headerlink" title="一些衡量MTL模型性能的指标"></a>一些衡量MTL模型性能的指标</h3><p>1)Segmentation（语义分割）</p><p>mIoU：平均交并比。这个指标是语义分割中常用的评价标准，计算方式是每个类别的交并比（IoU，Intersection over Union）取平均。交并比是预测结果和真实标签之间的交集与并集的比值。这个指标反映了模型在每个类别上的分割准确性，<strong>值越大表示分割结果越好</strong>。</p><p>Pix Acc：像素准确率。这个指标计算的是正确分类的像素点占总像素点的比例。它是一个比较简单的衡量标准，但可能在类别不均衡时会有偏差。</p><p>2)Depth（深度估计）相对误差</p><p>Abs Err：绝对误差。对于每个像素点，计算其预测深度值和真实深度值之间的差异的绝对值，然后取平均。这个指标越小，表示深度估计越准确。</p><p>Rel Err：计算预测深度值与真实深度值之间的相对差异，通常表示为：<br>$  \text{Rel Err} &#x3D; \frac{| \hat{d} - d |}{d} $</p><p>3)Surface Normal（表面法线）</p><p>Angle Distance：角度距离。这个指标计算的是预测法线方向与真实法线方向之间的角度差异。通常以度数（°）表示，<strong>值越小表示模型的法线估计越准确</strong>。</p><p>Within（Within Threshold）：通常指的是预测的法线与真实法线之间的角度差异小于某个阈值的比例。例如，如果设定阈值为$\theta$（例如11.25°、22.5°等），则“Within $\theta$”表示法线估计误差小于该阈值的像素所占比例。这个<strong>指标反映了模型能够准确预测法线的比例</strong>。</p><p>4)MR（Mean Rank）</p><p>**MR(Mean Rank)**是一个排名相关的指标，常用于排序问题。它通常计算的是模型对预测结果的排名准确度。例如，如果模型的预测最接近真实值，那么它会在排名中处于较高的位置。Mean Rank是计算多个任务或样本的平均排名值。</p><p>5)Δm%</p><p>Delta m%（Δm%）表示相对于基线模型的性能提升或下降百分比。计算方式通常是：<br>$  \Delta m% &#x3D; \frac{(\text{new performance} - \text{baseline performance})}{100}$</p><h3 id="张量"><a href="#张量" class="headerlink" title="张量"></a>张量</h3><p>张量的定义<br>在数学上，张量是一个多维数组，扩展了标量、向量和矩阵的概念。具体来说：</p><p>标量（Scalar）: 零阶张量，即一个单一的数值。<br>向量（Vector）: 一阶张量，即一维数组，具有方向和大小。<br>矩阵（Matrix）: 二阶张量，即二维数组，具有行和列的结构。<br>高阶张量（Higher-order Tensor）: 三维及以上的多维数组。</p><p>机器学习与深度学习: 训练数据和模型参数通常可以表示为高维张量。比如在深度学习框架（如TensorFlow和PyTorch）中，数据和权重都是以张量的形式存储和操作的。</p><h3 id="字面词汇"><a href="#字面词汇" class="headerlink" title="字面词汇"></a>字面词汇</h3><p>alleviate，缓解</p><p>negotiate，协商</p><p>heuristic，启发式方法</p><p>convergence，收敛</p><h3 id="文章架构"><a href="#文章架构" class="headerlink" title="文章架构"></a>文章架构</h3><p>这篇文章引入博弈论中的Nash bargaining solution，作为MTL中的aggregation algorithm，对多任务的梯度进行整合，减小gradients conflicts带来的性能影响。</p><p>总的来看，文章分为以下几个部分：</p><ol><li>改进Nash bargaining solution以适应MTL</li><li>从理论上对算法进行分析，保证了在convex和non-convex的case下的收敛</li><li>在多个领域对算法进行了验证</li></ol><h3 id="改进Nash-bargaining-solution以适应MTL"><a href="#改进Nash-bargaining-solution以适应MTL" class="headerlink" title="改进Nash bargaining solution以适应MTL"></a>改进Nash bargaining solution以适应MTL</h3><h4 id="Nash-bargaining-solution"><a href="#Nash-bargaining-solution" class="headerlink" title="Nash bargaining solution"></a>Nash bargaining solution</h4><p><code>这一部分简单介绍纳什协商解(Nash bargaining solution)在谈判博弈(bargaining game)中出现的条件</code></p><p><strong>谈判博弈问题是指</strong>$K$名玩家，每个玩家有一个效用函数$u_i:  A \cup {B} \rightarrow \mathbb{R}$，所有玩家都追求自身<strong>效用函数的最大化</strong>。其中$A$是所有<strong>可能达成的协议</strong>的集合，$D$是<strong>不能达成的协议</strong>（并非集合），对应的是无法达成$A$中元素对应协议时，玩家会采用<strong>默认策略</strong></p><p>定义收益集合$U$与默认收益$d$如下：</p><p>$U &#x3D; {u_1(x),…,u_k(x) : x \in A} \subset \mathbb{R}^{k}$<br>$d &#x3D; (u_1(D),…,u_k(D)) \in \mathbb{R}^{k}$</p><p>假设$U$满足以下性质：</p><ol><li>convex 集合是凸的</li><li>compact 集合是紧致的，即集合满足<strong>有界性、闭性</strong>，有界意味着集合 $U$ 的所有元素（即所有的解）都位于某个有限范围内，没有元素可以无限远离原点；闭性意味着集合 $U$ 包含它的边界点，也就是说，集合中的任何极限点都属于集合 $U$。</li><li>$U$对应的$k$维空间中至少存在一个点$u &#x3D; (u_1,u_2,…,u_k), u \in U$ strictly dominates $d &#x3D; {d_1,d_2,…,d_k}$，即$\forall i &#x3D; 1,…,k: u_i &gt; d_i$</li></ol><p><strong>注：</strong>（在效用函数确定的时候，$U$中不同的点是由协议或称博弈问题的解$x$所影响，产生的。所以当直接讨论$u$的时候实际上可以看作是在讨论某个解$x$，如果直接讨论$u_1,u_2…,u_n$而没有其作为“分量”的上下文，也可以将其看作对应的某些解$x_1,x_2,…,x_n$，或者直接称$U$是解的集合，其中的元素$u_1,u_2,…u_n$就是解）</p><p>则该问题<strong>存在</strong>唯一的解$x$即<strong>最优的策略、协议</strong>，称为<strong>Nash bargaining solution</strong>，且该类博弈具有如下性质：</p><ol><li>Pareto optimality：唯一解$x$满足帕累托最优，此处指的是不存在其它任何解$y$，可以使得$(u_1(y),…u_k(y))$支配$(u_1(x),…,u_k(x))$<br><del>（这个性质确保了，在这类博弈问题中具有唯一的最优解，因为没有其它任何解可以通过损害某方的利益，增大另一方的利益。）</del></li><li>Symmetry： 对称性，交换玩家的排列顺序，最终得到的解仍然是$x$<br><del>（这个性质确保了，这类博弈问题中没有任何特别的角色存在，player的效用函数只于其“所处位置”有关，而与角色自己没有关系。例如player1、palyer2在博弈中扮演character1、character2，则$x$协议下的效用函数对应$(u_1(x),u_2(x))$，交换玩家位置，player1、player2对应character2、character1，同样协议下的效用函数对应$(u_2(x),u_1(x))，效用函数不会因为player的不同而改变，只与character有关$）</del></li><li>Independence of Irrelevant Alternatives (IIA)：不相关选择的独立性，如果在解集合$U$中加入其它<strong>不相关</strong>选项，最优解仍然是$(u_1(x),…,u_k(x))$，不会改变。</li><li>Invariance to affine transformation：仿射变换的不变性，将每个效用函数 $u_i(x)$转换为 $u_i(x) &#x3D; c_i u_i(x) + b_i$且 $c_i &gt; 0$，那么如果原始协议的效用是 $(y_1,…,y_k)$，则经过变换后的协议效用将是 $(c_1 y_1 + b_1,…, c_k y_k + b_k)$。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习（MTL） </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高斯混合聚类</title>
      <link href="/2025/05/07/%E9%AB%98%E6%96%AF%E6%B7%B7%E5%90%88%E8%81%9A%E7%B1%BB/"/>
      <url>/2025/05/07/%E9%AB%98%E6%96%AF%E6%B7%B7%E5%90%88%E8%81%9A%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>高斯混合聚类不同于k-means、LVQ利用原型向量刻画聚类结构，而是利用概率来刻画聚类结构。</p><p>简单来说，这种算法认为数据集中的每个样本都符合一个多元高斯分布（多元的原因是样本常是多元向量），如下</p><p>所有的样本共同符合“混合高斯分布”。混合高斯分布对应的概率密度函数是所有多元高斯分布密度函数的加权量。</p><h3 id="多元高斯分布"><a href="#多元高斯分布" class="headerlink" title="多元高斯分布"></a>多元高斯分布</h3><p>若$x$服从多元高斯分布，对应概率密度函数为</p><p>$p(x) &#x3D; \frac{1}{(2\pi)^{\frac{n}{2}}\lvert \Sigma \rvert^{\frac{1}{2}}}e^{-\frac{1}{2}(x-\mu)^{T}\Sigma^{-1}(x-\mu)}$，其中$x$是样本对应的向量，$\Sigma$是协方差矩阵，$\mu$是期望</p><p>为了便于理解，参照一元高斯分布</p><p>$\frac{1}{\sqrt{2\pi}\sigma}e^{\frac{-1}{2}\frac{(x - \mu)^{2}}{\sigma^{2}}}$</p><p>协方差矩阵就对应方差、多元高斯分布中期望对应一元中的期望（只是多元高斯分布中期望是一个多维向量）</p><p>所以<strong>多元高斯分布的情况，由$\Sigma$和$\mu$唯一确定</strong></p><h3 id="混合高斯分布"><a href="#混合高斯分布" class="headerlink" title="混合高斯分布"></a>混合高斯分布</h3><p>将多元高斯分布密度函数记作$p(x|\mu,\Sigma)$</p><p>可以定义混合高斯分布如下：</p><p>若$x$服从混合高斯分布，整个样本空间对应有k种多元高斯分布，对应概率密度函数$p_M &#x3D; \sum^{k}<em>{i&#x3D;1} \alpha_i p(x|\mu_i,\Sigma_i)$，其中$\alpha$是混合系数，$\alpha_i$对应的实际意义是，选择第$i$个混合成分的概率，所以有$\alpha_i &gt; 0$且$\sum^{k}</em>{i&#x3D;1} \alpha_i &#x3D; 1$；而$p(x|\mu_i,\Sigma_i)$对应第i个混合成分的概率密度</p><h3 id="样本属于某混合成分的概率"><a href="#样本属于某混合成分的概率" class="headerlink" title="样本属于某混合成分的概率"></a>样本属于某混合成分的概率</h3><p>令数据集$D &#x3D; {x_1,x_2,…,x_m}$随机变量$z_j \in {1,2,…,k}$，$z_j$表征样本$x_j$属于哪个混合成分。</p><p>对于$x_j$并不确定的情况下，$z_j$的先验分布为</p><p>$p(z_j &#x3D; i) &#x3D; \alpha_i, i &#x3D; {1,2,…,k}$</p><p>根据贝叶斯定理，当$x_j$确定时，$z_j$的后验分布记作$p_M(z_j &#x3D; i|x_j)$，为</p><p>$p_M(z_j &#x3D; i|x_j) &#x3D; \frac{p(z_j &#x3D; i)p_M(x_j|z_j &#x3D; i)}{p_M(x_j)}$<br>其中，$p(z_j &#x3D; i) &#x3D; \alpha_i$；$p_M(x_j|z_j &#x3D; i) &#x3D; p(x|\mu_i,\Sigma_i)$，因为当确定$z_j &#x3D; i$时除了$\alpha_i &#x3D; 1$其它$\alpha_1,…\alpha_i-1,\alpha_i+1,…,\alpha_k$均为$0$；而$p_M(x_j)$即混合高斯分布的概率密度函数</p><p>将$p_M(z_j &#x3D; i|x_j)$简记作$\gamma_{ji}$，这个概率就是$x_j$的分布为$\mu_i,\Sigma_i$所对应的多元高斯分布的概率。</p><p>于是我们可以找到令$\gamma_{ji}$最大的$i \in {1,2,…,k}$，令$\lambda_j &#x3D; argmax_{i \in {1,2,…,k}} \gamma_{ji}$，$\lambda_j$即$x_j$的标签。对于每个都进行相同的操作，整个数据集便可被划分为k个多元高斯分布对应的k个簇。</p><h3 id="模型训练"><a href="#模型训练" class="headerlink" title="模型训练"></a>模型训练</h3><h4 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h4><p>对于k-means、LVQ的模型训练实际上就是通过训练集获得对应的原型向量，有了原型向量便有了划分为簇的依据，也就完成了模型的训练。</p><p>而对于高斯混合聚类，根据前面的描述，我们划分为簇的重要依据就是$\gamma_{ji}$，进一步说实际上是<strong>计算$\gamma_{ji}$的依据</strong>，根据计算公式可知，这个依据实际上就是决定高斯混合分布的参数$\mu_i,\Sigma_i,\alpha_i, i \in {1,2,…,k}$。</p><p><strong>于是训练的目的实际上就是要得到它们的值。</strong></p><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><p>对于模型参数${(\alpha_i,\mu_i,\Sigma_i)|1 \le i \le k}$，我们采用<strong>极大似然</strong>的方法进行求解。</p><p>这里引用南瓜书中的一句话：<br>“对于每个样本$x_j$来说，它出现的概率是$p_M(x_j)$既然现在训练集D中确实出现了$x_j$，我们当然希望待求解的参数${(\alpha_i,\mu_i,\Sigma_i)|1 \le i \le k}$能够使这种可能性$p_M(x_j)$最大”</p><p>于是根据极大似然方法，我们令<br>$LL(D) &#x3D; ln(\prod^{m}<em>{j&#x3D;1} p_M(x_j)) &#x3D; \sum^{m}</em>{j&#x3D;1} ln(\sum^k_{i&#x3D;1} \alpha_i \cdot p(x_j|\mu_i,\Sigma_i))$<br>为对数似然函数，将其最大化得到对应的参数，就是我们要求解的模型参数。</p><h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><p>经过一系列数学运算，我们可以得得到如下结果：</p><p>$\mu_i &#x3D; \frac{\sum^{m}_{j&#x3D;1} \gamma_{ji} x_j}{\sum^{m}_{j&#x3D;1} \gamma_{ji}}$</p><p>$\Sigma_i &#x3D; \frac{\sum^{m}_{j&#x3D;1} \gamma_{ji} (x_j - \mu_i)(x_j - \mu_i)^{T}}{\sum^{m}_{j&#x3D;1}} \gamma_{ji}$</p><p>$\alpha_i &#x3D; \frac{1}{m} \sum^{m}_{j&#x3D;1} \gamma{ji}$</p><p>$i &#x3D; 1,2,…,k$</p><p>注意结果当中，每一个参数的计算都要用到$\gamma{ji}$，而问题在于计算$\gamma{ji}$的时候又要用到参数本身，这似乎是一个循环的无从下手的问题。这种情况下，我们利用EM算法来求解。</p><h3 id="EM算法"><a href="#EM算法" class="headerlink" title="EM算法"></a>EM算法</h3><p>EM算法(Expectation-Maximization)称为“期望最大化算法”，这种算法最开始应用于：使用极大似然法对模型参数进行估计，但是已知的样本中存在还没有“观测”的变量，这种变量称为隐变量，它的值是不确定的。</p><p>令$X,Z,\Theta$分别为已观测变量集、隐变量集、参数集，则应最大化对数似然$LL(\Theta|X,Z) &#x3D; lnP(X,Z|\Theta)$，但是Z是隐变量，所以无法直接求解。</p><p>EM算法可以用于估计隐变量，并在这个过程中对参数做最大似然估计。</p><p>其基本的思想是这样的：</p><ol><li>初始化参数$\Theta$，根据参数去估计隐变量的<strong>概率分布</strong>，并利用此概率分布求得隐变量的<strong>期望</strong>——E步</li><li>将隐变量的期望作为我们观测到的隐变量本身，于是此时所有样本都已被观测，对$\Theta$做极大似然估计——M步</li></ol><p>不断重复上述两个过程——迭代，直到满足退出条件，例如$\Theta$收敛</p><p>贴一篇介绍EM算法的博客：<br><a href="https://blog.csdn.net/qq_41554005/article/details/100591525">CSDN</a></p><h2 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h2><p>结合EM算法，整个高斯混合聚类算法流程如下：</p><p>输入：</p><ol><li>样本集$D &#x3D; {x_1,x_2,…,x_m}$</li><li>高斯混合成分的个数k（当然也就是希望划分出的簇的个数）</li></ol><p>过程：</p><ol><li>初始化高斯混合分布的参数${(\alpha_i,\mu_i,\Sigma_i)|i &#x3D; 1,2…,k}$</li><li>repeat：</li><li>对每个样本$x_j,j &#x3D; 1,2,…,m$估计其属于第$i,i &#x3D; 1,2,…k$个成分的概率：$\gamma_{ji}$</li><li>利用公式<br>$\mu_i &#x3D; \frac{\sum^{m}_{j&#x3D;1} \gamma_{ji} x_j}{\sum^{m}_{j&#x3D;1} \gamma_{ji}}$，<br>$\Sigma_i &#x3D; \frac{\sum^{m}_{j&#x3D;1} \gamma_{ji} (x_j - \mu_i)(x_j - \mu_i)^{T}}{\sum^{m}_{j&#x3D;1}} \gamma_{ji}$，<br>$\alpha_i &#x3D; \frac{1}{m} \sum^{m}_{j&#x3D;1} \gamma{ji}$，$i &#x3D; 1,2,…,k$对参数进行更新</li><li>until:收敛条件（达到一定轮数 or 参数收敛）</li><li>求解$x_j,j &#x3D; 1,2,…,m$的标记$\lambda_j &#x3D; agrmax_{i &#x3D; 1,2,…,k} \gamma_{ji}$</li><li>根据标记划分为对应的簇</li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>Data.py:数据集部分</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">D = [</span><br><span class="line">    [<span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">0.697</span>, <span class="number">0.460</span>], [<span class="number">0.774</span>, <span class="number">0.376</span>], [<span class="number">0.634</span>, <span class="number">0.264</span>], [<span class="number">0.608</span>, <span class="number">0.318</span>], [<span class="number">0.556</span>, <span class="number">0.215</span>],</span><br><span class="line">    [<span class="number">0.403</span>, <span class="number">0.237</span>], [<span class="number">0.481</span>, <span class="number">0.149</span>], [<span class="number">0.437</span>, <span class="number">0.211</span>], [<span class="number">0.666</span>, <span class="number">0.091</span>], [<span class="number">0.243</span>, <span class="number">0.267</span>],</span><br><span class="line">    [<span class="number">0.245</span>, <span class="number">0.057</span>], [<span class="number">0.343</span>, <span class="number">0.099</span>], [<span class="number">0.639</span>, <span class="number">0.161</span>], [<span class="number">0.657</span>, <span class="number">0.198</span>], [<span class="number">0.360</span>, <span class="number">0.370</span>],</span><br><span class="line">    [<span class="number">0.593</span>, <span class="number">0.042</span>], [<span class="number">0.719</span>, <span class="number">0.103</span>], [<span class="number">0.359</span>, <span class="number">0.188</span>], [<span class="number">0.339</span>, <span class="number">0.241</span>], [<span class="number">0.282</span>, <span class="number">0.257</span>],</span><br><span class="line">    [<span class="number">0.748</span>, <span class="number">0.232</span>], [<span class="number">0.714</span>, <span class="number">0.346</span>], [<span class="number">0.483</span>, <span class="number">0.312</span>], [<span class="number">0.478</span>, <span class="number">0.437</span>], [<span class="number">0.525</span>, <span class="number">0.369</span>],</span><br><span class="line">    [<span class="number">0.751</span>, <span class="number">0.489</span>], [<span class="number">0.532</span>, <span class="number">0.472</span>], [<span class="number">0.473</span>, <span class="number">0.376</span>], [<span class="number">0.725</span>, <span class="number">0.445</span>], [<span class="number">0.446</span>, <span class="number">0.459</span>]</span><br><span class="line">]  <span class="comment"># 数据集，1~30，0索引不使用</span></span><br></pre></td></tr></table></figure><p>main.py:主函数部分</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Gauss</span><br><span class="line"><span class="keyword">import</span> Data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;高斯混合聚类 的结果&quot;</span>, end=<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    res = Gauss.gauss(Data.D)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">len</span>(res[i]), end=<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(res[i])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Guass.py:高斯混合聚类算法部分</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">multi_gauss_distri_p</span>(<span class="params">sigma, mu, n, x</span>):</span><br><span class="line">    <span class="comment"># 计算多元高斯分布下取得x的概率，n是维度</span></span><br><span class="line">    vec_mu = np.array(mu)</span><br><span class="line">    vec_x = np.array(x)</span><br><span class="line">    t1 = vec_x - vec_mu</span><br><span class="line">    <span class="comment">#    t1 = t1.T</span></span><br><span class="line">    det_sigma = np.linalg.det(sigma)</span><br><span class="line">    <span class="keyword">if</span>(det_sigma &lt; <span class="number">1e-10</span>):  <span class="comment"># 当行列式过小时，添加一个较小的正则化项</span></span><br><span class="line">        sigma += np.eye(sigma.shape[<span class="number">0</span>]) * <span class="number">1e-6</span>  <span class="comment"># 添加正则化，避免奇异矩阵</span></span><br><span class="line">    t2 = np.linalg.inv(sigma)</span><br><span class="line">    t3 = vec_x - vec_mu</span><br><span class="line">    t3 = t3.T  <span class="comment"># 西瓜书上的公式里没有转置的向量默认是列向量</span></span><br><span class="line">    log_p = -<span class="number">0.5</span> * (np.dot(np.dot(t1, t2), t3) + np.linalg.slogdet(sigma)[<span class="number">1</span>] + n * np.log(<span class="number">2</span> * np.pi))</span><br><span class="line">    p = np.exp(log_p)</span><br><span class="line"><span class="comment">#    p = 1 / ((2 * np.pi) ** (n / 2) * np.linalg.det(sigma) ** (1 / 2)) * np.e ** (-0.5 * np.dot(np.dot(t1, t2), t3)</span></span><br><span class="line"><span class="comment">#    print(&quot;p:&quot;, p, end=&quot;\n&quot;)</span></span><br><span class="line">    <span class="keyword">if</span> p &lt; <span class="number">1e-10</span>:</span><br><span class="line">        p = <span class="number">1e-6</span>  <span class="comment"># 避免数值问题</span></span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">new_mu_i</span>(<span class="params">D, lamda_, i</span>):</span><br><span class="line">    up_sum = [<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">    down_sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">31</span>):</span><br><span class="line">        up_sum[<span class="number">0</span>] += lamda_[j][i] * D[j][<span class="number">0</span>]</span><br><span class="line">        up_sum[<span class="number">1</span>] += lamda_[j][i] * D[j][<span class="number">1</span>]</span><br><span class="line">        down_sum += lamda_[j][i]</span><br><span class="line">    new_mu = [up_sum[<span class="number">0</span>] / down_sum, up_sum[<span class="number">1</span>] / down_sum]</span><br><span class="line">    <span class="keyword">return</span> new_mu</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">new_sigma_i</span>(<span class="params">D, mu, lamda_, i</span>):</span><br><span class="line">    vec_x = np.array(D[i])</span><br><span class="line">    vec_mu = np.array(mu)</span><br><span class="line">    up_sum = np.array([[<span class="number">0.0</span>, <span class="number">0.0</span>], [<span class="number">0.0</span>, <span class="number">0.0</span>]])</span><br><span class="line">    down_sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">31</span>):</span><br><span class="line">        t = vec_x - vec_mu</span><br><span class="line">        up_sum += lamda_[j][i] * (np.outer(t.T, t))</span><br><span class="line">        down_sum += lamda_[j][i]</span><br><span class="line">    new_sigma = up_sum / down_sum</span><br><span class="line">    <span class="keyword">return</span> new_sigma</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">new_alpha_i</span>(<span class="params">lambda_, i</span>):</span><br><span class="line">    up_sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">31</span>):</span><br><span class="line">        up_sum += lambda_[j][i]</span><br><span class="line">    new_alpha = up_sum / <span class="number">30</span></span><br><span class="line">    <span class="keyword">return</span> new_alpha</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gauss</span>(<span class="params">D: [[<span class="built_in">float</span>]]</span>):</span><br><span class="line">    <span class="comment">#  定义混合高斯分布参数</span></span><br><span class="line">    sigma = []  <span class="comment"># 协方差矩阵</span></span><br><span class="line">    alpha = []  <span class="comment"># 混合权重</span></span><br><span class="line">    mu = []  <span class="comment"># 期望</span></span><br><span class="line">    <span class="comment">#  初始化参数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">3</span>):</span><br><span class="line">        sigma.append(np.array([[<span class="number">0.1</span>, <span class="number">0.0</span>], [<span class="number">0.0</span>, <span class="number">0.1</span>]]))</span><br><span class="line">        alpha.append(<span class="number">1</span>/<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">3</span>):</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">            mu.append(D[<span class="number">6</span>])</span><br><span class="line">        <span class="keyword">elif</span> i == <span class="number">1</span>:</span><br><span class="line">            mu.append(D[<span class="number">22</span>])</span><br><span class="line">        <span class="keyword">elif</span> i == <span class="number">2</span>:</span><br><span class="line">            mu.append(D[<span class="number">27</span>])</span><br><span class="line">    <span class="comment">#  定义xj属于第i种多元高斯分布的概率</span></span><br><span class="line">    lambda_ = []</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">31</span>):</span><br><span class="line">        lambda_.append([[], [], []])</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">100</span>):  <span class="comment"># 迭代</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">31</span>):  <span class="comment"># 依次对每个xj计算lambda_ji,i = 0，1，2，对应三种多元高斯分布</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">3</span>):</span><br><span class="line">                t_sum = <span class="number">0</span></span><br><span class="line">                <span class="keyword">for</span> l <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">3</span>):</span><br><span class="line">                    t_sum += alpha[l] * multi_gauss_distri_p(sigma[l], mu[l], <span class="number">2</span>, D[j])</span><br><span class="line">                lambda_ji = alpha[i] * multi_gauss_distri_p(sigma[i], mu[i], <span class="number">2</span>, D[j]) / t_sum</span><br><span class="line">                lambda_[j][i] = lambda_ji</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">3</span>):  <span class="comment"># 更新混合高斯分布参数</span></span><br><span class="line">            mu[i] = new_mu_i(D, lambda_, i)</span><br><span class="line">            sigma[i] = new_sigma_i(D, mu[i], lambda_, i)</span><br><span class="line">            alpha[i] = new_alpha_i(lambda_, i)</span><br><span class="line"></span><br><span class="line">    result = [[], [], []]  <span class="comment"># 最终的划分结果</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">31</span>):  <span class="comment"># 依次对每个xj计算lambda_ji,i = 0，1，2，对应三种多元高斯分布</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">3</span>):</span><br><span class="line">            t_sum = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> l <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">3</span>):</span><br><span class="line">                t_sum += alpha[l] * multi_gauss_distri_p(sigma[l], mu[l], <span class="number">2</span>, D[j])</span><br><span class="line">            lambda_ji = alpha[i] * multi_gauss_distri_p(sigma[i], mu[i], <span class="number">2</span>, D[j]) / t_sum</span><br><span class="line">            lambda_[j][i] = lambda_ji</span><br><span class="line"></span><br><span class="line">        flag = <span class="number">0</span></span><br><span class="line">        ll = lambda_[j][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">3</span>):</span><br><span class="line">            <span class="keyword">if</span> ll &lt; lambda_[j][i]:</span><br><span class="line">                flag = i</span><br><span class="line">        result[flag].append(D[j])</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>进行这一部分的时候让我最大的感悟是，在使用计算机进行数据处理的时候，很可能会出现数据的溢出问题，非常大、非常小的数都在计算机的表示范围之外，就会带来问题。例如在进行协方差矩阵更新的时候，有时它的行列式值虽然不是0，但是已经非常小了，计算机会默认其为0。同样，可能作为除数的数也是一样的，如果太小变为0就会发送除以0的错误。<br><strong>这称为数值稳定性问题</strong></p><p>因此代码中有一些涉及处理这些问题的地方（主要是在求第i个多元高斯分布中取得xj这个值的概率的时候，一处是正则化、一处是对数化并添加过小的判断），尽管我现在并不清楚这样处理是否有问题。但是抛开这些细节，作为一次上手的练习，整个混合高斯聚类算法是正确的。<br><strong>不过值得一提的是，EM算法的收敛与迭代的次数没有必然的关系，通常应该使用参数变化的情况来决定是否结束迭代</strong></p><p>最后的结果如下：</p><blockquote><p>高斯混合聚类 的结果<br>2<br>[[0.608, 0.318], [0.359, 0.188]]<br>0<br>[]<br>28<br>[[0.697, 0.46], [0.774, 0.376], [0.634, 0.264], [0.556, 0.215], [0.403, 0.237], [0.481, 0.149], [0.437, 0.211], [0.666, 0.091], [0.243, 0.267], [0.245, 0.057], [0.343, 0.099], [0.639, 0.161], [0.657, 0.198], [0.36, 0.37], [0.593, 0.042], [0.719, 0.103], [0.339, 0.241], [0.282, 0.257], [0.748, 0.232], [0.714, 0.346], [0.483, 0.312], [0.478, 0.437], [0.525, 0.369], [0.751, 0.489], [0.532, 0.472], [0.473, 0.376], [0.725, 0.445], [0.446, 0.459]]</p></blockquote><p>经过我的观察，第3次迭代之后划分结果基本上就稳定了，第1次的时候分得比较均匀。这或许是数据的原因。（也有可能是我对于数值稳定性的处理不好）</p><p>如果将正则化项改大一些结果如下：</p><blockquote><p>高斯混合聚类 的结果<br>12<br>[[0.608, 0.318], [0.556, 0.215], [0.403, 0.237], [0.481, 0.149], [0.437, 0.211], [0.243, 0.267], [0.245, 0.057], [0.343, 0.099], [0.359, 0.188], [0.339, 0.241], [0.282, 0.257], [0.483, 0.312]]<br>10<br>[[0.634, 0.264], [0.666, 0.091], [0.639, 0.161], [0.657, 0.198], [0.593, 0.042], [0.719, 0.103], [0.748, 0.232], [0.714, 0.346], [0.751, 0.489], [0.725, 0.445]]<br>8<br>[[0.697, 0.46], [0.774, 0.376], [0.36, 0.37], [0.478, 0.437], [0.525, 0.369], [0.532, 0.472], [0.473, 0.376], [0.446, 0.459]]</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习（聚类） </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习向量量化</title>
      <link href="/2025/05/06/%E5%AD%A6%E4%B9%A0%E5%90%91%E9%87%8F%E9%87%8F%E5%8C%96/"/>
      <url>/2025/05/06/%E5%AD%A6%E4%B9%A0%E5%90%91%E9%87%8F%E9%87%8F%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p><code>这篇blog用于记录我使用python对学习向量量化这种聚类算法的复现</code></p><h2 id="算法简介"><a href="#算法简介" class="headerlink" title="算法简介"></a>算法简介</h2><p>学习向量量化也成为LVQ(Learning Vector Quantization)，同样属于原型聚类算法，类似于k-means通过希望划分的簇的数量求得相同数量的“簇中心”并以此为原型将数据集划分为对应的簇，LVQ通过求得与希望划分的簇数量相同的“原型向量”，并以此来将数据集划分为对应的簇。</p><p>如果说k-means也同样是借助原型向量的话，那么关键就在于两种算法更新原型向量的方法不同。k-means是不断的用原型向量划分簇，又用簇更新原型向量；LVQ则是利用样本的预先标注作为“监督信息”，不断利用样本更新原型向量。</p><h2 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h2><p>整个算法的大致流程如下：</p><p>输入: $D &#x3D; {(x_1,y_1),(x_2,y_2),…,(x_m,y_m)}, q, {t_1,t_2,…,t_q},\eta \in (0,1)$其中，D是带有标记的数据集，q是原型向量个数，$t_i,i \in {1,2,…,q}$ 对应原型向量的标记，$\eta$是学习率</p><p>算法过程：</p><ol><li>初始化原型向量${p_1,p_2,…,p_q}$</li><li>repeat:</li><li>从$D$中随机挑选一个样本$(x_j,y_j)$</li><li>找到与$x_j$最近的原型向量$p_i^{*}$</li><li>if($t_i^{*}$ &#x3D;&#x3D; $y_j$): $p’ &#x3D; p_i^{*} + \eta(p_i^{*} - x_j)$</li><li>else: $p’ &#x3D; p_i^{*} - \eta(p_i^{*} - x_j)$</li><li>判断是否到达退出条件</li></ol><p>整个算法过程的关键就在于5、6，实际上相当于找到距离原型向量最近的样本，如果是同标记的则将该原型向量向该样本“拉近”，如果是不同标记的则“推远”（因为对应的是同标记的在一个簇中可能性较大，不同标记在不同簇中可能性较大）</p><p>关于7的退出条件，通常可以设置一个最大迭代轮数，或者是原型向量的更新程度已经小于了一个阈值。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>使用python对西瓜书上的示例复现代码如下（30个样本，9-21号样本标记为2，其它样本标记为1，随机选择5个样本作为原始向量，标记分别为1、2、2、1、1，学习率为0.1）</p><p>Data.py数据集部分:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">D = [</span><br><span class="line">    [<span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">0.697</span>, <span class="number">0.460</span>], [<span class="number">0.774</span>, <span class="number">0.376</span>], [<span class="number">0.634</span>, <span class="number">0.264</span>], [<span class="number">0.608</span>, <span class="number">0.318</span>], [<span class="number">0.556</span>, <span class="number">0.215</span>],</span><br><span class="line">    [<span class="number">0.403</span>, <span class="number">0.237</span>], [<span class="number">0.481</span>, <span class="number">0.149</span>], [<span class="number">0.437</span>, <span class="number">0.211</span>], [<span class="number">0.666</span>, <span class="number">0.091</span>], [<span class="number">0.243</span>, <span class="number">0.267</span>],</span><br><span class="line">    [<span class="number">0.245</span>, <span class="number">0.057</span>], [<span class="number">0.343</span>, <span class="number">0.099</span>], [<span class="number">0.639</span>, <span class="number">0.161</span>], [<span class="number">0.657</span>, <span class="number">0.198</span>], [<span class="number">0.360</span>, <span class="number">0.370</span>],</span><br><span class="line">    [<span class="number">0.593</span>, <span class="number">0.042</span>], [<span class="number">0.719</span>, <span class="number">0.103</span>], [<span class="number">0.359</span>, <span class="number">0.188</span>], [<span class="number">0.339</span>, <span class="number">0.241</span>], [<span class="number">0.282</span>, <span class="number">0.257</span>],</span><br><span class="line">    [<span class="number">0.748</span>, <span class="number">0.232</span>], [<span class="number">0.714</span>, <span class="number">0.346</span>], [<span class="number">0.483</span>, <span class="number">0.312</span>], [<span class="number">0.478</span>, <span class="number">0.437</span>], [<span class="number">0.525</span>, <span class="number">0.369</span>],</span><br><span class="line">    [<span class="number">0.751</span>, <span class="number">0.489</span>], [<span class="number">0.532</span>, <span class="number">0.472</span>], [<span class="number">0.473</span>, <span class="number">0.376</span>], [<span class="number">0.725</span>, <span class="number">0.445</span>], [<span class="number">0.446</span>, <span class="number">0.459</span>]</span><br><span class="line">]  <span class="comment"># 数据集，1~30，0索引不使用</span></span><br><span class="line"><span class="comment"># 数据集的标记，LVQ使用</span></span><br><span class="line">T = [</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>,</span><br><span class="line">    <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>,</span><br><span class="line">    <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>,</span><br><span class="line">    <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">]</span><br><span class="line"><span class="comment"># 原始向量标记的输入</span></span><br><span class="line">q_vect = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>main.py主函数部分：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> K_means</span><br><span class="line"><span class="keyword">import</span> LVQ</span><br><span class="line"><span class="keyword">import</span> Data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(): </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;LVQ 的结果&quot;</span>, end=<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    res = LVQ.lvq(Data.D, Data.T, Data.q_vect)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">len</span>(res[i]) - <span class="number">1</span>, end=<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(res[i]) == <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[]&quot;</span>, end=<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(res[i])):</span><br><span class="line">            <span class="keyword">if</span> j == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="built_in">print</span>(res[i][j], end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(res[i]) != <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot; &quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">        main()</span><br></pre></td></tr></table></figure><p>LVQ.py学习向量量化算法部分：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">lvq</span>(<span class="params">D:[[<span class="built_in">float</span>]], T:[<span class="built_in">int</span>], q_vect:[]</span>):</span><br><span class="line">l_rate = <span class="number">0.1</span></span><br><span class="line"><span class="keyword">import</span> random <span class="keyword">as</span> rd</span><br><span class="line">q_vec_index = rd.sample(<span class="built_in">range</span>(<span class="number">1</span>, <span class="number">31</span>), <span class="number">5</span>)  <span class="comment"># 随机选取5个样本作为原型向量</span></span><br><span class="line">q_vec = []  <span class="comment"># 原型向量</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">5</span>):</span><br><span class="line">    q_vec.append(D[q_vec_index[i]])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">10000</span>):  <span class="comment"># 迭代10000轮</span></span><br><span class="line">    j_dex = rd.randint(<span class="number">1</span>,<span class="number">30</span>)  <span class="comment"># 随机挑选一个样本，randint函数的参数是一个闭区间！</span></span><br><span class="line">    q = <span class="number">0</span> <span class="comment"># 距离j_dex最近的原型向量的索引</span></span><br><span class="line">    d = (D[j_dex][<span class="number">0</span>] - q_vec[<span class="number">0</span>][<span class="number">0</span>])**<span class="number">2</span> + (D[j_dex][<span class="number">1</span>] - q_vec[<span class="number">0</span>][<span class="number">1</span>])**<span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">5</span>):</span><br><span class="line">        d_i = (D[j_dex][<span class="number">0</span>] - q_vec[i][<span class="number">0</span>])**<span class="number">2</span> + (D[j_dex][<span class="number">1</span>] - q_vec[i][<span class="number">1</span>])**<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> d_i &lt; d:</span><br><span class="line">            q = i</span><br><span class="line">            d = d_i</span><br><span class="line">    <span class="keyword">if</span> q_vect[q] == T[j_dex]:  <span class="comment"># 将原型向量与样本拉近</span></span><br><span class="line">        q_vec[q][<span class="number">0</span>] = q_vec[q][<span class="number">0</span>] + l_rate*(D[j_dex][<span class="number">0</span>] - q_vec[q][<span class="number">0</span>])</span><br><span class="line">        q_vec[q][<span class="number">1</span>] = q_vec[q][<span class="number">1</span>] + l_rate*(D[j_dex][<span class="number">1</span>] - q_vec[q][<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">else</span>:  <span class="comment"># 将原型向量与样本推远</span></span><br><span class="line">        q_vec[q][<span class="number">0</span>] = q_vec[q][<span class="number">0</span>] - l_rate * (D[j_dex][<span class="number">0</span>] - q_vec[q][<span class="number">0</span>])</span><br><span class="line">        q_vec[q][<span class="number">1</span>] = q_vec[q][<span class="number">1</span>] - l_rate * (D[j_dex][<span class="number">1</span>] - q_vec[q][<span class="number">1</span>])</span><br><span class="line">result = [[], [], [], [], []]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">5</span>):</span><br><span class="line">    result[i].append(q_vec[i])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">31</span>):</span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    d = (D[i][<span class="number">0</span>] - q_vec[j][<span class="number">0</span>])**<span class="number">2</span> + (D[i][<span class="number">1</span>] - q_vec[j][<span class="number">0</span>])**<span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">5</span>):</span><br><span class="line">        d_ = (D[i][<span class="number">0</span>] - q_vec[_][<span class="number">0</span>])**<span class="number">2</span> + (D[i][<span class="number">1</span>] - q_vec[_][<span class="number">1</span>])**<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> d_ &lt; d:</span><br><span class="line">            d = d_</span><br><span class="line">            j = _</span><br><span class="line">    result[j].append(D[i])</span><br><span class="line"><span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p><code>捉个一个虫，py中万物皆对象，在初始化q_vec的时候直接将数据集D中的元素append进去，实际上共享了内存，这会导致更新原型向量的时候，数据集中的元素被更新，解决方案是使用深拷贝</code></p><p>修改方法：<br>将q_vec初始化的地方：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">q_vec = []  <span class="comment"># 原型向量</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">5</span>):</span><br><span class="line">    q_vec.append(D[q_vec_index[i]])</span><br></pre></td></tr></table></figure><p>更改为：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q_vec = [x.copy() <span class="keyword">for</span> x <span class="keyword">in</span> (D[i] <span class="keyword">for</span> i <span class="keyword">in</span> q_vec_index)]  <span class="comment"># 关键修复点：使用列表拷贝</span></span><br></pre></td></tr></table></figure><p>最终运行结果：</p><blockquote><p>3<br>[0.36, 0.37] [0.478, 0.437] [0.446, 0.459]<br>8<br>[0.634, 0.264] [0.556, 0.215] [0.666, 0.091] [0.639, 0.161] [0.657, 0.198] [0.593, 0.042] [0.719, 0.103] [0.748, 0.232]<br>9<br>[0.403, 0.237] [0.481, 0.149] [0.437, 0.211] [0.243, 0.267] [0.245, 0.057] [0.343, 0.099] [0.359, 0.188] [0.339, 0.241] [0.282, 0.257]<br>5<br>[0.697, 0.46] [0.774, 0.376] [0.714, 0.346] [0.751, 0.489] [0.725, 0.445]<br>5<br>[0.608, 0.318] [0.483, 0.312] [0.525, 0.369] [0.532, 0.472] [0.473, 0.376]  </p></blockquote><p>对应为5个簇中样本的数量和相应的样本</p><p><code>注：理论上应该将数据集D划分为训练集和测试集，通过训练集训练模型（得到所有合理的原型向量），然后利用测试集测试，利用原型向量将测试集划分为对应数量的簇；这样才能完整地体现“机器学习”，但是这里只是一个简单的例子，将数据集D全用作训练集，得到原型向量，再把整个训练集划分为了对应的簇。</code><br><code>有了原型向量之后，划分为簇是很简单的，样本距离哪个原型向量最近，就纳入对应的簇即可。</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习（聚类） </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>六级词汇</title>
      <link href="/2025/05/06/%E5%85%AD%E7%BA%A7%E8%AF%8D%E6%B1%87/"/>
      <url>/2025/05/06/%E5%85%AD%E7%BA%A7%E8%AF%8D%E6%B1%87/</url>
      
        <content type="html"><![CDATA[<p><code>这篇博客用于记录我在备考英语六级时所做的词汇准备，目前我已经完成了核心词汇的记忆，我会在这里为这些词汇补充一些例句。</code><br><code>目前的打算是每天20个词语，此外我会开始着手阅读、听力以及写译的准备，这篇blog中也会用于记录相应的内容</code></p><h2 id="词汇"><a href="#词汇" class="headerlink" title="词汇"></a>词汇</h2><h3 id="2025-05-06"><a href="#2025-05-06" class="headerlink" title="2025.05.06"></a>2025.05.06</h3><p>1</p><blockquote><p>stabilize  “How can I stabilize the colour of our love, my dear.”</p></blockquote><p>2</p><blockquote><p>manipulate “Your mean is that you can manipualte such a monster machine.”</p></blockquote><p>3</p><blockquote><p>ambiguous “Don’t treat me with such a ambiguous attitude.”</p></blockquote><p>4</p><blockquote><p>interaction “The relationship forms from the interaction among people little by little.”</p></blockquote><p>5</p><blockquote><p>perception “What’s your perception about our future?”</p></blockquote><p>6</p><blockquote><p>strive “I’ll strive to achieve our happiness in future.”</p></blockquote><p>7</p><blockquote><p>expense “How much is the expense of our lives in the month?”</p></blockquote><p>8</p><blockquote><p>cater “We will cater for the party.”</p></blockquote><p>9</p><blockquote><p>summon “I am trying to summon up the courage to love you.” “He was summoning the elevator.”</p></blockquote><p>10</p><blockquote><p>plug “The broken bus pluged the traffic.”</p></blockquote><p>11</p><blockquote><p>elaspe “I don’t think our love will elapse.”</p></blockquote><p>12</p><blockquote><p>authorize “The law won’t autorize anybody to kill.”</p></blockquote><p>13</p><blockquote><p>commentary “With a conception about freedom of expression, the commentraies online are too cynic and dirty sometimes.”</p></blockquote><p>14</p><blockquote><p>conservative “Some people are still conservative about sex, which’s treasurable.”</p></blockquote><p>15</p><blockquote><p>arson “People would arson to destory all the thing of a witch even her body in the middle centery, however many women called wicth are innocent.”</p></blockquote><p>16</p><blockquote><p>litre “How much water should a people to drink a day? 2 litres?”</p></blockquote><p>17</p><blockquote><p>vengeance “The lifelong traveling of Gess is to make vengeane.”</p></blockquote><p>18</p><blockquote><p>expenditure “He is rigorous in his contorl of expenditure.”</p></blockquote><p>19</p><blockquote><p>overwhelm “The fear overwhelmed in his mind.”</p></blockquote><p>20</p><blockquote><p>surpass “His achievement supasses anybody.”</p></blockquote><h3 id="2025-05-07"><a href="#2025-05-07" class="headerlink" title="2025.05.07"></a>2025.05.07</h3><p>1</p><blockquote><p>visualize “If you can visualize your success, you’ll succeed.”</p></blockquote><p>2</p><blockquote><p>tension “For several hours tension mounted.”</p></blockquote><p>3</p><blockquote><p>shrewd “She is a shrewd bussinesswoman indeed, however she is a kind mother as well.”</p></blockquote><p>4</p><blockquote><p>phase “For our aim of happiness, we are staying the phase of adapating to each other.”</p></blockquote><p>5</p><blockquote><p>abject “If you are down to abject poverty, you actually get everything.”</p></blockquote><p>6</p><blockquote><p>intense “The fight between Gess and Geri is intense.”</p></blockquote><p>7</p><blockquote><p>recruit “His dream is to be recruited as a chairman by Tiktok.”</p></blockquote><p>8</p><blockquote><p>abolish “The princess will abolish the man’s title of knight, granting a new title of lover to him.”</p></blockquote><p>9</p><blockquote><p>reluctant “I don’t want your hug because you are reluctant.”</p></blockquote><p>10</p><blockquote><p>vacant “The room is vacant so you can use it.”</p></blockquote><p>11</p><blockquote><p>priest “My priest, listen to my confession. Please.”</p></blockquote><p>12</p><blockquote><p>transparent “My heart is just like a transparent river.”</p></blockquote><p>13</p><blockquote><p>hamper “Why did you hamper me forever?”</p></blockquote><p>14</p><blockquote><p>rust “The blank-red rust grow on the sword, saying the pride from the past.”</p></blockquote><p>15</p><blockquote><p>sulphur “Whenever I see the word sulphur, I think of my chemistry teacher Mr.Fu.”</p></blockquote><p>16</p><blockquote><p>vivid “The birds on the picture is vivid.”</p></blockquote><p>17</p><blockquote><p>intensive “You need to keep intensive when you are taking exam.”</p></blockquote><p>18</p><blockquote><p>diagnose “The doctor diagnosed him, saying he just need to take a rest.”</p></blockquote><p>19</p><blockquote><p>convict “God will convict you!”</p></blockquote><p>20</p><blockquote><p>implement “When will we implement this law?”</p></blockquote><h3 id="2025-05-08"><a href="#2025-05-08" class="headerlink" title="2025.05.08"></a>2025.05.08</h3><p>1</p><blockquote><p>vertical “The wall is vertical.”</p></blockquote><p>2</p><blockquote><p>clinical “Clinical medicine is a difficuilt subject.”</p></blockquote><p>3</p><blockquote><p>thrill “When she heared sound like this, she thrilled from the bottom of feet to the upper head.”</p></blockquote><p>4</p><blockquote><p>paw “Don’t touch the paw of a cat.”</p></blockquote><p>5</p><blockquote><p>conscience “Where are your conscience?”</p></blockquote><p>6</p><blockquote><p>scope “This is a scope so you should scope this question to find where is the key.”</p></blockquote><p>7</p><blockquote><p>excceed “His power excceed a lot.”</p></blockquote><p>8</p><blockquote><p>indicative “How can you speak out with such a indicative tone.”</p></blockquote><p>9</p><blockquote><p>mayor “The mayor of the city is a lion.”</p></blockquote><p>10</p><blockquote><p>rectify “Should I rectify my teeth?”</p></blockquote><p>11</p><blockquote><p>commemorate “People made a sculpture to commemorate this hero.”</p></blockquote><p>12</p><blockquote><p>nourish “We are noursihed by the land we stand.”</p></blockquote><p>13</p><blockquote><p>lease “I make the lease so I lease the house.”</p></blockquote><p>14</p><blockquote><p>flee “She fleed away and will never go back.”</p></blockquote><p>15</p><blockquote><p>criterion “Who makes the criterion, whose talking work.”</p></blockquote><p>16</p><blockquote><p>credentials “I spend lots of time in my life to study so I got this credentials finally.”</p></blockquote><p>17</p><blockquote><p>notable “It’s not a notable thing.”</p></blockquote><p>18</p><blockquote><p>secure “Please secure that the ladder is secure so I can feel secure.”</p></blockquote><p>19</p><blockquote><p>gear “There is a little gear which is broken so the forth gear of the car can’t be used.”</p></blockquote><p>20</p><blockquote><p>axis “Fllow the axis so you can draw anything accurately.”</p></blockquote><h3 id="2025-05-09"><a href="#2025-05-09" class="headerlink" title="2025.05.09"></a>2025.05.09</h3><p>1</p><blockquote><p>filter “If you want a cup of clear water, you could use the filter.”<br>2<br>confine “Your imagination will confine your arrival at the further place.”<br>3<br>rumour “If you really love her, you shouldn’t believe the rumour.”<br>4<br>category “There are some categories of people, which means that good people and bad people all exist.”<br>5<br>paradox “Sometimes I think I am the paradox itself, which hurts her a lot.”<br>6<br>transistor “Do you konw about transister? It sounds like some high technology.”<br>7<br>illusion “Give up your illusion and be ready to fight!”<br>8<br>ingredient “I once heard that the ingredients of girl are sweet, flower and any other things of happiness.”<br>9<br>feasible “Your idea is exactly genius and feasible.”<br>10<br>petroleum “If you mention my monitor in high shcool, I will think of petroleum which has relation to her profession.”<br>11<br>revenue “How much was the revenue of our government in the past year.”<br>12<br>transplant “If you want to make the flower alive, you can transplant it to another land to nourish it. If you want to make a people alive, you can give him a transplant.”<br>13<br>earnest “Please don’t hurt him, he is a earnest boy.”<br>14<br>instinct “Animals’ instinct will make them own the capablity to live in wild.”<br>15<br>resort “Whenever I listen to the word resort, I will think of people everywhere.”<br>16<br>solitude “Do you want solitude? Although sometimes you will feel lonely, you are free at all.”<br>17<br>notion “The notions about MTL is not easy.”<br>18<br>silicon “The silicon has a deep relation to the production of CPU.”<br>19<br>provoke “This funtion is used to provoke the next layer of GNN.”<br>20<br>intuition “You can’t do everything based on your intuition and you need to think independently sometimes.”</p></blockquote><h3 id="2025-05-10"><a href="#2025-05-10" class="headerlink" title="2025.05.10"></a>2025.05.10</h3><p>1</p><blockquote><p>trial “Do you want to make a trial to chase her?”<br>2<br>dense “Someone will fear something tiny and tense.”<br>3<br>identical “There is no leaf identical to another one on the world.”<br>4<br>feminine “An expert said that sensitive psychology is feminine.”<br>5<br>tuition “The tuition from the teacher is fantastic but the tuition is expensive.”<br>6<br>empirical “I’m a empirical man and I’m not good at intution.”<br>7<br>predominant “A efficient algorithm should be predominant on the advantage of time or space.”<br>8<br>marvellous “Gess is a marvellous man with a life like legend.”<br>9<br>ignite “IGNITE!”<br>10<br>conquest “The conquest over her satisfy my hugury and thirsty.”<br>11<br>tenant “The tenant make lease with me yesterday.”<br>12<br>sphere “A sphere is an abstractive name of a kind of objects like basketball and football.”<br>13<br>negligible “You are actually negligible for me like a tiny sand swaying in the air.”<br>14<br>cynical “If you feel you are injured by the world, you can change it but never be a cynical people.”<br>15<br>tempt “The game is so tempting that he can’t focus on study.”<br>16<br>portion “Can you indentify these words:portion, composition, segment and part.”<br>17<br>competent “He is a competent man and he can be our leader.”<br>18<br>jury “She was finally commited by the lawyer and the jury.”<br>19<br>vibrate “The small tool is vibrating, making her thrilled constantly.”<br>20<br>session “They asked for the thrilling feeling from bottom of their feet to the upper head during the session of such a crazy activity.”</p></blockquote><h3 id="2025-05-11"><a href="#2025-05-11" class="headerlink" title="2025.05.11"></a>2025.05.11</h3><p>1</p><blockquote><p>upright “The tower on the hill is upright.”<br>2<br>estate “A beautiful woman was killed in the estate lived by a lot of people.”<br>3<br>symphony “The symphony played by us sounds so smooth.”<br>4<br>medium “His ablity is medium among these people.”<br>5<br>commence “Let’s commence this job.”<br>6<br>exceptional “His advancement is exceptional.”<br>7<br>induce “You can induce him but not persude him.”<br>8<br>drought “This drought lasted 20 years, making no life here again.”<br>9<br>executive “He is recruited as the executive.”<br>10<br>initiative “She offers us a new initiative with the high initiative.”<br>11<br>riot “Tension occurred, society is turbulent and riots always appeared in everywhere.”<br>12<br>affirm “I can make an affirm that she isn’t a girl like that.”<br>13<br>outward “You can touch the outward texture. It’s so soft.”<br>14<br>denial “You can make a denial for me but I’ll never give up.”<br>15<br>faculty “The faculty refers to all the teacher of a colleage.”<br>16<br>supervise “We must make a principle to supervise officers.”<br>17<br>imperative “The task is so imperative that we must handle it now.”<br>18<br>mingle “If you mingle something, you have mixed them.”<br>19<br>obscure “Dying as a well-konwn hero or obscure as normal people, which one would you choose?”<br>20<br>forth “He paced back and forth.”</p></blockquote><h3 id="2025-05-12"><a href="#2025-05-12" class="headerlink" title="2025.05.12"></a>2025.05.12</h3><p>1</p><blockquote><p>shuttle “Which shuttle wii you choose, if you want to go to the western coast. The plane shuttles to carry apples?”<br>2<br>personnel “Look at me! Personnel in attendance!”<br>3<br>intensify “What hurts my heart will intensify my power.”<br>4<br>turbulent “Intension occurred and society was turbulent.”<br>5<br>attendant “Two attandants of the KTV saw a monster and the anttendant disaseter.”<br>6<br>prospect “Do you think that we have the prospect of our future.”<br>7<br>texture “The texture of the cloth makes me feel comfortable.”<br>8<br>span “The ache of the wound is spanning and the span has been more than 12 hours.”<br>9<br>tragic “Your targic destiny makes you great.”<br>10<br>commodity “She is not a commodity and you should respect her.”<br>11<br>downfall “The reason of Osman’s downfall began from 2000 years ago.”<br>12<br>timber “We can use the timber to arson.”<br>13<br>accessory “I am not your accessory!”<br>14<br>ridiculous “You want to change her, a selflish woman, which is so ridiculous!”<br>15<br>textile “The country’s prosperity is based on the textile.”<br>16<br>composition “What’s the composition of the liquid.”<br>17<br>bribe “Don’t want to bribe him because he is a judge with justice.”<br>18<br>treaty “There are two treaties between me and Lele.”<br>19<br>archive “The archive showes us his experience of honor.”<br>20<br>retreat “Don’t retreat! We have guts, a very awesome man.”</p></blockquote><h3 id="2025-05-13"><a href="#2025-05-13" class="headerlink" title="2025.05.13"></a>2025.05.13</h3><p>1</p><blockquote><p>dazzle “A dazzle dazzles my eyes.”<br>2<br>chronic “I’m so sorry to tell you that you have a chronic disease.”<br>3<br>compromise “I would never make a compromise on the view of love even for you.”<br>4<br>flourish “I hope that you can grow up well like plants flourishing under the sun.”<br>5<br>occupancy “The lasting occupancy of the computer results into the overflow of memory.”<br>6<br>vulnerable “Although his body is weak, his heart is never vulnerable.”<br>7<br>exclusive “For the president, the car is exclusive.”<br>8<br>favourable “Everybody holds a favourable attitude for the decision to recurit him as manager.”<br>9<br>spacecraft “The spacecraft is mainly made by element called Al.”<br>10<br>preserve “We are supposed to preserve the environment.”<br>11<br>analogy “How do you dare to make an analogy between a poor guy and the king.”<br>12<br>orient “You must orient, if you wanna to drive a ship on the ocean.”<br>13<br>warehouse “You can pile your goods in the warehouse.”<br>14<br>testify “I can testify that he is a good man.”<br>15<br>petty “Lele is actually a petty girl.”<br>16<br>cargo “Cargo is another name of goods.”<br>17<br>reckon “Gery reckons as a hero.” 一个本就含有被动语态的词语<br>18<br>bind “Binding a name to a object is the begining of artifical intelligence.”<br>19<br>expertise “The management of stack is the expertise of a CS students.”<br>20<br>conform “I won’t conform you without my principle.” “This action dosen’t conform our rules.”</p></blockquote><h3 id="2025-05-14"><a href="#2025-05-14" class="headerlink" title="2025.05.14"></a>2025.05.14</h3><p>1</p><blockquote><p>ego “If you can feel your own ego, you will acquire your real happiness.”<br>2<br>deficiency “The deficiency of your ego results in the regret of your life.”<br>3<br>assemble “We assemble something to get a set.”<br>4<br>punch “He was punched to death.”<br>5<br>irritate “Don’t irritate him otherwise he would kill you.”<br>6<br>patch “The patch on the pant makes her so sexy.”<br>7<br>prompt “A prompt prompt prompts him to give a right answer.”<br>8<br>oblige “I wanna to kiss you but I won’t oblige you until you are relunctant.”<br>9<br>correspondent “The correspondents are essential because they can deliver the information concerning the battle.”<br>10<br>flock “A flock of flock follow the God they trust.”<br>11<br>ponder “Confronted with this problem he pondered all the night.”<br>12<br>provision “The provision of food comfrot us a lot.”<br>13<br>stem “The stem of the flower is so thin.”<br>14<br>anticipate “I have anticipated that you might leave me one day but actually we will never leave each other during the life.”<br>15<br>threshold “The Forward Phase is just a threshold of your lengend jounery to pary for Elden Ring.”<br>16<br>expire “Don’t be unforgettable about your youngest which had expired and be concertrated on present.”<br>17<br>profess “I can’t believe you still profess that you love me even that you betray me.”<br>18<br>severe “She made such a severe worry and he won’t forgive her.”<br>19<br>ornament “We make quantities of bright ornaments to ornament our shop.”<br>20<br>germ “On the place you can’t see do exist lots of germs.”</p></blockquote><h3 id="2025-05-15"><a href="#2025-05-15" class="headerlink" title="2025.05.15"></a>2025.05.15</h3><p>1</p><blockquote><p>reconcile “Do you think that I can’t reconcile myself to the prospect of losing you?”<br>2<br>transit “The car to transit money is protected carefully.”<br>3<br>whereas “I don’t want to leave you whereas we can’t reconcile our contradiction.”<br>4<br>prominent “Success in this competition is a prominent achievement.”<br>5<br>mount “You can mount the file system or mount a horse to go out!”<br>6<br>naval “The naval power of the country is strengthful.”<br>7<br>waist “I wanna to hold your waist.”<br>8<br>academy “Don’t look down upon a student of the academy, especially in Germany.”<br>9<br>isolate “She is isolated by all of them.”<br>10<br>acute “This is an acute problem and you should note it in details.”<br>11<br>feeble “Though he is phsically feeble, his soul is strong.”<br>12<br>pledge “You have pledged to me that you won’t leave me forever.”<br>13<br>pension “Don’t use the pension of your parents otherwise you would really make me disappointed.”<br>14<br>terminate “Could we terminate this crazy plan?”<br>15<br>assert “I can assert that I won’t make you lose!”<br>16<br>conceal “Where do you want to conceal yourself? No matter where you go to, I will find you finally.”<br>17<br>skim “If you just skim what I have said or what I have done, you will never really know me.”<br>18<br>authentic “I don’t know what the authentic character of me is because I am a people full of paradox.”<br>19<br>presumably “Presumably, she has never produced heartbeat for you so she can leave you easily.”<br>20<br>masculine “Although you just like a puppy confronted with her, I know you are actually masculine.”</p></blockquote><h3 id="2025-05-18"><a href="#2025-05-18" class="headerlink" title="2025.05.18"></a>2025.05.18</h3><p>1</p><blockquote><p>applaud “Everyone at presence applauds for what he has done.”<br>2<br>intrigue “Such a strange thing intrigues him who is curious.”<br>3<br>delicate “You are supposed to treat her carefully because her heart is delicate.”<br>4<br>consolidate “What I have gotten could consolidate my confidence.”o<br>5<br>cable “Stay away from the cable otherwise you will get an electric shock.”<br>6<br>manifest “This is a manifest thing that manifests your loss!”<br>7<br>catastrophe “Looking at the broken world makes me know what a real catastrophe is.”<br>8<br>offensive “I’m so sorry that what I had said is offensive.”<br>10<br>dwell “Where your body dwells in, where your heart is then you will feel happy.”<br>11<br>eliminate “Why do you always want to eliminate who holds a different idea? You won’t be welcome.”<br>12<br>grief “Sometimes leaving from you would result in grief of ours but we all know that it’s the best anwser.”<br>13<br>concede “I’m relieved that you’d like to concede the wrong made by you.”<br>14<br>stagger “He is drunk deeply and he is just staggering.”<br>15<br>colonial “Our country will never be your colonial land!”<br>16<br>liquor “Liquor is a liquid will make you drunk.”<br>17<br>negotiation “The negotiation will be held concerning the theme of convicting the convict.”<br>18<br>peculiar “I’m peculiar sometimes because I am the parodox itself.”<br>19<br>confess “Your confessing will make us relieved.”<br>20<br>hoist “People will hoist a witch.”</p></blockquote><h3 id="2025-05-19"><a href="#2025-05-19" class="headerlink" title="2025.05.19"></a>2025.05.19</h3><p>1</p><blockquote><p>breadth “Breadth means a big width.”<br>2<br>convene “We will convene a class meeting after this class.”<br>3<br>tremendous “What a tremendous script.”<br>4<br>toss “You make make a toss to decide which one to be tossed.”<br>5<br>utter “He utters this speaking with an utter justice.”<br>6<br>flap “Don’t use the flap to flap your belly.”<br>7<br>notorious “Don’t stay with her otherwise you will be notorious.”<br>8<br>uphold “Everyone should uphold the pride of constitution.”<br>9<br>cruise “This period of time of cruise makes me unforgettable, crusing on the sea and feeling the wind.”<br>10<br>overlap “You are supposed to notice the overlap among these books, which is important.”<br>11<br>scrape “Stop scraping the blackboard. We can’t stand it!”<br>12<br>insult “Someone is just cheap to like being insulted.”<br>13<br>permeate “Don’t let the virus permeating your blood or you will die.”<br>14<br>liability “Liability is responsibility from some aspects.”<br>15<br>comply “complying somebody means you conform him or her.”<br>16<br>harsh “Sometimes the reallity is harsh.”<br>17<br>stereotype “Nowadays Gaokao in China has become a kind of stereotype.”<br>18<br>generalize “If you can generalize this paper, you will understand it more deeply.”<br>19<br>defect “Her defects are that she is stingy sometimes.”<br>20<br>scheme “I want to see a scheme to explain your plans.”</p></blockquote><h3 id="2025-05-20"><a href="#2025-05-20" class="headerlink" title="2025.05.20"></a>2025.05.20</h3><p>1</p><blockquote><p>folklore “The folklore in China is that two people who want to get married with each other should ask the suggestions of their parents.”<br>2<br>drown “The huge and grand water will drown us.”<br>3<br>loose “Don’t touch it! It’s about to loose.”<br>4<br>transaction “If you make a deal, you would make a transaction.”<br>5<br>trivial “Trivial thing is something negligible.”<br>6<br>proportion “This proportion of our enterprise is belong to Mr.L, a beautiful lady.”<br>7<br>concrete “The concrete is concrete thing which isn’t abstract.”<br>8<br>confidential “We all are supposed to protect the confidential material of our country.”<br>9<br>portray “Can you portray the beautiful view of the spring.”<br>10<br>additive “We don’t want the food with lots of additive.”<br>11<br>flip “When you toss the coin is flipped to the air.”<br>12<br>furnish “We can furnish you with some desks and chairs to furnish your home.”<br>13<br>suspicion “I don’t like your suspicion even that I can understand you.”<br>14<br>refute “Don’t incline to refute me and be patient to listen to me.”<br>15<br>migrate “Our ancestors migrated from a very far place to here.”<br>16<br>beam “I want the girl to beam because the smile of her is just like quantities of beam lighten my heart.”<br>17<br>token “There are lots of tokens so you don’t need money.”<br>18<br>navie “Confronted with love we are all navie.”<br>19<br>corporate “As a person recruited by us you are supposed to think of the corporate interests.”<br>20<br>emit “Your smile can emit the beam.”</p></blockquote><h3 id="2025-05-21"><a href="#2025-05-21" class="headerlink" title="2025.05.21"></a>2025.05.21</h3><blockquote></blockquote><p>1</p><blockquote><p>curl “Her hair is curled and she has the curl.”<br>2<br>funeral “I won’t attend your funeral because it would make me sad.”<br>3<br>postpone “This meeting is postponed so we should attend this meeting on next monday.”<br>4<br>polish “He polish his sword so that it is shiny.”<br>5<br>wander “Don’t wander in front of me, which will distract my attention.”<br>6<br>deputy “She is the deputy of the policeman and she is a good assistant.”<br>7<br>coward “He almost fears everything so he is a coward.”<br>8<br>missile “If the country still offends the pride of China, we will treat it with missile.”<br>9<br>allege “If you allege something, you assert something.”<br>10<br>destiny “Don’t just accept the destiny and fight back!”<br>11<br>facilitate “This strategy of our country facilitate our life, which means that it makes our life more convenient.”<br>12<br>revolve “Let us revolve this sphere and you won’t feel anything changed.”<br>13<br>doctrine “Do you want the priest to tell you our doctrine that ‘God always right’.”<br>14<br>distinct “The difference among these distinct species is distinct.”<br>15<br>ascertain “We are supposed to ascertain the truth of this case.”<br>16<br>symptom “If a doctor want to diagnose what’s disease she has, he will be based on the symptom.”<br>17<br>drift “We stay on the small boat and drift in the river.”<br>18<br>inherent “Kindness is an inherent characteristic of her which forms from the experience of her life so it won’t change.”<br>19<br>aggravate “Somking will aggravate the disease in her lung.”<br>20<br>alternative “There are lots of women one of whom will become an alternative of her.”</p></blockquote><h3 id="2025-05-22"><a href="#2025-05-22" class="headerlink" title="2025.05.22"></a>2025.05.22</h3><blockquote></blockquote><p>1</p><blockquote><p>obedient “I am not an obedient person so I won’t comply you.”<br>2<br>lane “There is only a lane which can’t accommodate such a big truck.”<br>3<br>cite “I can cite lots of proofs to prove you never love him.”<br>4<br>tissue “She is crying and I guess that she might need some tissues.”<br>5<br>refrain “You should refrain your desires and keep calm to study continually.”<br>6<br>integrity “Integrity is a quality of mine so I won’t lie to you.”<br>7<br>evaporate “The water had evaporated and there is nothing now.”<br>8<br>fragment “How can we assemble a whole sotry with these fragments.”<br>9<br>antique “This is just an antique legend which began from 5,000 years ago.”<br>10<br>clumsy “Her feet is too clumsy to do this.”<br>11<br>venture “A venture means that some business like adventure but there is possibly a good payoff.”<br>12<br>contaminate “We should protect our environment and not contaminate the river.”<br>13<br>toxic “This water is toxic so you don’t drink it!”<br>14<br>curb “Curb your horse! It are almost crazy!”<br>15<br>ingenious “The CPU is an ingenious product which is full of people’s wisdom.”<br>16<br>intricate “This layout of our estate is intricate so follow me closely otherwise you will miss your direction.”<br>17<br>conspicuous “This is a conspicuous result that she dosen’t love you anymore.”<br>18<br>asset “We should be an asset but not just be a person with lots of asset.”<br>19<br>primitive “The primitive human used the fire to protect themselves.”<br>20<br>embody “You should tell me your advancements to embody your ability.”</p></blockquote><h3 id="2025-05-23"><a href="#2025-05-23" class="headerlink" title="2025.05.23"></a>2025.05.23</h3><blockquote></blockquote><p>1</p><blockquote><p>stationary “I juat want the stationary relation with people.”<br>2<br>radical “You are too radical to find out the radical reason.”<br>3<br>ritual “Following the ritual rule or as a part of the ritual, you should give a hug to each other.”<br>4<br>subtle “A subtle rabbit would have three homes.”<br>5<br>precaution “You should make a good precaution before you have a intimate contact with her.”<br>6<br>roar “The wolf is roaring and you are going to die.”<br>7<br>subordinate “Taiwan is sunordinate to China.”<br>8<br>indignant “He is angry and indignant.”<br>9<br>intrinsic “An intrinsic characteristic is inherent.”<br>10<br>After a period of time, there will be a new prevalent thing being popular among people.<br>11<br>grieve “Don’t grieve because it’s normal about the change of our relation.”<br>12<br>diplomatic “This diplomatic event symbolize the improvement of the relationship between China and the US.”<br>13<br>tuck “Just tuck it into my body and it will thrill me too much.”<br>14<br>alienate “The remote distance won’t alienate us.”<br>15<br>banner “What written on the banner tell us the truth.”<br>16<br>exile “The princess was exiled and was down to be a hooker.”<br>17<br>remedy “This remedy will remedy your condition of the disease.”<br>18<br>preach “The priest is preaching.”<br>19<br>precede “My love to her precede you.”<br>20<br>exert “I will exert myself to make it.”</p></blockquote><h3 id="2025-05-24"><a href="#2025-05-24" class="headerlink" title="2025.05.24"></a>2025.05.24</h3><blockquote></blockquote><p>1</p><blockquote><p>withstand “You can’t withstand the pain.”<br>2<br>deem “Do you deem the reason? I don’t believe it.”<br>3<br>retail “Please retail the condition about the change of the price when we take a way of retail.”<br>4<br>predecessor “He is the predecessor of her.”<br>5<br>flaw “This is just a flaw and don’t deem the mistake.”<br>6<br>destined “Can you take us to our destined room.”<br>7<br>epidemic “This epidemic will destory our country and many people will die because of the disease.”<br>8<br>gossip “Don’t deem the gossip because it is just the rumor.”<br>9<br>ward “Stay away from the ward because the patients were illed by the epidemic and you might be illed as well.”<br>10<br>integrate “If you are not usd to being alone you can integrate yourself into a group.”<br>11<br>tackle “If you can tackle something, you can deal with something.”<br>12<br>perceive “Can you perceive that she don’t understand you.”<br>13<br>fluctuate “Don’t let your emotion fluctuate and calm down to think and exert.”<br>14<br>sediment “Look at the sediment from the water, which shows it’s toxic.”</p></blockquote><h2 id="写译"><a href="#写译" class="headerlink" title="写译"></a>写译</h2><h3 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h3><p><code>先记录一下这个模版，下面总结为自己的模版</code></p><p>六级通常情况只考议论文essay，包括几种类型</p><ol><li>how to问题解决型</li><li>what 现象解释型</li><li>Option、choice choose 观点选择型</li></ol><p>三个段落11句话</p><p>第一个段落（3句话）：<br>    1-2句话，提出问题；<br>    3过渡；<br>第二个段落（6句话）：<br>    3个论点+论据<br>第三个段落（2句话）：<br>    1句话，重申观点；<br>    第2句话，提出期望（万能结尾）；</p><h4 id="第一段"><a href="#第一段" class="headerlink" title="第一段"></a>第一段</h4><p>第一句话通常有两种情况；<br>第一句话主要是用来阐释写作讨论问题的背景；</p><ol><li>题目要求copy the sentence（直接把这句话抄在开头即可）</li><li>With respect to（名词或者句子）,opinions are sharply divided, but what is widely acknowledged is that 句子<br> 注意：<br> 1）with respect to后面如果是句子：要使用连词，例如whether College Chinese should be a compulsory course<br> 2）主语从句what is acknowledged is that后面的句子，主要是对前面提到的名词或句子，进一步的“客观”阐释；<br>     eg：it is irreplaceable to cultivate our mind and strengthed the culture confidence of us.</li></ol><p><strong>by Yesys</strong></p><p>Concerning（名词或句子）,It is a deeply <strong>contentious</strong> issue, but there is a <strong>prevailing consensus</strong> that 句子</p><p>第二句话用来表明自己的观点，常见可以有以下写法</p><ol><li>As I see it&#x2F;It is my belief that 句子</li><li>I concur with&#x2F;I‘m totally in line with 句子</li></ol><p><strong>by Yesys</strong><br>I am a <strong>staunch advocate</strong> for 句子<br>（坚定的拥护者）</p><h4 id="第二段"><a href="#第二段" class="headerlink" title="第二段"></a>第二段</h4><p>6句话，3个论点+3个论据；<br>可以论点在前，也可以论据在前，or 交换着来；</p><p>论点1：<br>    To start with, as is widely argeed, 句子（非限制性定语从句）</p><p><strong>by Yesys</strong><br>The first and foremost argument <strong>rests on</strong> the widely accepted view that </p><p>论据1：<br>    It is a fundmental conviction that 句子（形式主语+主语从句）</p><p><strong>by Yesys</strong><br>It is an <strong>established truth</strong> that…</p><p>论点2：<br>    what’s more, equally important is the enduring truth that 句子（同位语从句+表语倒装）</p><p><strong>by Yesys</strong><br>Beyond that, of no less significance is the widely acknowledged reality that…</p><p>论据2：<br>    To put it simply, A and B are two sides of the same coin; one is incomplete without the other.（谚语）</p><p><strong>by Yesys</strong><br>Fundamentally, A and B enjoy a <strong>symbiotic relationship</strong>; the <strong>vitality</strong> of “A or B” is <strong>fundamentally contingent upon</strong> the <strong>presence</strong> of the other.<br>（共生关系）（活力）（从根本上取决于）（存在）</p><p>论点3：<br>    Last and certainly not least, we must shine a spotlight on 名词, a factor whose value has been consistenly undervalued througout history.</p><p><strong>by Yesys</strong><br>Ultimately, we must bring into sharp focus [核心名词], a factor that has been historically overlooked yet is fundamental to [相关领域].</p><p>论据3：<br>    Therefore, urgent steps must be taken to 动词原形（被动语态）</p><p><strong>by Yesys</strong><br>Hence, <strong>concerted</strong> and immediate measures must be <strong>implemented</strong> to [动词原形]…<br>（具体的）（实施）</p><h4 id="第三段"><a href="#第三段" class="headerlink" title="第三段"></a>第三段</h4><p>第一句话（再次对我们对观点进行阐释）<br>    In conclusion, while 主题词 has its imperfections, its positive effects far outweight the negative ones, provided that we use it rationally.（让步状语从句+条件状语从句）</p><p><strong>by Yesys</strong><br>In summary, while [主题] is not without its limitations, its <strong>net benefits remain substantial</strong>, <strong>contingent upon</strong> its <strong>judicious</strong> application.<br>（净收益）（取决于）（明智的）</p><p>第二句话（表达期望&#x2F;号召）<br>    The quicker we are when 句子, the less&#x2F;more 句子</p><p><strong>by Yesys</strong><br>The more <strong>proactively</strong> we act to [动词不定式], the greater the <strong>dividend</strong> we <strong>stand to reap</strong> in terms of [积极结果].<br>（积极主动）（红利）（收获）</p><h4 id="万能语料库"><a href="#万能语料库" class="headerlink" title="万能语料库"></a>万能语料库</h4><p>cultural identity 文化认同；<br>language proficiency 语言能力；<br>facilitate：协助；促进；使…容易发生</p>]]></content>
      
      
      
        <tags>
            
            <tag> 大学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计组复习</title>
      <link href="/2025/05/03/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/"/>
      <url>/2025/05/03/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p><code>我在大二下选修了计算机组成原理，这篇blog用来梳理相关知识点</code></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一些学习计算机组成原理之前应该知道的知识…</p><ol><li>计算机结构：系统程序员所能见到的<strong>硬件特性</strong>，指的是计算机的<strong>逻辑结构</strong></li><li>计算机组成：计算机硬件的<strong>具体实现</strong>，指的是计算的<strong>物理结构</strong></li><li>两类汇编语言，RISC &amp; CISC，对应精简与复杂的指令系统，MIPS属于RISC的一种</li><li>计算机组成原理涉及：汇编，处理器、内存、IO三者对应的逻辑系统与硬件实现（数据通路），课程定位在整个计算机系统中处于硬件方面的数字电路之上，软件层面的操作系统之内（因为上到汇编），但在编译器之下（编译器同样属于OS的范畴）</li><li>核心内容：CPU Organization(data path &amp; controller), Caches</li><li>重点内容：MIPS汇编，Virtual Memory</li><li>了解内容：I&#x2F;O, Bus</li></ol><p><strong>最后请谨记，该门课特点是概念抽象、繁琐…但是“清澈见底”，只要想弄清楚，一定可以！</strong></p><h2 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h2><h3 id="指令系统设计"><a href="#指令系统设计" class="headerlink" title="指令系统设计"></a>指令系统设计</h3><p><code>这一部分主要是一些有关指令系统设计的知识点</code></p><p>于是，首先看看这三个知识点：</p><ol><li>指令：二进制的机器语言</li><li>汇编指令：助记符，每种条符号语句都映射到一条二进制的机器代码</li><li>ISA：指令系统（指令集体系结构），<strong>软硬件交汇的地方</strong></li></ol><p>接下来，一条指令应该包含以下信息：</p><ol><li>操作码（定长 or 变长）</li><li>源操作数参照（from where）</li><li>目的位置参照（to where）</li><li>下一条指令地址（what to do next?）</li></ol><p>按地址数的指令分类：</p><p>零、一、二、三、多地址指令，其中二三是典型的RISC风格。三的特点是显示指定了dst，一或二的dst是隐含的（built-in or src）</p><p>指令执行的阶段：</p><p>取指令-&gt;译码-&gt;取操作数-&gt;运算（执行）-&gt;存放结果-&gt;取下一条指令<br><strong>不一定所有指令都涉及所有步骤，但是考虑的时候应该按最复杂的来，何尝不是一种设计原则？</strong></p><p>指令设计基本原则：<br>完备性，兼容性，均匀性，可扩展性<br><strong>应当明白词语背后的含义</strong></p><p>最简单的完备指令系统：<br>load, store, inc, brn</p><h3 id="操作数类型"><a href="#操作数类型" class="headerlink" title="操作数类型"></a>操作数类型</h3><p>…</p><h3 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h3><p>…</p><h3 id="扩展操作码编码"><a href="#扩展操作码编码" class="headerlink" title="扩展操作码编码"></a>扩展操作码编码</h3><p>这是涉及关于如何给操作码编码，以及对应数量关系的问题。<br><strong>核心思想是一种数字状态，一个编码</strong></p><p>涉及到的相关信息有：</p><ol><li>指令字长，例如16位、32位…</li><li>地址长度，如6位…</li><li>操作码长度，通常不同地址数量的编码不同</li><li>不同地址数的指令的条数</li></ol><p>通常会已知1、2，4中某些地址数的指令条数，求剩余一种地址数的指令<strong>最多</strong>的条数。</p><p>关键点是：</p><ol><li>明确<strong>已知的某些地址数的指令条数——剩下的一种地址数的指令条数</strong>一定存在函数关系</li><li>从多地址数的指令开始考虑，考虑它的操作码有多少位，可求得这种指令至多有多少条</li><li>利用“已知”的实际条数与至多有多少条，可以求得这种指令的<strong>剩余状态</strong>数量</li><li>考虑减少一条地址的指令，对应操作码有多少位，<strong>记得计算操作码长度的时候，不仅是指令字长减去地址长度，还要减去上种指令操作码所用长度</strong></li><li>求得这种指令至多有多少条，利用<strong>剩余状态</strong>×<strong>操作码长度</strong></li><li>显然这个过程可以反复进行，由地址数量最多的情况，如3个地址码，到最少的情况，如零地址码<br><strong>最后，不一定所有的状态都有使用…</strong></li></ol><h3 id="指令设计的风格"><a href="#指令设计的风格" class="headerlink" title="指令设计的风格"></a>指令设计的风格</h3><p>尤其关注RISC的风格。</p><p>RISC是<strong>load&#x2F;store型指令系统</strong>，特点是只有load、store命令才能访问存储器，其它运算类的指令通通不能访问存储器<br>（值得注意的是这种指令系统，属于<strong>通用寄存器型指令系统</strong>的子集，特点是使用通用寄存器存放临时数据，而不使用累加器）</p><p>RISC的特点是：</p><ol><li>指令数目少</li><li>指令格式规整</li><li>Load&#x2F;store风格</li><li>采用流水线的指令执行方式</li><li>采用大量通用寄存器</li><li>采用硬连线控制器</li><li>采用优化的编译器</li></ol><h3 id="异常与中断"><a href="#异常与中断" class="headerlink" title="异常与中断"></a>异常与中断</h3><p>…</p><h3 id="程序的机器级表示（MIPS指令系统）"><a href="#程序的机器级表示（MIPS指令系统）" class="headerlink" title="程序的机器级表示（MIPS指令系统）"></a>程序的机器级表示（MIPS指令系统）</h3><p><code>这一部分是重点知识，所以会有多级的副标题。请着重掌握！</code></p><h4 id="MIPS有关的基础知识"><a href="#MIPS有关的基础知识" class="headerlink" title="MIPS有关的基础知识"></a>MIPS有关的基础知识</h4><p><code>一些零碎的知识点，不好纳入后面的各级标题之中，于是集中在此...</code><br><code>或者说并非无法纳入，而是比较重要...单拎出来也方便记忆</code></p><ol><li>MIPS指令长度都是32位</li><li>MIPS中设计了32个通用寄存器</li><li>MIPS使用大端的存储方式</li><li>MIPS设计的存储器按照字节编址，1Byte对应一个存储单元，有自己的专属地址</li><li>MIPS中人为修改pc的指令，如j、beq等，在机器级存储的转移值是相对转移的指令的条数（即应该修改pc的相对量除以4后的值）</li></ol><h4 id="MIPS指令的机器级表示"><a href="#MIPS指令的机器级表示" class="headerlink" title="MIPS指令的机器级表示"></a>MIPS指令的机器级表示</h4><p>MIPS中指令格式包括R型、I型、J型。</p><h5 id="1-R型指令"><a href="#1-R型指令" class="headerlink" title="1.R型指令"></a>1.R型指令</h5><p>机器级表示:<br>op6+rs5+rt5+rd5+shamt5+func5</p><ol><li>op是操作码，对于R型来说全是0</li><li>shamt是用于处理移位操作的</li><li>func是用于区分操作码的</li><li>rs, rt为源寄存器1、2</li><li>rd为目的寄存器</li></ol><p><strong>注意，R型指令助记符表示的时候，实际上是 op rd rs rt的顺序，要和机器级位置区分开</strong><br><code>不妨考虑一下，op全为0的好处是什么</code></p><h5 id="2-I型指令"><a href="#2-I型指令" class="headerlink" title="2.I型指令"></a>2.I型指令</h5><p>机器级表示：<br>op6+rs5+rt5+imm16</p><ol><li>常用I型指令：双目运算，rs与imm运算，送至rt，例如<code>addi $2,$1,imm</code></li><li>常用I型指令，load、store，采用的<strong>MIPS采用基址+相对位移量</strong>的访存方式，例如<code>lw $2,100($1)</code></li><li>常用I型指令，beq、bne，条件分支，例如<code>beq $1,$2,L</code></li><li>imm是16位，但是与其运算的寄存器rs是32位的，需要进行扩展，扩展的规则如下：<br>①用于进行双目运算的时候，i是符号扩展imm，iu是零扩展imm<br>②用于load、store的时候，imm总是符号扩展，虽然有u的存在，例如lhu, lbu等，但是这里的u对应的用于0扩展不足32位的存储内容，从而加载到寄存器<br>③用于条件分支的时候，beq、bne应该与slt搭配使用，所以imm通常只与1、0进行相等与否的比较，于是也不存在什么扩展与否的问题<br><strong>注意，实际上slt也可以是I型的，并且很常用，但是也有R型的</strong></li></ol><h5 id="3-J型指令"><a href="#3-J型指令" class="headerlink" title="3.J型指令"></a>3.J型指令</h5><p>机器级表示：<br>op6+target address26</p><ol><li>实际的目的地址计算方式，pc高4位:target address:00<br>最后总是00的原因，在于MIPS中指令总是32位的，从0地址开始访存：0,100,1000,1100…（0、4、8、12…），末尾总是00，这个特点在后面设计用于MIPS的CPU的时候也非常有用</li><li>显然，这是一种局部寻址的方式</li></ol><h4 id="MIPS设计的通用寄存器"><a href="#MIPS设计的通用寄存器" class="headerlink" title="MIPS设计的通用寄存器"></a>MIPS设计的通用寄存器</h4><p>MIPS使用32个通用寄存器，我们应该掌握以下有关的知识。</p><h5 id="1-两种助记符号的使用"><a href="#1-两种助记符号的使用" class="headerlink" title="1.两种助记符号的使用"></a>1.两种助记符号的使用</h5><ol><li>编号：”$”+“数字：0~31”</li><li>名称</li></ol><p><code>程序中一般都使用名称，举例子的时候使用编号多一些。或许，前者体现“助记”，后者体现“通用”</code></p><h5 id="2-经常使用的寄存器"><a href="#2-经常使用的寄存器" class="headerlink" title="2.经常使用的寄存器"></a>2.经常使用的寄存器</h5><ol><li>zero<br>编号为0，其功能是提供0值，寄存器中始终是全0</li><li>v0-v1<br>编号2-3，功能是存放过程调用的返回值</li><li>a0-a3<br>编号4-7，功能是存放过程调用的参数</li><li>t0-t7<br>编号8-15，功能是存放临时使用的变量</li><li>s0-s7<br>编号16-23 被调用者保存的寄存器</li><li>t8-t9<br>编号24-25，功能是存放临时使用的变量</li><li>sp, fp, ra<br>编号29-31，功能是，栈指针（栈顶），帧指针（栈底），存放调用过程返回地址</li></ol><p>记忆的方法，“一个过程调用，使用了4个参数a，返回了两个值v，调用者保存了8个寄存器s，被调用者保存了10个寄存器t，关键在于sp、fp与ra”+zero</p><h5 id="3-了解的寄存器"><a href="#3-了解的寄存器" class="headerlink" title="3.了解的寄存器"></a>3.了解的寄存器</h5><ol><li>at<br>编号为1，保留给编译器使用</li><li>k0-k1<br>编号为26-27，保留给系统使用</li><li>gp<br>编号为28，全局指针</li></ol><h4 id="MIPS汇编指令"><a href="#MIPS汇编指令" class="headerlink" title="MIPS汇编指令"></a>MIPS汇编指令</h4><p><code>在开始做这一部分的笔记之前，我思考了一个问题——如何才能更好的记忆MIPS汇编指令。我得出的答案是，一般性规律的记忆+特殊性个例的记忆。对于一般性规律的记忆，其规律包括：指令的助记符+什么类型的指令+指令的特性，前两者可以帮助我们正确地写出指令，后者可以帮助我们正确地理解指令。对于特殊性个例，我们不妨记住全部。在记忆的过程中带着这个思想，或许会容易记忆一些。</code></p><p>我们接下来按照指令的类别进行。</p><h5 id="1-算术类指令"><a href="#1-算术类指令" class="headerlink" title="1.算术类指令"></a>1.算术类指令</h5><ol><li>算术运算包括，加、减、乘、除<br>对应的基本助记符是add、sub、mult、div</li><li>加、减有I型和R型，使用I型的时候，如addi、subi</li><li>加、减默认会判断溢出，也有不判断溢出，对应u扩展（undo），如addu、subu<br><strong>当然也有addiu、subiu</strong></li><li>乘、除比较特殊，仅有R型，但是是双目操作符，因为结果存放在默认寄存器hi，lo（乘法hi，lo分别为高低32位，除法hi为32位余数，lo为32位商）</li><li>乘、除分有符号数和无符号数，对应为u扩展（unsigned），如multu、divu<br><strong>注意区分unsigned和undo</strong></li></ol><p><code>一般性的规律是，助记符：加、减有I、R型，乘、除只有R型</code></p><h5 id="2-存储访问"><a href="#2-存储访问" class="headerlink" title="2.存储访问"></a>2.存储访问</h5><p>存储访问，按照访存字节，分为按字（word，MIPS中是32位），按半字（half word，16位），按字节（byte，8位）访问</p><p>以及MIPS最有特色的指令<strong>lui</strong></p><ol><li>lw、sw，按字访问lw&#x2F;sw $1 100($2)，sw是MIPS中唯一一个dst在src之后的指令</li><li>lhu、lbu，按半字、字节加载，16位内存到32位存储器涉及扩展，格式与lw、sw相同，内存中数据是按无符号扩展<br><strong>注意，必须加u，这就意味着使用半字或字节的时候，内存中内容只能按字节扩展到寄存器</strong><br><strong>但是imm的扩展只能是符号扩展，没有undo的选择</strong></li><li>sh、sb，按半字、字节存储，格式与lw、sw相同，由于是寄存器到存储器，不用考虑扩展。<br><strong>sh、sb同样的只要是访存，imm都是按符号扩展</strong></li><li>lui，I型，使用方法，lui rs,imm，将16位imm放置在rs的高16位<br><em>这是一个很能体现MIPS特色的指令，如果程序员，<del>按照自己的想象</del>（这个数字并不存在于任何其它的位置），想要将一个32位的数字放置在寄存器中，就可以按照16位、16位的存放。可以先lui，再addi</em><br><strong>按照自己的想象是很重要的一点！这将lui和lw、lhu、lbu区分开来，因为lui根本没有访存！</strong></li></ol><p><code>一般性的规律是，助记符；访存都是I型</code></p><h5 id="3-逻辑运算"><a href="#3-逻辑运算" class="headerlink" title="3.逻辑运算"></a>3.逻辑运算</h5><p>MIPS中常用的逻辑运算是与、或、异或</p><ol><li>与，and，有R型、I型，I型对应i扩展，如addi rd,rs,rt</li><li>或，or，同与</li><li>异或，xor，同与</li></ol><p><code>一般性的规律是，助记符，逻辑运算有R型、I型</code></p><h5 id="4-移位操作"><a href="#4-移位操作" class="headerlink" title="4.移位操作"></a>4.移位操作</h5><p>MIPS中的涉及的移位操作有，逻辑左、右移动，算术右移</p><ol><li>逻辑左移，sll，I型，如sll rt,rs,imm</li><li>逻辑右移，srl，同上</li><li>算术右移，sra，同上<br><strong>注意，表示是逻辑还是算术的l和a，放在最后</strong></li></ol><p><code>一般性的规律是，助记符，移位只有I型</code></p><h5 id="5-条件分支"><a href="#5-条件分支" class="headerlink" title="5.条件分支"></a>5.条件分支</h5><p>MIPS中涉及的条件分支，常用的是，slt、beq、bne</p><ol><li>slt，有R型、I型，如slt rt,rs,imm<br><strong>注意slt的I型，不使用i扩展！</strong></li><li>beq，I型，如beq rs,rt,L<br><strong>实际编程中L的位置，通常写label，进一步的处理或许是交给汇编器进行的…</strong></li><li>bne，同beq</li></ol><p><code>一般性的规律是，助记符，slt有R型，其它都是I型</code></p><h5 id="6-无条件跳转指令"><a href="#6-无条件跳转指令" class="headerlink" title="6.无条件跳转指令"></a>6.无条件跳转指令</h5><p>MIPS中的跳转指令常用的是j、jr、jal</p><ol><li>j，J型指令，如j L（实际使用L是label）</li><li>jr，J型指令，地址存放在Register中，如j rd</li><li>jal，J型指令，<strong>注意这个指令有两个操作</strong>，一个如普通的j一般跳转到L，另一个是$ra &#x3D; PC + 4（存放返回地址，所以这个指令常用于过程调用）</li></ol><p><code>一般性的规律是，助记符，都是J型</code></p><h4 id="MIPS汇编代码"><a href="#MIPS汇编代码" class="headerlink" title="MIPS汇编代码"></a>MIPS汇编代码</h4><p><code>这一小节主要是掌握MIPS汇编代码的编写的常见结构，包括分支结构、循环结构、还有过程调用</code></p><h5 id="1-分支结构"><a href="#1-分支结构" class="headerlink" title="1.分支结构"></a>1.分支结构</h5><p>分支结构主要有如下两种：</p><ol><li><code>if(i == j) or if(i != j)</code>这种等或不等，主要使用<code>bne</code>,<code>beq</code>进行</li><li><code>if(i &lt; j)</code>这种大于小于的关系，主要使用<code>slt</code>与<code>bne</code>,<code>beq</code>进行</li></ol><p>下面是两个例子<br>eg1</p><pre><code>if(i == j)f = g + helse f = g - h</code></pre><p><code>$s1&lt;-i $s2&lt;-j  $s3&lt;-f  $s4&lt;-g $s5&lt;-h</code></p><pre><code>start: bne $s1,$s2,else       add $s3,$s4,$s5       j exitelse:  sub $s3,$s4,$s5exit:  ...</code></pre><h5 id="2-循环结构"><a href="#2-循环结构" class="headerlink" title="2.循环结构"></a>2.循环结构</h5><p>这里以while循环为例<br>eg</p><pre><code>while(i != k)&#123;    x = x + a[i];    i = i + 1;&#125;</code></pre><p><code>$s1&lt;-x $s2&lt;-i $s3&lt;-k  $s5&lt;-a</code></p><pre><code>loop: beq $2,$3,exit      sll $s7,$s2,2 #注意这行，不能直接将i &lt;&lt;= 2 （Bits -&gt; Byte）      add $s7,$s5,$s7      lw $s6,0($7)      add $s1,$s1,$s6      addi $s2,$2,1 #注意这行，i = i+1（Bits）      j loopexit: ...</code></pre><p>注意，将偏移i换算为地址的时候要乘4，换算成对应按字节编址的情况</p><h5 id="3-过程调用"><a href="#3-过程调用" class="headerlink" title="3.过程调用"></a>3.过程调用</h5><p>首先我们应该清楚整个过程调用的执行过程：</p><ol><li>P保存相应的寄存器（$t）</li><li>P将参数放置于Q可以访问的位置（$a）</li><li>P将返回位置保存，从而让Q可以执行返回（$ra）</li><li>P修改栈帧（$sp $fp）切换到Q的栈帧</li><li>Q将P的相关寄存器进行保存（$s、$ra、$fp）</li><li>Q为自己的局部变量分配栈帧空间</li><li>执行Q的过程</li><li>返回P（使用P最开始保存的$ra，或者是Q自己保存的$ra）</li></ol><p>注意，以上是以最严格、完整的过程来叙述的，实际上都是根据需要来进行。于是可以做以下几点说明：</p><ol><li>P是根据需要保存$t的，如果可以确保之后不再使用，不保存也行，对应了Q可以随意使用$t</li><li>如果参数多于4个，$a不够用了，需要将参数放到相应的栈帧中（如果必要的话$a也可以与$t类似，由P保存）</li><li>$ra的保存实际上是用jal来隐式执行的</li><li>在MIPS中$fp,$sp不一定都要修改，通常是只修改$sp，然后以其作为参考即可，当$fp需要修改的时候，$fp &#x3D; $sp + 栈帧空间大小</li><li>Q也是根据需要保存，如果要使用$s的话必须保存，如果自己还要进行过程调用（会修改$ra、$fp，那么也应该自行保存）</li><li>由于MIPS通用寄存器非常多，$t就多达10个，通常不需要将局部变量分配到栈帧中，直接使用寄存器即可</li><li>…</li><li>返回时总是使用$ra，如果Q中间执行了过程调用修改了$ra，当Q的调用返回时，应该根据Q保存的P的$ra值，将$ra进行还原；并且需要先释放Q的栈帧空间，通常可以使用$sp &#x3D; $fp（如果开始时修改了$fp，同样嵌套调用时若Q修改了$fp，在Q的调用结束时要先将$fp还原，就像$ra一样），或$sp &#x3D; $sp - 栈帧空间，来释放Q的栈帧；最后使用jr $ra返回P的执行。</li></ol><p>以上几点说明都是针对最开始描述的每一点过程进行的</p><p>下面还有一些需要补充的点</p><p>Ⅰ MIPS中栈帧是由高地址到低地址，这意味着分配栈帧空间对$sp执行的是减法操作</p><blockquote><p>eg:在栈帧中分配空间，保存$ra,$a0</p></blockquote><pre><code>subi $sp,$sp,8sw $a0,4($sp)sw $ra,0($sp)</code></pre><p>Ⅱ 一般只有在由数组或结构体等占用空间较大的复杂数据结构的时候才需要使用栈帧分配局部变量（$t不够用）</p><p>Ⅲ Q没有进一步嵌套调用其它函数的情况，Q被称为叶子过程。一般的叶子过程通常在MIPS中甚至不需要开辟栈帧，因为有足够多的通用寄存器</p><p>Ⅳ 如果$fp不使用（建立当前函数的栈帧时并没有维护$fp），可以将$fp作为$s8来使用</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Py_learning</title>
      <link href="/2025/05/01/Py-learning/"/>
      <url>/2025/05/01/Py-learning/</url>
      
        <content type="html"><![CDATA[<p><code>由于我在学习机器学习算法的时候，希望通过Python来对相关的算法进行复现。而自己在此之前其实零零散散不成体系地接触过Python语言，也了解一些基本的东西，但是对于Python中一些语言“特性”方面的东西所知甚少，例如变量的作用域与生命周期，不同模块间的访问等等；此外我对Python风格的代码写法也并不熟悉，其实写什么感觉都是C的味道......于是写下这篇blog用来记录，进一步对相关内容的学习</code></p><h2 id="模块化的Python程序"><a href="#模块化的Python程序" class="headerlink" title="模块化的Python程序"></a>模块化的Python程序</h2><h3 id="内置变量-name"><a href="#内置变量-name" class="headerlink" title="内置变量__name__"></a>内置变量__name__</h3><p>__name__是python模块当中的一个内置变量，每个模块都有。如果你选择当前模块开始执行，那么当前模块内置的__name__会被置为__main__；如果一个模块是被令一个模块import进去的，那么这个模块的__name__会被置为__模块名__，但是不会引入后缀。</p><h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><p>通过__name__我们就可以将我整个项目文件模块化的组织起来。将一个模块作为程序的执行入口，并始终自我约束地从这个模块开始启动整个项目程序。这样做的关键在于使用如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>:</span><br><span class="line">    something</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == __main__:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p><strong>关键点即，不要使用判断__name__以外的任何顶层代码</strong></p><h3 id="一些特性"><a href="#一些特性" class="headerlink" title="一些特性"></a>一些特性</h3><p>Python是一种解释性语言，特点就是不需要编译，而是在运行时通过解释器逐行读取、分析和执行源代码。对应的特点之一就是交互式的编程环境（可以在命令行中输入代码，并立刻看到执行的结果）</p><p>我联想到与这种特点相对应的就是——“顶层代码”，即相关的语句不会被封装在任何函数和类当中，点击运行，便会至上而下地逐行开始执行。</p><p><strong>所以一个关键的特性就是，使用import导入模块化后，该模块的顶层代码会立刻执行。</strong></p><p>启示：编写规范化的工程代码时，除了判断程序执行入口，不要使用顶层代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#k_means.py</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;this is k_means&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#main.py</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;this is mainn&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ == main:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>输出结果：</p><p><code>this is k_means this is main</code></p><h2 id="变量的作用域和生命周期"><a href="#变量的作用域和生命周期" class="headerlink" title="变量的作用域和生命周期"></a>变量的作用域和生命周期</h2><h3 id="单一模块"><a href="#单一模块" class="headerlink" title="单一模块"></a>单一模块</h3><ol><li><p>全局变量<br>在同一模块当中，定义于模块层的变量（顶层代码部分），对应的是<code>global varible</code>全局变量，这些变量的作用域是全局可见，生命周期是从程序开始执行开始，执行完毕结束。</p></li><li><p>局部变量<br>定义于函数中的变量是<code>local varible</code>局部变量，作用域局部可见。对于嵌套函数，外层变量对内层可见，内层对外层不可见。在Python中这种函数嵌套更加的显然。下面是一个例子：</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">outer_function</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;this is outer&quot;</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner_function</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;this is inner&quot;</span>)</span><br><span class="line">    inner_function()</span><br></pre></td></tr></table></figure><p>对应变量的生命周期，都是从定义自己的函数开始，到函数执行完毕结束。</p><p><strong>另外值得一提的是，在上面这个例子当中，inner_function不能从顶层代码调用。</strong><br>3. 内置变量<br><code>Built-in varible</code>内置变量的作用域是在任何地方都可以访问，且生命周期贯穿整个程序的运行期，最开始提到的__name__就是一个很好的例子。<br>4. 访问规则<br>python对于变量遵循<code>LEGB</code>的访问规则，即局部、嵌套、全局、内置。当发现了变量，即刻使用。</p><p>最后简单补充以下Python的变量定义规则，变量在“第一次赋值”时被定义。当然这意味着我们要定义一个变量必须考虑一个初始值，如果暂时没有初始值的话可以使用<code>None</code>作为初始值。随后根据需要赋予想要的初始值即可。当然，变量的类型也是根据你赋予的值来确定的。</p><h3 id="多模块"><a href="#多模块" class="headerlink" title="多模块"></a>多模块</h3><p>为了理解多模块情况下相关变量的作用域和生命周期，引入以下概念：</p><ol><li><p>模块对象，在导入模块的时候Python会为模块创建一个对象，这个对象的生命周期由其作用域确定</p></li><li><p>全局导入，模块对象在全局作用域中导入，此时模块变量生命周期同程序一样。作用域同全局变量。</p></li><li><p>局部导入，模块对象在局部作用域中导入，此时模块变量生命周期同导入了它的函数。作用域同相应的局部变量。</p></li><li><p>模块中的顶层代码在被导入时会立刻执行，相应的对应的全局变量会即刻创建，所以对应的全局变量生命周期、作用域，同模块对象。</p></li></ol><p><del>口语化的来说，模块被导入的时候也相当于一个变量（或者是一个类），如果是被主函数所在的模块作为全局变量导入，那么被导入模块的生命周期、作用域同全局变量，如果被作为局部变量导入，也同局部变量。相应的，被导入的时候，被导入模块中的“全局变量”也会即刻被创建，其生命周期同被导入的模块。</del>（毫不精准的表述…）</p><h2 id="名称冲突"><a href="#名称冲突" class="headerlink" title="名称冲突"></a>名称冲突</h2><p>在使用以下代码的时候，名称冲突时常发生。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> somemodule <span class="keyword">import</span> somename</span><br></pre></td></tr></table></figure><p>这类似是跳过了模块对象，直接导入了其中某个全局变量，自然就很可能与当前模块已有的全局变量、函数发生名称冲突。</p><p>常用的解决方法，也是我们使用模块化的常用方法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> somemodule</span><br><span class="line">somemodule.somename <span class="comment">#使用模块对象名来访问相应的变量、函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> somemodule <span class="keyword">import</span> somename <span class="keyword">as</span> another_name <span class="comment">#或者是别名</span></span><br></pre></td></tr></table></figure><h2 id="列表生成式"><a href="#列表生成式" class="headerlink" title="列表生成式"></a>列表生成式</h2><p>语法如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list_name = [formula <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(start, end)]</span><br><span class="line">list_name = [x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>)]</span><br></pre></td></tr></table></figure><p>这种创建列表的方法成为列表生成式，formula是用于生成列表的表达式，可以是返回一些值的函数，后面的循环是列表中生成元素的次数，循环一次便会调用一次formula。</p><p>当然formula也可以直接是数学表达式，例如第二个例子展示的，用于生成1到9的平方的列表。</p><p>注意end不被包含在内。</p><h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><p>元组（Tuple）是一种内置的数据结构，属于不可变序列类型，用于存储多个元素。与列表（List）不同，<strong>元组一旦创建，其内容就不能更改（即不可变）</strong>。元组常用于存储一组相关的数据，例如函数返回多个值时，可以使用元组来打包这些值。</p><h3 id="元组的创建"><a href="#元组的创建" class="headerlink" title="元组的创建"></a>元组的创建</h3><p>使用<code>()</code>来创建一个元组，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个空元组</span></span><br><span class="line">empty_tuple = ()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个包含多个元素的元组</span></span><br><span class="line">example_tuple = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">&quot;hello&quot;</span>, <span class="number">4.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个单元素的元组（注意逗号）</span></span><br><span class="line">single_element_tuple = (<span class="number">1</span>,)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以省略小括号，直接用逗号分隔元素</span></span><br><span class="line">another_tuple = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问元素</span></span><br><span class="line"><span class="built_in">print</span>(example_tuple[<span class="number">0</span>])  <span class="comment"># 输出 1</span></span><br><span class="line"><span class="built_in">print</span>(example_tuple[<span class="number">3</span>])  <span class="comment"># 输出 &quot;hello&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取元组的长度</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(example_tuple))  <span class="comment"># 输出 5</span></span><br></pre></td></tr></table></figure><h3 id="元组的常见用途"><a href="#元组的常见用途" class="headerlink" title="元组的常见用途"></a>元组的常见用途</h3><ol><li>多值返回，用于让函数返回多个值</li><li>作为字典的键，这是由于元组的不可变性</li></ol><h2 id="函数的参数以及返回值"><a href="#函数的参数以及返回值" class="headerlink" title="函数的参数以及返回值"></a>函数的参数以及返回值</h2><p>在python中函数的参数不需要提前声明类型，同样的返回值也不需要提前进行声明。但是在大型的项目中为了便于程序的维护，以及提供静态的检查，可以使用注解符号。例如，下面这个例子。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span>, <span class="type">Tuple</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">k_means</span>(<span class="params">D:<span class="type">List</span>[<span class="type">List</span>[<span class="built_in">float</span>]], n:<span class="built_in">int</span>, k:<span class="built_in">int</span></span>) -&gt; <span class="type">Tuple</span>(<span class="type">List</span>[<span class="type">List</span>[<span class="type">List</span>[<span class="built_in">float</span>]]], Lsit[<span class="type">List</span>[<span class="built_in">float</span>]])</span><br></pre></td></tr></table></figure><p>其中typing是类型注解使用的包，如果不需要使用类型进行注解可以不使用这个包。</p><p>常见的类型注解有：</p><ol><li>List     eg: List[int]</li><li>Tuple    eg: Tuple[float,str]</li><li>Dict     eg: Dict[int,str]</li><li>Set      eg: Set[str]<br>还有许多可用的…用到再查吧…</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Clustering-learning-route</title>
      <link href="/2025/04/30/Clustering-learning-route/"/>
      <url>/2025/04/30/Clustering-learning-route/</url>
      
        <content type="html"><![CDATA[<p><code>我从现在开始学习聚类相关的内容，最终目标是希望发表一篇相关的论文。我以现在浅显的眼光给自己定下的学习路线如下</code><br><code>1. 完成西瓜书聚类部分的学习，完成的标志是将书上给出的伪代码进行真实地复现</code><br><code>2. 阅读综述论文，了解聚类对应的科研领域当前大概的情况</code><br><code>3. 阅读聚类有关的顶会论文......</code><br><code>我以现在的知识，无法继续制定下面的计划了，因为我并不了解3、往后的真正开始着手科研工作会是怎样的。我目前粗浅的想法是，或许我会了解到一些聚类的具体应用，然后为了完成一篇相关的论文：我也必须将聚类投入到具体的应用当中去，这个时候我不得不学习一些其它领域的知识（当然，目前我并不清楚那些会是什么）；又或许我会做一些对聚类算法进行改进的工作，但是这或许会更加艰难（因为曾经一位厉害的学长告诉我将A运用于B会比将A升级为A+简单许多）</code><br><code>此外，我将这篇blog用作自己的学习日志与计划路线</code></p><h2 id="阶段一"><a href="#阶段一" class="headerlink" title="阶段一"></a>阶段一</h2><p>2025.4.30</p><ol><li>学习西瓜书上有关聚类的基础知识（概念、性能指标）</li><li>学习“k均值算法”、学习“学习向量量化算法”</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习（聚类） </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Clustering-watermelon-book</title>
      <link href="/2025/04/30/Clustering-watermelon-book/"/>
      <url>/2025/04/30/Clustering-watermelon-book/</url>
      
        <content type="html"><![CDATA[<h2 id="聚类任务简介"><a href="#聚类任务简介" class="headerlink" title="聚类任务简介"></a>聚类任务简介</h2><p>简单地说，就是要对一个n维向量元素的集合求一个划分，划分后的子集就是一类的（不相交的簇）。</p><p>对于数据集$D &#x3D; {x_1,x_2,…,x_m}$，划分为k个不相交的集合$C_1, C_2, …, C_k$，若$x_i \in C_j$，则$\lambda_i &#x3D; j$，其中$j \in {1,2,…,k}$，对应$\lambda_i$就是$x_i$的标签。聚类任务要做的是就是求出一个聚类结果$\lambda &#x3D; (\lambda_1,\lambda_2,…,\lambda_m)$，其中$\lambda$为数据集的簇标记向量，第$i$个分量标记了$x_i$属于哪一个簇。</p><h2 id="性能度量"><a href="#性能度量" class="headerlink" title="性能度量"></a>性能度量</h2><p>怎样的聚类是好的：</p><ol><li>簇内的样本尽量相似</li><li>簇间的样本尽量不同</li></ol><h3 id="外部指标"><a href="#外部指标" class="headerlink" title="外部指标"></a>外部指标</h3><p>外部指标：将聚类结果和某个“参考模型”进行比较，称为外部指标</p><p>对于数据集$D &#x3D; {x_1,x_2,…,x_m}$，使用聚类模型A，得到簇标记向量$\lambda$，另外使用参考聚类模型B，得到簇标记向量$\lambda^{*}$。</p><p>于是我们可以根据$\lambda_i$与$\lambda_j$相同与否的关系以及$\lambda^{<em>}_i$<br>与$\lambda^{</em>}_j$是否相同的关系定义如下集合。</p><p>$DD,DS,SD,SS$一共四个集合，这些集合中的元素类似$(x_i,x_j)$，是一个“向量对”，分别按照如下规则界定类似的向量对是否属于相应的集合</p><ol><li>$x_i$与$x_j$在模型A、B的划分下都属于同一簇，则$(x_i,x_j) \in SS$</li><li>$x_i$与$x_j$在模型A、B的划分下都不属于同一簇，则$(x_i,x_j) \in DD$</li><li>$x_i$与$x_j$在模型A划分下属于同一簇，在B划分下不属于同一簇，则$(x_i,x_j) \in SD$</li><li>$x_i$与$x_j$在模型A划分下不属于同一簇，在B划分下属于同一簇，则$(x_i,x_j) \in DS$</li></ol><p><code>D即different，S即same 这样就非常容易理解了</code></p><p>根据上面的集合，我们可以定义如下过度变量</p><ol><li>$\lvert SS \rvert &#x3D; a$</li><li>$\lvert SD \rvert &#x3D; b$</li><li>$\lvert DS \rvert &#x3D; c$</li><li>$\lvert DD \rvert &#x3D; d$</li></ol><p>进一步，我们定义常用于性能度量的第一组系数</p><ol><li><strong>JC系数</strong> $JC &#x3D; \frac{a}{a+b+c}$</li><li><strong>FMI系数</strong> $FMI &#x3D; \sqrt{\frac{a}{a+b} \ast \frac{a}{a+c}}$</li><li><strong>Rand指数</strong> $RI &#x3D; \frac{2(a+b)}{m(m-1)}$</li></ol><p>这些性能指标的范围都是$[0,1]$，并且越大说明聚类效果越好<br><code>当然，前提是参考的模型是“正确”的</code></p><h3 id="距离计算"><a href="#距离计算" class="headerlink" title="距离计算"></a>距离计算</h3><h4 id="闵可夫斯基距离"><a href="#闵可夫斯基距离" class="headerlink" title="闵可夫斯基距离"></a>闵可夫斯基距离</h4><p>定义函数$dist(\cdot,\cdot)$，用于计算两个向量的距离。则它应该满足下述三个性质</p><ol><li>非负性</li><li>对称性</li><li>直递性</li></ol><p>常用的距离是闵可夫斯基距离</p><p>$dist_mk(x_i,x_j) &#x3D; (\sum_{\mu &#x3D; 1}^{n} \lvert x_{i\mu} - x_{j\mu} \rvert ^{p})^{\frac{1}{p}}$<br>显然当$p &#x3D; 2$时即我们常用的欧氏距离，$p &#x3D; 1$时为曼哈顿距离</p><h4 id="有序属性和无序属性"><a href="#有序属性和无序属性" class="headerlink" title="有序属性和无序属性"></a>有序属性和无序属性</h4><p>在考虑属性之间的距离的时候，序十分重要。这里通过简单的例子引入有序和无序。属性值出自于能够直接计算距离的属性称为有序属性，例如属性定义域为${1,2,3}$，而不能的就是无序属性，例如${货车,西瓜,乐乐}$。</p><p>显然，闵可夫斯基距离是用于衡量有序属性的距离的。</p><h4 id="VDM——衡量无序属性的距离"><a href="#VDM——衡量无序属性的距离" class="headerlink" title="VDM——衡量无序属性的距离"></a>VDM——衡量无序属性的距离</h4><p>假设有$k$个样本簇，$m_\mu,a$表示在属性$\mu$上取值为$a$的样本的个数，$m_\mu,a,i$表示在第i个样本簇中，属性$\mu$取值为$a$的样本个数。定义VDM如下。</p><p>$VDM &#x3D; \sum_{i&#x3D;1}^{k} \lvert \frac{m_\mu,a,i}{m_\mu,a} - \frac{m_\mu,b,i}{m_\mu,b}\rvert ^{p}$</p><p>值得注意的是，这里衡量的只是无序属性的距离，而要衡量两个无序样本$x_i$与$x_j$的距离，即其中的各个属性（类比向量的分量）都是无序属性，我们应该对各个属性的$VDM$求和。</p><h4 id="混合元素的距离"><a href="#混合元素的距离" class="headerlink" title="混合元素的距离"></a>混合元素的距离</h4><p>不失一般性，我们可以定义混合元素的距离如下：<br>$MinkovDM_p(x_i,x_j) &#x3D; (\sum_{\mu&#x3D;1}^{n_c} \lvert x_{i\mu} - x_{j\mu} \rvert ^{p} + \sum_{\mu&#x3D;n_c+1}^{n} VDM_p(x_{i,\mu},x_{j,\mu}))^{\frac{1}{p}}$</p><p>其中$x_i,x_j$为混合属性的元素，$1到n_c$对应为有序属性，$n_c到n$对应为无序属性</p><h3 id="内部指标"><a href="#内部指标" class="headerlink" title="内部指标"></a>内部指标</h3><p>于是我们可以根据元素的不同（有序、无序、混合），选取我们需要的距离函数$dist(\cdot,\cdot)$，定义如下常用于刻画簇的性质的量</p><ol><li>$\mu_i &#x3D; \frac{1}{\lvert C \rvert} \sum_{1 \le i \le \lvert C \rvert} x_i, \mu &#x3D; (\mu_1,\mu_2,…,\mu_m)$为簇$C$的中心点</li><li>$avg(C) &#x3D; \frac{2}{\lvert C \rvert (\lvert C \rvert - 1)} \sum_{1 \le i &lt; j \le \lvert C \rvert} dist(x_i,x_j)$ 簇$C$内样本间的平均距离</li><li>$diam(C) &#x3D; max_{1 \le i &lt; j \le \lvert C \rvert} dist(x_i,x_j)$ 簇$C$内样本间的最远距离</li><li>$d_{min}(C_i,C_j) &#x3D; min_{x_i \in C_i,x_j \in C_j} dist(x_i,x_j)$ 簇$C_i$和簇$C_j$中最近样本的距离</li><li>$d_{cen}(C_i,C_j) &#x3D; dist(\mu_i,\mu_j)$ 簇$C_i$和簇$C_j$的中心点距离</li></ol><p>进一步我们定义一些内部指标如下。</p><ol><li>$DBI &#x3D; \frac{1}{k} \sum_{i&#x3D;1}^{k} max_{j \ne i}(\frac{avg(C_i)+avg(C_j)}{d_{cen}(\mu_i,\mu_j)})$</li><li>$DI &#x3D; min_{1 \le i \le k} { min_{j \ne i}(\frac{d_{min}(C_i,C_j)}{min_{1 \le l \le k} diam(C_i)}) }$</li></ol><p>DB指数越小越好，Dunn指数越大越好</p><h2 id="原型聚类"><a href="#原型聚类" class="headerlink" title="原型聚类"></a>原型聚类</h2><p>原型的概念对应的是空间中的点。原型聚类的前提是认为，数据集中的聚类结构可以通过一组原型来描述。而原型聚类要做的就是通过某些方法找出这组“原型”。常见的原型聚类算法的代表有<code>k-means（k均值算法）</code>、<code>学习向量量化算法</code>等等</p><p>在后续的blog中会记录我复现相关算法的过程</p>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习（聚类） </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Traceroute</title>
      <link href="/2025/04/27/Traceroute/"/>
      <url>/2025/04/27/Traceroute/</url>
      
        <content type="html"><![CDATA[<p>这篇blog用于记录我在学习计算机工程系统导论时，一个与网络有关的实验。</p><h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><ol><li>学习Ping和Traceroute工具的使用，能够在网络开发和维护中熟练使用该工具获取网络状态和进行错误排查。</li><li>巩固课堂学习的因特网分层设计实现知识，理解因特网的分组转发网络的特性，通过分析互联网数据包因转发而产生的时延，加深理解尽力而为的因特网设计思想。</li><li>通过分析ICMP协议，学习在分层设计中进行跨层通信的设计实现方法，思考因特网网络层在错误处理上的折中设计和处理技巧。</li><li>通过Traceroute工具基于错误处理包进行路径探测功能的设计，体会在实践中体会设计方案在解决问题的同时是如何带来新的设计机会的。</li></ol><h2 id="实验过程与习题"><a href="#实验过程与习题" class="headerlink" title="实验过程与习题"></a>实验过程与习题</h2><h3 id="ping应用"><a href="#ping应用" class="headerlink" title="ping应用"></a>ping应用</h3><ol><li><p><strong>用不超过200字简要概括ping命令</strong><br>ping命令用于向主机或网关发送请求，使用的是ICMP协议的ECHO_REQUSET数据包，并且会接收ICMP ECHO_RESPONSE作为回应。其中ECHO_REQUSET数据包包含了IP和ICMP头部，其后是一个timeval结构以及若干的填充字节。ping命令支持IPv6以及IPv4协议，其中对IPv6节点的信息查询是根据RFC4620进行的，但是由于IPv6源路由被起用，中间跳点可能不被允许。<br><em><code>man ping</code>结果如图1所示</em></p></li><li><p><strong>说明实验现象背后的原因</strong><br>我使用ping命令，分别对<code>www.sud.edu.cn</code>和<code>www.ouc.edu.cn</code>进行了10次<code>ping</code>操作，每次都发送了56字节的数据包。从结果可以看出，到<code>www.sud.edu.cn</code>的网络连接是通畅的，每一次都成功受到了回复，没有丢包发生。但是延迟时间在10.9ms-170ms之间不等，这可能是由于网络拥塞或者其它网络干扰因素导致的。但是发送到<code>www.ouc.edu.cn</code>始终没有得到回复，可能是因为OUC的网络配置了防火墙或者其它网络安全策略，阻止了<code>ping</code>请求。<br><em>实验现象如图2所示</em></p></li><li><p><strong>通过查询资料，画出所使用ICMP数据包的结构</strong><br>其中相关部分说明如下<br>(1)Type，8bits，用于指定ICMP消息类型，例如0表示<code>Echo Reply</code>，8表示<code>Echo Requset</code><br>(2)Code，8bits，用于对消息类型进行更详细的说明，例如目的地不可达，网络不可达等等<br>(3)Checksum，16bits，用于错误检查<br>(4)Identifier，16bits，用来匹配请求和响应<br>(5)Data，可变长度，包含可选的附加数据。<br><em>ICMP数据包如图3所示</em></p></li></ol><h3 id="traceroute应用"><a href="#traceroute应用" class="headerlink" title="traceroute应用"></a>traceroute应用</h3><ol><li><p><strong>不超过200字简要概括traceroute命令</strong><br>traceroute可以用于追踪数据包从源主机到目标主机的网络路径中，它通过发送一个含有TTL字段的IP数据包进行工作，数据包每传递到一个路由器TTL就会减1，当TTL为0的时候路由器就会丢弃该数据包，并给源主机发送一个ICMP（超时响应），其中包含了当前路由器的地址。traceroute在整个工作流程中会从TTL为1开始发送数据包，每次收到ICMP响应后就增大TTL值（2、3、4…），直到收到目的主机的响应。于是根据每一次收到的ICMP响应，traceroute就可以知晓从源主机到目标主机经过的每个路由器，并且显示相应的IP地址和响应时间。<br><em><code>man traceroute</code>结果如图4所示</em></p></li><li><p><strong>确定并说明从源计算机到<code>www.baidu.com</code>的路径</strong><br>源计算机到<code>www.baidu.com</code>实现路径探测，结果如下图如下图，一共经过了30跳，其中第一跳<code>172.19.0.1</code>是源计算机ip，第三、四、五跳<code>10.149.32.1</code>和<code>10.70.7.2</code>以及<code>10.90.0.4</code>是内部网络路由器，之后经过了若干公网路由器，最终到达目标服务器。显示为<code>***</code>的，可能是由于网络设备被配置为了不响应ICMP请求，所以路径不能完全确定。<br><em><code>traceroute www.baidu.com</code>结果如图5所示</em></p></li><li><p><strong>说明输出结果每个字段的意义</strong><br>(1)<code>traceroute to www.baidu.com (182.61.200.108)</code>为traceroute命令输出说明，目标的IP地址为182.61.200.108<br>(2)<code>30 hops max</code>指最多经过30跳<br>(3)<code>60 byte packets</code>指每个数据包大小为60字节<br>往下是每一跳的详细信息，以第一跳为例<br>(4)<code>1 1(172.19.0.1) 0.647ms 1.041ms 1.285ms</code><br>第一个数字1代表第一跳，172.19.0.1代表第一跳的设备IP，后续三个时间是三个ICMP包的往返时间；后续存在<code>***</code>的输出对应没有收到该跳的ICMP回复（或者是网络拥塞导致的丢包）。</p></li></ol><h3 id="traceroute探索"><a href="#traceroute探索" class="headerlink" title="traceroute探索"></a>traceroute探索</h3><p><code>注：这部分实验，我先是在自己本地的电脑上进行的实验，所以后续的描述是根据本地的输出来的，实验截图也是使用的本地截图</code></p><ol><li><strong>解释traceroute 18.31.0.200的输出</strong><br>通过这条指令，我们使用traceroute追踪了一条从本地网络，通过ISP、NAT字段、跨越国际骨干网再进入教育和研究网络的传输路径，最终到达了目标IP（18.31.0.200）</li></ol><p>以下按照每一跳对路径进行分析<br>(1)（1-3跳）<br>hop1是本地网络，hop2、hop3是私有IP（10.x.x.x），可能对应内部网络路由器、防火墙等<br>(2)（4跳）<br>显示为<code>***</code>，路由器没有响应ICMP请求（或者是丢包）<br>(3)（5-12跳）<br>hop5-hop12对应的是公网地址，数据包是在ISP网络中传输的（211.64.x.x和101.4.x.x地址段对应ISP或骨干网提供商，100.64.x.x属于共享地址空间，通常用于ISP内部的网络地址转换）<br>(4)（13-30跳）<br>hop13对应<code>***</code>同样可能没有响应ICMP请求或丢包；hop14开始数据包进入国际网络，延迟有显著的增加（20ms左右，到后续数百毫秒）；hop19开始数据包进入了亚洲太平洋先进网络（APAN网络），之后进入了教育和研究网络（Internet2），可以看到最后已经显示出了较高的延迟（200~400ms左右）<br><em><code>traceroute 18.31.0.200的输出</code>结果如图6所示</em><br>2. <strong>说明从源地址到<code>www.baidu.com</code>和到<code>cn.bing.com</code>的网络路径差异</strong><br>两者的网络路径在初始几跳上有共同点（除去<code>***</code>，至少前10跳是相同的），在进入外部网络之后，路径显然会分道扬镳（除去<code>***</code>，从第14跳开始不相同）；到<code>cn.bing.com</code>后续经过了一些国际骨干网，（例如202.97.x.x的IP地址属于中国电信骨干网），而到<code>www.baidu.com</code>主要是在国内网络中传输的。<br><em><code>traceroute www.baidu.com</code>与<code>traceroute cn.bing.com</code>的结果如图7、8所示</em><br>3. <strong>如果IPv6上实现路径探测，应该使用包头的哪个字段</strong><br>在IPv6网络中进行路径探测，主要依赖IPv6包头中的Hop limit字段，这个字段是“跳限字段”，其作用和IPv4中的TTL（生存周期）字段相同，用来限制数据包在网络传输的跳数，每经过一个路由器，这个字段的值都会减1，当减为0后数据包就会被丢弃，并且通常会返回一个ICMPv6的超时消息给源地址。</p><h2 id="遇到的问题及解决方法"><a href="#遇到的问题及解决方法" class="headerlink" title="遇到的问题及解决方法"></a>遇到的问题及解决方法</h2><p>在实验过程中我主要遇到了问题是在<code>ping www.ouc.edu.cn</code>始终无法收到返回的结果，掉包率总是100%。经过查阅相关资料，我推测应该是我们学校的服务器配置了防火墙或者其它安全策略，拒绝向ping发送的数据包进行响应。并且我使用<code>traceroute www.ouc.edu.cn</code>尝试追踪，我发现结果从第7跳开始往后始终都只返回<code>***</code>，这间接作证了我的猜测。（因为它们都使用的ICMP数据包）<br><em>结果如图9所示</em></p><h2 id="课后实验与思考"><a href="#课后实验与思考" class="headerlink" title="课后实验与思考"></a>课后实验与思考</h2><h3 id="Traceroute在网络故障排查中有哪些应用场景"><a href="#Traceroute在网络故障排查中有哪些应用场景" class="headerlink" title="Traceroute在网络故障排查中有哪些应用场景"></a>Traceroute在网络故障排查中有哪些应用场景</h3><p>Traceroute的主要应用场景有路径发现（它可以用于追踪整个网络路径）、网络延迟分析（可以识别在哪一条引入了延迟，可以判断哪一条延迟较大）、故障点识别（确定数据包在哪一条丢失或无法到达，例如<code>***</code>的出现可能就是这个原因）、路由问题诊断（找到可能存在的路由环路）、网络性能评估（综合以上功能可以进行网络性能评估）等</p><h3 id="Traceroute中如何通过修改参数来优化网络诊断效果"><a href="#Traceroute中如何通过修改参数来优化网络诊断效果" class="headerlink" title="Traceroute中如何通过修改参数来优化网络诊断效果"></a>Traceroute中如何通过修改参数来优化网络诊断效果</h3><p>(1)修改初始TTL值<br><code>traceroute -f 5 example.com</code> 使用参数f可以完成这种操作，用来跳过已知的安全路径<br>(2)设置最大TTL值<br><code>traceorute -m 20 example.com</code> 使用参数m可以完成这种操作，用于避免弹错过长的路径<br>(3)修改探测包的数量<br><code>traceroute -q 5 example.com</code> 使用参数q可以完成这种操作，用来减少或增加探测粒度</p><p>其它的还有使用不同的协议、修改探测包的端口号等等</p><h3 id="Traceroute交换源节点和目标结点，在同一时刻探测到两条路径是相同的吗"><a href="#Traceroute交换源节点和目标结点，在同一时刻探测到两条路径是相同的吗" class="headerlink" title="Traceroute交换源节点和目标结点，在同一时刻探测到两条路径是相同的吗"></a>Traceroute交换源节点和目标结点，在同一时刻探测到两条路径是相同的吗</h3><p>由于网络路由的动态性、负载均衡、多路径路由等因素，网络路径一般是非堆成的，即A到B的路径和B返回A的路径可能会经过不同的路由器以及有不同的跳数。所以一般情况下上述两条路径不会相同</p><h2 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h2><p>通过本次实验我掌握了<code>ping</code>和<code>traceroute</code>命令的基础使用方法，例如<code>traceroute</code>的一些常见参数的使用（f、m、q、l等）。并且能够分析两条命令的输出信息，例如ping命令输出的掉包率、时延等等，通过这个过程，我更深刻地体会了网络的结构，以及数据包在网络上传递的整个过程。此外我还了解了两条命令的基本实现原理，例如traceroute就是不断通过增大ICMP数据包的TTL，使其能够传播得更远，并每一次都记录返回的响应，最终形成完整的路径，作为信息进行输出。最后，我掌握了ICMP数据包的结构，对数据包有了更加清晰的认识。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法——树</title>
      <link href="/2025/02/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%A0%91/"/>
      <url>/2025/02/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="如何输入一棵树"><a href="#如何输入一棵树" class="headerlink" title="如何输入一棵树"></a>如何输入一棵树</h2><p>在这里记录一些算法题中常见的树的输入方法</p><p>*输入格式一<br>第一行输入一个正整数n，代表树中结点的数量。<br>第二行输入n个正整数w1…wn，代表i点的权重<br>接下来n行，每行输入两个整数，其中第i行的li、ri表示i点的左儿子与右儿子，若为-1则表示不存在。</p><h2 id="如何存储一颗树"><a href="#如何存储一颗树" class="headerlink" title="如何存储一颗树"></a>如何存储一颗树</h2><p>在这里记录常见的树的存储方法</p><p>*存储方式一<br>我们可以使用一个树结点的结构体，通过将这些结构体使用指针连接起来，从而构建一棵完整的树。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">tree_node</span>&#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    tree_node * ls;</span><br><span class="line">    tree_node * rs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>unity锚点</title>
      <link href="/2025/02/03/unity%E9%94%9A%E7%82%B9/"/>
      <url>/2025/02/03/unity%E9%94%9A%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="如下"><a href="#如下" class="headerlink" title="如下"></a>如下</h2><p>参考文章<a href="https://blog.csdn.net/Terie/article/details/111433486">https://blog.csdn.net/Terie/article/details/111433486</a></p><p>透过这篇博客，我大概了解到了两个点：<br>pviot：轴心，采用相对坐标系，(0,0)-&gt;(1,1)，位于某ui的方框内，其表征着在ui被自适应缩放的时候，以哪个位置为标准缩放</p><p>锚点：unity提供了三种模式<br>1、四个锚点合在一起的模式<br>该模式下，在屏幕分辨率改变的过程当中，ui相对于锚点的位置不改变，ui的宽、高也不变</p><p>2、四个锚点两两在一起的模式<br>该模式下，ui的对应对于锚点连成的线的距离不改变，宽高比不改变，随之缩放</p><p>3、四个锚点分开的模式<br>该模式下，ui的四个边对应锚点连线矩形的四边距离不改变，宽高随着四向距离的改变，自适应。</p><p>一般情况下，设置Canvas的UI为随屏幕缩放的模式，理解pivot，记住不同位置的ui常用的锚点模式和放置位置就好。</p><p>一下是gpt的建议：<br>a. 确定元素的锚点<br>对于屏幕边缘的UI元素（如按钮、面板），将其Anchors设置在父容器的相应边缘。例如：<br>左上角的按钮：Anchors设为（0，1）到（0，1）<br>右上角的按钮：Anchors设为（1，1）到（1，1）<br>底部中央的按钮：Anchors设为（0.5，0）到（0.5，0）<br>b. 中央对齐的元素<br>对于中心对齐的UI元素（如中心的面板），将其Anchors设置在父容器的中心。例如：<br>中央面板：Anchors设为（0.5，0.5）到（0.5，0.5）<br>c. 保持宽高比例<br>在Inspector中勾选Canvas Scaler组件的“UI Scale Mode”选项，设置为“Scale With Screen Size”，并设置参考分辨率为你设计时的分辨率（如1920x1080）。这样Unity会根据屏幕分辨率自动缩放UI元素。</p>]]></content>
      
      
      
        <tags>
            
            <tag> unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文阅读：基于复杂港口环境下的无人船自主靠泊最优控制方案研究</title>
      <link href="/2024/10/27/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%EF%BC%9A%E5%9F%BA%E4%BA%8E%E5%A4%8D%E6%9D%82%E6%B8%AF%E5%8F%A3%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E6%97%A0%E4%BA%BA%E8%88%B9%E8%87%AA%E4%B8%BB%E9%9D%A0%E6%B3%8A%E6%9C%80%E4%BC%98%E6%8E%A7%E5%88%B6%E6%96%B9%E6%A1%88%E7%A0%94%E7%A9%B6/"/>
      <url>/2024/10/27/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%EF%BC%9A%E5%9F%BA%E4%BA%8E%E5%A4%8D%E6%9D%82%E6%B8%AF%E5%8F%A3%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E6%97%A0%E4%BA%BA%E8%88%B9%E8%87%AA%E4%B8%BB%E9%9D%A0%E6%B3%8A%E6%9C%80%E4%BC%98%E6%8E%A7%E5%88%B6%E6%96%B9%E6%A1%88%E7%A0%94%E7%A9%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="论文阅读过程当中新了解的知识"><a href="#论文阅读过程当中新了解的知识" class="headerlink" title="论文阅读过程当中新了解的知识"></a>论文阅读过程当中新了解的知识</h2><p>1、无人船MMG模型：<br>一种用于模拟和分析船舶在水中运动行为的数学模型。</p><p>MMG模型的基本思想是将船舶的运动分解为船体本身、推进系统（如螺旋桨）和舵等操纵装置的独立贡献，然后将这些贡献综合起来，以描述船舶的整体运动。</p><p>主要包括四个部分：<br>船体动力学模型：描述船体在水中的基本运动特性，包括水动力、惯性力和阻力等。<br>螺旋桨模型：描述推进装置（如螺旋桨）对船舶的推力和转矩输出，这些输出通常与螺旋桨的转速和船速等参数相关。<br>舵模型：描述舵对船舶的横向力和转矩输出，这些输出通常与舵角和水流速度等参数有关。<br>干扰力模型：包括环境中的风、浪、流等对船舶运动的影响。</p><p>2、横荡、纵荡和艏摇：<br>横荡（Sway）：<br>横荡指船舶沿着横向（即垂直于船体中心线）的运动。对于一艘在水中的船舶来说，横荡运动通常是侧向的滑动，可能由于外部作用力（如侧风、侧流或舵面调整）而发生。横荡是三自由度（3-DOF）船舶动力学模型中的一个重要运动分量。<br>纵荡是指船舶沿着船体中心线方向的运动，即船舶的前进或后退运动。纵荡通常由船舶的推进装置（如螺旋桨）提供的推力驱动。纵荡运动决定了船舶的航速变化，在无人船中，通过调整纵荡速度可以实现对速度的控制和调整。<br>艏摇是指船舶围绕垂直轴的旋转运动，即船首（艏）左右摇摆的运动。艏摇角度的变化决定了船舶的航向。艏摇运动通常是由舵角调整或推进系统产生的转矩导致的，它是船舶操纵中控制航向的重要参数。无人船的自动导航系统会通过控制艏摇运动来实现精确的航向调整和路径跟踪。<br>3、航向角 艏摇角 舵角 漂流角 绝对风舷角和相对风舷角</p><p>4、无量纲化处理 运动参数和无量纲参数的对应关系<br>无量纲化处理的核心思想是通过适当选择基准量（如长度、时间、质量等），将物理量转换为无量纲量。这样做的目的是减少方程中的变量数量，揭示系统的内在规律，并使得不同尺度的系统可以进行比较和分析。</p><p>选择一组基准量，例如特征长度。无量纲变量的定义：将原始变量除以相应的基准量。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 大学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>srdp</title>
      <link href="/2024/10/17/srdp/"/>
      <url>/2024/10/17/srdp/</url>
      
        <content type="html"><![CDATA[<h2 id="关于srdp"><a href="#关于srdp" class="headerlink" title="关于srdp"></a>关于srdp</h2><ol><li>srpd在别校算是校级大创，国级与省级大创会在推免阶段很有优势</li><li>文章只有认可度较高的才会有影响因子，EI和会议期刊这些认可度不高，不过这些对本科生而言还是比较有难度，SCI中有影响因子</li><li>出国、企业就业一般看JCR</li></ol><h2 id="相关方向"><a href="#相关方向" class="headerlink" title="相关方向"></a>相关方向</h2><p>海洋技术；<br>声学：声信号数据处理、算法<br>光学：仿真、数据处理、算法<br>遥感：遥感信息数据处理、算法</p><p>光科：<br>光谱、光电结合（单片机）、光学设计等</p><p>电子信息：<br>单片机、算法等</p><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><p>Web of Science、中国知网、ScienceDirect、小绿鲸、截屏翻译APP</p><p>刚入门的直接看SCI会比较困难，最好从硕博文章开始看，在看SCI之前最好先看三篇博士文章（600多页）</p><p>看英文文章可以用小绿鲸，不用应用软件，用官网主页。截屏翻译、小绿鲸是看SCI时用到的，前期看博士文章最好。</p><p>GPT可以用，但是写出来的东西一定要自己看得懂。</p><p>zlibrary中有很多参考书，很好用。多运用CSDN、GitHub</p><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><p>国创、省创注意截至日期，中期的时候会有一个机会用来申请国创、省创，最好要把srdp升一个台阶，不要原原本本地交srdp。</p><p>理工科相关的公式要熟悉（明白如何推导的，或者说如何产生的）</p><p>流程：<br>10、11月立项（撰写立项书、制作ppt、填写系统、准备立项答辩）-&gt;4、5月中期检查（省创国创立项）-&gt;10、11月结项（省创国创中期检查）-&gt;4、5月省创国创结项</p><p>如果目标国创、省创的话最好前期干完百分之60到百分之80，除此之外一定要干满工作量，否则会延期，得不偿失。</p><p>选题的话主要看指导老师。</p><p>制定开发计划（敏捷开发计划）、迭代开发（要先有一个成果，逐步迭代，迎接变化）、定期开会（要和老师同步）、共同开发</p><h2 id="相关语言"><a href="#相关语言" class="headerlink" title="相关语言"></a>相关语言</h2><p>Origin（画图好用）、Latex、MathType（打字母公式）、Office…</p><h2 id="选题"><a href="#选题" class="headerlink" title="选题"></a>选题</h2><p>小发明、小制作、小设计；实际教学中的综合性、设计性、创新性、应用性课题</p>]]></content>
      
      
      
        <tags>
            
            <tag> 大学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>按位运算相关内容</title>
      <link href="/2024/10/16/%E6%8C%89%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9/"/>
      <url>/2024/10/16/%E6%8C%89%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="logs"><a href="#logs" class="headerlink" title="logs"></a>logs</h2><p>目前的打算是先更新思路，然后在有图片处空出，后续补充图片。</p><h2 id="使用算数右移实现逻辑右移"><a href="#使用算数右移实现逻辑右移" class="headerlink" title="使用算数右移实现逻辑右移"></a>使用算数右移实现逻辑右移</h2><p>以int 32位为例</p><p>我们清楚，当进行算数右移的时候，对于符号位为1的情况下，右移之后符号位、第32位的1，被移动到31位后，32位右被补上了1</p><p>而逻辑右移与之不同的是，逻辑右移后，最高位、32位会被补0</p><p>现在要用算数右移实现逻辑右移，看代码：</p><pre><code>x = x &gt;&gt; n;y = ~((1 &lt;&lt; 31) &gt;&gt; n &lt;&lt; 1);  x = x&amp;y;</code></pre><p>1、x符号位为0，算数右移动n位后，x为 0..（n+1个0）XXXXXXX…<br>2、x符号位为1，算数右移动n位后，x为 1..（n+1个1）XXXXXXX…<br>而对于逻辑右移n位后，无论x符号位是0还是1，都是算数右移中1、的情况</p><blockquote><p>所以我们只需要：x &#x3D; x&amp;0..（n+1个0）1111..1就可以将算数右移的结果转换为逻辑右移的结果。<br>关键在于凑出掩码0..（n+1个0）1111..1，即y处的操作。</p></blockquote><h2 id="分治法求二进制数中1的个数"><a href="#分治法求二进制数中1的个数" class="headerlink" title="分治法求二进制数中1的个数"></a>分治法求二进制数中1的个数</h2><p>分治法的思想：一个复杂的问题分解成若干个规模较小但相似的子问题，“递归”地解决这些子问题，然后将这些子问题的解组合起来，得到原问题的解。</p><p>让我们先以8位二进制数为例子：</p><blockquote><p>原问题：11011110 整体这个数（或者说“一”部分）有几个1<br>分解：求 1101 1110 两部分，分别有几个1<br>分解：求 11 01 11 10 四部分，分别有几个1<br>分解：求 1 1 0 1 1 1 1 0 八部分，分别有几个1</p></blockquote><p>显然，对于上一个问题，各个部分的数字0 or 1就代表了这个部分有几个1，即八个部分时各个部分有几个1已经清楚。最小问题的答案已知，考虑如何利用将最小问题的答案合并，求解上层的问题。</p><p>注意：“各个部分的数字0 or 1就代表了这个部分有几个1”正是八部分时最大的特点，记住这个特点，因为我们的目标是“让‘一’部分时，该部分的数字就代表该部分有几个1。”</p><p>下面开始合并，使用到的关系是：上一个问题中各个部分有几个1 &#x3D; 当前问题中相邻两个部分1的个数相加</p><p>采用上面的关系对问题合并，我们会发现每解决一个问题后，问题中各个部分的数字，就代表原来该部分有几个1。</p><blockquote><p>合并： 四部分状况的问题的答案：10 01 10 01<br>合并： 二部分状况的问题的答案：0011 0011<br>合并： “一”部分（原问题）的答案：00000110</p></blockquote><p>根据前面的描述，00000110即原本1的个数。</p><p>下面是具体的实现代码</p><pre><code>cin&gt;&gt;xint x1,x2,x3,x4,x5,s,m;s = x &gt;&gt; 1;m = ~((1 &lt;&lt; 31));x1 = s&amp;m;x = (x &amp; 0x55555555) + (x1 &amp; 0x55555555);s = x &gt;&gt; 2;m = ~((1 &lt;&lt; 31) &gt;&gt; 1);x2 = s&amp;m;x = (x &amp; 0x33333333) + (x2 &amp; 0x33333333);s = x &gt;&gt; 4;m = ~((1 &lt;&lt; 31) &gt;&gt; 3);x3 = s&amp;m;x = (x &amp; 0x0F0F0F0F) + (x3 &amp; 0x0F0F0F0F);s = x &gt;&gt; 8;m = ~((1 &lt;&lt; 31) &gt;&gt; 7);x4 = s&amp;m;x = (x &amp; 0x00FF00FF) + (x4 &amp; 0x00FF00FF);s = x &gt;&gt; 16;m = ~((1 &lt;&lt; 31) &gt;&gt; 15);x5 = s&amp;m;x = (x &amp; 0x0000FFFF) + (x5 &amp; 0x0000FFFF);return x;</code></pre><p>关键在于理解如何实现“上一个问题中各个部分有几个1 &#x3D; 当前问题中相邻两个部分1的个数相加”之中，相邻两部分相加。<br>不难想到，我们可以使用掩码。<br>例如：</p><blockquote><p>01010101和10101010（相邻的两位相加，结果为四部分状况答案）<br>x &#x3D; x&amp;0b01010101 + x&amp;0b10101010<br>00110011和11001100（相邻的四位相加，结果为两部分状况答案）<br>x &#x3D; x&amp;0b00110011 + x&amp;0b11001100<br>00001111和11110000（相邻的四位相加，结果为“一”部分状况、最终答案）<br>x &#x3D; x&amp;0b00001111 + x&amp;0b11110000</p></blockquote><p>当然这只是对最开始用例的解释，对于具体的计算机当中的int类型，32位可以如此类比。<br>最终我们需要合并使用当前问题的答案求解上一个问题5次（32 &#x3D; 2^5），对应代码中5处使用了掩码的位置。<br>值得一提的是，也可以在一次计算当中不更换掩码，但是要将x左或右移（逻辑右移！）对应的位数，就像我在代码中的那样。</p><h2 id="按位运算实现对数值变量实现逻辑Not"><a href="#按位运算实现对数值变量实现逻辑Not" class="headerlink" title="按位运算实现对数值变量实现逻辑Not"></a>按位运算实现对数值变量实现逻辑Not</h2><p>具体要求：对于数值型数据x，若x &#x3D;&#x3D; 0x00000000，则输出 0b00000000000000000000000000000001，否则输出0b00000000000000000000000000000000<br>注：上面的常数均为补码值，用于做相等的比较的时候也是用的x的补码值，而非真值。</p><p>思路：对于非0数，其相反数的符号位一定与原数的符号位不同。考虑原数与相反数相或后考虑符号位的情况，来判断x本身是否为0。</p><h2 id="7-fitsBits-判断x可否使用n位补码表示"><a href="#7-fitsBits-判断x可否使用n位补码表示" class="headerlink" title="7 fitsBits 判断x可否使用n位补码表示"></a>7 fitsBits 判断x可否使用n位补码表示</h2><p>思路：<br>1、我们知道n位补码的表示范围是-2^n~2^n-1，因此我们需要判断x是否在这个范围之内。<br>2、在当前环境下，x是由32位二进制补码储存在计算机当中的，我们不难发现：如果x只需要n位补码，那么在计算机当中前面的32-n位补码是空闲的，所以我们可以将x在计算机当中的补码，先左移32-n位，再右移动还原，通过判断这样操作之后得到的补码与x的补码是否仍然相同，来判断x是否只需要n位补码<br>3、最后加上一点补充，来更好地这个问题：<br>上面的思路对于正数来说是可以直接使用的，并且也是好理解的（因为闲置位置上的补码都是0，包括符号位也是0）</p><p>但是对于负数而言，最高位是1（符号位），我们或许会下意识认为，对于实际上的计算机而言，（从右往左，以下都是）第32位是没有闲置的，对于只需要n位补码的负数x，在32位的环境下，实际上被闲置的是第31位到第n位，而非和正数一样的第32位到第n+1位。进一步，我们会下意识认为，闲置的位置都是0，那么第31位是0，一旦左移符号位1就会被弃置，而再左移回来时在大多数情况下，符号位都只会是1，而认为由于32位环境最高位表示负数符号位的特殊性，导致了对于负数这样的“左移右移”无法解决问题。</p><p>显然，这样的理解是错误的，举个简单的反例，-1在32位中的补码是111…11（32个1），并非我们理解的闲置位置是0，所以其实对于一般的负数，我们会发现当它只需要n位补码表示的时候，在32位的环境下，其闲置的位置都是1，这样就不会出现我们认为的错误的情况，所以这个方法对于负数也是适用的。</p><pre><code>int l = 32 + ~n + 1; return !(x ^ (x &lt;&lt; l &gt;&gt; l));</code></pre><h2 id="按位运算计算-x-2-n-，向0取整"><a href="#按位运算计算-x-2-n-，向0取整" class="headerlink" title="按位运算计算 x&#x2F;2^n ，向0取整"></a>按位运算计算 x&#x2F;2^n ，向0取整</h2><p>思路：<br>1、首先我们要思考为什么有取整的问题，答案很简单，从一种简化的形式来说，答案可以用“1除以2除不尽（整数范围）”来概括，于是我们要考虑，该如何处理一下，让这个算式有一个结果。处理的方法就是向下取整（1&#x2F;2 &#x3D; 0）或者向上取整(1&#x2F;2 &#x3D; 1)<br>2、为了后面描述方便，我们在此前先看看向上、下取整，在1、在二进制下的形式。<br>不妨考虑（默认二进制，十进制末尾用D表示）奇数：XXXXX11（末位为1），除以2D，即右移1。XXXXX011&#x2F;2D &#x3D; (XXXXX010&#x2F;2D)+1&#x2F;2D，这就回到了1、，且更具有一般性。<br>如果要向下取整即1&#x2F;2D &#x3D; 1，在这个过程当中实际上等效于将1，当作10使用，即对XXXXX011进行了加1操作后进行XXXXX110&gt;&gt;1 &#x3D; XXXXXX11，而不同于原来的XXXXX011&gt;&gt;1 &#x3D; XXXXXX01<br>如果要向上取整，也就是直接抛弃最低位1，仍由右移时将它弃置。<br>3、所以1、中的情况在二进制下实际上就是考虑，要不要让末尾的1在一次右移当中被抛弃，如果是的话则对应向下取整，直接右移即可，如果不是的话则应该加1，让1-&gt;10，从而在除以2D时达到1D当作2D用的效果<br>4、所以一般地，对于除以2^n，即要右移动n次，是否要将前n位可能的1直接抛弃，就对应了是否要向下取整，所以我们直接对原数在前n位分别加上1，确保它们都有“1D当2D用的效果”即可达到向上取整的目的。<br>5、题目要求向0取整，对于正数而言向0取整就是向下取整，对于负数而言是向上取整。所以对正数直接右移n位，对负数在第n位后加1，再右移动n位。</p><h2 id="按位操作求-x"><a href="#按位操作求-x" class="headerlink" title="按位操作求-x"></a>按位操作求-x</h2><p>思路：原数的负数对应的补码，等于原数的补码取反再加1。</p><h2 id="按位运算判断x是否是正数"><a href="#按位运算判断x是否是正数" class="headerlink" title="按位运算判断x是否是正数"></a>按位运算判断x是否是正数</h2><p>思路：<br>1、考虑x的相反数，正数的相反数的补码符号位一定是1，负数及0的相反数的补码一定是0。<br>2、但是注意有一个特殊的负数存在，及-2^(n-1) - 1 &#x3D; -2147483648(32位)，这个负数是在32位补码对应的表示范围之内没有对应的相反数，按照常规的求相反数的补码（按位取反再加1）之后，得到的仍然是它本身，符号位不会改变。<br>3、所以在我们求完x的相反数y之后，只需要在最后查看y的符号（1则x为正，0则x为负或0）时：(y&gt;&gt;31)&amp;1（用于查看符号），加上(y&amp;(y^x)&gt;&gt;31)&amp;1（似乎还有一点问题）即可。因为y^x，的相当于查看x与其相反数的符号位是否相同，如果相同y^x的符号位是0，否则是1，即对-2147483648进行了特判。</p><h2 id="按位运算判断x是否小于等于y"><a href="#按位运算判断x是否小于等于y" class="headerlink" title="按位运算判断x是否小于等于y"></a>按位运算判断x是否小于等于y</h2><p>思路：<br>1、这道题要分三种情况考虑，我最开始想到的是情况1，直接判断x-y（即x + ~y + 1）的符号位是什么，如果是0，则x &gt; y，如果是1，则x &lt; y。<br>2、显然，上面的做法存在问题，很容易发现，无法处理x &#x3D;&#x3D; y的情况，这种情况下，对应x-y的符号位是0，而不同于x &lt; y时题目种要求的1。<br>所以我考虑了第二种情况，x &#x3D;&#x3D; y时，只需要判断!(x^y)的状态，如果是0则，x、y不等，这时交给1、判断，如果是1则x、y相等，只需要将1、2、中两个式子用|连接，如果2、中得到1则会直接得出答案，如果2、中得出0，也不会影响1、中的判断结果（零一律）。<br>3、然而还有一种情况是我们没有考虑到的，那就是在x、y异号的时候，可能出现的overflow，比如-2147483648，让其减去任意的负数，在32位补码的情况下，它都会变成一个正数（符号位为0），而这种情况是只会在x、y异号的时候出现的（同号时，只要是减法，都只会向0靠近，而不会向边界靠近，出现overflow），所以我们只需要和2、中一样，在加上一种情况的式子，并用|与前两个式子连接即可。所加的式子，首先判断x、y是否异号，如果是的话，我们可以直接通过x的符号给出答案，因为负数一定小于正数，所以第三种情况对应的式子是：((x^y)&gt;&gt;31&amp;1&amp;(x&gt;&gt;31&amp;1))，其中(x^y)&gt;&gt;31&amp;1在第一位给出了x、y符号是否相异，如果是的话，为1，后者(x&gt;&gt;31&amp;1)会在第一位给出x的符号；否则为0，整个式子为0，当前的大小情况交给1、2、来判断。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编语言学习日志</title>
      <link href="/2024/10/15/my-first-post/"/>
      <url>/2024/10/15/my-first-post/</url>
      
        <content type="html"><![CDATA[<h2 id="DEBUG模式下几种基本命令"><a href="#DEBUG模式下几种基本命令" class="headerlink" title="DEBUG模式下几种基本命令"></a>DEBUG模式下几种基本命令</h2><p>t 追踪执行命令<br>a 指定内存后（回车）写入指令<br>d 从哪段内存开始 显示多长的内存&#x2F;&#x2F;显示内存中内容<br>e 从哪段内存开始（回车）修改内存<br>u 从哪段内存开始&#x2F;&#x2F;显示翻译后内存中内容</p><pre><code>mov ax,bxadd ax,bxsub ax,bx</code></pre><blockquote><p>注意高八位、低八位，h、l<br>注意数据溢出，加法溢出则舍去，减法不足则借位，指定了高八位、低八位就以对应的两个数字为参考标准确定是否要舍去与借位，不能修改其它数字。</p></blockquote><h2 id="常见的运算符"><a href="#常见的运算符" class="headerlink" title="常见的运算符"></a>常见的运算符</h2><h3 id="mul"><a href="#mul" class="headerlink" title="mul"></a>mul</h3><pre><code>mul bx</code></pre><p>相乘的数都是八位或者都是十六位<br>八位：一个默认放在AL中，另一个放在8位reg或内存中；结果默认放在AX中<br>十六位：一个默认放在AX中，另一个放在16位reg或内存中；结果默认低16位放在AX中，高16位放在DX中。</p><blockquote><p>8位：AL<em>BL &#x3D; AX<br>16位：AX</em>BX &#x3D; DXAX</p></blockquote><h3 id="div"><a href="#div" class="headerlink" title="div"></a>div</h3><pre><code>div bx</code></pre><p>除数：8位、16位（2个数字、4个数字）两种<br>被除数：默认放在AX或DX和AX中，除数为8位则被除数为16位默认放在AX中；如果除数为16位，则被除数为32位，默认放在DX和AX中，DX存放高16位，AX存放低16位。<br>结果：如果除数为8位，则AL中存放结果，AH储存余数；如果除数为16位，则AX存储商，DX存储余数。</p><blockquote><p>除数8位:AX&#x2F;BL &#x3D; AL … AH<br>除数16位：DXAX&#x2F;BX &#x3D; AX … DX</p></blockquote><h3 id="and、or"><a href="#and、or" class="headerlink" title="and、or"></a>and、or</h3><p>以二进制为标准<br>指定8位还是16位进行运算</p><h3 id="shl"><a href="#shl" class="headerlink" title="shl"></a>shl</h3><pre><code>shl ax,1</code></pre><p>shl、shr 左移、右移，超出的舍去，缺少的0补<br>rol、ror 循环左移、右移，超出的补到后面缺少的<br>带进位的循环左移、右移 rcl rcr（了解）<br>以二进制为标准</p><h3 id="inc、dec"><a href="#inc、dec" class="headerlink" title="inc、dec"></a>inc、dec</h3><pre><code>inc axdec ax</code></pre><p>相当于ax++、ax–<br>（进位、借位与普通加减法相同）</p><h3 id="其它杂项"><a href="#其它杂项" class="headerlink" title="其它杂项"></a>其它杂项</h3><p>如果除法除以0会进入一个中断<br>使用int 0也可以进入这个中断<br>如果除以0是一个错误，会触发int 0的中断，会找到一个地址，代码运行的指针会指向这个地址，接下来或许可以通过在这个地址准备相应的处理方法来解决异常（了解）</p><p>我们需要知道的就是当代码发生错误，代码运行的指针会跳转到其它地址。</p><p>常见的中断编号int 0、int 9</p><h2 id="ds寄存器与地址"><a href="#ds寄存器与地址" class="headerlink" title="ds寄存器与地址"></a>ds寄存器与地址</h2><blockquote><p>物理地址 &#x3D; 段地址*16+偏移地址</p></blockquote><p>DS寄存器，数据段地址寄存器<br>    r ds<br>可编辑DS当中的内容</p><p>配合mov指令使用，如</p><pre><code>mov ax,[60]</code></pre><p>效果会是将DS中的段地址结合[60]偏移地址指向的内容复制给ax<br>[]中对应的都是低位</p><blockquote><p>但是注意：在内存当中字单元的概念，即将一个字型数据（16位）的内存单元，由两个地址连续的内存单元，高地址内存单元（非起始）存放字符型高位字节，低地址内存单元（起始）存放字符型低位字节。<br>如我们将DS设置为21F0后，使用mov指令会将21F0:0060中的内容复制给ax<br>而d 21F0:0060这样显示：<br>12 34<br>则0060为低位，0061为高位<br>所以对应AXL 和 AXH，由此得到ax为3412<br>但是以上内容在使用al、ah等直接对八位操作的时候，对应的物理地址上的八位数会直接被移动到对应位置，而不需要考虑是高地址还是低地址内存</p></blockquote><p>另外</p><blockquote><p>注意：不能使用mov ds，10 00<br>但是可以<br>mov 1000，ax<br>mov ds，ax</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>诗</title>
      <link href="/2020/01/01/%E8%AF%97/"/>
      <url>/2020/01/01/%E8%AF%97/</url>
      
        <content type="html"><![CDATA[<h2 id="壹"><a href="#壹" class="headerlink" title="壹"></a>壹</h2><blockquote><p>《甲辰正月初一为灵泉诸香客赋》<br>水澹金粼雾舞空，烟锁灵山山囚龙。<br>霰尽芳菲行者至，露上凝珠紫气东。<br>父老提携童子笑，诸君揖互彩云从。<br>香火连天今日有，爆竹声毕夕已终。</p></blockquote><p>~</p><blockquote><p>《危勉》<br>黄烛灯火暗凝香，红袖酥肩幻梦长。<br>醉酒吟誐任疏狂，百落临渊战心惶。<br>前路无光路满霜，苦难同尘藏四方。<br>来年不求万事祥，我愿与之较锋芒。</p></blockquote><p>~</p><blockquote><p>《贻君》<br>春秋五载与君识，几经离别未有知。<br>可怜怎奈书生骨，举杯邀酒话无时。<br>今昔难见来日昶，参商共映明月光。<br>高山流水何其多，相见不言别离长。</p></blockquote><h2 id="贰"><a href="#贰" class="headerlink" title="贰"></a>贰</h2><blockquote><p>《秋意尽》<br>秋霜一点红，寒露语松榕。<br>越鸟惊乡客，南巢临北冬。<br>遍揲晓风月，满羽繁星空。<br>择地息未有，淡裁碌日中。<br>何日花前酒，携诗青崖诵。</p></blockquote><p>~</p><blockquote><p>《不意雨》<br>云野伴骄阳，仲夏风曦长。<br>身待雨缦缦，旱久难滂滂。<br>卧阴苇下驻，遮乌泮水旁。<br>念死闲行日，不意甘霖降。</p></blockquote><h2 id="叁"><a href="#叁" class="headerlink" title="叁"></a>叁</h2><blockquote><p>《月夜寄故人》<br>细柳抚荫晓云畔，青山带水过君岸。<br>虽守陌路长相隔，念此故人月上看。</p></blockquote><p>~</p><blockquote><p>《碧波行》<br>见海连天月下开，踏彩逐浪思楼台。<br>台下霓潮绕浪舞，台上金麟为我来。</p></blockquote><p>~</p><blockquote><p>《临钟书阁》<br>长天碧色里，高阁一湖中。<br>传即千古士，行则知无穷。</p></blockquote><p>~</p><blockquote><p>《嘲》<br>携卷履地因风进，卧看长空皓月行。<br>明眸晶莹玉齿杯，蓬头恹面笑长情。</p></blockquote><h2 id="肆"><a href="#肆" class="headerlink" title="肆"></a>肆</h2><blockquote><p>《夏日乱笔》<br>墨上还新山水通，此间独骑临霜松。<br>昨年闻香落笔柔，意与锋芒寄青空。<br>海破日出乾坤动，河汉月邀金乌重。<br>沧浪折煞浮萍起，百波沉浮犬马恸。<br>他日锥断窠臼风，白鹤冲天烟柳中。<br>任子何笑鱼龙游，东风吹我麟阁梦。</p></blockquote><p>~</p><blockquote><p>《闻雨祭剑》<br>鸣剑八尺，柄灼伤伤。<br>血蚀锈迹，斑斑其煌。<br>剑折剑伤，不改剑刚。<br>素钢以铸，可刻金光。<br>百剑之中，其伤为扬。<br>剑鸣剑光，旦列剑榜。</p></blockquote><p>~</p><blockquote><p>《田间乱笔》<br>百日随春尽，新曦按夜来。<br>碧草凝寒露，陌上芳菲开。<br>折枝近门扉，黄䤋扶老待。<br>相论无功名，赤子初心在。</p></blockquote><p>~</p><blockquote><p>《告己书》<br>自负有翅，既委金笼。<br>不绝长空，何异斑鸠！<br>虽离群所，日起当思。<br>衣冠正否，行止绳否。<br>若背师恩，女颜不存。<br>若耽暖衾，女辞为空。<br>而至今日，才非盖世。<br>略有所长，只在微志。<br>今志但弃，形飞神灭。<br>渺渺于世，不知为人。<br>幸生父母，又遇恩师。<br>教吾配兰，视吾圣贤。<br>前见子丘，后瞻东坡。<br>周环吾身，竖子小儿。<br>其钻弥坚？其爱一欢？<br>若以为前，即当顺羽。<br>若就后居，不如便埋！</p></blockquote><p>~</p><blockquote><p>百年征程易难兴，只言片语寥可尽？<br>听罢放翁示儿语，途闻鹏举复国心。<br>鱼耽海者树鸟亲，风化雨兮草木喑。<br>今时往已难可忆，唯叹受多报无冯！</p></blockquote><p>~</p><blockquote><p>《白天野》<br>蹇驴踏寒山，欲寻春可安。<br>此去十二载，未觉铁岭难。<br>路别桃花庵，又至神女山。<br>朱唇抿贝齿，纵邀即日欢。<br>眄谢蛾眉观，仰首望河汉。<br>心驶沧浪处，欲起罢钓竿！</p></blockquote><h2 id="伍"><a href="#伍" class="headerlink" title="伍"></a>伍</h2><blockquote><p>《夏》<br>微月照鬓角，夏风拂过柳眉梢。<br>微踮首，咧嘴笑，花色泛上白裙脚。<br>又是一年蝉鸣时，荏苒莺飞鸟。<br>犹觉夏日胜好。</p></blockquote><p>~</p><blockquote><p>《览逍遥游有感》<br>余见千里之修厚鲲鹏者，以六月之息，适于南冥，一跃而上九万里，水击三千里。<br>余览其逍遥也，见其适者，天时也，非无所依也。然余谓之，己之限及身之短者，了然于胸，明所适者而享逍遥之微寥，不亦 逍遥也？<br>余见蜩与学鸠，以决起而飞，抢树而至，下鲲鹏之所适者，成其逍遥之逍遥也，特不解鲲鹏之所适者也。<br>余谓之，虽是井底之蛙，然于其身者，乐也，见世间万般皆下品，为己独高。于己之界，所达皆可有，所求皆以应，不亦逍遥 也？<br>且夫不死之椿，长生之冥灵，而宋荣子之辈不亦似鲲鹏哉，或有上中下之境焉也。<br>至于至人，神人，圣人，于天地之间无所适，乘万物之正，驾六气之辩者，余谓之人力所莫能及。然拊度其中，乘万物之正者 ，即庄周所言，物我为一，以天地万物之百变为己之息，如己心之动，血之流者。所适者皆如己出，故无所适也，通透哉！而 御六气之变，且夫游于无穷之中，仙人之谓也，非物力所能及。<br>故吾小儿，斗胆列逍遥之次，小，中，大者也。<br>小之逍遥，所限莫所大焉，然其不见，独达于己，鄙薄万物而如稚童，亦有乐者也。<br>中之逍遥，所限或有见微，然其了然，善适万物，夷其所长善之所短，诚然逍遥也。<br>大之逍遥，所限者于己身，通透明达，处之世间，无所不乐无所不适，此真逍遥也。<br>然三者之上，所能有游于无穷者，特为仙人之所处耳，言之何用？<br>小之逍遥，行年必出，中之逍遥，或死无穷。<br>故吾见中之逍遥亦有三般。<br>一曰，蟪蛄已死，化茧成蝶，初出井底，蓦然之余，惶惶之间，不知所为，旦怀为先，嘲之小儿以自饰，宋荣子之辈也。<br>二曰，明于世间，知所何为，明所不为，朝朝暮暮，施力其中，然有所乐，亦有所乏，或感万物之何为，或冥灵大椿也。<br>三曰，旷达自若，气定神闲，可借薄力，而撼世间，明哲处事，善以待人，乐而长命，无所喟叹无所疲，或鲲鹏之状也。<br>然一者之上，二者之下，或鄙之所谓也，目力有限，思有所疲，略省二者寥寥，而思三者谓何，至于大逍遥者，或愚竭毕生之 力而无以及，乃今之人或有一二，故余妄言，见之可由。余之所望，尽己之力，达于三者而望大逍遥者，仙人之风，果然之间 ，或付诸笑谈一二。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 诗歌 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
