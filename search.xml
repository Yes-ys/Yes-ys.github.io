<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>高斯混合聚类</title>
      <link href="/2025/05/07/%E9%AB%98%E6%96%AF%E6%B7%B7%E5%90%88%E8%81%9A%E7%B1%BB/"/>
      <url>/2025/05/07/%E9%AB%98%E6%96%AF%E6%B7%B7%E5%90%88%E8%81%9A%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>高斯混合聚类不同于k-means、LVQ利用原型向量刻画聚类结构，而是利用概率来刻画聚类结构。</p><p>简单来说，这种算法认为数据集中的每个样本都符合一个多元高斯分布（多元的原因是样本常是多元向量），如下</p><p>所有的样本共同符合“混合高斯分布”。混合高斯分布对应的概率密度函数是所有多元高斯分布密度函数的加权量。</p><h3 id="多元高斯分布"><a href="#多元高斯分布" class="headerlink" title="多元高斯分布"></a>多元高斯分布</h3><p>若$x$服从多元高斯分布，对应概率密度函数为</p><p>$p(x) &#x3D; \frac{1}{(2\pi)^{\frac{n}{2}}\lvert \Sigma \rvert^{\frac{1}{2}}}e^{-\frac{1}{2}(x-\mu)^{T}\Sigma^{-1}(x-\mu)}$，其中$x$是样本对应的向量，$\Sigma$是协方差矩阵，$\mu$是期望</p><p>为了便于理解，参照一元高斯分布</p><p>$\frac{1}{\sqrt{2\pi}\sigma}e^{\frac{-1}{2}\frac{(x - \mu)^{2}}{\sigma^{2}}}$</p><p>协方差矩阵就对应方差、多元高斯分布中期望对应一元中的期望（只是多元高斯分布中期望是一个多维向量）</p><p>所以<strong>多元高斯分布的情况，由$\Sigma$和$\mu$唯一确定</strong></p><h3 id="混合高斯分布"><a href="#混合高斯分布" class="headerlink" title="混合高斯分布"></a>混合高斯分布</h3><p>将多元高斯分布密度函数记作$p(x|\mu,\Sigma)$</p><p>可以定义混合高斯分布如下：</p><p>若$x$服从混合高斯分布，整个样本空间对应有k种多元高斯分布，对应概率密度函数$p_M &#x3D; \sum^{k}<em>{i&#x3D;1} \alpha_i p(x|\mu_i,\Sigma_i)$，其中$\alpha$是混合系数，$\alpha_i$对应的实际意义是，选择第$i$个混合成分的概率，所以有$\alpha_i &gt; 0$且$\sum^{k}</em>{i&#x3D;1} \alpha_i &#x3D; 1$；而$p(x|\mu_i,\Sigma_i)$对应第i个混合成分的概率密度</p><h3 id="样本属于某混合成分的概率"><a href="#样本属于某混合成分的概率" class="headerlink" title="样本属于某混合成分的概率"></a>样本属于某混合成分的概率</h3><p>令数据集$D &#x3D; {x_1,x_2,…,x_m}$随机变量$z_j \in {1,2,…,k}$，$z_j$表征样本$x_j$属于哪个混合成分。</p><p>对于$x_j$并不确定的情况下，$z_j$的先验分布为</p><p>$p(z_j &#x3D; i) &#x3D; \alpha_i, i &#x3D; {1,2,…,k}$</p><p>根据贝叶斯定理，当$x_j$确定时，$z_j$的后验分布记作$p_M(z_j &#x3D; i|x_j)$，为</p><p>$p_M(z_j &#x3D; i|x_j) &#x3D; \frac{p(z_j &#x3D; i)p_M(x_j|z_j &#x3D; i)}{p_M(x_j)}$<br>其中，$p(z_j &#x3D; i) &#x3D; \alpha_i$；$p_M(x_j|z_j &#x3D; i) &#x3D; p(x|\mu_i,\Sigma_i)$，因为当确定$z_j &#x3D; i$时除了$\alpha_i &#x3D; 1$其它$\alpha_1,…\alpha_i-1,\alpha_i+1,…,\alpha_k$均为$0$；而$p_M(x_j)$即混合高斯分布的概率密度函数</p><p>将$p_M(z_j &#x3D; i|x_j)$简记作$\gamma_{ji}$，这个概率就是$x_j$的分布为$\mu_i,\Sigma_i$所对应的多元高斯分布的概率。</p><p>于是我们可以找到令$\gamma_{ji}$最大的$i \in {1,2,…,k}$，令$\lambda_j &#x3D; argmax_{i \in {1,2,…,k}} \gamma_{ji}$，$\lambda_j$即$x_j$的标签。对于每个都进行相同的操作，整个数据集便可被划分为k个多元高斯分布对应的k个簇。</p><h3 id="模型训练"><a href="#模型训练" class="headerlink" title="模型训练"></a>模型训练</h3><h4 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h4><p>对于k-means、LVQ的模型训练实际上就是通过训练集获得对应的原型向量，有了原型向量便有了划分为簇的依据，也就完成了模型的训练。</p><p>而对于高斯混合聚类，根据前面的描述，我们划分为簇的重要依据就是$\gamma_{ji}$，进一步说实际上是<strong>计算$\gamma_{ji}$的依据</strong>，根据计算公式可知，这个依据实际上就是决定高斯混合分布的参数$\mu_i,\Sigma_i,\alpha_i, i \in {1,2,…,k}$。</p><p><strong>于是训练的目的实际上就是要得到它们的值。</strong></p><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><p>对于模型参数${(\alpha_i,\mu_i,\Sigma_i)|1 \le i \le k}$，我们采用<strong>极大似然</strong>的方法进行求解。</p><p>这里引用南瓜书中的一句话：<br>“对于每个样本$x_j$来说，它出现的概率是$p_M(x_j)$既然现在训练集D中确实出现了$x_j$，我们当然希望待求解的参数${(\alpha_i,\mu_i,\Sigma_i)|1 \le i \le k}$能够使这种可能性$p_M(x_j)$最大”</p><p>于是根据极大似然方法，我们令<br>$LL(D) &#x3D; ln(\prod^{m}<em>{j&#x3D;1} p_M(x_j)) &#x3D; \sum^{m}</em>{j&#x3D;1} ln(\sum^k_{i&#x3D;1} \alpha_i \cdot p(x_j|\mu_i,\Sigma_i))$<br>为对数似然函数，将其最大化得到对应的参数，就是我们要求解的模型参数。</p><h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><p>经过一系列数学运算，我们可以得得到如下结果：</p><p>$\mu_i &#x3D; \frac{\sum^{m}_{j&#x3D;1} \gamma_{ji} x_j}{\sum^{m}_{j&#x3D;1} \gamma_{ji}}$</p><p>$\Sigma_i &#x3D; \frac{\sum^{m}_{j&#x3D;1} \gamma_{ji} (x_j - \mu_i)(x_j - \mu_i)^{T}}{\sum^{m}_{j&#x3D;1}} \gamma_{ji}$</p><p>$\alpha_i &#x3D; \frac{1}{m} \sum^{m}_{j&#x3D;1} \gamma{ji}$</p><p>$i &#x3D; 1,2,…,k$</p><p>注意结果当中，每一个参数的计算都要用到$\gamma{ji}$，而问题在于计算$\gamma{ji}$的时候又要用到参数本身，这似乎是一个循环的无从下手的问题。这种情况下，我们利用EM算法来求解。</p><h3 id="EM算法"><a href="#EM算法" class="headerlink" title="EM算法"></a>EM算法</h3><p>EM算法(Expectation-Maximization)称为“期望最大化算法”，这种算法最开始应用于：使用极大似然法对模型参数进行估计，但是已知的样本中存在还没有“观测”的变量，这种变量称为隐变量，它的值是不确定的。</p><p>令$X,Z,\Theta$分别为已观测变量集、隐变量集、参数集，则应最大化对数似然$LL(\Theta|X,Z) &#x3D; lnP(X,Z|\Theta)$，但是Z是隐变量，所以无法直接求解。</p><p>EM算法可以用于估计隐变量，并在这个过程中对参数做最大似然估计。</p><p>其基本的思想是这样的：</p><ol><li>初始化参数$\Theta$，根据参数去估计隐变量的<strong>概率分布</strong>，并利用此概率分布求得隐变量的<strong>期望</strong>——E步</li><li>将隐变量的期望作为我们观测到的隐变量本身，于是此时所有样本都已被观测，对$\Theta$做极大似然估计——M步</li></ol><p>不断重复上述两个过程——迭代，直到满足退出条件，例如$\Theta$收敛</p><p>贴一篇介绍EM算法的博客：<br><a href="https://blog.csdn.net/qq_41554005/article/details/100591525">CSDN</a></p><h2 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h2><p>结合EM算法，整个高斯混合聚类算法流程如下：</p><p>输入：</p><ol><li>样本集$D &#x3D; {x_1,x_2,…,x_m}$</li><li>高斯混合成分的个数k（当然也就是希望划分出的簇的个数）</li></ol><p>过程：</p><ol><li>初始化高斯混合分布的参数${(\alpha_i,\mu_i,\Sigma_i)|i &#x3D; 1,2…,k}$</li><li>repeat：</li><li>对每个样本$x_j,j &#x3D; 1,2,…,m$估计其属于第$i,i &#x3D; 1,2,…k$个成分的概率：$\gamma_{ji}$</li><li>利用公式<br>$\mu_i &#x3D; \frac{\sum^{m}_{j&#x3D;1} \gamma_{ji} x_j}{\sum^{m}_{j&#x3D;1} \gamma_{ji}}$，<br>$\Sigma_i &#x3D; \frac{\sum^{m}_{j&#x3D;1} \gamma_{ji} (x_j - \mu_i)(x_j - \mu_i)^{T}}{\sum^{m}_{j&#x3D;1}} \gamma_{ji}$，<br>$\alpha_i &#x3D; \frac{1}{m} \sum^{m}_{j&#x3D;1} \gamma{ji}$，$i &#x3D; 1,2,…,k$对参数进行更新</li><li>until:收敛条件（达到一定轮数 or 参数收敛）</li><li>求解$x_j,j &#x3D; 1,2,…,m$的标记$\lambda_j &#x3D; agrmax_{i &#x3D; 1,2,…,k} \gamma_{ji}$</li><li>根据标记划分为对应的簇</li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>Data.py:数据集部分</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">D = [</span><br><span class="line">    [<span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">0.697</span>, <span class="number">0.460</span>], [<span class="number">0.774</span>, <span class="number">0.376</span>], [<span class="number">0.634</span>, <span class="number">0.264</span>], [<span class="number">0.608</span>, <span class="number">0.318</span>], [<span class="number">0.556</span>, <span class="number">0.215</span>],</span><br><span class="line">    [<span class="number">0.403</span>, <span class="number">0.237</span>], [<span class="number">0.481</span>, <span class="number">0.149</span>], [<span class="number">0.437</span>, <span class="number">0.211</span>], [<span class="number">0.666</span>, <span class="number">0.091</span>], [<span class="number">0.243</span>, <span class="number">0.267</span>],</span><br><span class="line">    [<span class="number">0.245</span>, <span class="number">0.057</span>], [<span class="number">0.343</span>, <span class="number">0.099</span>], [<span class="number">0.639</span>, <span class="number">0.161</span>], [<span class="number">0.657</span>, <span class="number">0.198</span>], [<span class="number">0.360</span>, <span class="number">0.370</span>],</span><br><span class="line">    [<span class="number">0.593</span>, <span class="number">0.042</span>], [<span class="number">0.719</span>, <span class="number">0.103</span>], [<span class="number">0.359</span>, <span class="number">0.188</span>], [<span class="number">0.339</span>, <span class="number">0.241</span>], [<span class="number">0.282</span>, <span class="number">0.257</span>],</span><br><span class="line">    [<span class="number">0.748</span>, <span class="number">0.232</span>], [<span class="number">0.714</span>, <span class="number">0.346</span>], [<span class="number">0.483</span>, <span class="number">0.312</span>], [<span class="number">0.478</span>, <span class="number">0.437</span>], [<span class="number">0.525</span>, <span class="number">0.369</span>],</span><br><span class="line">    [<span class="number">0.751</span>, <span class="number">0.489</span>], [<span class="number">0.532</span>, <span class="number">0.472</span>], [<span class="number">0.473</span>, <span class="number">0.376</span>], [<span class="number">0.725</span>, <span class="number">0.445</span>], [<span class="number">0.446</span>, <span class="number">0.459</span>]</span><br><span class="line">]  <span class="comment"># 数据集，1~30，0索引不使用</span></span><br></pre></td></tr></table></figure><p>main.py:主函数部分</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Gauss</span><br><span class="line"><span class="keyword">import</span> Data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;高斯混合聚类 的结果&quot;</span>, end=<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    res = Gauss.gauss(Data.D)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">len</span>(res[i]), end=<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(res[i])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Guass.py:高斯混合聚类算法部分</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">multi_gauss_distri_p</span>(<span class="params">sigma, mu, n, x</span>):</span><br><span class="line">    <span class="comment"># 计算多元高斯分布下取得x的概率，n是维度</span></span><br><span class="line">    vec_mu = np.array(mu)</span><br><span class="line">    vec_x = np.array(x)</span><br><span class="line">    t1 = vec_x - vec_mu</span><br><span class="line">    <span class="comment">#    t1 = t1.T</span></span><br><span class="line">    det_sigma = np.linalg.det(sigma)</span><br><span class="line">    <span class="keyword">if</span>(det_sigma &lt; <span class="number">1e-10</span>):  <span class="comment"># 当行列式过小时，添加一个较小的正则化项</span></span><br><span class="line">        sigma += np.eye(sigma.shape[<span class="number">0</span>]) * <span class="number">1e-6</span>  <span class="comment"># 添加正则化，避免奇异矩阵</span></span><br><span class="line">    t2 = np.linalg.inv(sigma)</span><br><span class="line">    t3 = vec_x - vec_mu</span><br><span class="line">    t3 = t3.T  <span class="comment"># 西瓜书上的公式里没有转置的向量默认是列向量</span></span><br><span class="line">    log_p = -<span class="number">0.5</span> * (np.dot(np.dot(t1, t2), t3) + np.linalg.slogdet(sigma)[<span class="number">1</span>] + n * np.log(<span class="number">2</span> * np.pi))</span><br><span class="line">    p = np.exp(log_p)</span><br><span class="line"><span class="comment">#    p = 1 / ((2 * np.pi) ** (n / 2) * np.linalg.det(sigma) ** (1 / 2)) * np.e ** (-0.5 * np.dot(np.dot(t1, t2), t3)</span></span><br><span class="line"><span class="comment">#    print(&quot;p:&quot;, p, end=&quot;\n&quot;)</span></span><br><span class="line">    <span class="keyword">if</span> p &lt; <span class="number">1e-10</span>:</span><br><span class="line">        p = <span class="number">1e-6</span>  <span class="comment"># 避免数值问题</span></span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">new_mu_i</span>(<span class="params">D, lamda_, i</span>):</span><br><span class="line">    up_sum = [<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">    down_sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">31</span>):</span><br><span class="line">        up_sum[<span class="number">0</span>] += lamda_[j][i] * D[j][<span class="number">0</span>]</span><br><span class="line">        up_sum[<span class="number">1</span>] += lamda_[j][i] * D[j][<span class="number">1</span>]</span><br><span class="line">        down_sum += lamda_[j][i]</span><br><span class="line">    new_mu = [up_sum[<span class="number">0</span>] / down_sum, up_sum[<span class="number">1</span>] / down_sum]</span><br><span class="line">    <span class="keyword">return</span> new_mu</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">new_sigma_i</span>(<span class="params">D, mu, lamda_, i</span>):</span><br><span class="line">    vec_x = np.array(D[i])</span><br><span class="line">    vec_mu = np.array(mu)</span><br><span class="line">    up_sum = np.array([[<span class="number">0.0</span>, <span class="number">0.0</span>], [<span class="number">0.0</span>, <span class="number">0.0</span>]])</span><br><span class="line">    down_sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">31</span>):</span><br><span class="line">        t = vec_x - vec_mu</span><br><span class="line">        up_sum += lamda_[j][i] * (np.outer(t.T, t))</span><br><span class="line">        down_sum += lamda_[j][i]</span><br><span class="line">    new_sigma = up_sum / down_sum</span><br><span class="line">    <span class="keyword">return</span> new_sigma</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">new_alpha_i</span>(<span class="params">lambda_, i</span>):</span><br><span class="line">    up_sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">31</span>):</span><br><span class="line">        up_sum += lambda_[j][i]</span><br><span class="line">    new_alpha = up_sum / <span class="number">30</span></span><br><span class="line">    <span class="keyword">return</span> new_alpha</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gauss</span>(<span class="params">D: [[<span class="built_in">float</span>]]</span>):</span><br><span class="line">    <span class="comment">#  定义混合高斯分布参数</span></span><br><span class="line">    sigma = []  <span class="comment"># 协方差矩阵</span></span><br><span class="line">    alpha = []  <span class="comment"># 混合权重</span></span><br><span class="line">    mu = []  <span class="comment"># 期望</span></span><br><span class="line">    <span class="comment">#  初始化参数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">3</span>):</span><br><span class="line">        sigma.append(np.array([[<span class="number">0.1</span>, <span class="number">0.0</span>], [<span class="number">0.0</span>, <span class="number">0.1</span>]]))</span><br><span class="line">        alpha.append(<span class="number">1</span>/<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">3</span>):</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">            mu.append(D[<span class="number">6</span>])</span><br><span class="line">        <span class="keyword">elif</span> i == <span class="number">1</span>:</span><br><span class="line">            mu.append(D[<span class="number">22</span>])</span><br><span class="line">        <span class="keyword">elif</span> i == <span class="number">2</span>:</span><br><span class="line">            mu.append(D[<span class="number">27</span>])</span><br><span class="line">    <span class="comment">#  定义xj属于第i种多元高斯分布的概率</span></span><br><span class="line">    lambda_ = []</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">31</span>):</span><br><span class="line">        lambda_.append([[], [], []])</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">100</span>):  <span class="comment"># 迭代</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">31</span>):  <span class="comment"># 依次对每个xj计算lambda_ji,i = 0，1，2，对应三种多元高斯分布</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">3</span>):</span><br><span class="line">                t_sum = <span class="number">0</span></span><br><span class="line">                <span class="keyword">for</span> l <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">3</span>):</span><br><span class="line">                    t_sum += alpha[l] * multi_gauss_distri_p(sigma[l], mu[l], <span class="number">2</span>, D[j])</span><br><span class="line">                lambda_ji = alpha[i] * multi_gauss_distri_p(sigma[i], mu[i], <span class="number">2</span>, D[j]) / t_sum</span><br><span class="line">                lambda_[j][i] = lambda_ji</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">3</span>):  <span class="comment"># 更新混合高斯分布参数</span></span><br><span class="line">            mu[i] = new_mu_i(D, lambda_, i)</span><br><span class="line">            sigma[i] = new_sigma_i(D, mu[i], lambda_, i)</span><br><span class="line">            alpha[i] = new_alpha_i(lambda_, i)</span><br><span class="line"></span><br><span class="line">    result = [[], [], []]  <span class="comment"># 最终的划分结果</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">31</span>):  <span class="comment"># 依次对每个xj计算lambda_ji,i = 0，1，2，对应三种多元高斯分布</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">3</span>):</span><br><span class="line">            t_sum = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> l <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">3</span>):</span><br><span class="line">                t_sum += alpha[l] * multi_gauss_distri_p(sigma[l], mu[l], <span class="number">2</span>, D[j])</span><br><span class="line">            lambda_ji = alpha[i] * multi_gauss_distri_p(sigma[i], mu[i], <span class="number">2</span>, D[j]) / t_sum</span><br><span class="line">            lambda_[j][i] = lambda_ji</span><br><span class="line"></span><br><span class="line">        flag = <span class="number">0</span></span><br><span class="line">        ll = lambda_[j][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">3</span>):</span><br><span class="line">            <span class="keyword">if</span> ll &lt; lambda_[j][i]:</span><br><span class="line">                flag = i</span><br><span class="line">        result[flag].append(D[j])</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>进行这一部分的时候让我最大的感悟是，在使用计算机进行数据处理的时候，很可能会出现数据的溢出问题，非常大、非常小的数都在计算机的表示范围之外，就会带来问题。例如在进行协方差矩阵更新的时候，有时它的行列式值虽然不是0，但是已经非常小了，计算机会默认其为0。同样，可能作为除数的数也是一样的，如果太小变为0就会发送除以0的错误。<br><strong>这称为数值稳定性问题</strong></p><p>因此代码中有一些涉及处理这些问题的地方（主要是在求第i个多元高斯分布中取得xj这个值的概率的时候，一处是正则化、一处是对数化并添加过小的判断），尽管我现在并不清楚这样处理是否有问题。但是抛开这些细节，作为一次上手的练习，整个混合高斯聚类算法是正确的。<br><strong>不过值得一提的是，EM算法的收敛与迭代的次数没有必然的关系，通常应该使用参数变化的情况来决定是否结束迭代</strong></p><p>最后的结果如下：</p><blockquote><p>高斯混合聚类 的结果<br>2<br>[[0.608, 0.318], [0.359, 0.188]]<br>0<br>[]<br>28<br>[[0.697, 0.46], [0.774, 0.376], [0.634, 0.264], [0.556, 0.215], [0.403, 0.237], [0.481, 0.149], [0.437, 0.211], [0.666, 0.091], [0.243, 0.267], [0.245, 0.057], [0.343, 0.099], [0.639, 0.161], [0.657, 0.198], [0.36, 0.37], [0.593, 0.042], [0.719, 0.103], [0.339, 0.241], [0.282, 0.257], [0.748, 0.232], [0.714, 0.346], [0.483, 0.312], [0.478, 0.437], [0.525, 0.369], [0.751, 0.489], [0.532, 0.472], [0.473, 0.376], [0.725, 0.445], [0.446, 0.459]]</p></blockquote><p>经过我的观察，第3次迭代之后划分结果基本上就稳定了，第1次的时候分得比较均匀。这或许是数据的原因。（也有可能是我对于数值稳定性的处理不好）</p><p>如果将正则化项改大一些结果如下：</p><blockquote><p>高斯混合聚类 的结果<br>12<br>[[0.608, 0.318], [0.556, 0.215], [0.403, 0.237], [0.481, 0.149], [0.437, 0.211], [0.243, 0.267], [0.245, 0.057], [0.343, 0.099], [0.359, 0.188], [0.339, 0.241], [0.282, 0.257], [0.483, 0.312]]<br>10<br>[[0.634, 0.264], [0.666, 0.091], [0.639, 0.161], [0.657, 0.198], [0.593, 0.042], [0.719, 0.103], [0.748, 0.232], [0.714, 0.346], [0.751, 0.489], [0.725, 0.445]]<br>8<br>[[0.697, 0.46], [0.774, 0.376], [0.36, 0.37], [0.478, 0.437], [0.525, 0.369], [0.532, 0.472], [0.473, 0.376], [0.446, 0.459]]</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 聚类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习向量量化</title>
      <link href="/2025/05/06/%E5%AD%A6%E4%B9%A0%E5%90%91%E9%87%8F%E9%87%8F%E5%8C%96/"/>
      <url>/2025/05/06/%E5%AD%A6%E4%B9%A0%E5%90%91%E9%87%8F%E9%87%8F%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p><code>这篇blog用于记录我使用python对学习向量量化这种聚类算法的复现</code></p><h2 id="算法简介"><a href="#算法简介" class="headerlink" title="算法简介"></a>算法简介</h2><p>学习向量量化也成为LVQ(Learning Vector Quantization)，同样属于原型聚类算法，类似于k-means通过希望划分的簇的数量求得相同数量的“簇中心”并以此为原型将数据集划分为对应的簇，LVQ通过求得与希望划分的簇数量相同的“原型向量”，并以此来将数据集划分为对应的簇。</p><p>如果说k-means也同样是借助原型向量的话，那么关键就在于两种算法更新原型向量的方法不同。k-means是不断的用原型向量划分簇，又用簇更新原型向量；LVQ则是利用样本的预先标注作为“监督信息”，不断利用样本更新原型向量。</p><h2 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h2><p>整个算法的大致流程如下：</p><p>输入: $D &#x3D; {(x_1,y_1),(x_2,y_2),…,(x_m,y_m)}, q, {t_1,t_2,…,t_q},\eta \in (0,1)$其中，D是带有标记的数据集，q是原型向量个数，$t_i,i \in {1,2,…,q}$ 对应原型向量的标记，$\eta$是学习率</p><p>算法过程：</p><ol><li>初始化原型向量${p_1,p_2,…,p_q}$</li><li>repeat:</li><li>从$D$中随机挑选一个样本$(x_j,y_j)$</li><li>找到与$x_j$最近的原型向量$p_i^{*}$</li><li>if($t_i^{*}$ &#x3D;&#x3D; $y_j$): $p’ &#x3D; p_i^{*} + \eta(p_i^{*} - x_j)$</li><li>else: $p’ &#x3D; p_i^{*} - \eta(p_i^{*} - x_j)$</li><li>判断是否到达退出条件</li></ol><p>整个算法过程的关键就在于5、6，实际上相当于找到距离原型向量最近的样本，如果是同标记的则将该原型向量向该样本“拉近”，如果是不同标记的则“推远”（因为对应的是同标记的在一个簇中可能性较大，不同标记在不同簇中可能性较大）</p><p>关于7的退出条件，通常可以设置一个最大迭代轮数，或者是原型向量的更新程度已经小于了一个阈值。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>使用python对西瓜书上的示例复现代码如下（30个样本，9-21号样本标记为2，其它样本标记为1，随机选择5个样本作为原始向量，标记分别为1、2、2、1、1，学习率为0.1）</p><p>Data.py数据集部分:</p><pre><code>D = [    [0, 0],    [0.697, 0.460], [0.774, 0.376], [0.634, 0.264], [0.608, 0.318], [0.556, 0.215],    [0.403, 0.237], [0.481, 0.149], [0.437, 0.211], [0.666, 0.091], [0.243, 0.267],    [0.245, 0.057], [0.343, 0.099], [0.639, 0.161], [0.657, 0.198], [0.360, 0.370],    [0.593, 0.042], [0.719, 0.103], [0.359, 0.188], [0.339, 0.241], [0.282, 0.257],    [0.748, 0.232], [0.714, 0.346], [0.483, 0.312], [0.478, 0.437], [0.525, 0.369],    [0.751, 0.489], [0.532, 0.472], [0.473, 0.376], [0.725, 0.445], [0.446, 0.459]]  # 数据集，1~30，0索引不使用# 数据集的标记，LVQ使用T = [    0,    1, 1, 1, 1, 1,    1, 1, 1, 2, 2,    2, 2, 2, 2, 2,    2, 2, 2, 2, 2,    2, 1, 1, 1, 1,    1, 1, 1, 1, 1]# 原始向量标记的输入q_vect = [1, 2, 2, 1, 1]</code></pre><p>main.py主函数部分：</p><pre><code>import K_meansimport LVQimport Datadef main():     print(&quot;LVQ 的结果&quot;, end=&quot;\n&quot;)    res = LVQ.lvq(Data.D, Data.T, Data.q_vect)    for i in range(5):        print(len(res[i]) - 1, end=&quot;\n&quot;)        if len(res[i]) == 1:            print(&quot;[]&quot;, end=&quot;\n&quot;)            continue        for j in range(len(res[i])):            if j == 0:                continue            print(res[i][j], end=&quot; &quot;)        if len(res[i]) != 1:            print(&quot; &quot;)    if __name__ == &quot;__main__&quot;:        main()</code></pre><p>LVQ.py学习向量量化算法部分：</p><pre><code>def lvq(D:[[float]], T:[int], q_vect:[]):l_rate = 0.1import random as rdq_vec_index = rd.sample(range(1, 31), 5)  # 随机选取5个样本作为原型向量q_vec = []  # 原型向量for i in range(0,5):    q_vec.append(D[q_vec_index[i]])for _ in range(0,10000):  # 迭代10000轮    j_dex = rd.randint(1,30)  # 随机挑选一个样本，randint函数的参数是一个闭区间！    q = 0 # 距离j_dex最近的原型向量的索引    d = (D[j_dex][0] - q_vec[0][0])**2 + (D[j_dex][1] - q_vec[0][1])**2    for i in range(1,5):        d_i = (D[j_dex][0] - q_vec[i][0])**2 + (D[j_dex][1] - q_vec[i][1])**2        if d_i &lt; d:            q = i            d = d_i    if q_vect[q] == T[j_dex]:  # 将原型向量与样本拉近        q_vec[q][0] = q_vec[q][0] + l_rate*(D[j_dex][0] - q_vec[q][0])        q_vec[q][1] = q_vec[q][1] + l_rate*(D[j_dex][1] - q_vec[q][1])    else:  # 将原型向量与样本推远        q_vec[q][0] = q_vec[q][0] - l_rate * (D[j_dex][0] - q_vec[q][0])        q_vec[q][1] = q_vec[q][1] - l_rate * (D[j_dex][1] - q_vec[q][1])result = [[], [], [], [], []]for i in range(0,5):    result[i].append(q_vec[i])for i in range(1,31):    j = 0    d = (D[i][0] - q_vec[j][0])**2 + (D[i][1] - q_vec[j][0])**2    for _ in range(1,5):        d_ = (D[i][0] - q_vec[_][0])**2 + (D[i][1] - q_vec[_][1])**2        if d_ &lt; d:            d = d_            j = _    result[j].append(D[i])return result</code></pre><p><code>捉个一个虫，py中万物皆对象，在初始化q_vec的时候直接将数据集D中的元素append进去，实际上共享了内存，这会导致更新原型向量的时候，数据集中的元素被更新，解决方案是使用深拷贝</code></p><p>修改方法：<br>将q_vec初始化的地方：</p><pre><code>q_vec = []  # 原型向量for i in range(0,5):    q_vec.append(D[q_vec_index[i]])</code></pre><p>更改为：</p><pre><code>q_vec = [x.copy() for x in (D[i] for i in q_vec_index)]  # 关键修复点：使用列表拷贝</code></pre><p>最终运行结果：</p><blockquote><p>3<br>[0.36, 0.37] [0.478, 0.437] [0.446, 0.459]<br>8<br>[0.634, 0.264] [0.556, 0.215] [0.666, 0.091] [0.639, 0.161] [0.657, 0.198] [0.593, 0.042] [0.719, 0.103] [0.748, 0.232]<br>9<br>[0.403, 0.237] [0.481, 0.149] [0.437, 0.211] [0.243, 0.267] [0.245, 0.057] [0.343, 0.099] [0.359, 0.188] [0.339, 0.241] [0.282, 0.257]<br>5<br>[0.697, 0.46] [0.774, 0.376] [0.714, 0.346] [0.751, 0.489] [0.725, 0.445]<br>5<br>[0.608, 0.318] [0.483, 0.312] [0.525, 0.369] [0.532, 0.472] [0.473, 0.376]  </p></blockquote><p>对应为5个簇中样本的数量和相应的样本</p><p><code>注：理论上应该将数据集D划分为训练集和测试集，通过训练集训练模型（得到所有合理的原型向量），然后利用测试集测试，利用原型向量将测试集划分为对应数量的簇；这样才能完整地体现“机器学习”，但是这里只是一个简单的例子，将数据集D全用作训练集，得到原型向量，再把整个训练集划分为了对应的簇。</code><br><code>有了原型向量之后，划分为簇是很简单的，样本距离哪个原型向量最近，就纳入对应的簇即可。</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> 聚类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>六级词汇</title>
      <link href="/2025/05/06/%E5%85%AD%E7%BA%A7%E8%AF%8D%E6%B1%87/"/>
      <url>/2025/05/06/%E5%85%AD%E7%BA%A7%E8%AF%8D%E6%B1%87/</url>
      
        <content type="html"><![CDATA[<p><code>这篇博客用于记录我在备考英语六级时所做的词汇准备，目前我已经完成了核心词汇的记忆，我会在这里为这些词汇补充一些例句。</code><br><code>目前的打算是每天20个词语，此外我会开始着手阅读、听力以及写译的准备，这篇blog中也会用于记录相应的内容</code></p><h2 id="词汇"><a href="#词汇" class="headerlink" title="词汇"></a>词汇</h2><h3 id="2025-05-06"><a href="#2025-05-06" class="headerlink" title="2025.05.06"></a>2025.05.06</h3><p>1</p><blockquote><p>stabilize  “How can I stabilize the colour of our love, my dear.”</p></blockquote><p>2</p><blockquote><p>manipulate “Your mean is that you can manipualte such a monster machine.”</p></blockquote><p>3</p><blockquote><p>ambiguous “Don’t treat me with such a ambiguous attitude.”</p></blockquote><p>4</p><blockquote><p>interaction “The relationship forms from the interaction among people little by little.”</p></blockquote><p>5</p><blockquote><p>perception “What’s your perception about our future?”</p></blockquote><p>6</p><blockquote><p>strive “I’ll strive to achieve our happiness in future.”</p></blockquote><p>7</p><blockquote><p>expense “How much is the expense of our lives in the month?”</p></blockquote><p>8</p><blockquote><p>cater “We will cater for the party.”</p></blockquote><p>9</p><blockquote><p>summon “I am trying to summon up the courage to love you.” “He was summoning the elevator.”</p></blockquote><p>10</p><blockquote><p>plug “The broken bus pluged the traffic.”</p></blockquote><p>11</p><blockquote><p>elaspe “I don’t think our love will elapse.”</p></blockquote><p>12</p><blockquote><p>authorize “The law won’t autorize anybody to kill.”</p></blockquote><p>13</p><blockquote><p>commentary “With a conception about freedom of expression, the commentraies online are too cynic and dirty sometimes.”</p></blockquote><p>14</p><blockquote><p>conservative “Some people are still conservative about sex, which’s treasurable.”</p></blockquote><p>15</p><blockquote><p>arson “People would arson to destory all the thing of a witch even her body in the middle centery, however many women called wicth are innocent.”</p></blockquote><p>16</p><blockquote><p>litre “How much water should a people to drink a day? 2 litres?”</p></blockquote><p>17</p><blockquote><p>vengeance “The lifelong traveling of Gess is to make vengeane.”</p></blockquote><p>18</p><blockquote><p>expenditure “He is rigorous in his contorl of expenditure.”</p></blockquote><p>19</p><blockquote><p>overwhelm “The fear overwhelmed in his mind.”</p></blockquote><p>20</p><blockquote><p>surpass “His achievement supasses anybody.”</p></blockquote><h2 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h2><h2 id="写译"><a href="#写译" class="headerlink" title="写译"></a>写译</h2><h2 id="听力"><a href="#听力" class="headerlink" title="听力"></a>听力</h2>]]></content>
      
      
      
        <tags>
            
            <tag> 大学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计组复习</title>
      <link href="/2025/05/03/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/"/>
      <url>/2025/05/03/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p><code>我在大二下选修了计算机组成原理，这篇blog用来梳理相关知识点</code></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一些学习计算机组成原理之前应该知道的知识…</p><ol><li>计算机结构：系统程序员所能见到的<strong>硬件特性</strong>，指的是计算机的<strong>逻辑结构</strong></li><li>计算机组成：计算机硬件的<strong>具体实现</strong>，指的是计算的<strong>物理结构</strong></li><li>两类汇编语言，RISC &amp; CISC，对应精简与复杂的指令系统，MIPS属于RISC的一种</li><li>计算机组成原理涉及：汇编，处理器、内存、IO三者对应的逻辑系统与硬件实现（数据通路），课程定位在整个计算机系统中处于硬件方面的数字电路之上，软件层面的操作系统之内（因为上到汇编），但在编译器之下（编译器同样属于OS的范畴）</li><li>核心内容：CPU Organization(data path &amp; controller), Caches</li><li>重点内容：MIPS汇编，Virtual Memory</li><li>了解内容：I&#x2F;O, Bus</li></ol><p><strong>最后请谨记，该门课特点是概念抽象、繁琐…但是“清澈见底”，只要想弄清楚，一定可以！</strong></p><h2 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h2><h3 id="指令系统设计"><a href="#指令系统设计" class="headerlink" title="指令系统设计"></a>指令系统设计</h3><p><code>这一部分主要是一些有关指令系统设计的知识点</code></p><p>于是，首先看看这三个知识点：</p><ol><li>指令：二进制的机器语言</li><li>汇编指令：助记符，每种条符号语句都映射到一条二进制的机器代码</li><li>ISA：指令系统（指令集体系结构），<strong>软硬件交汇的地方</strong></li></ol><p>接下来，一条指令应该包含以下信息：</p><ol><li>操作码（定长 or 变长）</li><li>源操作数参照（from where）</li><li>目的位置参照（to where）</li><li>下一条指令地址（what to do next?）</li></ol><p>按地址数的指令分类：</p><p>零、一、二、三、多地址指令，其中二三是典型的RISC风格。三的特点是显示指定了dst，一或二的dst是隐含的（built-in or src）</p><p>指令执行的阶段：</p><p>取指令-&gt;译码-&gt;取操作数-&gt;运算（执行）-&gt;存放结果-&gt;取下一条指令<br><strong>不一定所有指令都涉及所有步骤，但是考虑的时候应该按最复杂的来，何尝不是一种设计原则？</strong></p><p>指令设计基本原则：<br>完备性，兼容性，均匀性，可扩展性<br><strong>应当明白词语背后的含义</strong></p><p>最简单的完备指令系统：<br>load, store, inc, brn</p><h3 id="操作数类型"><a href="#操作数类型" class="headerlink" title="操作数类型"></a>操作数类型</h3><p>…</p><h3 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h3><p>…</p><h3 id="扩展操作码编码"><a href="#扩展操作码编码" class="headerlink" title="扩展操作码编码"></a>扩展操作码编码</h3><p>这是涉及关于如何给操作码编码，以及对应数量关系的问题。<br><strong>核心思想是一种数字状态，一个编码</strong></p><p>涉及到的相关信息有：</p><ol><li>指令字长，例如16位、32位…</li><li>地址长度，如6位…</li><li>操作码长度，通常不同地址数量的编码不同</li><li>不同地址数的指令的条数</li></ol><p>通常会已知1、2，4中某些地址数的指令条数，求剩余一种地址数的指令<strong>最多</strong>的条数。</p><p>关键点是：</p><ol><li>明确<strong>已知的某些地址数的指令条数——剩下的一种地址数的指令条数</strong>一定存在函数关系</li><li>从多地址数的指令开始考虑，考虑它的操作码有多少位，可求得这种指令至多有多少条</li><li>利用“已知”的实际条数与至多有多少条，可以求得这种指令的<strong>剩余状态</strong>数量</li><li>考虑减少一条地址的指令，对应操作码有多少位，<strong>记得计算操作码长度的时候，不仅是指令字长减去地址长度，还要减去上种指令操作码所用长度</strong></li><li>求得这种指令至多有多少条，利用<strong>剩余状态</strong>×<strong>操作码长度</strong></li><li>显然这个过程可以反复进行，由地址数量最多的情况，如3个地址码，到最少的情况，如零地址码<br><strong>最后，不一定所有的状态都有使用…</strong></li></ol><h3 id="指令设计的风格"><a href="#指令设计的风格" class="headerlink" title="指令设计的风格"></a>指令设计的风格</h3><p>尤其关注RISC的风格。</p><p>RISC是<strong>load&#x2F;store型指令系统</strong>，特点是只有load、store命令才能访问存储器，其它运算类的指令通通不能访问存储器<br>（值得注意的是这种指令系统，属于<strong>通用寄存器型指令系统</strong>的子集，特点是使用通用寄存器存放临时数据，而不使用累加器）</p><p>RISC的特点是：</p><ol><li>指令数目少</li><li>指令格式规整</li><li>Load&#x2F;store风格</li><li>采用流水线的指令执行方式</li><li>采用大量通用寄存器</li><li>采用硬连线控制器</li><li>采用优化的编译器</li></ol><h3 id="异常与中断"><a href="#异常与中断" class="headerlink" title="异常与中断"></a>异常与中断</h3><p>…</p><h3 id="程序的机器级表示（MIPS指令系统）"><a href="#程序的机器级表示（MIPS指令系统）" class="headerlink" title="程序的机器级表示（MIPS指令系统）"></a>程序的机器级表示（MIPS指令系统）</h3><p><code>这一部分是重点知识，所以会有多级的副标题。请着重掌握！</code></p><h4 id="MIPS有关的基础知识"><a href="#MIPS有关的基础知识" class="headerlink" title="MIPS有关的基础知识"></a>MIPS有关的基础知识</h4><p><code>一些零碎的知识点，不好纳入后面的各级标题之中，于是集中在此...</code><br><code>或者说并非无法纳入，而是比较重要...单拎出来也方便记忆</code></p><ol><li>MIPS指令长度都是32位</li><li>MIPS中设计了32个通用寄存器</li><li>MIPS使用大端的存储方式</li><li>MIPS设计的存储器按照字节编址，1Byte对应一个存储单元，有自己的专属地址</li><li>MIPS中人为修改pc的指令，如j、beq等，在机器级存储的转移值是相对转移的指令的条数（即应该修改pc的相对量除以4后的值）</li></ol><h4 id="MIPS指令的机器级表示"><a href="#MIPS指令的机器级表示" class="headerlink" title="MIPS指令的机器级表示"></a>MIPS指令的机器级表示</h4><p>MIPS中指令格式包括R型、I型、J型。</p><h5 id="1-R型指令"><a href="#1-R型指令" class="headerlink" title="1.R型指令"></a>1.R型指令</h5><p>机器级表示:<br>op6+rs5+rt5+rd5+shamt5+func5</p><ol><li>op是操作码，对于R型来说全是0</li><li>shamt是用于处理移位操作的</li><li>func是用于区分操作码的</li><li>rs, rt为源寄存器1、2</li><li>rd为目的寄存器</li></ol><p><strong>注意，R型指令助记符表示的时候，实际上是 op rd rs rt的顺序，要和机器级位置区分开</strong><br><code>不妨考虑一下，op全为0的好处是什么</code></p><h5 id="2-I型指令"><a href="#2-I型指令" class="headerlink" title="2.I型指令"></a>2.I型指令</h5><p>机器级表示：<br>op6+rs5+rt5+imm16</p><ol><li>常用I型指令：双目运算，rs与imm运算，送至rt，例如<code>addi $2,$1,imm</code></li><li>常用I型指令，load、store，采用的<strong>MIPS采用基址+相对位移量</strong>的访存方式，例如<code>lw $2,100($1)</code></li><li>常用I型指令，beq、bne，条件分支，例如<code>beq $1,$2,L</code></li><li>imm是16位，但是与其运算的寄存器rs是32位的，需要进行扩展，扩展的规则如下：<br>①用于进行双目运算的时候，i是符号扩展imm，iu是零扩展imm<br>②用于load、store的时候，imm总是符号扩展，虽然有u的存在，例如lhu, lbu等，但是这里的u对应的用于0扩展不足32位的存储内容，从而加载到寄存器<br>③用于条件分支的时候，beq、bne应该与slt搭配使用，所以imm通常只与1、0进行相等与否的比较，于是也不存在什么扩展与否的问题<br><strong>注意，实际上slt也可以是I型的，并且很常用，但是也有R型的</strong></li></ol><h5 id="3-J型指令"><a href="#3-J型指令" class="headerlink" title="3.J型指令"></a>3.J型指令</h5><p>机器级表示：<br>op6+target address26</p><ol><li>实际的目的地址计算方式，pc高4位:target address:00<br>最后总是00的原因，在于MIPS中指令总是32位的，从0地址开始访存：0,100,1000,1100…（0、4、8、12…），末尾总是00，这个特点在后面设计用于MIPS的CPU的时候也非常有用</li><li>显然，这是一种局部寻址的方式</li></ol><h4 id="MIPS设计的通用寄存器"><a href="#MIPS设计的通用寄存器" class="headerlink" title="MIPS设计的通用寄存器"></a>MIPS设计的通用寄存器</h4><p>MIPS使用32个通用寄存器，我们应该掌握以下有关的知识。</p><h5 id="1-两种助记符号的使用"><a href="#1-两种助记符号的使用" class="headerlink" title="1.两种助记符号的使用"></a>1.两种助记符号的使用</h5><ol><li>编号：”$”+“数字：0~31”</li><li>名称</li></ol><p><code>程序中一般都使用名称，举例子的时候使用编号多一些。或许，前者体现“助记”，后者体现“通用”</code></p><h5 id="2-经常使用的寄存器"><a href="#2-经常使用的寄存器" class="headerlink" title="2.经常使用的寄存器"></a>2.经常使用的寄存器</h5><ol><li>zero<br>编号为0，其功能是提供0值，寄存器中始终是全0</li><li>v0-v1<br>编号2-3，功能是存放过程调用的返回值</li><li>a0-a3<br>编号4-7，功能是存放过程调用的参数</li><li>t0-t7<br>编号8-15，功能是存放临时使用的变量</li><li>s0-s7<br>编号16-23 被调用者保存的寄存器</li><li>t8-t9<br>编号24-25，功能是存放临时使用的变量</li><li>sp, fp, ra<br>编号29-31，功能是，栈指针（栈顶），帧指针（栈底），存放调用过程返回地址</li></ol><p>记忆的方法，“一个过程调用，使用了4个参数a，返回了两个值v，调用者保存了8个寄存器s，被调用者保存了10个寄存器t，关键在于sp、fp与ra”+zero</p><h5 id="3-了解的寄存器"><a href="#3-了解的寄存器" class="headerlink" title="3.了解的寄存器"></a>3.了解的寄存器</h5><ol><li>at<br>编号为1，保留给编译器使用</li><li>k0-k1<br>编号为26-27，保留给系统使用</li><li>gp<br>编号为28，全局指针</li></ol><h4 id="MIPS汇编指令"><a href="#MIPS汇编指令" class="headerlink" title="MIPS汇编指令"></a>MIPS汇编指令</h4><p><code>在开始做这一部分的笔记之前，我思考了一个问题——如何才能更好的记忆MIPS汇编指令。我得出的答案是，一般性规律的记忆+特殊性个例的记忆。对于一般性规律的记忆，其规律包括：指令的助记符+什么类型的指令+指令的特性，前两者可以帮助我们正确地写出指令，后者可以帮助我们正确地理解指令。对于特殊性个例，我们不妨记住全部。在记忆的过程中带着这个思想，或许会容易记忆一些。</code></p><p>我们接下来按照指令的类别进行。</p><h5 id="1-算术类指令"><a href="#1-算术类指令" class="headerlink" title="1.算术类指令"></a>1.算术类指令</h5><ol><li>算术运算包括，加、减、乘、除<br>对应的基本助记符是add、sub、mult、div</li><li>加、减有I型和R型，使用I型的时候，如addi、subi</li><li>加、减默认会判断溢出，也有不判断溢出，对应u扩展（undo），如addu、subu<br><strong>当然也有addiu、subiu</strong></li><li>乘、除比较特殊，仅有R型，但是是双目操作符，因为结果存放在默认寄存器hi，lo（乘法hi，lo分别为高低32位，除法hi为32位余数，lo为32位商）</li><li>乘、除分有符号数和无符号数，对应为u扩展（unsigned），如multu、divu<br><strong>注意区分unsigned和undo</strong></li></ol><p><code>一般性的规律是，助记符：加、减有I、R型，乘、除只有R型</code></p><h5 id="2-存储访问"><a href="#2-存储访问" class="headerlink" title="2.存储访问"></a>2.存储访问</h5><p>存储访问，按照访存字节，分为按字（word，MIPS中是32位），按半字（half word，16位），按字节（byte，8位）访问</p><p>以及MIPS最有特色的指令<strong>lui</strong></p><ol><li>lw、sw，按字访问lw&#x2F;sw $1 100($2)，sw是MIPS中唯一一个dst在src之后的指令</li><li>lhu、lbu，按半字、字节加载，16位内存到32位存储器涉及扩展，格式与lw、sw相同，内存中数据是按无符号扩展<br><strong>注意，必须加u，这就意味着使用半字或字节的时候，内存中内容只能按字节扩展到寄存器</strong><br><strong>但是imm的扩展只能是符号扩展，没有undo的选择</strong></li><li>sh、sb，按半字、字节存储，格式与lw、sw相同，由于是寄存器到存储器，不用考虑扩展。<br><strong>sh、sb同样的只要是访存，imm都是按符号扩展</strong></li><li>lui，I型，使用方法，lui rs,imm，将16位imm放置在rs的高16位<br><em>这是一个很能体现MIPS特色的指令，如果程序员，<del>按照自己的想象</del>（这个数字并不存在于任何其它的位置），想要将一个32位的数字放置在寄存器中，就可以按照16位、16位的存放。可以先lui，再addi</em><br><strong>按照自己的想象是很重要的一点！这将lui和lw、lhu、lbu区分开来，因为lui根本没有访存！</strong></li></ol><p><code>一般性的规律是，助记符；访存都是I型</code></p><h5 id="3-逻辑运算"><a href="#3-逻辑运算" class="headerlink" title="3.逻辑运算"></a>3.逻辑运算</h5><p>MIPS中常用的逻辑运算是与、或、异或</p><ol><li>与，and，有R型、I型，I型对应i扩展，如addi rd,rs,rt</li><li>或，or，同与</li><li>异或，xor，同与</li></ol><p><code>一般性的规律是，助记符，逻辑运算有R型、I型</code></p><h5 id="4-移位操作"><a href="#4-移位操作" class="headerlink" title="4.移位操作"></a>4.移位操作</h5><p>MIPS中的涉及的移位操作有，逻辑左、右移动，算术右移</p><ol><li>逻辑左移，sll，I型，如sll rt,rs,imm</li><li>逻辑右移，srl，同上</li><li>算术右移，sra，同上<br><strong>注意，表示是逻辑还是算术的l和a，放在最后</strong></li></ol><p><code>一般性的规律是，助记符，移位只有I型</code></p><h5 id="5-条件分支"><a href="#5-条件分支" class="headerlink" title="5.条件分支"></a>5.条件分支</h5><p>MIPS中涉及的条件分支，常用的是，slt、beq、bne</p><ol><li>slt，有R型、I型，如slt rt,rs,imm<br><strong>注意slt的I型，不使用i扩展！</strong></li><li>beq，I型，如beq rs,rt,L<br><strong>实际编程中L的位置，通常写label，进一步的处理或许是交给汇编器进行的…</strong></li><li>bne，同beq</li></ol><p><code>一般性的规律是，助记符，slt有R型，其它都是I型</code></p><h5 id="6-无条件跳转指令"><a href="#6-无条件跳转指令" class="headerlink" title="6.无条件跳转指令"></a>6.无条件跳转指令</h5><p>MIPS中的跳转指令常用的是j、jr、jal</p><ol><li>j，J型指令，如j L（实际使用L是label）</li><li>jr，J型指令，地址存放在Register中，如j rd</li><li>jal，J型指令，<strong>注意这个指令有两个操作</strong>，一个如普通的j一般跳转到L，另一个是$ra &#x3D; PC + 4（存放返回地址，所以这个指令常用于过程调用）</li></ol><p><code>一般性的规律是，助记符，都是J型</code></p><h4 id="MIPS汇编代码"><a href="#MIPS汇编代码" class="headerlink" title="MIPS汇编代码"></a>MIPS汇编代码</h4><p><code>这一小节主要是掌握MIPS汇编代码的编写的常见结构，包括分支结构、循环结构、还有过程调用</code></p><h5 id="1-分支结构"><a href="#1-分支结构" class="headerlink" title="1.分支结构"></a>1.分支结构</h5><p>分支结构主要有如下两种：</p><ol><li><code>if(i == j) or if(i != j)</code>这种等或不等，主要使用<code>bne</code>,<code>beq</code>进行</li><li><code>if(i &lt; j)</code>这种大于小于的关系，主要使用<code>slt</code>与<code>bne</code>,<code>beq</code>进行</li></ol><p>下面是两个例子<br>eg1</p><pre><code>if(i == j)f = g + helse f = g - h</code></pre><p><code>$s1&lt;-i $s2&lt;-j  $s3&lt;-f  $s4&lt;-g $s5&lt;-h</code></p><pre><code>start: bne $s1,$s2,else       add $s3,$s4,$s5       j exitelse:  sub $s3,$s4,$s5exit:  ...</code></pre><h5 id="2-循环结构"><a href="#2-循环结构" class="headerlink" title="2.循环结构"></a>2.循环结构</h5><p>这里以while循环为例<br>eg</p><pre><code>while(i != k)&#123;    x = x + a[i];    i = i + 1;&#125;</code></pre><p><code>$s1&lt;-x $s2&lt;-i $s3&lt;-k  $s5&lt;-a</code></p><pre><code>loop: beq $2,$3,exit      sll $s7,$s2,2 #注意这行，不能直接将i &lt;&lt;= 2 （Bits -&gt; Byte）      add $s7,$s5,$s7      lw $s6,0($7)      add $s1,$s1,$s6      addi $s2,$2,1 #注意这行，i = i+1（Bits）      j loopexit: ...</code></pre><p>注意，将偏移i换算为地址的时候要乘4，换算成对应按字节编址的情况</p><h5 id="3-过程调用"><a href="#3-过程调用" class="headerlink" title="3.过程调用"></a>3.过程调用</h5><p>首先我们应该清楚整个过程调用的执行过程：</p><ol><li>P保存相应的寄存器（$t）</li><li>P将参数放置于Q可以访问的位置（$a）</li><li>P将返回位置保存，从而让Q可以执行返回（$ra）</li><li>P修改栈帧（$sp $fp）切换到Q的栈帧</li><li>Q将P的相关寄存器进行保存（$s、$ra、$fp）</li><li>Q为自己的局部变量分配栈帧空间</li><li>执行Q的过程</li><li>返回P（使用P最开始保存的$ra，或者是Q自己保存的$ra）</li></ol><p>注意，以上是以最严格、完整的过程来叙述的，实际上都是根据需要来进行。于是可以做以下几点说明：</p><ol><li>P是根据需要保存$t的，如果可以确保之后不再使用，不保存也行，对应了Q可以随意使用$t</li><li>如果参数多于4个，$a不够用了，需要将参数放到相应的栈帧中（如果必要的话$a也可以与$t类似，由P保存）</li><li>$ra的保存实际上是用jal来隐式执行的</li><li>在MIPS中$fp,$sp不一定都要修改，通常是只修改$sp，然后以其作为参考即可，当$fp需要修改的时候，$fp &#x3D; $sp + 栈帧空间大小</li><li>Q也是根据需要保存，如果要使用$s的话必须保存，如果自己还要进行过程调用（会修改$ra、$fp，那么也应该自行保存）</li><li>由于MIPS通用寄存器非常多，$t就多达10个，通常不需要将局部变量分配到栈帧中，直接使用寄存器即可</li><li>…</li><li>返回时总是使用$ra，如果Q中间执行了过程调用修改了$ra，当Q的调用返回时，应该根据Q保存的P的$ra值，将$ra进行还原；并且需要先释放Q的栈帧空间，通常可以使用$sp &#x3D; $fp（如果开始时修改了$fp，同样嵌套调用时若Q修改了$fp，在Q的调用结束时要先将$fp还原，就像$ra一样），或$sp &#x3D; $sp - 栈帧空间，来释放Q的栈帧；最后使用jr $ra返回P的执行。</li></ol><p>以上几点说明都是针对最开始描述的每一点过程进行的</p><p>下面还有一些需要补充的点</p><p>Ⅰ MIPS中栈帧是由高地址到低地址，这意味着分配栈帧空间对$sp执行的是减法操作</p><blockquote><p>eg:在栈帧中分配空间，保存$ra,$a0</p></blockquote><pre><code>subi $sp,$sp,8sw $a0,4($sp)sw $ra,0($sp)</code></pre><p>Ⅱ 一般只有在由数组或结构体等占用空间较大的复杂数据结构的时候才需要使用栈帧分配局部变量（$t不够用）</p><p>Ⅲ Q没有进一步嵌套调用其它函数的情况，Q被称为叶子过程。一般的叶子过程通常在MIPS中甚至不需要开辟栈帧，因为有足够多的通用寄存器</p><p>Ⅳ 如果$fp不使用（建立当前函数的栈帧时并没有维护$fp），可以将$fp作为$s8来使用</p>]]></content>
      
      
      
        <tags>
            
            <tag> 大学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k-means</title>
      <link href="/2025/05/01/k-means/"/>
      <url>/2025/05/01/k-means/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> 聚类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Py_learning</title>
      <link href="/2025/05/01/Py-learning/"/>
      <url>/2025/05/01/Py-learning/</url>
      
        <content type="html"><![CDATA[<p><code>由于我在学习机器学习算法的时候，希望通过Python来对相关的算法进行复现。而自己在此之前其实零零散散不成体系地接触过Python语言，也了解一些基本的东西，但是对于Python中一些语言“特性”方面的东西所知甚少，例如变量的作用域与生命周期，不同模块间的访问等等；此外我对Python风格的代码写法也并不熟悉，其实写什么感觉都是C的味道......于是写下这篇blog用来记录，进一步对相关内容的学习</code></p><h2 id="模块化的Python程序"><a href="#模块化的Python程序" class="headerlink" title="模块化的Python程序"></a>模块化的Python程序</h2><h3 id="内置变量-name"><a href="#内置变量-name" class="headerlink" title="内置变量__name__"></a>内置变量__name__</h3><p>__name__是python模块当中的一个内置变量，每个模块都有。如果你选择当前模块开始执行，那么当前模块内置的__name__会被置为__main__；如果一个模块是被令一个模块import进去的，那么这个模块的__name__会被置为__模块名__，但是不会引入后缀。</p><h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><p>通过__name__我们就可以将我整个项目文件模块化的组织起来。将一个模块作为程序的执行入口，并始终自我约束地从这个模块开始启动整个项目程序。这样做的关键在于使用如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>:</span><br><span class="line">    something</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == __main__:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p><strong>关键点即，不要使用判断__name__以外的任何顶层代码</strong></p><h3 id="一些特性"><a href="#一些特性" class="headerlink" title="一些特性"></a>一些特性</h3><p>Python是一种解释性语言，特点就是不需要编译，而是在运行时通过解释器逐行读取、分析和执行源代码。对应的特点之一就是交互式的编程环境（可以在命令行中输入代码，并立刻看到执行的结果）</p><p>我联想到与这种特点相对应的就是——“顶层代码”，即相关的语句不会被封装在任何函数和类当中，点击运行，便会至上而下地逐行开始执行。</p><p><strong>所以一个关键的特性就是，使用import导入模块化后，该模块的顶层代码会立刻执行。</strong></p><p>启示：编写规范化的工程代码时，除了判断程序执行入口，不要使用顶层代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#k_means.py</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;this is k_means&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#main.py</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;this is mainn&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ == main:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>输出结果：</p><p><code>this is k_means this is main</code></p><h2 id="变量的作用域和生命周期"><a href="#变量的作用域和生命周期" class="headerlink" title="变量的作用域和生命周期"></a>变量的作用域和生命周期</h2><h3 id="单一模块"><a href="#单一模块" class="headerlink" title="单一模块"></a>单一模块</h3><ol><li><p>全局变量<br>在同一模块当中，定义于模块层的变量（顶层代码部分），对应的是<code>global varible</code>全局变量，这些变量的作用域是全局可见，生命周期是从程序开始执行开始，执行完毕结束。</p></li><li><p>局部变量<br>定义于函数中的变量是<code>local varible</code>局部变量，作用域局部可见。对于嵌套函数，外层变量对内层可见，内层对外层不可见。在Python中这种函数嵌套更加的显然。下面是一个例子：</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">outer_function</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;this is outer&quot;</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner_function</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;this is inner&quot;</span>)</span><br><span class="line">    inner_function()</span><br></pre></td></tr></table></figure><p>对应变量的生命周期，都是从定义自己的函数开始，到函数执行完毕结束。</p><p><strong>另外值得一提的是，在上面这个例子当中，inner_function不能从顶层代码调用。</strong><br>3. 内置变量<br><code>Built-in varible</code>内置变量的作用域是在任何地方都可以访问，且生命周期贯穿整个程序的运行期，最开始提到的__name__就是一个很好的例子。<br>4. 访问规则<br>python对于变量遵循<code>LEGB</code>的访问规则，即局部、嵌套、全局、内置。当发现了变量，即刻使用。</p><p>最后简单补充以下Python的变量定义规则，变量在“第一次赋值”时被定义。当然这意味着我们要定义一个变量必须考虑一个初始值，如果暂时没有初始值的话可以使用<code>None</code>作为初始值。随后根据需要赋予想要的初始值即可。当然，变量的类型也是根据你赋予的值来确定的。</p><h3 id="多模块"><a href="#多模块" class="headerlink" title="多模块"></a>多模块</h3><p>为了理解多模块情况下相关变量的作用域和生命周期，引入以下概念：</p><ol><li><p>模块对象，在导入模块的时候Python会为模块创建一个对象，这个对象的生命周期由其作用域确定</p></li><li><p>全局导入，模块对象在全局作用域中导入，此时模块变量生命周期同程序一样。作用域同全局变量。</p></li><li><p>局部导入，模块对象在局部作用域中导入，此时模块变量生命周期同导入了它的函数。作用域同相应的局部变量。</p></li><li><p>模块中的顶层代码在被导入时会立刻执行，相应的对应的全局变量会即刻创建，所以对应的全局变量生命周期、作用域，同模块对象。</p></li></ol><p><del>口语化的来说，模块被导入的时候也相当于一个变量（或者是一个类），如果是被主函数所在的模块作为全局变量导入，那么被导入模块的生命周期、作用域同全局变量，如果被作为局部变量导入，也同局部变量。相应的，被导入的时候，被导入模块中的“全局变量”也会即刻被创建，其生命周期同被导入的模块。</del>（毫不精准的表述…）</p><h2 id="名称冲突"><a href="#名称冲突" class="headerlink" title="名称冲突"></a>名称冲突</h2><p>在使用以下代码的时候，名称冲突时常发生。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> somemodule <span class="keyword">import</span> somename</span><br></pre></td></tr></table></figure><p>这类似是跳过了模块对象，直接导入了其中某个全局变量，自然就很可能与当前模块已有的全局变量、函数发生名称冲突。</p><p>常用的解决方法，也是我们使用模块化的常用方法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> somemodule</span><br><span class="line">somemodule.somename <span class="comment">#使用模块对象名来访问相应的变量、函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> somemodule <span class="keyword">import</span> somename <span class="keyword">as</span> another_name <span class="comment">#或者是别名</span></span><br></pre></td></tr></table></figure><h2 id="列表生成式"><a href="#列表生成式" class="headerlink" title="列表生成式"></a>列表生成式</h2><p>语法如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list_name = [formula <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(start, end)]</span><br><span class="line">list_name = [x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>)]</span><br></pre></td></tr></table></figure><p>这种创建列表的方法成为列表生成式，formula是用于生成列表的表达式，可以是返回一些值的函数，后面的循环是列表中生成元素的次数，循环一次便会调用一次formula。</p><p>当然formula也可以直接是数学表达式，例如第二个例子展示的，用于生成1到9的平方的列表。</p><p>注意end不被包含在内。</p><h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><p>元组（Tuple）是一种内置的数据结构，属于不可变序列类型，用于存储多个元素。与列表（List）不同，<strong>元组一旦创建，其内容就不能更改（即不可变）</strong>。元组常用于存储一组相关的数据，例如函数返回多个值时，可以使用元组来打包这些值。</p><h3 id="元组的创建"><a href="#元组的创建" class="headerlink" title="元组的创建"></a>元组的创建</h3><p>使用<code>()</code>来创建一个元组，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个空元组</span></span><br><span class="line">empty_tuple = ()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个包含多个元素的元组</span></span><br><span class="line">example_tuple = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">&quot;hello&quot;</span>, <span class="number">4.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个单元素的元组（注意逗号）</span></span><br><span class="line">single_element_tuple = (<span class="number">1</span>,)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以省略小括号，直接用逗号分隔元素</span></span><br><span class="line">another_tuple = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问元素</span></span><br><span class="line"><span class="built_in">print</span>(example_tuple[<span class="number">0</span>])  <span class="comment"># 输出 1</span></span><br><span class="line"><span class="built_in">print</span>(example_tuple[<span class="number">3</span>])  <span class="comment"># 输出 &quot;hello&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取元组的长度</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(example_tuple))  <span class="comment"># 输出 5</span></span><br></pre></td></tr></table></figure><h3 id="元组的常见用途"><a href="#元组的常见用途" class="headerlink" title="元组的常见用途"></a>元组的常见用途</h3><ol><li>多值返回，用于让函数返回多个值</li><li>作为字典的键，这是由于元组的不可变性</li></ol><h2 id="函数的参数以及返回值"><a href="#函数的参数以及返回值" class="headerlink" title="函数的参数以及返回值"></a>函数的参数以及返回值</h2><p>在python中函数的参数不需要提前声明类型，同样的返回值也不需要提前进行声明。但是在大型的项目中为了便于程序的维护，以及提供静态的检查，可以使用注解符号。例如，下面这个例子。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span>, <span class="type">Tuple</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">k_means</span>(<span class="params">D:<span class="type">List</span>[<span class="type">List</span>[<span class="built_in">float</span>]], n:<span class="built_in">int</span>, k:<span class="built_in">int</span></span>) -&gt; <span class="type">Tuple</span>(<span class="type">List</span>[<span class="type">List</span>[<span class="type">List</span>[<span class="built_in">float</span>]]], Lsit[<span class="type">List</span>[<span class="built_in">float</span>]])</span><br></pre></td></tr></table></figure><p>其中typing是类型注解使用的包，如果不需要使用类型进行注解可以不使用这个包。</p><p>常见的类型注解有：</p><ol><li>List     eg: List[int]</li><li>Tuple    eg: Tuple[float,str]</li><li>Dict     eg: Dict[int,str]</li><li>Set      eg: Set[str]<br>还有许多可用的…用到再查吧…</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Clustering-learning-route</title>
      <link href="/2025/04/30/Clustering-learning-route/"/>
      <url>/2025/04/30/Clustering-learning-route/</url>
      
        <content type="html"><![CDATA[<p><code>我从现在开始学习聚类相关的内容，最终目标是希望发表一篇相关的论文。我以现在浅显的眼光给自己定下的学习路线如下</code><br><code>1. 完成西瓜书聚类部分的学习，完成的标志是将书上给出的伪代码进行真实地复现</code><br><code>2. 阅读综述论文，了解聚类对应的科研领域当前大概的情况</code><br><code>3. 阅读聚类有关的顶会论文......</code><br><code>我以现在的知识，无法继续制定下面的计划了，因为我并不了解3、往后的真正开始着手科研工作会是怎样的。我目前粗浅的想法是，或许我会了解到一些聚类的具体应用，然后为了完成一篇相关的论文：我也必须将聚类投入到具体的应用当中去，这个时候我不得不学习一些其它领域的知识（当然，目前我并不清楚那些会是什么）；又或许我会做一些对聚类算法进行改进的工作，但是这或许会更加艰难（因为曾经一位厉害的学长告诉我将A运用于B会比将A升级为A+简单许多）</code><br><code>此外，我将这篇blog用作自己的学习日志与计划路线</code></p><h2 id="阶段一"><a href="#阶段一" class="headerlink" title="阶段一"></a>阶段一</h2><p>2025.4.30</p><ol><li>学习西瓜书上有关聚类的基础知识（概念、性能指标）</li><li>学习“k均值算法”、学习“学习向量量化算法”</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 聚类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Clustering-watermelon-book</title>
      <link href="/2025/04/30/Clustering-watermelon-book/"/>
      <url>/2025/04/30/Clustering-watermelon-book/</url>
      
        <content type="html"><![CDATA[<h2 id="聚类任务简介"><a href="#聚类任务简介" class="headerlink" title="聚类任务简介"></a>聚类任务简介</h2><p>简单地说，就是要对一个n维向量元素的集合求一个划分，划分后的子集就是一类的（不相交的簇）。</p><p>对于数据集$D &#x3D; {x_1,x_2,…,x_m}$，划分为k个不相交的集合$C_1, C_2, …, C_k$，若$x_i \in C_j$，则$\lambda_i &#x3D; j$，其中$j \in {1,2,…,k}$，对应$\lambda_i$就是$x_i$的标签。聚类任务要做的是就是求出一个聚类结果$\lambda &#x3D; (\lambda_1,\lambda_2,…,\lambda_m)$，其中$\lambda$为数据集的簇标记向量，第$i$个分量标记了$x_i$属于哪一个簇。</p><h2 id="性能度量"><a href="#性能度量" class="headerlink" title="性能度量"></a>性能度量</h2><p>怎样的聚类是好的：</p><ol><li>簇内的样本尽量相似</li><li>簇间的样本尽量不同</li></ol><h3 id="外部指标"><a href="#外部指标" class="headerlink" title="外部指标"></a>外部指标</h3><p>外部指标：将聚类结果和某个“参考模型”进行比较，称为外部指标</p><p>对于数据集$D &#x3D; {x_1,x_2,…,x_m}$，使用聚类模型A，得到簇标记向量$\lambda$，另外使用参考聚类模型B，得到簇标记向量$\lambda^{*}$。</p><p>于是我们可以根据$\lambda_i$与$\lambda_j$相同与否的关系以及$\lambda^{<em>}_i$<br>与$\lambda^{</em>}_j$是否相同的关系定义如下集合。</p><p>$DD,DS,SD,SS$一共四个集合，这些集合中的元素类似$(x_i,x_j)$，是一个“向量对”，分别按照如下规则界定类似的向量对是否属于相应的集合</p><ol><li>$x_i$与$x_j$在模型A、B的划分下都属于同一簇，则$(x_i,x_j) \in SS$</li><li>$x_i$与$x_j$在模型A、B的划分下都不属于同一簇，则$(x_i,x_j) \in DD$</li><li>$x_i$与$x_j$在模型A划分下属于同一簇，在B划分下不属于同一簇，则$(x_i,x_j) \in SD$</li><li>$x_i$与$x_j$在模型A划分下不属于同一簇，在B划分下属于同一簇，则$(x_i,x_j) \in DS$</li></ol><p><code>D即different，S即same 这样就非常容易理解了</code></p><p>根据上面的集合，我们可以定义如下过度变量</p><ol><li>$\lvert SS \rvert &#x3D; a$</li><li>$\lvert SD \rvert &#x3D; b$</li><li>$\lvert DS \rvert &#x3D; c$</li><li>$\lvert DD \rvert &#x3D; d$</li></ol><p>进一步，我们定义常用于性能度量的第一组系数</p><ol><li><strong>JC系数</strong> $JC &#x3D; \frac{a}{a+b+c}$</li><li><strong>FMI系数</strong> $FMI &#x3D; \sqrt{\frac{a}{a+b} \ast \frac{a}{a+c}}$</li><li><strong>Rand指数</strong> $RI &#x3D; \frac{2(a+b)}{m(m-1)}$</li></ol><p>这些性能指标的范围都是$[0,1]$，并且越大说明聚类效果越好<br><code>当然，前提是参考的模型是“正确”的</code></p><h3 id="距离计算"><a href="#距离计算" class="headerlink" title="距离计算"></a>距离计算</h3><h4 id="闵可夫斯基距离"><a href="#闵可夫斯基距离" class="headerlink" title="闵可夫斯基距离"></a>闵可夫斯基距离</h4><p>定义函数$dist(\cdot,\cdot)$，用于计算两个向量的距离。则它应该满足下述三个性质</p><ol><li>非负性</li><li>对称性</li><li>直递性</li></ol><p>常用的距离是闵可夫斯基距离</p><p>$dist_mk(x_i,x_j) &#x3D; (\sum_{\mu &#x3D; 1}^{n} \lvert x_{i\mu} - x_{j\mu} \rvert ^{p})^{\frac{1}{p}}$<br>显然当$p &#x3D; 2$时即我们常用的欧氏距离，$p &#x3D; 1$时为曼哈顿距离</p><h4 id="有序属性和无序属性"><a href="#有序属性和无序属性" class="headerlink" title="有序属性和无序属性"></a>有序属性和无序属性</h4><p>在考虑属性之间的距离的时候，序十分重要。这里通过简单的例子引入有序和无序。属性值出自于能够直接计算距离的属性称为有序属性，例如属性定义域为${1,2,3}$，而不能的就是无序属性，例如${货车,西瓜,乐乐}$。</p><p>显然，闵可夫斯基距离是用于衡量有序属性的距离的。</p><h4 id="VDM——衡量无序属性的距离"><a href="#VDM——衡量无序属性的距离" class="headerlink" title="VDM——衡量无序属性的距离"></a>VDM——衡量无序属性的距离</h4><p>假设有$k$个样本簇，$m_\mu,a$表示在属性$\mu$上取值为$a$的样本的个数，$m_\mu,a,i$表示在第i个样本簇中，属性$\mu$取值为$a$的样本个数。定义VDM如下。</p><p>$VDM &#x3D; \sum_{i&#x3D;1}^{k} \lvert \frac{m_\mu,a,i}{m_\mu,a} - \frac{m_\mu,b,i}{m_\mu,b}\rvert ^{p}$</p><p>值得注意的是，这里衡量的只是无序属性的距离，而要衡量两个无序样本$x_i$与$x_j$的距离，即其中的各个属性（类比向量的分量）都是无序属性，我们应该对各个属性的$VDM$求和。</p><h4 id="混合元素的距离"><a href="#混合元素的距离" class="headerlink" title="混合元素的距离"></a>混合元素的距离</h4><p>不失一般性，我们可以定义混合元素的距离如下：<br>$MinkovDM_p(x_i,x_j) &#x3D; (\sum_{\mu&#x3D;1}^{n_c} \lvert x_{i\mu} - x_{j\mu} \rvert ^{p} + \sum_{\mu&#x3D;n_c+1}^{n} VDM_p(x_{i,\mu},x_{j,\mu}))^{\frac{1}{p}}$</p><p>其中$x_i,x_j$为混合属性的元素，$1到n_c$对应为有序属性，$n_c到n$对应为无序属性</p><h3 id="内部指标"><a href="#内部指标" class="headerlink" title="内部指标"></a>内部指标</h3><p>于是我们可以根据元素的不同（有序、无序、混合），选取我们需要的距离函数$dist(\cdot,\cdot)$，定义如下常用于刻画簇的性质的量</p><ol><li>$\mu_i &#x3D; \frac{1}{\lvert C \rvert} \sum_{1 \le i \le \lvert C \rvert} x_i, \mu &#x3D; (\mu_1,\mu_2,…,\mu_m)$为簇$C$的中心点</li><li>$avg(C) &#x3D; \frac{2}{\lvert C \rvert (\lvert C \rvert - 1)} \sum_{1 \le i &lt; j \le \lvert C \rvert} dist(x_i,x_j)$ 簇$C$内样本间的平均距离</li><li>$diam(C) &#x3D; max_{1 \le i &lt; j \le \lvert C \rvert} dist(x_i,x_j)$ 簇$C$内样本间的最远距离</li><li>$d_{min}(C_i,C_j) &#x3D; min_{x_i \in C_i,x_j \in C_j} dist(x_i,x_j)$ 簇$C_i$和簇$C_j$中最近样本的距离</li><li>$d_{cen}(C_i,C_j) &#x3D; dist(\mu_i,\mu_j)$ 簇$C_i$和簇$C_j$的中心点距离</li></ol><p>进一步我们定义一些内部指标如下。</p><ol><li>$DBI &#x3D; \frac{1}{k} \sum_{i&#x3D;1}^{k} max_{j \ne i}(\frac{avg(C_i)+avg(C_j)}{d_{cen}(\mu_i,\mu_j)})$</li><li>$DI &#x3D; min_{1 \le i \le k} { min_{j \ne i}(\frac{d_{min}(C_i,C_j)}{min_{1 \le l \le k} diam(C_i)}) }$</li></ol><p>DB指数越小越好，Dunn指数越大越好</p><h2 id="原型聚类"><a href="#原型聚类" class="headerlink" title="原型聚类"></a>原型聚类</h2><p>原型的概念对应的是空间中的点。原型聚类的前提是认为，数据集中的聚类结构可以通过一组原型来描述。而原型聚类要做的就是通过某些方法找出这组“原型”。常见的原型聚类算法的代表有<code>k-means（k均值算法）</code>、<code>学习向量量化算法</code>等等</p><p>在后续的blog中会记录我复现相关算法的过程</p>]]></content>
      
      
      
        <tags>
            
            <tag> 聚类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Traceroute</title>
      <link href="/2025/04/27/Traceroute/"/>
      <url>/2025/04/27/Traceroute/</url>
      
        <content type="html"><![CDATA[<p>这篇blog用于记录我在学习计算机工程系统导论时，一个与网络有关的实验。</p><h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><ol><li>学习Ping和Traceroute工具的使用，能够在网络开发和维护中熟练使用该工具获取网络状态和进行错误排查。</li><li>巩固课堂学习的因特网分层设计实现知识，理解因特网的分组转发网络的特性，通过分析互联网数据包因转发而产生的时延，加深理解尽力而为的因特网设计思想。</li><li>通过分析ICMP协议，学习在分层设计中进行跨层通信的设计实现方法，思考因特网网络层在错误处理上的折中设计和处理技巧。</li><li>通过Traceroute工具基于错误处理包进行路径探测功能的设计，体会在实践中体会设计方案在解决问题的同时是如何带来新的设计机会的。</li></ol><h2 id="实验过程与习题"><a href="#实验过程与习题" class="headerlink" title="实验过程与习题"></a>实验过程与习题</h2><h3 id="ping应用"><a href="#ping应用" class="headerlink" title="ping应用"></a>ping应用</h3><ol><li><p><strong>用不超过200字简要概括ping命令</strong><br>ping命令用于向主机或网关发送请求，使用的是ICMP协议的ECHO_REQUSET数据包，并且会接收ICMP ECHO_RESPONSE作为回应。其中ECHO_REQUSET数据包包含了IP和ICMP头部，其后是一个timeval结构以及若干的填充字节。ping命令支持IPv6以及IPv4协议，其中对IPv6节点的信息查询是根据RFC4620进行的，但是由于IPv6源路由被起用，中间跳点可能不被允许。<br><em><code>man ping</code>结果如图1所示</em></p></li><li><p><strong>说明实验现象背后的原因</strong><br>我使用ping命令，分别对<code>www.sud.edu.cn</code>和<code>www.ouc.edu.cn</code>进行了10次<code>ping</code>操作，每次都发送了56字节的数据包。从结果可以看出，到<code>www.sud.edu.cn</code>的网络连接是通畅的，每一次都成功受到了回复，没有丢包发生。但是延迟时间在10.9ms-170ms之间不等，这可能是由于网络拥塞或者其它网络干扰因素导致的。但是发送到<code>www.ouc.edu.cn</code>始终没有得到回复，可能是因为OUC的网络配置了防火墙或者其它网络安全策略，阻止了<code>ping</code>请求。<br><em>实验现象如图2所示</em></p></li><li><p><strong>通过查询资料，画出所使用ICMP数据包的结构</strong><br>其中相关部分说明如下<br>(1)Type，8bits，用于指定ICMP消息类型，例如0表示<code>Echo Reply</code>，8表示<code>Echo Requset</code><br>(2)Code，8bits，用于对消息类型进行更详细的说明，例如目的地不可达，网络不可达等等<br>(3)Checksum，16bits，用于错误检查<br>(4)Identifier，16bits，用来匹配请求和响应<br>(5)Data，可变长度，包含可选的附加数据。<br><em>ICMP数据包如图3所示</em></p></li></ol><h3 id="traceroute应用"><a href="#traceroute应用" class="headerlink" title="traceroute应用"></a>traceroute应用</h3><ol><li><p><strong>不超过200字简要概括traceroute命令</strong><br>traceroute可以用于追踪数据包从源主机到目标主机的网络路径中，它通过发送一个含有TTL字段的IP数据包进行工作，数据包每传递到一个路由器TTL就会减1，当TTL为0的时候路由器就会丢弃该数据包，并给源主机发送一个ICMP（超时响应），其中包含了当前路由器的地址。traceroute在整个工作流程中会从TTL为1开始发送数据包，每次收到ICMP响应后就增大TTL值（2、3、4…），直到收到目的主机的响应。于是根据每一次收到的ICMP响应，traceroute就可以知晓从源主机到目标主机经过的每个路由器，并且显示相应的IP地址和响应时间。<br><em><code>man traceroute</code>结果如图4所示</em></p></li><li><p><strong>确定并说明从源计算机到<code>www.baidu.com</code>的路径</strong><br>源计算机到<code>www.baidu.com</code>实现路径探测，结果如下图如下图，一共经过了30跳，其中第一跳<code>172.19.0.1</code>是源计算机ip，第三、四、五跳<code>10.149.32.1</code>和<code>10.70.7.2</code>以及<code>10.90.0.4</code>是内部网络路由器，之后经过了若干公网路由器，最终到达目标服务器。显示为<code>***</code>的，可能是由于网络设备被配置为了不响应ICMP请求，所以路径不能完全确定。<br><em><code>traceroute www.baidu.com</code>结果如图5所示</em></p></li><li><p><strong>说明输出结果每个字段的意义</strong><br>(1)<code>traceroute to www.baidu.com (182.61.200.108)</code>为traceroute命令输出说明，目标的IP地址为182.61.200.108<br>(2)<code>30 hops max</code>指最多经过30跳<br>(3)<code>60 byte packets</code>指每个数据包大小为60字节<br>往下是每一跳的详细信息，以第一跳为例<br>(4)<code>1 1(172.19.0.1) 0.647ms 1.041ms 1.285ms</code><br>第一个数字1代表第一跳，172.19.0.1代表第一跳的设备IP，后续三个时间是三个ICMP包的往返时间；后续存在<code>***</code>的输出对应没有收到该跳的ICMP回复（或者是网络拥塞导致的丢包）。</p></li></ol><h3 id="traceroute探索"><a href="#traceroute探索" class="headerlink" title="traceroute探索"></a>traceroute探索</h3><p><code>注：这部分实验，我先是在自己本地的电脑上进行的实验，所以后续的描述是根据本地的输出来的，实验截图也是使用的本地截图</code></p><ol><li><strong>解释traceroute 18.31.0.200的输出</strong><br>通过这条指令，我们使用traceroute追踪了一条从本地网络，通过ISP、NAT字段、跨越国际骨干网再进入教育和研究网络的传输路径，最终到达了目标IP（18.31.0.200）</li></ol><p>以下按照每一跳对路径进行分析<br>(1)（1-3跳）<br>hop1是本地网络，hop2、hop3是私有IP（10.x.x.x），可能对应内部网络路由器、防火墙等<br>(2)（4跳）<br>显示为<code>***</code>，路由器没有响应ICMP请求（或者是丢包）<br>(3)（5-12跳）<br>hop5-hop12对应的是公网地址，数据包是在ISP网络中传输的（211.64.x.x和101.4.x.x地址段对应ISP或骨干网提供商，100.64.x.x属于共享地址空间，通常用于ISP内部的网络地址转换）<br>(4)（13-30跳）<br>hop13对应<code>***</code>同样可能没有响应ICMP请求或丢包；hop14开始数据包进入国际网络，延迟有显著的增加（20ms左右，到后续数百毫秒）；hop19开始数据包进入了亚洲太平洋先进网络（APAN网络），之后进入了教育和研究网络（Internet2），可以看到最后已经显示出了较高的延迟（200~400ms左右）<br><em><code>traceroute 18.31.0.200的输出</code>结果如图6所示</em><br>2. <strong>说明从源地址到<code>www.baidu.com</code>和到<code>cn.bing.com</code>的网络路径差异</strong><br>两者的网络路径在初始几跳上有共同点（除去<code>***</code>，至少前10跳是相同的），在进入外部网络之后，路径显然会分道扬镳（除去<code>***</code>，从第14跳开始不相同）；到<code>cn.bing.com</code>后续经过了一些国际骨干网，（例如202.97.x.x的IP地址属于中国电信骨干网），而到<code>www.baidu.com</code>主要是在国内网络中传输的。<br><em><code>traceroute www.baidu.com</code>与<code>traceroute cn.bing.com</code>的结果如图7、8所示</em><br>3. <strong>如果IPv6上实现路径探测，应该使用包头的哪个字段</strong><br>在IPv6网络中进行路径探测，主要依赖IPv6包头中的Hop limit字段，这个字段是“跳限字段”，其作用和IPv4中的TTL（生存周期）字段相同，用来限制数据包在网络传输的跳数，每经过一个路由器，这个字段的值都会减1，当减为0后数据包就会被丢弃，并且通常会返回一个ICMPv6的超时消息给源地址。</p><h2 id="遇到的问题及解决方法"><a href="#遇到的问题及解决方法" class="headerlink" title="遇到的问题及解决方法"></a>遇到的问题及解决方法</h2><p>在实验过程中我主要遇到了问题是在<code>ping www.ouc.edu.cn</code>始终无法收到返回的结果，掉包率总是100%。经过查阅相关资料，我推测应该是我们学校的服务器配置了防火墙或者其它安全策略，拒绝向ping发送的数据包进行响应。并且我使用<code>traceroute www.ouc.edu.cn</code>尝试追踪，我发现结果从第7跳开始往后始终都只返回<code>***</code>，这间接作证了我的猜测。（因为它们都使用的ICMP数据包）<br><em>结果如图9所示</em></p><h2 id="课后实验与思考"><a href="#课后实验与思考" class="headerlink" title="课后实验与思考"></a>课后实验与思考</h2><h3 id="Traceroute在网络故障排查中有哪些应用场景"><a href="#Traceroute在网络故障排查中有哪些应用场景" class="headerlink" title="Traceroute在网络故障排查中有哪些应用场景"></a>Traceroute在网络故障排查中有哪些应用场景</h3><p>Traceroute的主要应用场景有路径发现（它可以用于追踪整个网络路径）、网络延迟分析（可以识别在哪一条引入了延迟，可以判断哪一条延迟较大）、故障点识别（确定数据包在哪一条丢失或无法到达，例如<code>***</code>的出现可能就是这个原因）、路由问题诊断（找到可能存在的路由环路）、网络性能评估（综合以上功能可以进行网络性能评估）等</p><h3 id="Traceroute中如何通过修改参数来优化网络诊断效果"><a href="#Traceroute中如何通过修改参数来优化网络诊断效果" class="headerlink" title="Traceroute中如何通过修改参数来优化网络诊断效果"></a>Traceroute中如何通过修改参数来优化网络诊断效果</h3><p>(1)修改初始TTL值<br><code>traceroute -f 5 example.com</code> 使用参数f可以完成这种操作，用来跳过已知的安全路径<br>(2)设置最大TTL值<br><code>traceorute -m 20 example.com</code> 使用参数m可以完成这种操作，用于避免弹错过长的路径<br>(3)修改探测包的数量<br><code>traceroute -q 5 example.com</code> 使用参数q可以完成这种操作，用来减少或增加探测粒度</p><p>其它的还有使用不同的协议、修改探测包的端口号等等</p><h3 id="Traceroute交换源节点和目标结点，在同一时刻探测到两条路径是相同的吗"><a href="#Traceroute交换源节点和目标结点，在同一时刻探测到两条路径是相同的吗" class="headerlink" title="Traceroute交换源节点和目标结点，在同一时刻探测到两条路径是相同的吗"></a>Traceroute交换源节点和目标结点，在同一时刻探测到两条路径是相同的吗</h3><p>由于网络路由的动态性、负载均衡、多路径路由等因素，网络路径一般是非堆成的，即A到B的路径和B返回A的路径可能会经过不同的路由器以及有不同的跳数。所以一般情况下上述两条路径不会相同</p><h2 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h2><p>通过本次实验我掌握了<code>ping</code>和<code>traceroute</code>命令的基础使用方法，例如<code>traceroute</code>的一些常见参数的使用（f、m、q、l等）。并且能够分析两条命令的输出信息，例如ping命令输出的掉包率、时延等等，通过这个过程，我更深刻地体会了网络的结构，以及数据包在网络上传递的整个过程。此外我还了解了两条命令的基本实现原理，例如traceroute就是不断通过增大ICMP数据包的TTL，使其能够传播得更远，并每一次都记录返回的响应，最终形成完整的路径，作为信息进行输出。最后，我掌握了ICMP数据包的结构，对数据包有了更加清晰的认识。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法——树</title>
      <link href="/2025/02/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%A0%91/"/>
      <url>/2025/02/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="如何输入一棵树"><a href="#如何输入一棵树" class="headerlink" title="如何输入一棵树"></a>如何输入一棵树</h2><p>在这里记录一些算法题中常见的树的输入方法</p><p>*输入格式一<br>第一行输入一个正整数n，代表树中结点的数量。<br>第二行输入n个正整数w1…wn，代表i点的权重<br>接下来n行，每行输入两个整数，其中第i行的li、ri表示i点的左儿子与右儿子，若为-1则表示不存在。</p><h2 id="如何存储一颗树"><a href="#如何存储一颗树" class="headerlink" title="如何存储一颗树"></a>如何存储一颗树</h2><p>在这里记录常见的树的存储方法</p><p>*存储方式一<br>我们可以使用一个树结点的结构体，通过将这些结构体使用指针连接起来，从而构建一棵完整的树。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">tree_node</span>&#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    tree_node * ls;</span><br><span class="line">    tree_node * rs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>unity锚点</title>
      <link href="/2025/02/03/unity%E9%94%9A%E7%82%B9/"/>
      <url>/2025/02/03/unity%E9%94%9A%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="如下"><a href="#如下" class="headerlink" title="如下"></a>如下</h2><p>参考文章<a href="https://blog.csdn.net/Terie/article/details/111433486">https://blog.csdn.net/Terie/article/details/111433486</a></p><p>透过这篇博客，我大概了解到了两个点：<br>pviot：轴心，采用相对坐标系，(0,0)-&gt;(1,1)，位于某ui的方框内，其表征着在ui被自适应缩放的时候，以哪个位置为标准缩放</p><p>锚点：unity提供了三种模式<br>1、四个锚点合在一起的模式<br>该模式下，在屏幕分辨率改变的过程当中，ui相对于锚点的位置不改变，ui的宽、高也不变</p><p>2、四个锚点两两在一起的模式<br>该模式下，ui的对应对于锚点连成的线的距离不改变，宽高比不改变，随之缩放</p><p>3、四个锚点分开的模式<br>该模式下，ui的四个边对应锚点连线矩形的四边距离不改变，宽高随着四向距离的改变，自适应。</p><p>一般情况下，设置Canvas的UI为随屏幕缩放的模式，理解pivot，记住不同位置的ui常用的锚点模式和放置位置就好。</p><p>一下是gpt的建议：<br>a. 确定元素的锚点<br>对于屏幕边缘的UI元素（如按钮、面板），将其Anchors设置在父容器的相应边缘。例如：<br>左上角的按钮：Anchors设为（0，1）到（0，1）<br>右上角的按钮：Anchors设为（1，1）到（1，1）<br>底部中央的按钮：Anchors设为（0.5，0）到（0.5，0）<br>b. 中央对齐的元素<br>对于中心对齐的UI元素（如中心的面板），将其Anchors设置在父容器的中心。例如：<br>中央面板：Anchors设为（0.5，0.5）到（0.5，0.5）<br>c. 保持宽高比例<br>在Inspector中勾选Canvas Scaler组件的“UI Scale Mode”选项，设置为“Scale With Screen Size”，并设置参考分辨率为你设计时的分辨率（如1920x1080）。这样Unity会根据屏幕分辨率自动缩放UI元素。</p>]]></content>
      
      
      
        <tags>
            
            <tag> unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文阅读：基于复杂港口环境下的无人船自主靠泊最优控制方案研究</title>
      <link href="/2024/10/27/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%EF%BC%9A%E5%9F%BA%E4%BA%8E%E5%A4%8D%E6%9D%82%E6%B8%AF%E5%8F%A3%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E6%97%A0%E4%BA%BA%E8%88%B9%E8%87%AA%E4%B8%BB%E9%9D%A0%E6%B3%8A%E6%9C%80%E4%BC%98%E6%8E%A7%E5%88%B6%E6%96%B9%E6%A1%88%E7%A0%94%E7%A9%B6/"/>
      <url>/2024/10/27/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%EF%BC%9A%E5%9F%BA%E4%BA%8E%E5%A4%8D%E6%9D%82%E6%B8%AF%E5%8F%A3%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E6%97%A0%E4%BA%BA%E8%88%B9%E8%87%AA%E4%B8%BB%E9%9D%A0%E6%B3%8A%E6%9C%80%E4%BC%98%E6%8E%A7%E5%88%B6%E6%96%B9%E6%A1%88%E7%A0%94%E7%A9%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="论文阅读过程当中新了解的知识"><a href="#论文阅读过程当中新了解的知识" class="headerlink" title="论文阅读过程当中新了解的知识"></a>论文阅读过程当中新了解的知识</h2><p>1、无人船MMG模型：<br>一种用于模拟和分析船舶在水中运动行为的数学模型。</p><p>MMG模型的基本思想是将船舶的运动分解为船体本身、推进系统（如螺旋桨）和舵等操纵装置的独立贡献，然后将这些贡献综合起来，以描述船舶的整体运动。</p><p>主要包括四个部分：<br>船体动力学模型：描述船体在水中的基本运动特性，包括水动力、惯性力和阻力等。<br>螺旋桨模型：描述推进装置（如螺旋桨）对船舶的推力和转矩输出，这些输出通常与螺旋桨的转速和船速等参数相关。<br>舵模型：描述舵对船舶的横向力和转矩输出，这些输出通常与舵角和水流速度等参数有关。<br>干扰力模型：包括环境中的风、浪、流等对船舶运动的影响。</p><p>2、横荡、纵荡和艏摇：<br>横荡（Sway）：<br>横荡指船舶沿着横向（即垂直于船体中心线）的运动。对于一艘在水中的船舶来说，横荡运动通常是侧向的滑动，可能由于外部作用力（如侧风、侧流或舵面调整）而发生。横荡是三自由度（3-DOF）船舶动力学模型中的一个重要运动分量。<br>纵荡是指船舶沿着船体中心线方向的运动，即船舶的前进或后退运动。纵荡通常由船舶的推进装置（如螺旋桨）提供的推力驱动。纵荡运动决定了船舶的航速变化，在无人船中，通过调整纵荡速度可以实现对速度的控制和调整。<br>艏摇是指船舶围绕垂直轴的旋转运动，即船首（艏）左右摇摆的运动。艏摇角度的变化决定了船舶的航向。艏摇运动通常是由舵角调整或推进系统产生的转矩导致的，它是船舶操纵中控制航向的重要参数。无人船的自动导航系统会通过控制艏摇运动来实现精确的航向调整和路径跟踪。<br>3、航向角 艏摇角 舵角 漂流角 绝对风舷角和相对风舷角</p><p>4、无量纲化处理 运动参数和无量纲参数的对应关系<br>无量纲化处理的核心思想是通过适当选择基准量（如长度、时间、质量等），将物理量转换为无量纲量。这样做的目的是减少方程中的变量数量，揭示系统的内在规律，并使得不同尺度的系统可以进行比较和分析。</p><p>选择一组基准量，例如特征长度。无量纲变量的定义：将原始变量除以相应的基准量。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 论文学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>srdp</title>
      <link href="/2024/10/17/srdp/"/>
      <url>/2024/10/17/srdp/</url>
      
        <content type="html"><![CDATA[<h2 id="关于srdp"><a href="#关于srdp" class="headerlink" title="关于srdp"></a>关于srdp</h2><ol><li>srpd在别校算是校级大创，国级与省级大创会在推免阶段很有优势</li><li>文章只有认可度较高的才会有影响因子，EI和会议期刊这些认可度不高，不过这些对本科生而言还是比较有难度，SCI中有影响因子</li><li>出国、企业就业一般看JCR</li></ol><h2 id="相关方向"><a href="#相关方向" class="headerlink" title="相关方向"></a>相关方向</h2><p>海洋技术；<br>声学：声信号数据处理、算法<br>光学：仿真、数据处理、算法<br>遥感：遥感信息数据处理、算法</p><p>光科：<br>光谱、光电结合（单片机）、光学设计等</p><p>电子信息：<br>单片机、算法等</p><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><p>Web of Science、中国知网、ScienceDirect、小绿鲸、截屏翻译APP</p><p>刚入门的直接看SCI会比较困难，最好从硕博文章开始看，在看SCI之前最好先看三篇博士文章（600多页）</p><p>看英文文章可以用小绿鲸，不用应用软件，用官网主页。截屏翻译、小绿鲸是看SCI时用到的，前期看博士文章最好。</p><p>GPT可以用，但是写出来的东西一定要自己看得懂。</p><p>zlibrary中有很多参考书，很好用。多运用CSDN、GitHub</p><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><p>国创、省创注意截至日期，中期的时候会有一个机会用来申请国创、省创，最好要把srdp升一个台阶，不要原原本本地交srdp。</p><p>理工科相关的公式要熟悉（明白如何推导的，或者说如何产生的）</p><p>流程：<br>10、11月立项（撰写立项书、制作ppt、填写系统、准备立项答辩）-&gt;4、5月中期检查（省创国创立项）-&gt;10、11月结项（省创国创中期检查）-&gt;4、5月省创国创结项</p><p>如果目标国创、省创的话最好前期干完百分之60到百分之80，除此之外一定要干满工作量，否则会延期，得不偿失。</p><p>选题的话主要看指导老师。</p><p>制定开发计划（敏捷开发计划）、迭代开发（要先有一个成果，逐步迭代，迎接变化）、定期开会（要和老师同步）、共同开发</p><h2 id="相关语言"><a href="#相关语言" class="headerlink" title="相关语言"></a>相关语言</h2><p>Origin（画图好用）、Latex、MathType（打字母公式）、Office…</p><h2 id="选题"><a href="#选题" class="headerlink" title="选题"></a>选题</h2><p>小发明、小制作、小设计；实际教学中的综合性、设计性、创新性、应用性课题</p>]]></content>
      
      
      
        <tags>
            
            <tag> 大学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>按位运算相关内容</title>
      <link href="/2024/10/16/%E6%8C%89%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9/"/>
      <url>/2024/10/16/%E6%8C%89%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="logs"><a href="#logs" class="headerlink" title="logs"></a>logs</h2><p>目前的打算是先更新思路，然后在有图片处空出，后续补充图片。</p><h2 id="使用算数右移实现逻辑右移"><a href="#使用算数右移实现逻辑右移" class="headerlink" title="使用算数右移实现逻辑右移"></a>使用算数右移实现逻辑右移</h2><p>以int 32位为例</p><p>我们清楚，当进行算数右移的时候，对于符号位为1的情况下，右移之后符号位、第32位的1，被移动到31位后，32位右被补上了1</p><p>而逻辑右移与之不同的是，逻辑右移后，最高位、32位会被补0</p><p>现在要用算数右移实现逻辑右移，看代码：</p><pre><code>x = x &gt;&gt; n;y = ~((1 &lt;&lt; 31) &gt;&gt; n &lt;&lt; 1);  x = x&amp;y;</code></pre><p>1、x符号位为0，算数右移动n位后，x为 0..（n+1个0）XXXXXXX…<br>2、x符号位为1，算数右移动n位后，x为 1..（n+1个1）XXXXXXX…<br>而对于逻辑右移n位后，无论x符号位是0还是1，都是算数右移中1、的情况</p><blockquote><p>所以我们只需要：x &#x3D; x&amp;0..（n+1个0）1111..1就可以将算数右移的结果转换为逻辑右移的结果。<br>关键在于凑出掩码0..（n+1个0）1111..1，即y处的操作。</p></blockquote><h2 id="分治法求二进制数中1的个数"><a href="#分治法求二进制数中1的个数" class="headerlink" title="分治法求二进制数中1的个数"></a>分治法求二进制数中1的个数</h2><p>分治法的思想：一个复杂的问题分解成若干个规模较小但相似的子问题，“递归”地解决这些子问题，然后将这些子问题的解组合起来，得到原问题的解。</p><p>让我们先以8位二进制数为例子：</p><blockquote><p>原问题：11011110 整体这个数（或者说“一”部分）有几个1<br>分解：求 1101 1110 两部分，分别有几个1<br>分解：求 11 01 11 10 四部分，分别有几个1<br>分解：求 1 1 0 1 1 1 1 0 八部分，分别有几个1</p></blockquote><p>显然，对于上一个问题，各个部分的数字0 or 1就代表了这个部分有几个1，即八个部分时各个部分有几个1已经清楚。最小问题的答案已知，考虑如何利用将最小问题的答案合并，求解上层的问题。</p><p>注意：“各个部分的数字0 or 1就代表了这个部分有几个1”正是八部分时最大的特点，记住这个特点，因为我们的目标是“让‘一’部分时，该部分的数字就代表该部分有几个1。”</p><p>下面开始合并，使用到的关系是：上一个问题中各个部分有几个1 &#x3D; 当前问题中相邻两个部分1的个数相加</p><p>采用上面的关系对问题合并，我们会发现每解决一个问题后，问题中各个部分的数字，就代表原来该部分有几个1。</p><blockquote><p>合并： 四部分状况的问题的答案：10 01 10 01<br>合并： 二部分状况的问题的答案：0011 0011<br>合并： “一”部分（原问题）的答案：00000110</p></blockquote><p>根据前面的描述，00000110即原本1的个数。</p><p>下面是具体的实现代码</p><pre><code>cin&gt;&gt;xint x1,x2,x3,x4,x5,s,m;s = x &gt;&gt; 1;m = ~((1 &lt;&lt; 31));x1 = s&amp;m;x = (x &amp; 0x55555555) + (x1 &amp; 0x55555555);s = x &gt;&gt; 2;m = ~((1 &lt;&lt; 31) &gt;&gt; 1);x2 = s&amp;m;x = (x &amp; 0x33333333) + (x2 &amp; 0x33333333);s = x &gt;&gt; 4;m = ~((1 &lt;&lt; 31) &gt;&gt; 3);x3 = s&amp;m;x = (x &amp; 0x0F0F0F0F) + (x3 &amp; 0x0F0F0F0F);s = x &gt;&gt; 8;m = ~((1 &lt;&lt; 31) &gt;&gt; 7);x4 = s&amp;m;x = (x &amp; 0x00FF00FF) + (x4 &amp; 0x00FF00FF);s = x &gt;&gt; 16;m = ~((1 &lt;&lt; 31) &gt;&gt; 15);x5 = s&amp;m;x = (x &amp; 0x0000FFFF) + (x5 &amp; 0x0000FFFF);return x;</code></pre><p>关键在于理解如何实现“上一个问题中各个部分有几个1 &#x3D; 当前问题中相邻两个部分1的个数相加”之中，相邻两部分相加。<br>不难想到，我们可以使用掩码。<br>例如：</p><blockquote><p>01010101和10101010（相邻的两位相加，结果为四部分状况答案）<br>x &#x3D; x&amp;0b01010101 + x&amp;0b10101010<br>00110011和11001100（相邻的四位相加，结果为两部分状况答案）<br>x &#x3D; x&amp;0b00110011 + x&amp;0b11001100<br>00001111和11110000（相邻的四位相加，结果为“一”部分状况、最终答案）<br>x &#x3D; x&amp;0b00001111 + x&amp;0b11110000</p></blockquote><p>当然这只是对最开始用例的解释，对于具体的计算机当中的int类型，32位可以如此类比。<br>最终我们需要合并使用当前问题的答案求解上一个问题5次（32 &#x3D; 2^5），对应代码中5处使用了掩码的位置。<br>值得一提的是，也可以在一次计算当中不更换掩码，但是要将x左或右移（逻辑右移！）对应的位数，就像我在代码中的那样。</p><h2 id="按位运算实现对数值变量实现逻辑Not"><a href="#按位运算实现对数值变量实现逻辑Not" class="headerlink" title="按位运算实现对数值变量实现逻辑Not"></a>按位运算实现对数值变量实现逻辑Not</h2><p>具体要求：对于数值型数据x，若x &#x3D;&#x3D; 0x00000000，则输出 0b00000000000000000000000000000001，否则输出0b00000000000000000000000000000000<br>注：上面的常数均为补码值，用于做相等的比较的时候也是用的x的补码值，而非真值。</p><p>思路：对于非0数，其相反数的符号位一定与原数的符号位不同。考虑原数与相反数相或后考虑符号位的情况，来判断x本身是否为0。</p><h2 id="7-fitsBits-判断x可否使用n位补码表示"><a href="#7-fitsBits-判断x可否使用n位补码表示" class="headerlink" title="7 fitsBits 判断x可否使用n位补码表示"></a>7 fitsBits 判断x可否使用n位补码表示</h2><p>思路：<br>1、我们知道n位补码的表示范围是-2^n~2^n-1，因此我们需要判断x是否在这个范围之内。<br>2、在当前环境下，x是由32位二进制补码储存在计算机当中的，我们不难发现：如果x只需要n位补码，那么在计算机当中前面的32-n位补码是空闲的，所以我们可以将x在计算机当中的补码，先左移32-n位，再右移动还原，通过判断这样操作之后得到的补码与x的补码是否仍然相同，来判断x是否只需要n位补码<br>3、最后加上一点补充，来更好地这个问题：<br>上面的思路对于正数来说是可以直接使用的，并且也是好理解的（因为闲置位置上的补码都是0，包括符号位也是0）</p><p>但是对于负数而言，最高位是1（符号位），我们或许会下意识认为，对于实际上的计算机而言，（从右往左，以下都是）第32位是没有闲置的，对于只需要n位补码的负数x，在32位的环境下，实际上被闲置的是第31位到第n位，而非和正数一样的第32位到第n+1位。进一步，我们会下意识认为，闲置的位置都是0，那么第31位是0，一旦左移符号位1就会被弃置，而再左移回来时在大多数情况下，符号位都只会是1，而认为由于32位环境最高位表示负数符号位的特殊性，导致了对于负数这样的“左移右移”无法解决问题。</p><p>显然，这样的理解是错误的，举个简单的反例，-1在32位中的补码是111…11（32个1），并非我们理解的闲置位置是0，所以其实对于一般的负数，我们会发现当它只需要n位补码表示的时候，在32位的环境下，其闲置的位置都是1，这样就不会出现我们认为的错误的情况，所以这个方法对于负数也是适用的。</p><pre><code>int l = 32 + ~n + 1; return !(x ^ (x &lt;&lt; l &gt;&gt; l));</code></pre><h2 id="按位运算计算-x-2-n-，向0取整"><a href="#按位运算计算-x-2-n-，向0取整" class="headerlink" title="按位运算计算 x&#x2F;2^n ，向0取整"></a>按位运算计算 x&#x2F;2^n ，向0取整</h2><p>思路：<br>1、首先我们要思考为什么有取整的问题，答案很简单，从一种简化的形式来说，答案可以用“1除以2除不尽（整数范围）”来概括，于是我们要考虑，该如何处理一下，让这个算式有一个结果。处理的方法就是向下取整（1&#x2F;2 &#x3D; 0）或者向上取整(1&#x2F;2 &#x3D; 1)<br>2、为了后面描述方便，我们在此前先看看向上、下取整，在1、在二进制下的形式。<br>不妨考虑（默认二进制，十进制末尾用D表示）奇数：XXXXX11（末位为1），除以2D，即右移1。XXXXX011&#x2F;2D &#x3D; (XXXXX010&#x2F;2D)+1&#x2F;2D，这就回到了1、，且更具有一般性。<br>如果要向下取整即1&#x2F;2D &#x3D; 1，在这个过程当中实际上等效于将1，当作10使用，即对XXXXX011进行了加1操作后进行XXXXX110&gt;&gt;1 &#x3D; XXXXXX11，而不同于原来的XXXXX011&gt;&gt;1 &#x3D; XXXXXX01<br>如果要向上取整，也就是直接抛弃最低位1，仍由右移时将它弃置。<br>3、所以1、中的情况在二进制下实际上就是考虑，要不要让末尾的1在一次右移当中被抛弃，如果是的话则对应向下取整，直接右移即可，如果不是的话则应该加1，让1-&gt;10，从而在除以2D时达到1D当作2D用的效果<br>4、所以一般地，对于除以2^n，即要右移动n次，是否要将前n位可能的1直接抛弃，就对应了是否要向下取整，所以我们直接对原数在前n位分别加上1，确保它们都有“1D当2D用的效果”即可达到向上取整的目的。<br>5、题目要求向0取整，对于正数而言向0取整就是向下取整，对于负数而言是向上取整。所以对正数直接右移n位，对负数在第n位后加1，再右移动n位。</p><h2 id="按位操作求-x"><a href="#按位操作求-x" class="headerlink" title="按位操作求-x"></a>按位操作求-x</h2><p>思路：原数的负数对应的补码，等于原数的补码取反再加1。</p><h2 id="按位运算判断x是否是正数"><a href="#按位运算判断x是否是正数" class="headerlink" title="按位运算判断x是否是正数"></a>按位运算判断x是否是正数</h2><p>思路：<br>1、考虑x的相反数，正数的相反数的补码符号位一定是1，负数及0的相反数的补码一定是0。<br>2、但是注意有一个特殊的负数存在，及-2^(n-1) - 1 &#x3D; -2147483648(32位)，这个负数是在32位补码对应的表示范围之内没有对应的相反数，按照常规的求相反数的补码（按位取反再加1）之后，得到的仍然是它本身，符号位不会改变。<br>3、所以在我们求完x的相反数y之后，只需要在最后查看y的符号（1则x为正，0则x为负或0）时：(y&gt;&gt;31)&amp;1（用于查看符号），加上(y&amp;(y^x)&gt;&gt;31)&amp;1（似乎还有一点问题）即可。因为y^x，的相当于查看x与其相反数的符号位是否相同，如果相同y^x的符号位是0，否则是1，即对-2147483648进行了特判。</p><h2 id="按位运算判断x是否小于等于y"><a href="#按位运算判断x是否小于等于y" class="headerlink" title="按位运算判断x是否小于等于y"></a>按位运算判断x是否小于等于y</h2><p>思路：<br>1、这道题要分三种情况考虑，我最开始想到的是情况1，直接判断x-y（即x + ~y + 1）的符号位是什么，如果是0，则x &gt; y，如果是1，则x &lt; y。<br>2、显然，上面的做法存在问题，很容易发现，无法处理x &#x3D;&#x3D; y的情况，这种情况下，对应x-y的符号位是0，而不同于x &lt; y时题目种要求的1。<br>所以我考虑了第二种情况，x &#x3D;&#x3D; y时，只需要判断!(x^y)的状态，如果是0则，x、y不等，这时交给1、判断，如果是1则x、y相等，只需要将1、2、中两个式子用|连接，如果2、中得到1则会直接得出答案，如果2、中得出0，也不会影响1、中的判断结果（零一律）。<br>3、然而还有一种情况是我们没有考虑到的，那就是在x、y异号的时候，可能出现的overflow，比如-2147483648，让其减去任意的负数，在32位补码的情况下，它都会变成一个正数（符号位为0），而这种情况是只会在x、y异号的时候出现的（同号时，只要是减法，都只会向0靠近，而不会向边界靠近，出现overflow），所以我们只需要和2、中一样，在加上一种情况的式子，并用|与前两个式子连接即可。所加的式子，首先判断x、y是否异号，如果是的话，我们可以直接通过x的符号给出答案，因为负数一定小于正数，所以第三种情况对应的式子是：((x^y)&gt;&gt;31&amp;1&amp;(x&gt;&gt;31&amp;1))，其中(x^y)&gt;&gt;31&amp;1在第一位给出了x、y符号是否相异，如果是的话，为1，后者(x&gt;&gt;31&amp;1)会在第一位给出x的符号；否则为0，整个式子为0，当前的大小情况交给1、2、来判断。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 杂项 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编语言学习日志</title>
      <link href="/2024/10/15/my-first-post/"/>
      <url>/2024/10/15/my-first-post/</url>
      
        <content type="html"><![CDATA[<h2 id="DEBUG模式下几种基本命令"><a href="#DEBUG模式下几种基本命令" class="headerlink" title="DEBUG模式下几种基本命令"></a>DEBUG模式下几种基本命令</h2><p>t 追踪执行命令<br>a 指定内存后（回车）写入指令<br>d 从哪段内存开始 显示多长的内存&#x2F;&#x2F;显示内存中内容<br>e 从哪段内存开始（回车）修改内存<br>u 从哪段内存开始&#x2F;&#x2F;显示翻译后内存中内容</p><pre><code>mov ax,bxadd ax,bxsub ax,bx</code></pre><blockquote><p>注意高八位、低八位，h、l<br>注意数据溢出，加法溢出则舍去，减法不足则借位，指定了高八位、低八位就以对应的两个数字为参考标准确定是否要舍去与借位，不能修改其它数字。</p></blockquote><h2 id="常见的运算符"><a href="#常见的运算符" class="headerlink" title="常见的运算符"></a>常见的运算符</h2><h3 id="mul"><a href="#mul" class="headerlink" title="mul"></a>mul</h3><pre><code>mul bx</code></pre><p>相乘的数都是八位或者都是十六位<br>八位：一个默认放在AL中，另一个放在8位reg或内存中；结果默认放在AX中<br>十六位：一个默认放在AX中，另一个放在16位reg或内存中；结果默认低16位放在AX中，高16位放在DX中。</p><blockquote><p>8位：AL<em>BL &#x3D; AX<br>16位：AX</em>BX &#x3D; DXAX</p></blockquote><h3 id="div"><a href="#div" class="headerlink" title="div"></a>div</h3><pre><code>div bx</code></pre><p>除数：8位、16位（2个数字、4个数字）两种<br>被除数：默认放在AX或DX和AX中，除数为8位则被除数为16位默认放在AX中；如果除数为16位，则被除数为32位，默认放在DX和AX中，DX存放高16位，AX存放低16位。<br>结果：如果除数为8位，则AL中存放结果，AH储存余数；如果除数为16位，则AX存储商，DX存储余数。</p><blockquote><p>除数8位:AX&#x2F;BL &#x3D; AL … AH<br>除数16位：DXAX&#x2F;BX &#x3D; AX … DX</p></blockquote><h3 id="and、or"><a href="#and、or" class="headerlink" title="and、or"></a>and、or</h3><p>以二进制为标准<br>指定8位还是16位进行运算</p><h3 id="shl"><a href="#shl" class="headerlink" title="shl"></a>shl</h3><pre><code>shl ax,1</code></pre><p>shl、shr 左移、右移，超出的舍去，缺少的0补<br>rol、ror 循环左移、右移，超出的补到后面缺少的<br>带进位的循环左移、右移 rcl rcr（了解）<br>以二进制为标准</p><h3 id="inc、dec"><a href="#inc、dec" class="headerlink" title="inc、dec"></a>inc、dec</h3><pre><code>inc axdec ax</code></pre><p>相当于ax++、ax–<br>（进位、借位与普通加减法相同）</p><h3 id="其它杂项"><a href="#其它杂项" class="headerlink" title="其它杂项"></a>其它杂项</h3><p>如果除法除以0会进入一个中断<br>使用int 0也可以进入这个中断<br>如果除以0是一个错误，会触发int 0的中断，会找到一个地址，代码运行的指针会指向这个地址，接下来或许可以通过在这个地址准备相应的处理方法来解决异常（了解）</p><p>我们需要知道的就是当代码发生错误，代码运行的指针会跳转到其它地址。</p><p>常见的中断编号int 0、int 9</p><h2 id="ds寄存器与地址"><a href="#ds寄存器与地址" class="headerlink" title="ds寄存器与地址"></a>ds寄存器与地址</h2><blockquote><p>物理地址 &#x3D; 段地址*16+偏移地址</p></blockquote><p>DS寄存器，数据段地址寄存器<br>    r ds<br>可编辑DS当中的内容</p><p>配合mov指令使用，如</p><pre><code>mov ax,[60]</code></pre><p>效果会是将DS中的段地址结合[60]偏移地址指向的内容复制给ax<br>[]中对应的都是低位</p><blockquote><p>但是注意：在内存当中字单元的概念，即将一个字型数据（16位）的内存单元，由两个地址连续的内存单元，高地址内存单元（非起始）存放字符型高位字节，低地址内存单元（起始）存放字符型低位字节。<br>如我们将DS设置为21F0后，使用mov指令会将21F0:0060中的内容复制给ax<br>而d 21F0:0060这样显示：<br>12 34<br>则0060为低位，0061为高位<br>所以对应AXL 和 AXH，由此得到ax为3412<br>但是以上内容在使用al、ah等直接对八位操作的时候，对应的物理地址上的八位数会直接被移动到对应位置，而不需要考虑是高地址还是低地址内存</p></blockquote><p>另外</p><blockquote><p>注意：不能使用mov ds，10 00<br>但是可以<br>mov 1000，ax<br>mov ds，ax</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>诗</title>
      <link href="/2020/01/01/%E8%AF%97/"/>
      <url>/2020/01/01/%E8%AF%97/</url>
      
        <content type="html"><![CDATA[<h2 id="壹"><a href="#壹" class="headerlink" title="壹"></a>壹</h2><blockquote><p>《甲辰正月初一为灵泉诸香客赋》<br>水澹金粼雾舞空，烟锁灵山山囚龙。<br>霰尽芳菲行者至，露上凝珠紫气东。<br>父老提携童子笑，诸君揖互彩云从。<br>香火连天今日有，爆竹声毕夕已终。</p></blockquote><p>~</p><blockquote><p>《危勉》<br>黄烛灯火暗凝香，红袖酥肩幻梦长。<br>醉酒吟誐任疏狂，百落临渊战心惶。<br>前路无光路满霜，苦难同尘藏四方。<br>来年不求万事祥，我愿与之较锋芒。</p></blockquote><p>~</p><blockquote><p>《贻君》<br>春秋五载与君识，几经离别未有知。<br>可怜怎奈书生骨，举杯邀酒话无时。<br>今昔难见来日昶，参商共映明月光。<br>高山流水何其多，相见不言别离长。</p></blockquote><h2 id="贰"><a href="#贰" class="headerlink" title="贰"></a>贰</h2><blockquote><p>《秋意尽》<br>秋霜一点红，寒露语松榕。<br>越鸟惊乡客，南巢临北冬。<br>遍揲晓风月，满羽繁星空。<br>择地息未有，淡裁碌日中。<br>何日花前酒，携诗青崖诵。</p></blockquote><p>~</p><blockquote><p>《不意雨》<br>云野伴骄阳，仲夏风曦长。<br>身待雨缦缦，旱久难滂滂。<br>卧阴苇下驻，遮乌泮水旁。<br>念死闲行日，不意甘霖降。</p></blockquote><h2 id="叁"><a href="#叁" class="headerlink" title="叁"></a>叁</h2><blockquote><p>《月夜寄故人》<br>细柳抚荫晓云畔，青山带水过君岸。<br>虽守陌路长相隔，念此故人月上看。</p></blockquote><p>~</p><blockquote><p>《碧波行》<br>见海连天月下开，踏彩逐浪思楼台。<br>台下霓潮绕浪舞，台上金麟为我来。</p></blockquote><p>~</p><blockquote><p>《临钟书阁》<br>长天碧色里，高阁一湖中。<br>传即千古士，行则知无穷。</p></blockquote><p>~</p><blockquote><p>《嘲》<br>携卷履地因风进，卧看长空皓月行。<br>明眸晶莹玉齿杯，蓬头恹面笑长情。</p></blockquote><h2 id="肆"><a href="#肆" class="headerlink" title="肆"></a>肆</h2><blockquote><p>《夏日乱笔》<br>墨上还新山水通，此间独骑临霜松。<br>昨年闻香落笔柔，意与锋芒寄青空。<br>海破日出乾坤动，河汉月邀金乌重。<br>沧浪折煞浮萍起，百波沉浮犬马恸。<br>他日锥断窠臼风，白鹤冲天烟柳中。<br>任子何笑鱼龙游，东风吹我麟阁梦。</p></blockquote><p>~</p><blockquote><p>《闻雨祭剑》<br>鸣剑八尺，柄灼伤伤。<br>血蚀锈迹，斑斑其煌。<br>剑折剑伤，不改剑刚。<br>素钢以铸，可刻金光。<br>百剑之中，其伤为扬。<br>剑鸣剑光，旦列剑榜。</p></blockquote><p>~</p><blockquote><p>《田间乱笔》<br>百日随春尽，新曦按夜来。<br>碧草凝寒露，陌上芳菲开。<br>折枝近门扉，黄䤋扶老待。<br>相论无功名，赤子初心在。</p></blockquote><p>~</p><blockquote><p>《告己书》<br>自负有翅，既委金笼。<br>不绝长空，何异斑鸠！<br>虽离群所，日起当思。<br>衣冠正否，行止绳否。<br>若背师恩，女颜不存。<br>若耽暖衾，女辞为空。<br>而至今日，才非盖世。<br>略有所长，只在微志。<br>今志但弃，形飞神灭。<br>渺渺于世，不知为人。<br>幸生父母，又遇恩师。<br>教吾配兰，视吾圣贤。<br>前见子丘，后瞻东坡。<br>周环吾身，竖子小儿。<br>其钻弥坚？其爱一欢？<br>若以为前，即当顺羽。<br>若就后居，不如便埋！</p></blockquote><p>~</p><blockquote><p>百年征程易难兴，只言片语寥可尽？<br>听罢放翁示儿语，途闻鹏举复国心。<br>鱼耽海者树鸟亲，风化雨兮草木喑。<br>今时往已难可忆，唯叹受多报无冯！</p></blockquote><p>~</p><blockquote><p>《白天野》<br>蹇驴踏寒山，欲寻春可安。<br>此去十二载，未觉铁岭难。<br>路别桃花庵，又至神女山。<br>朱唇抿贝齿，纵邀即日欢。<br>谢蛾眉观，仰首望河汉。<br>心驶沧浪处，欲起罢钓竿！</p></blockquote><h2 id="伍"><a href="#伍" class="headerlink" title="伍"></a>伍</h2><blockquote><p>《夏》<br>微月照鬓角，夏风拂过柳眉梢。<br>微踮首，咧嘴笑，花色泛上白裙脚。<br>又是一年蝉鸣时，荏苒莺飞鸟。<br>犹觉夏日胜好。</p></blockquote><p>~</p><blockquote><p>《览逍遥游有感》<br>余见千里之修厚鲲鹏者，以六月之息，适于南冥，一跃而上九万里，水击三千里。<br>余览其逍遥也，见其适者，天时也，非无所依也。然余谓之，己之限及身之短者，了然于胸，明所适者而享逍遥之微寥，不亦 逍遥也？<br>余见蜩与学鸠，以决起而飞，抢树而至，下鲲鹏之所适者，成其逍遥之逍遥也，特不解鲲鹏之所适者也。<br>余谓之，虽是井底之蛙，然于其身者，乐也，见世间万般皆下品，为己独高。于己之界，所达皆可有，所求皆以应，不亦逍遥 也？<br>且夫不死之椿，长生之冥灵，而宋荣子之辈不亦似鲲鹏哉，或有上中下之境焉也。<br>至于至人，神人，圣人，于天地之间无所适，乘万物之正，驾六气之辩者，余谓之人力所莫能及。然拊度其中，乘万物之正者 ，即庄周所言，物我为一，以天地万物之百变为己之息，如己心之动，血之流者。所适者皆如己出，故无所适也，通透哉！而 御六气之变，且夫游于无穷之中，仙人之谓也，非物力所能及。<br>故吾小儿，斗胆列逍遥之次，小，中，大者也。<br>小之逍遥，所限莫所大焉，然其不见，独达于己，鄙薄万物而如稚童，亦有乐者也。<br>中之逍遥，所限或有见微，然其了然，善适万物，夷其所长善之所短，诚然逍遥也。<br>大之逍遥，所限者于己身，通透明达，处之世间，无所不乐无所不适，此真逍遥也。<br>然三者之上，所能有游于无穷者，特为仙人之所处耳，言之何用？<br>小之逍遥，行年必出，中之逍遥，或死无穷。<br>故吾见中之逍遥亦有三般。<br>一曰，蟪蛄已死，化茧成蝶，初出井底，蓦然之余，惶惶之间，不知所为，旦怀为先，嘲之小儿以自饰，宋荣子之辈也。<br>二曰，明于世间，知所何为，明所不为，朝朝暮暮，施力其中，然有所乐，亦有所乏，或感万物之何为，或冥灵大椿也。<br>三曰，旷达自若，气定神闲，可借薄力，而撼世间，明哲处事，善以待人，乐而长命，无所喟叹无所疲，或鲲鹏之状也。<br>然一者之上，二者之下，或鄙之所谓也，目力有限，思有所疲，略省二者寥寥，而思三者谓何，至于大逍遥者，或愚竭毕生之 力而无以及，乃今之人或有一二，故余妄言，见之可由。余之所望，尽己之力，达于三者而望大逍遥者，仙人之风，果然之间 ，或付诸笑谈一二。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 诗歌 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
