


<!DOCTYPE html>
<html lang="ch">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
	<title>CN-Exercise [ 代码和诗 ]</title>
	
	
	<!-- stylesheets list from _config.yml -->
	
	<link rel="stylesheet" href="/css/PreciousJoy.css">
	
	<link rel="stylesheet" href="/css/top-bar.css">
	
	<link rel="stylesheet" href="/css/menu-outer.css">
	
	<link rel="stylesheet" href="/css/content-outer.css">
	
	<link rel="stylesheet" href="/css/bottom-outer.css">
	
	<link rel="stylesheet" href="/css/atom-one-dark.css">
	
	<link rel="stylesheet" href="/css/recent-posts-item.css">
	
	<link rel="stylesheet" href="/css/article-sidebar-toc.css">
	
	<link rel="stylesheet" href="/css/jquery.fancybox.min.css">
	
	<link rel="stylesheet" href="/css/search.css">
	
	<link rel="stylesheet" href="/css/toc.css">
	
	<link rel="stylesheet" href="/css/sidebar.css">
	
	<link rel="stylesheet" href="/css/archive.css">
	
	<link rel="stylesheet" href="/css/jquery.mCustomScrollbar.min.css">
	
	<link rel="stylesheet" href="/css/Z-last-cover-others.css">
	
	
	
<meta name="generator" content="Hexo 7.3.0"></head>




<body id="wrapper">

	<div id="">
		
		<div id="top-bar">
			
			<div id="avatar-box">
				<img 
				class="avatar"
				src="/images/my-avatar.jpg" //网站头像
				alt="avatar">
			</div>

			<div id="top-bar-text">
				<div id="top-bar-title">
					阳生。
				</div>
				<div id="top-bar-slogan">
					风毛丛劲节，只上尽头竿。
				</div>
			</div>

		</div>

		<div id="menu-outer">
			<div id="menu-inner">
				
				
				<div class="menu-item">
					<a href="/">Home</a>
				</div>
				
				<div class="menu-item">
					<a href="/about">About</a>
				</div>
				
				<div class="menu-item">
					<a href="/archives">Archives</a>
				</div>
				

				<div class="menu-item menu-item-search">
					
  <span class="local-search local-search-google local-search-plugin">
      <input type="search" placeholder="站内搜索" id="local-search-input" class="local-search-input-cls" style="">
      <div id="local-search-result" class="local-search-result-cls"></div>
  </span>
	
				</div>

			</div>
		</div>

		<div id="content-outer">
			<div id="content-inner">

				
<div id="details">
	
	<article id="details-post">
		<div id=details-post-item>
			<h1>CN-Exercise</h1>
			<h2 id="期末重点"><a href="#期末重点" class="headerlink" title="期末重点"></a>期末重点</h2><p><code>根据老师划的重点整理的内容</code></p>
<h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><p>物理层的功能：<br>    ()，为链路层提供服务；</p>
<p>不同信道复用技术的区别：<br>    信道复用技术：<br>        频分复用、时分复用、统计时分复用、波分复用、码分复用；<br>        1）()的各路信号在()占用()（频率带宽而非发送速率）；<br>        2）()的所有用户是在()占用()；<br>        3）()：在频分复用的基础上()，其中要包含()；<br>        4）()：在时分复用的基础上()，其中要包含()；<br>        5）()：使用STDM帧来传送数据，STDM帧()，按需()，其中要()；<br>        （基本原理是一个STDM帧中有多个时隙，但小于总用户数量，用户有想发的数据就往集中器中发，集中器按顺序扫描输入缓冲，放入STDM帧的各个时隙中，当一个STDM帧的数据放满了就发送出去）<br>        6）()就是()，但是由于光的频率很高，所以()而不用频率这一概念，所以描述为波分复用；</p>
<p>FDM、TDM、FDMA、TDMA、STDM哪种效率高：<br>    统计时分复用()，因为其对于每个用户()，总是()，保证()，避免存在时隙有空便发送信号的情况，所以这种效率高；</p>
<h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><p>数据链路层的功能：<br>    ()传输()；</p>
<p>为了实现正确传输数据帧需要解决的<strong>三个基本问题</strong>：<br>    ()、()、()；</p>
<p><strong>封装成帧的含义</strong>：<br>    封装成帧就是在()的前后分别添加()，()，使得接收方能够在收到物理层上交的比特流之后()，()出帧的开始和结束；<br>    （首部、尾部的主要作用是()）；<br>    （帧的数据部分有长度上限()，eg：以太网是()）；</p>
<p><strong>透明传输的含义</strong>：<br>    无论什么样比特组合的数据，都能够按照原样没有差错地通过数据链路层进行正确地传输，不会因为数据中出现了与()相同的比特组合而导致传输的()；</p>
<p><strong>透明传输的方法</strong>：<br>    使用转义字符”()”，十六进制是()；<br>    如果数据中有比特组合呈现出：()或()，则前面加上转义字符；<br>    如果数据中出现了ESC，也在前面加上ESC；</p>
<p><strong>差错检测的含义</strong>：<br>    由于实际通信的链路并非是理想的，存在误码率，为了保证数据传输的()，在计算机网络传输数据时，必须采用的手段，用于检测是否存在差错；</p>
<p>差错检测的方法：<br>    ()；<br>    发送方：<br>        1）原始k位01串数据；<br>        2）()，事先商量好n位；<br>        3）k位原数据+(n-1)个0作为()；<br>        4）被除数对除数进行()；<br>        5）最终得到的()，就是()（帧检验序列）<br>        6）k位原始数据+n-1位FCS，构成()；<br>    接收放：<br>        1）使用()；<br>        2）如果()则没有差错；<br>        3）否则存在差错；<br>    注意：<br>        1）n位除数可以用多项式生成，对应()（因为有个常数）；<br>        2）eg：$p(X) &#x3D; X^3 + X^2$，对应：1100</p>
<p><strong>传输差错：</strong><br>    1）()，()可以避免；<br>    2）帧丢失、帧重复、帧失序；<br>        解决它们意味着：<br>            实现了()：数据链路层发送端发送什么，接收端就接收什么；<br>    注意：<br>        ()可以解决比特差错，但是这并()；</p>
<p>PPP协议的组成：<br>    1）一个将IP数据包封装到串行链路的()；<br>    （既支持()（一连串比特连续传送），又支持()（逐个字符的传输，8bit一字符，没有奇偶校验）<br>    2）用来()的()；<br>    3）一套()<br>    （其中的每个协议支持不同的网络层协议，例如IP、OSI的网络层）</p>
<p>PPP协议的<strong>数据帧</strong>：<br>    首部字段从前往后：<br>        1）标志字段F：()（对应的就是首尾()）；<br>        2）地址字段A：0xFF，固定；<br>        3）控制字段C：0x03，固定；<br>        4）<strong>协议字段：</strong><br>            1）紧接着控制字段；<br>            2）2个字节；<br>            3）表征当前信息字段的含义：<br>                ()，对应()；<br>                ()，对应链路控制协议()；<br>                ()，对应网络层的控制数据（()协议）；<br>    尾部字段从前往后：<br>        1）()，两个字节，使用CRC；<br>        2）标志字段F：0x7E</p>
<p>PPP协议如何完成<strong>透明传输</strong>：<br>    对应的是组成的第一部分的作用（透明传输）；<br>    方法：<br>        <strong>字节填充</strong>：转义字符0x7D；<br>            1）若有()，则修改为：()；<br>            2）若有()，则修改为：()；<br>            3）若有()的字符，则修改为：()；<br>        <strong>零比特填充</strong>：<br>            1）尤其适用于同步传输的场景，传输一连串比特串；<br>            2）对于信息字段，只要发现有()，则填入一个()（填在连续的1后面）<br>    通过这些方法：<br>        在所传送的数据比特流中可以传送任意组合的比特流，而不会引起对帧边界的错误判断；</p>
<p><strong>LCP</strong>链路配置协议的作用：<br>    用来()；</p>
<p><strong>NCP</strong>网络控制协议的作用：<br>    为新接入的用户个人电脑()；</p>
<p>PPP协议的工作状态：<br>    <strong>链路静止</strong>：<br>        1）PPP协议的()，这时用户个人电脑和ISP路由器()；<br>    <strong>链路静止-&gt;链路建立</strong>：<br>        ()通过调制解调器()，路由器检测对应的载波信号，建立()；<br>    <strong>链路建立-&gt;鉴别：</strong><br>        进行()：<br>            链路的()，信息字段携带有特定的()；<br>                eg：<br>                    1）最大帧长；<br>                    2）所使用的鉴别协议；<br>                    3）不使用PPP协议的地址和控制字段；<br>            链路的另一端发送：<br>                1）配置()：所有选项都()；<br>                2）配置()：所有选项都理解但()；<br>                3）配置()：选项有的不能识别或无法接受，需要()；<br>        注意：<br>            如果配置协商失败，<strong>链路建立-&gt;链路静止</strong>；<br>    <strong>鉴别：</strong><br>        该状态只允许()，()的分组以及()质量的分组；<br>        eg：<br>            使用PAP口令鉴别协议：<br>                要求发起通信方，发送身份标识符和口令，系统允许用户重试多次；<br>    <strong>鉴别-&gt;网络层协议：</strong><br>        如果鉴别成功 or 不需要鉴别；<br>        注意：<br>            如果鉴别失败，<strong>鉴别-&gt;链路终止</strong>；<br>    <strong>网络层协议：</strong><br>        PPP协议的()根据网络层不同的协议，()；<br>        （重要的一步，是()的关键，从而让PPP协议两端端网络层在使用不同网络层协议的基础上，仍然使用同一个PPP协议进行通信）；<br>        eg：<br>            如果使用IP协议，则使用NCP中支持IP协议的IPCP（IP控制协议），将其封装成PPP帧，在链路上传送；<br>    <strong>网络层协议-&gt;链路打开：</strong><br>        NCP配置协商完成；<br>    <strong>链路打开：</strong><br>        1）链路的()；<br>        2）也可以发送给回送请求、回送回答对应的()；<br>    <strong>链路打开-&gt;链路终止：</strong><br>        终止请求：<br>            1）数据传输结束后，由链路的一方发送()，请求终止链路；<br>            2）接收到终止请求的一方，发送()，确认终止；<br>            3）转到链路终止状态；<br>        链路故障；<br>    <strong>链路终止-&gt;链路静止：</strong><br>        调制解调器的()；</p>
<p>CSMA&#x2F;CD协议（() 协议）<br>    背景：<br>        计算机之间在数据链路层端到端的通信，是通过总线实现的；<br>            尽力而为：<br>                1）这是无连接的工作方式，适配器对数据帧不编号、不要求确认，仅发送；<br>                2）以太网提供了()（不可靠交付），出现差错是否重传由高层决定；<br>                3）即使()，只是当作新的数据帧传输；<br>            总线传输：<br>                1）共用一个总线，在()只能允许()；<br>                2）()通信；<br>            编码：<br>                使用()，用跳变来代表01<br>                （代表0&#x2F;1的跳变：差分曼彻斯特编码跳变发生在虚线处，有跳变0无跳变1、曼彻斯特编码跳变发生在虚线间，低跳高1，高跳低0）；<br>                （差分曼彻斯特编码实际上会在时钟周期之间用跳变来同步时钟信号）；<br>    CSMA&#x2F;CD协议的作用：<br>        在上述背景下，以太网采用最简单的随机接入，所以需要一个协议来减少冲突发生的概率；<br>        （好像一个没有主持人的会议，大家想发言就发言，但是要找到一个规则，让大家的发言尽可能不同时发生，产生冲突；于是有了CSMA&#x2F;CD协议）；<br>    各部分的含义：<br>        CS：载波监听；<br>            ()，站点不管在发送数据之前，还是在发送数据之中，每个站都必须不停地检测信道；<br>            （在发送之前监听，是为了()）；<br>            （在发送中监听，是为了()）；<br>        MA：多点接入；<br>            说明这是()，许多计算机以多点点方式连接在一根总线上；（这就是一个背景，CS、CD才是协议的实质关键）；<br>        CD：碰撞检测；<br>            ()边发送数据边()信道上的信号()情况；<br>            （当两个站点同时发送数据的时候，总线上信号电压的幅度会变大）<br>    CSMA&#x2F;CD协议的内容：<br>        1）准备发送：网卡从网络层接收数据报，封装成帧；<br>        2）检测信道：<br>            如果网卡监听到()（()，信道上没有信号），则开始传送帧；<br>            如果监听到()，则()信道空闲（从没有信号开始，经过96比特时间）才开始传送帧；<br>            96比特时间称为()；<br>        3）边听边发：<br>            如果在()内一直未检测到碰撞，就认为发送成功（尽管此时可能还没发送完，接着发送完毕即可），回到1）；<br>            （接收方如果发现数据帧有差错就直接丢弃，等待高层来处理）；<br>            如果()内检测到碰撞，就立刻停止发送数据，并按规定发送()，然后适配器执行()，等待r倍争用期之后，回到步骤2）；<br>            如果重传达到()，仍然不能成功，停止重传向上报错；<br>            （在()以太网中，对应的争用期是()，计算如下）；<br>            <img src="/Computer-Network/p1.png" alt="争用期计算"><br>        关键概念：<br>            1）帧间最小间隔，96比特时间；<br>            2）争用期：<br>                1）是对于发送端而言的时间概念；<br>                2）()；<br>                3）这个时间就是发送站发送数据之后，最迟要经过多长的时间才能知道自己发送的数据和其他站发送的数据有没有发生碰撞；<br>            3）截断二进制指数退避算法：<br>                作用：决定冲突后等待，重新开始检测信道的时间；<br>                算法：<br>                    1）从离散集合 $[()]$ 中随机挑选一个数r；<br>                    2）其中 $k &#x3D; min(())$；<br>                    3）推后r倍的争用期（ $r \times RTT$ ），然后开始重新检测信道；<br>                （当重传次数达到16次之后会停止重传，向高层汇报）；<br>            4）强化碰撞：<br>                发送()的人为干扰信号，以便让所有用户都知道现在已经发送了碰撞；<br>            5）最短帧长：<br>                目的：为了确保载波监听可以发现争用期内的冲突；<br>                eg：<br>                    如果某站发送了()，但在发送完毕之前没有检测出碰撞（即载波监听时间内没有发现冲突），但是在向前传播到目的站之前和别的站发生了冲突（目前()以内），因而目的站会接收到有差错的帧，并将它丢弃；但是发送站不知道这个帧发生了碰撞，因而不会重传这个帧；<br>                本质原因：<br>                    1）发送的帧太短了，完全用不了一个争用期的时间；<br>                    2）而载波监听只会在发的时候进行；<br>                    3）如果有冲突发生，理论最迟监听到的时间是一个争用期的时间；<br>                    4）所以至少要让发送时间大于一个争用期；<br>                于是最短帧长：<br>                    () &gt;&#x3D; ()；<br>                注意：<br>                    1）如果发送的数据不足最短帧长，则必须加入一些()；<br>                    2）()的数据都被站点认为是，由于冲突而异常终止的()，收到后会立刻丢弃；<br>                    （()，对应的就是64字节，()）；</p>
<p>相关设备：<br>    <strong>网桥（()）</strong>：<br>        作用：对收到的帧根据()目的地址进行()；<br>        ()，()；<br>    <strong>转发器、集线器</strong>（()）：<br>        ()；<br>    <strong>以太网交换机</strong>（()）<br>        实质：多端口网桥；<br>        工作方式：()；<br>        作用：让相互通信的主机可以独占传输媒体，无碰撞地传输数据；<br>        原理：<br>            多端口负责接收数据和转发数据，自学习构建转发表；<br>            存储支持暂存再发送，从而隔离冲突域，用户尽管往交换机发；<br>        ()，()；<br>    <strong>路由器</strong>（()）<br>        可以()，()；<br>    （如果可以冲突域，考虑平均带宽，<em>练习题目</em>）；</p>
<p>以太网交换机的转发原理：<br>    1）以太网交换机具有()；<br>    2）转发原理：<br>        1）交换机中维护一个()，用来指示对于目的地址是某个MAC地址的数据帧应该从哪个端口发出去；<br>        2）若有一个()发来，数据帧中有（()），并且是从一个交换机可以感知的()的；<br>        3）()表项：<br>            检查该数据帧的()是否在表中，如果()；<br>        4）尝试()：<br>            1）如果表中有目的MAC地址对应的端口号则从()；<br>            2）如果表中没有目的地址对应的端口号，则从除了进入端口号以外的所有端口号()；<br>    注意：<br>        1）广播发送可以保证，目的MAC地址方能够接收到；<br>        2）对于不是目的MAC地址方的，会将这个数据帧丢弃，即()；<br>        3）交换机更新表项的能力就称为()；</p>
<h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>网络层的主要功能：<br>    完成不同网络中的()；</p>
<p>路由器之间传送信息：<br>    1）转发()之间所()（将源主机发送的分组一个一个路由器的转发，直到转发到目的主机）；<br>    2）传送()（根据路由选择协议所使用的路由算法，彼此不断地交换路由信息分组，从而建立路由表）；</p>
<p>ipv4几个类网络地址：<br>    网络地址+主机地址；开头；<br>    1）A：()；0；<br>    2）B：()；10；<br>    3）C：()；110；<br>    其他：<br>        1）D：1110+多播地址；<br>        2）E：1111+实验开发；<br>    注意：<br>        <strong>如何通过开头的地址判断网络类型</strong>；<br>    特殊号码：<br>        1）A类中00000000网络号码，代表()；<br>        2）A类中01111111网络号码，代表()；<br>        （B类、C类没有这个问题）；<br>        3）网络号不为全0主机号为全0，代表()；<br>        4）网络号为全0主机号不为全0，代表()；<br>        5）网络号和主机号均为0，代表()；<br>        6）网络号不为全1，主机号为全1，()；<br>        7）网络号全为1，主机号全为1，代表()；<br>        （注意6、7都可以指广播地址，要注意具体的应用场景）；<br>        8）()，本地主机测试地址；<br>    按照某类地址给<strong>机构划分子网</strong>：<br>        1）可以使用二叉树划分法；<br>        2）注意划分的时候主机号全0全1不能用；<br>        （对应特殊号码的3、6，<em>练习题目</em>）</p>
<p>ARP协议<br>    作用：根据机器的()，找到相应的()，使得数据能够通过链路层传输；<br>    背景：<br>        1）IP地址与MAC地址格式不同，()，不存在简单的映射关系；<br>        2）一个网络上可能经常有新的主机加入进来，或撤走一些主机；<br>        3）更换网络适配器也会使主机的MAC地址改变（主机的()实际上就来自其()）；<br>    ARP协议的思想：<br>        在主机中维护一个()，存放一个从IP地址到MAC地址到映射表，这个映射表可以动态更新（新增或超时删除）；<br>    协议具体工作流程：<br>        1）()：<br>            当主机A要向本局域网的某台主机B发送IP数据包时，检查自己的ARP高速缓存，如果其中有B的IP地址对应的MAC地址，则将数据包封装的MAC帧发送到对应的地址，否则进入2）；<br>            （注意，这一步实际上是没有用到ARP协议的）；<br>        2）运行ARP：<br>            1）ARP进程在杂本局域网上()（其中写入了A自己的IP地址、MAC地址，想要请求的MAC地址对应的IP地址）；<br>            2）局域网上所有运行ARP进程的主机都会收到这个分组；<br>            3）收到ARP请求分组的主机，检查其中请求MAC地址对应的IP地址是否与自己的()，如果一致就向A()；<br>            （注意，ARP请求分组虽然是广播发送的，但是ARP响应分组是单播，因为有A确定的MAC地址）；<br>            （注意，为了()，会采取一种()，即让B在收到A的请求分组后，将A的IP地址和对应MAC地址写入ARP高速缓存中，因为后续B很可能会和A通信）；<br>            4）A收到B的响应分组后，将B的IP地址和对应的MAC地址()自己的ARP高速缓存表中；</p>
<p>ipv4 IP数据包报头：<br>    1）Version（版本号）：<br>        1）()：ipv4；<br>        2）()：ipv6；<br>    2）Header length（首部长度）：<br>        1）标识首部长度，()，ip数据报头()，所以该()；<br>    3）type of service（区分服务）：<br>        1）一般情况下不会使用这个字段；<br>    4）datagram length（数据报）：<br>        1）()，()，该字段是16位，所以ip数据包最长是()；<br>        2）如果ip数据包进行了()，则该字段1是()；<br>    5）identifier（标识）：<br>        1）当ip数据报需要分片的时候，来自于()的分片数据报该()，用来()；<br>        2）实际的赋值机制，是每产生一个数据报计数器就加1（未分片），然后对该数据报进行分片，完成后，将这个字段的值复制到每一个分片；<br>    6）flag（标志）：<br>        1）3位只有()有意义；<br>        2）最低位MF，1代表()，0代表()；<br>        3）中间位DF，1代表()，0代表()；<br>    7）Fragmentation offset（位偏移）：<br>        1）指出分片后，当前()；<br>        2）偏移()，也就是说除了最后一个分片其他分片的长度一定是8的倍数；<br>        3）该字段实际使用的时候，字段值是多少就代表该分片的数据部分，第一个字节，在原始数据中是第()字节；<br>            eg：offset &#x3D; 0，则原来是第一个字节；<br>                offset &#x3D; 1，则原来是第65个字节；<br>        （当然如果直接考虑偏移量，使用第0个字节的表述，并以其作为开头的话，实际上offset<em>8的值就代表，当前分片开始的字节，在原始数据报中是第几个字节）；<br>        4）在分片的时候不能忘记，每个分片都要添加报头，()的时候很重要；<br>        5）但是在计算offset的时候，不能加入报头，()；<br>        6）()；<br>    8）TTL（生存时间）<br>        1）功能是作为()，()不能到达目的地的IP数据报在互联网中()；<br>        2）当数据报到达一个路由器，()，如果等于0则丢弃；<br>        3）如果一个数据报只允许在局域网中转发，那么将TTL设置为1（到达该局域网的路由器的时候，TTL减为0就会被丢弃）；<br>        4）一个数据报能经过（到达）的路由器()；<br>    9）upper-layer protocal（协议）<br>        1）指出当前IP数据报携带的数据来自于什么上层协议；<br>        2）常用的：<br>            ICMP-1；()；()；EGP-8；IGP-9；OSPF-89；<br>    10）check sum（首部检验和）<br>        1）只检验数据报的首部，不包括数据部分；<br>        2）()就要()首部检验和；<br>        3）计算方法是()，相加，()，()；<br>        （接收方检验方法是()，如果()则没有出错，否则认为出错，丢弃；</em>题目练习*）<br>    11）source address（源地址）<br>        1）32位，发送主机的IP地址；<br>        2）32位，接收主机的IP地址；</p>
<p>最长前缀匹配<br>    1）<strong>原则：</strong><br>        在采用CIDR编址时，如果一个分组在转发表中可以找到()，那么就应当()前缀()的一个作为匹配的前缀。这个原则称为最长前缀匹配；<br>    2）思想：<br>        网络前缀越长，其地址块就越小，因而路由越具体；</p>
<p><strong>分组转发算法</strong> 路由表项的排列 特定主机路由 默认路由（若有 若无）<br>    分组转发算法：<br>        1）从收到的分组的首部提取()；<br>        2）查找是否有()，对应该IP地址，若有责直接按照下一跳转发；<br>        3）否则，从转发表中()进行检查：<br>            1）将这一行的子网掩码与目的地址AND运算；<br>            2）如果结果和本行()则按下一跳转发（或直接交付本网络上的目的主机，或转发给下一跳路由器）；<br>            3）如果不匹配则继续检查下一行；<br>        4）如果检查结果均不匹配，则来到最后的()，按照指定的接口进行转发；<br>    一些说明：<br>        关于3）：<br>            1）这里查找转发表的逻辑实际上涉及路由表项的排列；<br>            2）路由表项中按照前缀的长度进行排列，由长到短递减；<br>            3）这样的基础上从上到下检查不断“下一行”检查，本身就契合了最长前缀匹配；<br>            4）这样排列也契合了，先检查特定路由，然后进行匹配，最后考虑默认路由；<br>            （因为特定路由等价于前缀长度32，最长；进行匹配就是前缀长度长到短排列；默认路由0.0.0.0是其子网掩码，实际上就等价于前缀长度是0，最短）；<br>        关于1）、4）：<br>            1）特定主机路由和默认主机路由其实都是可选的，不一定存在；<br>            2）尤其是如果默认主机路由不存在，又找不到转发的接口，那么就会报告转发分组错误；</p>
<p>二叉线索查找转发表：<br>    背景：<br>        1）使用CIDR完成路由聚合后，由于不知道目的网络前缀，让转发表的查找变复杂了；<br>        2）在转发表项目数很大的时候，怎样缩短转发表查找实践是一个非常重要的问题；<br>        3）普通情况，无分类编址的转发表，最简单的查找算法就是对所有前缀进行循环查找，逐行检查网络前缀；<br>    二叉线索查找思想：<br>        1）将无分类编址的转发表存入一种层次数据结构中，然后自上而下地按层次查找；<br>        2）好处就是可以一次排除“一类”前缀，避免不必要的AND运算；<br>    使用方法：<br>        1）用()构造()；<br>        2）是否与()匹配；（对应到叶节点）；<br>        （转发时用目的地址与唯一前缀进行匹配，对目的地址按照高位到低位的顺序，查看0&#x2F;1，选择二叉树上对应的边，从根节点出发持续向下，直到到达叶节点，如果不能到达叶节点则直接丢弃，因为一定没有匹配的前缀）<br>        3）与掩码运算-&gt;是否与()匹配；<br>        （到达叶节点了之后，只是说明唯一前缀匹配上了，还要查看网络是否匹配）；<br>        4）() or 默认转发 or ()；<br>        （如果匹配上了就转发，没有的话看有没有默认转发，没有则丢弃，报错）；</p>
<p>DHCP协议（应用层 C&#x2F;S模式 UDP协议为其提供服务）<br>    作用：<br>        1）()；<br>        2）为()进入一个网络的主机分配()；<br>    工作原理：<br>        1）DHCP ()：<br>            新到来的主机发送DHCP报文：<br>                1）src: ()；（()，()客户端端口）<br>                2）dest: ()；（()，()服务器端口）<br>                3）<strong>yiaddr</strong>: 0.0.0.0；（等待服务器分配的地址）<br>                4） transaction ID：654；（代表这是获得动态主机IP地址的请求报文）；<br>        2）DHCP ()：<br>            服务器收到discover后回复：<br>                1）src：223.1.2.5，67；<br>                2）dest：255.255.255.255，68；<br>                3）yiaddr：223.1.2.4（()）；<br>                4）transaction ID：654；（代表这是回复动态主机IP地址请求的应答）；<br>                5）()：3600（动态IP使用时间）；<br>        3）DHCP ()：<br>            客户端收到offer后再与服务器()：<br>                1）src：0.0.0.0，68；<br>                2）dest：255.255.255.255，67；<br>                3）yiaddr：223.1.2.4；<br>                4）transaction ID：655；（代表这是核实IP的请求）；<br>                5）Lifetime：3600；<br>        4）DHCP ()：<br>            服务器()：<br>                1）src：223.1.2.5，67；<br>                2）dest：255.255.255.255，68；<br>                3）yiaddr：223.1.2.4；<br>                4）transaction ID：655；<br>                5）Lifetime：3600；</p>
<p>RIP协议<br>    基本知识：<br>        1）中文名是()；<br>        2）是一种()的选路协议；<br>        3）RIP适用于小型网络，因为不可达距离只有16；<br>    <strong>距离的定义</strong>（跳数、路由器数）：<br>        1）从路由器到直接连接到网络距离为1；<br>        2）从一个主机到非直接连接到网络距离是()；<br>        （+1是因为直接相连定义了距离为1）；<br>        3）不可达距离 ()<br>    交换信息（特点）：和谁交换信息？交换哪些信息？（1、2、3）何时交换信息（1、2）？<br>        协议是通过交换信息工作的，使用RIP协议的路由器有如下特点：<br>            1）仅和()交换信息；<br>            2）交换的信息是本路由器知道的全部信息，即自己的()（到本自治系统中所有网络的最短距离，对应的下一跳路由器）；<br>            3）按固定的时间间隔交换信息：<br>                1）每隔()秒会交换信息；<br>                2）当网络拓扑结构发生变化时，交换信息；<br>        注意：<br>            1）主机也运行RIP协议的话，它智能被动的接收信息，不能发出自己的信息，因为它没有转发功能；<br>            2）刚开始的时候，路由器中路由表是空的，然后可以直接得出与其直接相连的几个网络的距离（定义为1）；     </p>
<p>距离向量算法：<br>    1）路由器维护的表项目、交换报文（RIP报文）的内容（1、2、3）；<br>        路由器中维护的表项信息，就是交换报文中的主要项目信息；<br>            1）目的网络Neti：代表往这个方向转发的最终目的地；<br>            2）下一跳路由器Ri：要前往目的地下一跳应该向哪个路由器转发；<br>            3）距离d：从当前路由器到达目的地的最终距离；<br>    2）收到报文的操作（项目信息(Neti,Ri,d)）：<br>        1）修改报文项目（1、2）；<br>            1）将Ri改为()；<br>            2）距离d &#x3D; ()；<br>        2）若无目的网络-更新表项目；<br>            如果当前路由器的转发表中没有能够到达Neti的转发表项，则直接将报文项目加入自己的转发表中；<br>        3）若有目的网络-下一跳路由器？<br>            如果当前路由器转发表中有能够到达Neti的表项目：<br>                1）如果对应表项的下一跳是Rj，则直接()；<br>                2）如果对应表项下一跳不是Rj，谁的距离()；<br>    3）3分钟-不可达；<br>        如果3分钟没有收到相邻路由器的更新路由表，则把此相邻路由器，标记为不可达路由器，距离设置为16；<br>    注意：<br>        1）一个RIP报文最多()个路由-()个表项，超过25个报文要再用一个发；<br>        （即实际上上述交换的一个RIP报文，不止有一个表项信息）</p>
<p>坏消息传得慢-例子（RIP报原始内容）<br>    <em>习题练习</em>；</p>
<p>OSPF：<br>    基本知识：<br>        1）使用()协议；<br>    交换信息（特点）：<br>        1）向本自治系统中的所有路由器发送信息，使用()；<br>        2）发送的信息：<br>            1）相邻的所有路由器的()；<br>            2）其中包括链路的度量，用来表示代价；<br>            （可以选择费用、距离、时延等等信息来作为这个度量）；<br>            3）每隔一段时间（30分钟） 或者 链路状态发生变化的时候，向所有路由器使用可靠的洪泛法发送链路状态信息<br>            （和谁交换信息（可靠的洪泛法）、交换哪些信息（1、2）、何时交换信息（30分钟））<br>    注意：<br>        1）实际上，所有的路由器最终都能建立一个()，对应的就是全网的拓扑结构图，并且这个结构在全网范围是一致的；<br>        （最直接的结果就是，可以直接看作在一个静态的图上面做Dijkstra算法搜索最短路，或者说对于我们应试来说，在使用OSPF路由的时候，我们可以直接看哪条路最短，来确定下一跳路由器）；<br>        2）OSPF收敛得快；<br>        3）OSPF能够适用于大规模网络；<br>        4）OSPF能够实现()：<br>            <strong>如果到同一个目的网络有多条相同代价的路径，那么可以将通信量分配给这几条路径；</strong></p>
<p>OSPF使用层次结构区域划分：<br>    好处：在使用洪泛法的时候将链路状态信息的范围局限在一个区域中，而不是整个自治系统，减少整个网络上的通信量；<br>    1）主干区域：<br>        标识符规定()（本自治系统内生效）；<br>    2）其他区域：<br>        主干区域以外的其他各个区域，标识符自定，例如0.0.0.1，0.0.0.2；<br>        （当然都是本自治系统内生效）；<br>    3）相关路由器：<br>        1）主干区域路由器，主干区域内的路由器；<br>        2）区域边界路由器，一个区域的边界路由器，负责将当前区域和其他区域连接起来；<br>        3）自治系统边界路由器，一个自治系统的边界的路由器，负责将当前AS和其他AS连接起来；<br>        注意：<br>            自治系统边界路由器一般在主干区域中，可以同时是主干区域路由器、自治系统边界路由器、区域边界路由器；</p>
<p>OSPF五种类型的分组：<br>    物种类型分组：<br>        1）()（10s一次，40s没有则不可达）；作用？（初始时）；<br>            作用：用来();<br>        2）()；（交换链路状态摘要信息，用来确认哪些没有）；<br>            作用：向邻站给出自己链路状态数据库中所有链路状态项目的摘要信息；<br>        3）()；（针对没有的请求）；<br>            作用：向对方请求发送某些链路状态的详细信息；<br>        4）();<br>            作用：在洪泛法中使用的分组，用来更新全网链路状态；<br>        5）()；<br>            作用：对链路更新分组的确认，也会在洪泛法中使用；<br>    OSPF的工作过程：<br>        1）使用问候分组判断可达与否：<br>            1）相邻路由器每10s必须交换一次问候分组，从而明确哪些邻站是可达达；<br>            2）如果40s没有收到某个邻站的问候分组，则认为不可达，立即修改链路状态数据库计算新的路由表；<br>            （可达是基本要求，只有可达邻站的链路状态信息才会存入链路状态数据库，路由表是根据链路状态数据库计算出来的）；<br>        2）使用其他分组进行链路状态数据库的同步：<br>            同步的概念：<br>                1）不同路由器的链路状态数据库内容是一样的；<br>                2）两个同步的路由器被称作是完全邻接的；<br>                （不完全邻接的路由器可能只是物理上相邻的）；<br>            过程：<br>                1）每个路由器使用数据库描述分组和相邻路由器交换本数据库中已有的链路状态摘要信息；<br>                2）路由器拿到对方的链路状态描述分组后，根据其中内容检查自己缺少的某些链路状态；<br>                3）向对方发送链路状态请求分组，请求对应自己没有的链路状态信息；<br>                4）收到链路状态请求分组的路由器，按照对方请求的链路状态，用单播的方式，将对应链路状态信息发送给请求方；<br>                5）洪泛法的启用：<br>                    1）当一个路由器的链路状态发生变化的时候，开始使用洪泛法发送信息；<br>                    2）路由器对所有相邻的路由器发送自己的链路状态更新分组；<br>                    3）收到该分组的路由器对链路状态更新分组进行转发（转发到排除上游路由器对所有相邻路由器）；<br>                    4）收到链路状态更新分组的路由器，向给自己发送该分组的路由器发送确认信号；<br>                    （确认是可靠的洪泛法所必要的，而OSPF就是采用可靠的洪泛法）；<br>                    （收到重复的更新分组，只用发送一次确认）；</p>
<p>可靠的洪泛法：<br>    1）发送；<br>    2）转发（除了上游）；<br>    3）确认（忽略重复）；</p>
<p>BGP协议：<br>    基本知识：<br>        1）BGP是()；<br>        （RIP、OSPF协议都是内部网关协议）；<br>        2）用于()之间的路由选择；<br>        3）采用的是()路由选择协议；<br>    作用：<br>        选择出一条能够到达目的网络前缀且比较好的路由（不兜圈子），而不是非要计算出一条最佳路由；<br>        为什么不是最佳路由？<br>            1）互联网的规模太大，使得自治系统AS之间的路由选择非常困难；<br>            （例如不同AS中的代价度量不同，比较合理地做法是考虑可达性）；<br>            2）自治系统AS之间的路由选择必须考虑有关策略；<br>            （即考虑多种路由选择策略，包括政治、安全或经济方面；）<br>    相关路由器：<br>        1）AS中有()和()；<br>        2）一个AS至少有一个边界路由器和相邻AS的边界路由器直接相连；<br>        3）正是有了边界路由器，AS之间才能利用协议BGP交换可达性路由信息；<br>    BGP路由的一般格式：<br>        1）这里的路由指的是BGP协议报中有关选路的信息，就类似于RIP报文中的信息；<br>        2）格式：“前缀，BGP信息” &#x3D; “()”；<br>        3）其中：<br>            1）前缀，对应的是BGP路由终点的子网前缀；<br>            2）AS-PATH，是()，通告BGP路由所经过的自治系统；<br>            3）NEXT-HOP，()，对应当前BGP路由的起点；<br>    BGP协议的使用：<br>        1）两个边界路由器建立()连接；<br>        2）边界路由器作为对等端通过()协议互相发送BGP路由；<br>            注意：<br>                1）例如，BGP路由：“X，AS1，R1”，代表可以到达网络前缀位X的网络，经过AS1，下一跳是R1；<br>                2）边界路由器R2就知道下一跳R1，会进入AS1中的，X前缀对应的网络；<br>                3）建立eBGP的两个路由，即不同AS之间的对等端建立了BGP连接；<br>        3）边界路由器收到BGP路由后，更新自己的转发表，然后：<br>            1）与AS内的路由两两之间均建立()连接；<br>                注意：<br>                    1）这种连接是全连通的，即使物理上没有连通；<br>                    2）建立iBGP的两个路由器，即同一AS中的对等端建立了BGP连接；<br>            2）边界路由器通过iBGP将BGP路由发送给AS内的对等端；<br>        3）内部路由器收到BGP路由后，构建转发表：<br>            关键是修改BGP路由中的下一跳信息；<br>            （例如AS2中的R4，不能直接用原始的BGP路由信息中的R1，作为下一跳的转发，因为根本没连接）；<br>            1）通过两次递归查询，找到可用的下一跳路由器；<br>                1）找到非自己所在AS的边界路由器的对等端，即在自己的AS中的边界路由器，且与BGP路由中的边界路由器相连；<br>                （例如R1在AS1中，R4不清楚R1的位置，就找到R1对应的边界路由器R2）；<br>                2）使用IGP（内部网关协议），查询从自己到达边界路由器的最佳路由；<br>                （例如R4要到R2，查看转发表到达R2的最好下一跳发现是R3）；<br>            2）用对应的路由器修改该BGP路由信息，存入自己的转发表中；<br>            （例如，最终BGP路由中有“X，R3”，存放在R4的转发表中）<br>    注意：<br>        1）上面的BGP协议使用，我们主要关注了各个路由器如何使用BGP路由来更新自己的路由表；<br>        2）但是BGP路由的AS信息也是需要维护的，每新到一个自治系统，该AS会被加入BGP路由的AS-PATH中；<br>        （例如上面的例子，最终的”X,R3”，实际上是”X,AS2-AS1,R3”）；</p>
<p>为什么使用BGP？<br>    1）巨大规模的互联网，自制系统AS之间选路；<br>    2）考虑相关策略（可达性而非代价）</p>
<p>BGP使用：()选路策略</p>
<p>BGP报文内容（到达AS1对应的前缀、发送报文的路由器、路由器所在的自治系统AS1）<br>BGP协议路由表（前缀X，下一跳路由器）-含义是下一跳经过路由器，前缀X可达；</p>
<p>eBGP、iBGP（区别，适用路由器）</p>
<p>iBGP的全连通</p>
<p>RIP OSPF BGP区别对比<br>1）RIP不能使用多条路由 OSPF可以()，每一个路由器都知道全网有多少路由器，哪些是相连的，代价是多少；<br>2）RIP、OSPF是工作在()内的 BGP工作在()之间；<br>3）使用的协议不同；<br>4）OSPF在网络层 RIP、BGP在()层（分别由()、()服务）；<br>5）OSPF、RIP属于() 对应BGP；<br>6）OSPF知道全网的拓扑结构，RIP不知道；</p>
<h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>运输层的两个主要协议：<br>    1）()：提供可靠的、面向连接的运输服务；<br>    2）()：无连接，实时、快速高效；</p>
<p>TCP报文中有一个可选项MSS：<br>    这是()字段，代表的是数据字段的最大长度，这个字段要加上TCP首部的长度才是TCP报文的总的最大长度；<br>    <em>考虑这个字段与拥塞控制的关系</em>；</p>
<p>TCP流量控制<br>    1）含义：让发送方的速率不要太快，要让接收方来得及接收；<br>    2）实现方式：()；<br>    3）一些细节：<br>        1）发送方的发送窗口大小不能超过接收方给出的接收窗口()；<br>        2）TCP窗口单位是()不是报文段；<br>        3）当rwnd为0时对应()，发送方不允许再发送数据，直到接收方重新发送一个新的窗口值为止；<br>    4）什么时候会发送零窗口通知：<br>        1）接收端将接收到的数据放入缓冲区，如果上层应用不及时读取，缓冲区满了的时候；<br>        2）当接收方检测到可用窗口为0的时候；<br>        3）出现1、2两种情况的时候发送方在对于先前数据的确认报文中会通知rwnd&#x3D;0；<br>    5）零窗口的死锁问题：<br>        描述：<br>            接收方向发送方发送了零窗口报文段之后不久，接收方释放了一些空间，向发送方发送了rwnd&#x3D;400的报文段；但是报文段在传送中丢失了，发送方一直在等待接收方发送非零窗口报文段，接收方一直在等待发送方发送数据，陷入死锁；<br>        解决方法：<br>            TCP为每个链接设立的——()；<br>            机制：<br>                只要TCP连接的一方收到了零窗口报文段，就启动持续计时器，如果计时器时间到了就发送一个()（仅携带1字节数据），对方会在确认探测报文段时给出当前窗口值，如果仍是零，则重置计时器，否则死锁局面解除；</p>
<p>TCP的拥塞控制<br>    基本概念：<br>        1）拥塞：在某段时间，若对网络中的某一资源的需求超过了该资源所能提供的可用部分，网络的性能就会变坏，这种情况就叫做拥塞。<br>        2）拥塞控制：<br>            1）含义：防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不至于过载。<br>            2）前提：网络能够承载现有的负荷（负载）；<br>            3）特点：这是一个全局性的过程，对比流量控制是点对点的通信量控制（是端到端的过程）；<br>        3）网络负载：提供给网络的负载，也称为输入负载；<br>            （常用于 网络负载-吞吐量 图中）；<br>        4）网络的几种状态（用负载和吞吐量进行判定）：<br>            1）理想情况：吞吐量饱和之前，网络吞吐量&#x3D;网络负载，吞吐量曲线是45度的直线；<br>            2）轻度拥塞状态：网络吞吐量还未到饱和，但是已经有分组被丢弃了，网络吞吐量明显小于理想吞吐量；<br>            3）拥塞状态：网络吞吐量随着负载增减开始减少，而不是理想情况下保持饱和不变；<br>            4）死锁：当网络负载增大到一定数量的时候，吞吐量下降到零；<br>    TCP拥塞控制方法：<br>        假定（理想情况方便讨论算法）：<br>            1）数据是单向发送的，对方只传送确认报文；<br>            2）接收方有足够大的缓存空间，因而发送窗口的大小由网络的拥塞程度来决定；<br>            （实际情况发送方接收窗口的上限 &#x3D; ()，其中rwnd是接收方报文中规定的接收窗口大小）；<br>        基本思想：<br>            1）基于窗口进行拥塞控制，发送方维持一个()，随着网络拥塞程度动态变化，让发送窗口等于拥塞窗口；<br>            2）只要网络没有拥塞，拥塞窗口就可以增大一些以便发送更多的分组，只要出现了拥塞，拥塞窗口就减小一些，以缓解拥塞；<br>        慢开始：<br>            1）设置初始拥塞窗口大小：<br>                1）旧规定：将初始cwnd设置为1～2个SMSS（发送方最大报文长度）；<br>                2）新规定：将初始cwnd设置为2～4个SMSS；<br>                    1）如果SMSS &gt; 2190B，则cwnd &#x3D; 2*SMSS；（不得超过两个报文段）；<br>                    2）如果1095 &lt; SMSS &lt;&#x3D; 2190，则cwnd &#x3D; 3*SMSS；（不得超过三个报文段）；<br>                    3）如果SMSS &lt;&#x3D; 1095，则cwnd &#x3D; 4*SMSS；（不得超过四个报文段）；<br>            2）拥塞窗口增大机制：<br>                1）在每收到一个对新的报文段的确认后，可以把拥塞窗口增加最多一个SMSS的数值；<br>                2）具体来说，拥塞窗口cwnd每次的增加量 &#x3D; ()，其中N是原来未被确认的、但是现在刚收到的确认报文段，所确认的字节数；<br>                3）显然，这种规定下，理想情况cwnd在慢开始阶段是()（每次扩大为原来的两倍）；<br>            3）慢开始阶段的表现：<br>                1）虽然TCP是用字节数作为窗口大小的单位的，但是拥塞控制中为了方便叙述，通常使用报文段个数作为单位；<br>                2）开始时cwnd&#x3D;1；<br>                3）发送方每收到一个对新报文段段确认（对重传的确认不算），cwnd就加1；<br>                4）那么一个RTT后，cwnd&#x3D;2，允许连续发送两个报文段，再一个RTT后收到两个确认，cwnd&#x3D;4，允许连续发送4个报文段，…以此类推；<br>                （注意，显然发送方不是要在所有的确认都收齐了之后才调整其拥塞窗口，而是收到一个确认就调整一下拥塞窗口，这是里面的细节）；<br>            4）慢开始门限()：<br>                1）当cwnd &lt; ssthresh时使用()；<br>                2）当cwnd &gt; ssthresh时停止慢开始算法，启用()；<br>                3）当cwnd &#x3D; ssthresh时，可以选择一个用，决定下一个时刻的行为；<br>        拥塞避免：<br>            1）加法增大：<br>                1）每经过一个RTT的时间，发送方的cwnd大小就()，而不是像慢开始那样成倍增长；<br>                2）这样做可以让cwnd缓慢增大；<br>            2）拥塞避免阶段的表现：<br>                cwnd按()缓慢增长；<br>        超时处理：<br>            1）超时标志：<br>                1）超时重传计时器启动；<br>                2）判断网络出现了拥塞；<br>            2）处理机制：<br>                1）慢开始门限ssthresh设置为()；<br>                2）拥塞窗口置一，cwnd &#x3D; 1；<br>                3）重新开始()；<br>            注意：<br>                1）超时的发生不一定就是网络发生了拥塞，也可能是因为传输出现了差错，而导致分组被丢弃；<br>                2）尽管现代通信线路传输质量都很好，因为传输差错而丢弃分组的概率远小于1%。这也是为什么用超时来判断拥塞，因为超时大概率是拥塞造成的；<br>                3）因此设置了快重传机制；<br>        快重传与快恢复：<br>            1）算法要求：<br>                1）接收方不要等待自己发送数据时才稍带确认，而是在收到报文后立即发送确认；<br>                2）即使收到的失序的报文段也要立即发出对已收到报文段的重复确认；（尽管本来可以什么都不做）；<br>            2）快重传：<br>                1）在接收方一连收到()之后，判断网络没有出现拥塞，但是接收方少了一个报文段M；<br>                2）对方却少的是被重复确认的报文段的下一个报文段，例如重复确认三次M2，那么缺少了M3；<br>                3）发送方立即重新发送接收方缺少的报文段；<br>            3）快恢复：<br>                1）在快重传之后启动快恢复；<br>                2）设置慢启动门限为()；<br>                3）将cwnd减小，通常有两种方法：（这个过程称为()）；<br>                    1）()；（课本上主要阐释的这种）；<br>                    2）()；<br>        <img src="/Computer-Network/p1.jpeg" alt="TCP拥塞控制算法流程图">;</p>
<h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>DNS的作用：<br>    ();</p>
<p>DNS协议依赖的下层协议：<br>    传输层：()；<br>    网络层：IP协议；<br>    数据链路层（以太网）：CSMA&#x2F;CD协议；</p>
<p>HTTP协议依赖的下层协议：<br>    传输层：()；<br>    网络层：IP协议；<br>    数据链路层：CSMA&#x2F;CD协议；</p>
<p>使用一个协议就要封装一个协议的数据包（例如使用DNS协议的时候封装了4层数据包）；</p>
<h3 id="无线网络"><a href="#无线网络" class="headerlink" title="无线网络"></a>无线网络</h3><p>隐蔽站&#x2F;暴露站</p>
<p>CSMA&#x2F;CA协议：<br>    背景：<br>        1）无线局域网使用的数据链路比较特殊，对应的是无线信号的信道，但是和物理链路一样也要考虑信道上信号的碰撞问题，同一时刻同一信道上应该只有一种信号；<br>        2）无线局域网的特点：<br>            1）无线局域网的适配器无法实现碰撞检测；<br>            2）检测到信道空闲，起始信道可能并不空闲；<br>            3）即使我们能够在硬件上实现无线局域网的碰撞检测功能，也无法检测出隐蔽站问题带来的碰撞；<br>        3）所以实际上CSMA&#x2F;CA协议不是载波监听多路复用&#x2F;碰撞检测协议，而是()（尽量减少碰撞发生的概率）；<br>    独特的MAC层：<br>        1）802.11标准为CSMA&#x2F;CA协议中设计了独特的MAC层；<br>        2）其中集成了协调功能所必需的字段：<br>            1）()：分布式协调功能，这是为了后面的争用服务必需实现的字段；（重点）；<br>            2）()：点协调功能，无争用服务选用；<br>    CSMA&#x2F;CA协议要点：<br>        1）站点如果要发送数据，必须先监听信道，如果信道在()内均空闲，则发送整个数据帧；<br>        2）否则，<strong>争用信道</strong>；<br>            站点选择随机数，设置退避计时器；<br>            如果信道忙则冻结计时器；<br>            如果信道空闲，且在DIFS内均空闲，则启动计时器；<br>            当计时器减到零，则发送数据帧；<br>        3）如果发送方站点，接收到却认帧，且后续还有帧要发送，再次进入2），但是要在<strong>更大范围</strong>选择随机数；<br>    要点补充：<br>        1）关于DIFS：假设A給B发送数据帧DATA；<br>            1）B接收到数据帧要发送确认ACK；<br>            2）确认发送时间必然滞后于B接收完DATA的时间，因为有CRC校验等；<br>            3）考虑滞后时间统一设置一个标准为()；<br>            4）那么实际上SIFS这段时间内信道是空闲的；<br>            5）为了保证这段空闲时间内其他站点不发送数据，使用更长的()（分布式协调帧间间隔）；<br>            6）空闲时间其他站点想发送数据必须等待DIFS的时间；<br>        2）关于监听（确定信道在忙的具体方法）：<br>            1）802.11标准要求每个站必须同时使用两个方法；<br>            2）第一是，()（软件实现）：<br>                1）源站（发送站）：将自己占用信道的时间（DATA+SIFS+ACK）写入数据帧；<br>                2）广播范围内的各站能够接收到该信息，创建自己的()，指出信道在忙的时间，除了源站和目的站在这一时间内不能使用信道；<br>            3）第二是，()（物理层实现）：<br>                每个站检测接收到的信号强度是否超过一定门限数值，由此判断是否有其他移动站在信道上发送数据；<br>        3）关于争用期的触发：<br>            1）要发送数据时检测到信道在忙；<br>            2）已发送到数据帧未收到确认，要重传数据帧；<br>            3）发送了一个数据帧要接着发送后续的数据帧；（为了防止一个站点长期垄断信道）；<br>            （其他情况，当站点想要发送数据，并检测到信道空闲时间超过DIFS可以直接发送，不用经过争用期）；<br>        4）争用信道的过程（争用期）：<br>            1）使用争用窗口CW，它由许多时隙组成；<br>                （802.11g规定一个时隙为9微秒，SIFS是10微秒，DIFS是28微秒）；<br>            2）退避：<br>                进入争用期（信道空闲）时，在0～CW的时隙中随机生成时隙个数，设置退避计时器；<br>            3）推迟接入：<br>                1）退避计时器先降为0的，开始发送数据帧，信道转为忙；<br>                2）正在退避的站，冻结计时器，保留数值不变，等待下一次争用期接着继续倒计时；<br>        5）关于争用窗口CW的维护：<br>            1）CW需要增大的两种情况：<br>                1）紧接着发送后续帧；<br>                2）每一次重传；<br>            2）具体操作：<br>                1）在每次增大的时候CW会近似翻倍；<br>                2）例如初始时CW &#x3D; 15 &#x3D; 2^4 - 1，那么第i次增大的时候CW &#x3D; 2^(4+i) - 1；<br>                3）通常802.11建议：CW最小取15，最大取1023，当到达1023之后CW不会再增大；<br>    信道预约技术：<br>        目的：更好地避免()；<br>        具体方法：假设A給B发送数据；<br>            1）对于无线局域网，移动站点都会接入一个AP，用来充当站点之间的中介进行信息转发；<br>            2）A在与B通信之前，A向AP发送()；<br>            3）AP收到之后，经过SIFS，恢复()；<br>            4）其他所有能够收到AP的CTS的站点，都会知道在一段时间内信道被A、B的通信占用，并以此设置其NAV；<br>            （实际上这与前面的虚拟载波监听、载波监听，互为一个补充）；</p>
<h2 id="try-yourself"><a href="#try-yourself" class="headerlink" title="try yourself"></a>try yourself</h2><p><code>if you make sure you&#39;re ready, just try this</code></p>

		</div>

		<!-- 来必力City版安装代码 -->
<div id="lv-container" data-id="city" data-uid="MTAyMC80NjIyNC8yMjczNQ==">
	<script type="text/javascript">
   (function(d, s) {
       var j, e = d.getElementsByTagName(s)[0];

       if (typeof LivereTower === 'function') { return; }

       j = d.createElement(s);
       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
       j.async = true;

       e.parentNode.insertBefore(j, e);
   })(document, 'script');
	</script>
<noscript> 为正常使用来必力评论功能请激活JavaScript</noscript>
</div>
<!-- City版安装代码已完成 -->
		
	</article>

	<div id="toc">
		
	</div>

</div>

<!-- <div id="paginator"> -->
<!-- 	 -->
<!-- </div> -->
<!-- page.mathjax == true修改为true，默认开启-->

    
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
          tex2jax: {
            inlineMath: [ ['$','$'], ["\\(","\\)"] ],
            processEscapes: true
          }
        });
      </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
            tex2jax: {
              skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
            }
          });
      </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
              var all = MathJax.Hub.getAllJax(), i;
              for(i=0; i < all.length; i += 1) {
                  all[i].SourceElement().parentNode.className += ' has-jax';
              }
          });
    </script>

    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>



			</div>
		</div>

		<div id="bottom-outer">
			<div id="bottom-inner">
				Site by 阳生 | 
				Powered by <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a> |
				theme <a target="_blank" rel="noopener" href="https://github.com/fireworks99/hexo-theme-PreciousJoy">PreciousJoy</a>
			</div>
		</div>

		
	</div>





	
	<!-- scripts list from theme config.yml -->
	
	<script src="/js/jquery-3.5.1.min.js"></script>
	
	<script src="/js/PreciousJoy.js"></script>
	
	<script src="/js/highlight.pack.js"></script>
	
	<script src="/js/jquery.fancybox.min.js"></script>
	
	<script src="/js/search.js"></script>
	
	<script src="/js/load.js"></script>
	
	<script src="/js/jquery.mCustomScrollbar.concat.min.js"></script>
	
	<script src="/js/clipboard.min.js"></script>
	
	

	<script>hljs.initHighlightingOnLoad();</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>
