


<!DOCTYPE html>
<html lang="ch">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
	<title> [ 代码和诗 ]</title>
	
	
	<!-- stylesheets list from _config.yml -->
	
	<link rel="stylesheet" href="/css/PreciousJoy.css">
	
	<link rel="stylesheet" href="/css/top-bar.css">
	
	<link rel="stylesheet" href="/css/menu-outer.css">
	
	<link rel="stylesheet" href="/css/content-outer.css">
	
	<link rel="stylesheet" href="/css/bottom-outer.css">
	
	<link rel="stylesheet" href="/css/atom-one-dark.css">
	
	<link rel="stylesheet" href="/css/recent-posts-item.css">
	
	<link rel="stylesheet" href="/css/article-sidebar-toc.css">
	
	<link rel="stylesheet" href="/css/jquery.fancybox.min.css">
	
	<link rel="stylesheet" href="/css/search.css">
	
	<link rel="stylesheet" href="/css/toc.css">
	
	<link rel="stylesheet" href="/css/sidebar.css">
	
	<link rel="stylesheet" href="/css/archive.css">
	
	<link rel="stylesheet" href="/css/jquery.mCustomScrollbar.min.css">
	
	<link rel="stylesheet" href="/css/Z-last-cover-others.css">
	
	
	
<meta name="generator" content="Hexo 7.3.0"></head>




<body id="wrapper">

	<div id="">
		
		<div id="top-bar">
			
			<div id="avatar-box">
				<img 
				class="avatar"
				src="/images/my-avatar.jpg" //网站头像
				alt="avatar">
			</div>

			<div id="top-bar-text">
				<div id="top-bar-title">
					阳生。
				</div>
				<div id="top-bar-slogan">
					风毛丛劲节，只上尽头竿。
				</div>
			</div>

		</div>

		<div id="menu-outer">
			<div id="menu-inner">
				
				
				<div class="menu-item">
					<a href="/">Home</a>
				</div>
				
				<div class="menu-item">
					<a href="/about">About</a>
				</div>
				
				<div class="menu-item">
					<a href="/archives">Archives</a>
				</div>
				

				<div class="menu-item menu-item-search">
					
  <span class="local-search local-search-google local-search-plugin">
      <input type="search" placeholder="站内搜索" id="local-search-input" class="local-search-input-cls" style="">
      <div id="local-search-result" class="local-search-result-cls"></div>
  </span>
	
				</div>

			</div>
		</div>

		<div id="content-outer">
			<div id="content-inner">

				

<div id="recent-posts-box">

  
  <div id="recent-posts">
    <!-- <h1>Recent Posts</h1> -->
    
    
    <div class="recent-post-item">

      <a href="/2026/01/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/" class="item-title">软件工程导论</a>
      
      <time datetime="2026-01-05T11:25:39.000Z">
        2026-01-05
      </time>
      
      <!-- <div class="article-digest"> -->
        <!-- ch1:软件工程学概述软件的生命周期：    1）问题定义；    2）可行性研究；    3）需求分析；    4）整体设计；    5）详细设计；    6）编码和单元测试；    7）综合测试；    8）软件维护；
增量模型的优点：    1）可以在较短的时间内，为客户提供一个可以完成部分功能的产品；    2）能够让客户有充裕的时间去熟悉和适应产品，能够减少新的软件为客户组织带来的冲击；
螺旋模型的优点：    1）适用于内部开发的大规模项目；    2）它是风险驱动的；    3）只有在内部开发时，才能在风险过大时方便地终止；
ch2:可行性研究系统流程图的定义：    系统流程图是概括性地描绘物理系统的传统工具，其基本思想是用图形符号以黑盒子的形式描绘组成系统的各个部件（程序、文档、人工过程、数据库）；
系统流程图基本符号：    1）处理-矩形；    2）输入输出-平行四边形；    3）数据流-箭头；
数据流图的基本符号：    1）数据的源点&#x2F;终点-正方形&#x2F;立方体；    2）数据的变换-圆角正方形&#x2F;圆形；    3）数据的存储-缺宽 -->
        <!-- </div> -->

        
        <h2 id="ch1-软件工程学概述"><a href="#ch1-软件工程学概述" class="headerlink" title="ch1:软件工程学概述"></a>ch1:软件工程学概述</h2><p>软件的生命周期：<br>    1）问题定义；<br>    2）可行性研究；<br>    3）需求分析；<br>    4）整体设计；<br>    5）详细设计；<br>    6）编码和单元测试；<br>    7）综合测试；<br>    8）软件维护；</p>
<p>增量模型的优点：<br>    1）可以在较短的时间内，为客户提供一个可以完成部分功能的产品；<br>    2）能够让客户有充裕的时间去熟悉和适应产品，能够减少新的软件为客户组织带来的冲击；</p>
<p>螺旋模型的优点：<br>    1）适用于内部开发的大规模项目；<br>    2）它是风险驱动的；<br>    3）只有在内部开发时，才能在风险过大时方便地终止；</p>
<h2 id="ch2-可行性研究"><a href="#ch2-可行性研究" class="headerlink" title="ch2:可行性研究"></a>ch2:可行性研究</h2><p>系统流程图的定义：<br>    系统流程图是概括性地描绘物理系统的传统工具，其基本思想是用图形符号以黑盒子的形式描绘组成系统的各个部件（程序、文档、人工过程、数据库）；</p>
<p>系统流程图基本符号：<br>    1）处理-矩形；<br>    2）输入输出-平行四边形；<br>    3）数据流-箭头；</p>
<p>数据流图的基本符号：<br>    1）数据的源点&#x2F;终点-正方形&#x2F;立方体；<br>    2）数据的变换-圆角正方形&#x2F;圆形；<br>    3）数据的存储-缺宽矩形&#x2F;双线；<br>    4）数据流-箭头；</p>
<p>数据流图注意事项：<br>    1）只用画符号，不用说明含义；<br>    2）只画业务逻辑，不考虑异常、错误处理；</p>
<p>数据字典的组成：<br>    1）数据流；<br>    2）数据流分量；<br>    3）数据存储；<br>    4）处理；</p>
<p>数据字典的用途：<br>    数据字典最重要的用途是用作分析节点的工具，在数据字典中建立一套严密、一致的定义，有助于改进分析员和用户之间的通信，可能消除很多误解；</p>

        


        <span>
          <a class="article-read" href="/2026/01/05/软件工程导论/"> Read more -->
          </span>
        </div>

        
    
    <div class="recent-post-item">

      <a href="/2026/01/02/Connect6%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/" class="item-title">Connect6框架学习</a>
      
      <time datetime="2026-01-02T15:38:11.000Z">
        2026-01-02
      </time>
      
      <!-- <div class="article-digest"> -->
        <!-- 在大三学年的秋季学期，人工智能导论课堂上开发了一个AI六子棋的项目，整个开发依托于一个开源的框架，在这里对框架与实现思路做一些简单的记录
基本框架比赛如何开始？主函数AITester()-&gt;oucLeague()-&gt;GameEvent根据HostID调用函数hostGames()，开始一场比赛；
关于hostGames:
1234567891011121314public void hostGames(int hostId) throws CloneNotSupportedException &#123;   ArrayList&lt;Game&gt; games = new ArrayList();   Player host = this.getHost(hostId);   Iterator var4 = this.players.iterator();   while(var4.hasNext()) &#123;      Player player = (Player)var4.next();      if (!player.equals(host)) &#12 -->
        <!-- </div> -->

        
        <p><code>在大三学年的秋季学期，人工智能导论课堂上开发了一个AI六子棋的项目，整个开发依托于一个开源的框架，在这里对框架与实现思路做一些简单的记录</code></p>
<h2 id="基本框架"><a href="#基本框架" class="headerlink" title="基本框架"></a>基本框架</h2><h3 id="比赛如何开始？"><a href="#比赛如何开始？" class="headerlink" title="比赛如何开始？"></a>比赛如何开始？</h3><p>主函数AITester()-&gt;oucLeague()-&gt;GameEvent根据HostID调用函数hostGames()，开始一场比赛；</p>
<p>关于hostGames:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hostGames</span><span class="params">(<span class="type">int</span> hostId)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">   ArrayList&lt;Game&gt; games = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">   <span class="type">Player</span> <span class="variable">host</span> <span class="operator">=</span> <span class="built_in">this</span>.getHost(hostId);</span><br><span class="line">   <span class="type">Iterator</span> <span class="variable">var4</span> <span class="operator">=</span> <span class="built_in">this</span>.players.iterator();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">while</span>(var4.hasNext()) &#123;</span><br><span class="line">      <span class="type">Player</span> <span class="variable">player</span> <span class="operator">=</span> (Player)var4.next();</span><br><span class="line">      <span class="keyword">if</span> (!player.equals(host)) &#123;</span><br><span class="line">         games.add(<span class="keyword">new</span> <span class="title class_">Game</span>((Player)host.clone(), (Player)player.clone()));</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">this</span>.runGames(games);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>简单来说就是读取properties文件中的hostId，作为host；</li>
<li>读取Players列表，选择除了host以外的作为自己的对手；</li>
<li>games.add()创建对应比赛，最终形成一个比死列表，然后在runGames()中依次完成比赛，得到结果列表；</li>
</ol>
<p>配置文件中相关项如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#the Ids of each player. corresponding ClassName, for example &quot;stud.g77.AI&quot;</span></span><br><span class="line">Player_Ids = 2,14</span><br><span class="line"><span class="comment">#the group who hosts the games with each other groups.</span></span><br><span class="line"><span class="comment">#at every game, the host plays first, i.e. who uses the white stone.</span></span><br><span class="line">Host = 2</span><br></pre></td></tr></table></figure>

<ol>
<li>runGames会遍历当前的games列表，对于其中的每个元素转换为Game对象，使用game.start()开始一次对局；</li>
<li>上述函数在Game类中，最终的效果是将一局游戏启动为一个Thread，并运行该game.run()；</li>
</ol>
<p>Game类中相关函数如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Configuration.GUI) &#123;</span><br><span class="line">       <span class="built_in">this</span>.referee.setUi(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">steps</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    Move move;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">Move</span> <span class="variable">currMove</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="built_in">this</span>.running(); currMove = move) &#123; <span class="comment">//running()布尔值判断游戏是否还在运行</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//处理游戏结束的逻辑，不同的结束原因给出对应的提示；</span></span><br><span class="line">       <span class="keyword">if</span> (<span class="built_in">this</span>.referee.gameOver()) &#123;</span><br><span class="line">          <span class="built_in">this</span>.endingGame(<span class="string">&quot;F&quot;</span>, (Move)<span class="literal">null</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (steps &gt; Configuration.MAX_STEP) &#123;</span><br><span class="line">          <span class="built_in">this</span>.endingGame(<span class="string">&quot;M&quot;</span>, (Move)<span class="literal">null</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//检查当前是谁在下棋，创建对应的Player实例以应用对应的算法</span></span><br><span class="line">       <span class="type">Player</span> <span class="variable">currPlayer</span> <span class="operator">=</span> <span class="built_in">this</span>.referee.whoseMove();</span><br><span class="line">       currPlayer.startTimer();</span><br><span class="line">       move = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">          move = currPlayer.findMove(currMove);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception var6) &#123;</span><br><span class="line">          <span class="comment">//由于Player实例出错导致的游戏结束；</span></span><br><span class="line">          <span class="built_in">this</span>.endingGame(<span class="string">&quot;E&quot;</span>, (Move)<span class="literal">null</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       currPlayer.stopTimer();</span><br><span class="line">       <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//由于当前Player实例犯规导致的游戏结束；</span></span><br><span class="line">       <span class="keyword">if</span> (!<span class="built_in">this</span>.referee.legalMove(move)) &#123;</span><br><span class="line">          <span class="built_in">this</span>.endingGame(<span class="string">&quot;N&quot;</span>, move);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//观战者相关的逻辑，或许与GUI的绘制有关；</span></span><br><span class="line">       <span class="built_in">this</span>.setChanged();</span><br><span class="line">       <span class="built_in">this</span>.notifyObservers(move);</span><br><span class="line">       ++steps;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>anyway，最核心的方法实际上就是我们的AI要继承Player类，去按照六子棋的合法规则，实现findMove()方法；</li>
<li>那么首要的，要明确findMove()的返回值，Move类是怎样的；</li>
</ol>
<p>作为一个框架，其内容纷繁，我们看它的核心部分：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Move</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIDE</span> <span class="operator">=</span> <span class="number">19</span>;<span class="comment">//规定棋盘大小</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">char</span> <span class="variable">MAXCHAR</span> <span class="operator">=</span> <span class="string">&#x27;S&#x27;</span>;<span class="comment">//字符索引最大值，19*19的棋盘，用&#x27;A&#x27;到&#x27;S&#x27;来对印索引</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_INDEX</span> <span class="operator">=</span> <span class="number">360</span>;<span class="comment">//二维棋盘19*19 = 361后压缩到一维数组中（从0开始）对应的最大索引值，这个360就是(19,19)的位置</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">STEP_C</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//数字索引最小值</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">STEP_R</span> <span class="operator">=</span> <span class="number">19</span>;<span class="comment">//数字索引最大值</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INDEX_ORIGIN</span> <span class="operator">=</span> -<span class="number">1300</span>;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> _index0;<span class="comment">//表示当前Move的数字索引，一维数组的，一个数字就可以代表二维的一个坐标</span></span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> _index1;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">char</span> _col0;<span class="comment">//表示当前Move的字符索引，二维数组的，结合_row0，一起代表一个坐标</span></span><br><span class="line">   <span class="keyword">private</span> <span class="type">char</span> _row0;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">char</span> _col1;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">char</span> _row1;</span><br></pre></td></tr></table></figure>

<p>关键点是明确一个Move对象的属性值是如何对应到具体的落子位置的，有两种规则：</p>
<ol>
<li>字符规则col,row分别取A到S的某个字符</li>
<li>整型规则index，取一个数字直接对应到转换后的一维数组<br>（index计算规则也很简单，不用看代码就可以想到：index &#x3D; 列号 + (行号-1)*19 - 1，注意行列号从1开始最大到19，最后再减1是因为一维数组从0开始）</li>
</ol>
<p>明确了Move之后，我们还应该知道，每个Player实际上自己维护了一个Board；<br>在findNextMove()中会用如下规则更新：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">board.makeMove(opponentMove);</span><br><span class="line"></span><br><span class="line"><span class="type">BoardPro</span> <span class="variable">board</span> <span class="operator">=</span> getBoard();</span><br><span class="line">bestMoveCandidate = board.findwinMoves();</span><br><span class="line"><span class="keyword">if</span> (bestMoveCandidate != <span class="literal">null</span>) &#123;</span><br><span class="line">	board.makeMove(bestMoveCandidate);</span><br><span class="line">	<span class="keyword">return</span> bestMoveCandidate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进一步查看makeMove()也可以体会到前面关于Move到说明</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeMove</span><span class="params">(Move mov)</span> &#123;</span><br><span class="line">   <span class="keyword">assert</span> <span class="built_in">this</span>.legalMove(mov);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">this</span>.moveList.add(mov);</span><br><span class="line">   <span class="built_in">this</span>.set(mov.col0(), mov.row0(), <span class="built_in">this</span>._whoseMove);</span><br><span class="line">   <span class="built_in">this</span>.set(mov.col1(), mov.row1(), <span class="built_in">this</span>._whoseMove);</span><br><span class="line">   <span class="built_in">this</span>._whoseMove = <span class="built_in">this</span>._whoseMove.opposite();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然Board肯定也是一个绕不过去的数据结构，接下里对其进行说明。</p>
<p>Board对象中比较关键的数据结构如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PieceColor[] _board;<span class="comment">//这就是实际代表board的一维数组；</span></span><br></pre></td></tr></table></figure>
<p>上述数组是一个PieceColer的对象，这个类型就是界定了当前的黑方棋子、白方棋子、空格；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">PieceColor</span> &#123;</span><br><span class="line">   EMPTY,</span><br><span class="line">   BLACK,</span><br><span class="line">   WHITE;</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure>

<p>在这一节的最后在简单说明一下findNextMove()的逻辑；</p>
<ol>
<li>维护board，使用opponentMove更新自己的board；</li>
<li>维护board，用自己决定的Move，更新自己的board；</li>
<li>将自己的Move返回；<br>（自己的Move自己更新，将自己的返回給对手，对手用来更新）</li>
</ol>
<h3 id="博弈算法"><a href="#博弈算法" class="headerlink" title="博弈算法"></a>博弈算法</h3><p>判断是否有必胜招式，逻辑集成在findWinMoves()中；</p>
<p>在开始具体的算法之前，我们要明确一个关键的数据结构，即路Road与路表RoadTable<br>先从一个高度的概念范畴理解：</p>
<ol>
<li>Road：在六子棋中，任何连续的 6 个位置（横、竖、斜）都可能连成六子。</li>
<li>RoadTable：RoadTable 预先计算并存储了棋盘上所有这些可能的 6 连位置。</li>
<li>好处：这使得 AI 无需遍历整个棋盘去寻找连珠，而是通过 O(1) 的时间复杂度直接从集合中获取威胁信息。</li>
</ol>
<p>好处的例子（结合后面的说明很好理解）；</p>
<figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">roadSetsByStoneCount[<span class="string">blackCount</span>][<span class="symbol">whiteCount</span>] 存储了所有包含 blackCount 个黑子和 whiteCount 个白子的“路”。</span><br><span class="line">即时威胁识别：</span><br><span class="line">如果 roadSetsByStoneCount[<span class="string">5</span>][<span class="symbol">0</span>] 不为空，说明黑方已经有“五连”，下一手必胜。</span><br><span class="line">如果 roadSetsByStoneCount[<span class="string">0</span>][<span class="symbol">4</span>] 不为空，说明白方有“四连”，黑方必须防守。</span><br></pre></td></tr></table></figure>

<p>关于Road，从其数据结构进行把握</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//主要是根据 起始位置 方向 黑白子数量来界定一个路；</span></span><br><span class="line">   <span class="comment">//默认的前提是一个路最多6个棋子；</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Road</span><span class="params">(<span class="type">int</span> startPos, <span class="type">int</span> dir, <span class="type">int</span> blackNum, <span class="type">int</span> whiteNum, <span class="type">boolean</span> active)</span> &#123;</span><br><span class="line">	<span class="built_in">super</span>();</span><br><span class="line">	<span class="built_in">this</span>.startPos = startPos;<span class="comment">//起始位置，对应的就是一维board的index</span></span><br><span class="line">	<span class="built_in">this</span>.dir = dir;<span class="comment">//方向，数字0～3，后面的路表初始化也可以体现（分别是横、竖、左斜、右斜）</span></span><br><span class="line">       <span class="comment">//不用考虑前后，仅管往前，因为不同的startPos会覆盖到当前位置“往后的情况”</span></span><br><span class="line">	<span class="built_in">this</span>.blackNum = blackNum;<span class="comment">//黑子数量</span></span><br><span class="line">	<span class="built_in">this</span>.whiteNum = whiteNum;<span class="comment">//白子数量</span></span><br><span class="line">	<span class="built_in">this</span>.isLegal = active;<span class="comment">//是否合法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于RoadTable</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基本路表</span></span><br><span class="line"><span class="keyword">private</span> Road[][] roadsByStartPos = <span class="keyword">new</span> <span class="title class_">Road</span>[SIDE * SIDE][<span class="number">4</span>];</span><br></pre></td></tr></table></figure>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 初始化路表 (伪代码)</span><br><span class="line">function iniRoadTable():</span><br><span class="line">	for i from 0 to SIDE-1: // 遍历行</span><br><span class="line">		for j from 0 to SIDE-1: // 遍历列</span><br><span class="line">			for k from 0 to 3: // 遍历4个方向 (横, 纵, 斜上, 斜下)</span><br><span class="line">				</span><br><span class="line">				// 1. 预判终点：计算当前点往方向k延伸5步后的坐标</span><br><span class="line">				endCol = i + FORWARD[k].x * 5</span><br><span class="line">				endRow = j + FORWARD[k].y * 5</span><br><span class="line">				</span><br><span class="line">				// 2. 合法性检查：判断终点是否还在棋盘内</span><br><span class="line">				active = isValidSquare(endCol, endRow)</span><br><span class="line">				</span><br><span class="line">				// 3. 索引转换：二维坐标转一维</span><br><span class="line">				startIndex = getIndex(i, j)</span><br><span class="line">				</span><br><span class="line">				// 4. 创建路对象：记录起点、方向、初始棋子数(0,0)、是否激活</span><br><span class="line">				road = new Road(startIndex, k, 0, 0, active)</span><br><span class="line">				</span><br><span class="line">				// 5. 存入全量表：无论是否合法都存入 roadsByStartPos</span><br><span class="line">				roadsByStartPos[startIndex][k] = road</span><br><span class="line">				</span><br><span class="line">				// 6. 存入分类表：只有合法的路才加入&quot;0黑0白&quot;的集合中</span><br><span class="line">				if active is true:</span><br><span class="line">					roadSetsByStoneCount[0][0].add(road)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

        


        <span>
          <a class="article-read" href="/2026/01/02/Connect6框架学习/"> Read more -->
          </span>
        </div>

        
    
    <div class="recent-post-item">

      <a href="/2025/12/15/Computer-Graphic/" class="item-title">Computer Graphic</a>
      
      <time datetime="2025-12-15T11:48:09.000Z">
        2025-12-15
      </time>
      
      <!-- <div class="article-digest"> -->
        <!-- 这篇blog用来记录我在大学三年级的秋季学期，选修计算机图形学时学到的专业知识，以备增强自己的专业素养以及应对后续考核
光栅化引入：    到目前为止我们完成了：        1）模型变换-放置好了物品；        2）视图变换-放置好了相机；        3）投影变换-得到了标准空间下的图像信息；    下一步我们需要考虑：        如何将图像显示在屏幕上？        视口变换；
一些基础概念    屏幕：        1）由像素构成，计算机将其抽象为数组进行管理；        2）数组的大小对应分辨率；        3）屏幕是典型的光栅化显示；    光栅：Raster，即德语中的屏幕；    光栅化：Rasterize，画在屏幕上；    像素：Pixel，具有颜色的小正方形，可以用RGB形式来描述颜色；
视口变换：Viewport Transformation    屏幕空间：        连续坐标系下：屏幕覆盖的区域上(0,0)-&gt;(width,height)；        将屏幕离散为像素进行考虑：            1）分辨率，像素的 -->
        <!-- </div> -->

        
        <p><code>这篇blog用来记录我在大学三年级的秋季学期，选修计算机图形学时学到的专业知识，以备增强自己的专业素养以及应对后续考核</code></p>
<h2 id="光栅化"><a href="#光栅化" class="headerlink" title="光栅化"></a>光栅化</h2><p>引入：<br>    到目前为止我们完成了：<br>        1）模型变换-放置好了物品；<br>        2）视图变换-放置好了相机；<br>        3）投影变换-得到了标准空间下的图像信息；<br>    下一步我们需要考虑：<br>        如何将图像显示在屏幕上？<br>        视口变换；</p>
<p>一些基础概念<br>    <em>屏幕</em>：<br>        1）由<em>像素</em>构成，计算机将其抽象为数组进行管理；<br>        2）数组的大小对应<em>分辨率</em>；<br>        3）屏幕是典型的<em>光栅化显示</em>；<br>    光栅：Raster，即德语中的屏幕；<br>    光栅化：Rasterize，画在屏幕上；<br>    像素：Pixel，具有颜色的小正方形，可以用RGB形式来描述颜色；</p>
<p>视口变换：Viewport Transformation<br>    屏幕空间：<br>        连续坐标系下：屏幕覆盖的区域上(0,0)-&gt;(width,height)；<br>        将屏幕离散为像素进行考虑：<br>            1）分辨率，像素的个数：$width \times height$；<br>            2）每个像素对应的范围是(x,y)-&gt;(x+1,y+1)；<br>            （简单地将一个像素的长宽考虑为单位1）<br>            3）其中x、y是像素的索引，都是整数；<br>            4）当然x、y也可以对应到连续空间中的坐标；<br>            5）x、y的取值范围分别是0～width-1的整数、0～height-1的整数；<br>            （相当于连续空间坐标的离散化，根据2）中每个像素的范围，这些索引范围的像素实际上就覆盖了原始的屏幕空间）<br>        注意：<br>            1）虽然像素被离散化处理了，但是我们在进行图形学上的处理时，经常会将其放在连续空间下讨论对其如何处理；<br>            2）例如(x,y)索引的像素的中心坐标被认为是(x+0.5,y+0.5)<br>        一句话总结：<br>            屏幕坐标是一定范围中的连续空间，其按照每个小单位将坐标离散化作为像素，对用的索引是，离散化后的坐标，其既可以在连续空间中仍旧保持原来的坐标意义，又可以作为计算机管理像素的基本索引<br>    <strong>视口变换</strong>：<br>        1）是将投影变化后的标准空间里的相关图像信息（空间中的点与对应的位置信息），变换到屏幕空间中；<br>        2）与<strong>Z轴无关</strong>，eg：将$[-1,1]^2 \rightarrow [0,width]\times [0,height]$<br>    使用到的<strong>变换矩阵</strong>如下图所示：<br>    <img src="/Computer-Graphic/p1.png" alt="视口转换矩阵"></p>
<p>计算机中<strong>图像的表示方式</strong>：<br>    多边形网格：<br>        1）<strong>三角形网格</strong>：<br>            最<strong>简单</strong>的多边形；<br>            其他多边形可以<strong>拆分</strong>成三角形；<br>            具有良好的性质：<br>                1）一定是<strong>平面</strong>；<br>                2）<strong>内外</strong>定义清晰；<br>                3）对内部任意点方便做<strong>插值</strong>；（重心坐标插值）</p>
<p>如何使用像素近似三角形：<br>    前置条件：<br>        三角形的图形信息已经经过一系列变换，到了屏幕空间中，三角形图像的相关坐标信息可以与像素的坐标信息一概而论；<br>    最简单的光栅化方法：<br>        采样：<br>            <strong>基本定义</strong>：给定一个连续的函数，计算某些点上的函数值；<br>            （本质上将连续的函数给离散化的过程）<br>            样本的作用：<br>                1）我们可以利用它得到原始连续物体的信息；<br>                2）对所有的样本进行一系列处理，得到一些结果；<br>        图形学中的常见采样：<br>            1）一维：对时间采样；<br>            2）二维：对面积采样、对方向采样；<br>            3）三维：对体积采样；<br>    使用二维采样进行光栅化：<br>        1）定义二值函数<strong>inside(t,x,y)<strong>，为1则(x,y)在三角形t内，为0则在三角形外部；<br>        （使用判断点是否在三角形内部的方法，常见的如：重心坐标、向量叉乘等）<br>        2）遍历每一个</strong>像素的中心坐标(x+0.5,y+0.5)，判断是否在三角形内部</strong>，即inside(t,x+0.5,y+0.5)等于1与否；<br>        3）对于中心在三角形内部的像素，则像素的颜色使用该三角形t，属性中的颜色；<br>        4）将每一个像素均处理之后，就可以得到一个光栅化的三角形表示；<br>        如下图所示：<img src="/Computer-Graphic/p2.png" alt="光栅化后的三角形"></p>
<p>采样中存在的问题：<br>    遍历所有的像素点时间消耗太多：<br>        1）使用<strong>包围盒</strong>：<br>            构造方法是取三角形包含坐标的：<br>                x轴方向上最小值-包围盒左下、左上的x坐标；<br>                x轴方向上最大值-包围盒右下、右上的x坐标；<br>                y轴方向上最小值-包围盒左下、右下的y坐标；<br>                y轴方向上最大值-包围盒左上、右上的y坐标；<br>        2）<strong>扫描</strong>的方法：<br>            从下至上、从左至右，逐行或逐列扫描三角形内部像素中心坐标的情况，找到相对应的像素；<br>    光栅化的结果存在采样伪迹：<br>        常见的<strong>采样伪迹</strong>：<br>            1）锯齿；<br>            2）摩尔纹；<br>            3）车轮错觉；<br>        出现<strong>采样伪迹的原因</strong>：<br>            <strong>走样</strong>：<br>                本质原因：<strong>信号变换太快（高频），而采样频率太慢</strong>，导致面向结果估计出的原始信号频率是错误的（与原始信号相差甚远）；<br>                具体的例子：<br>                    锯齿：<strong>空间采样</strong>，频率太低；<br>                    摩尔纹：<strong>欠采样的图像</strong>；<br>                    车轮错觉：<strong>时间采样</strong>，频率太低；<br>        如何<strong>改善走样</strong>问题：<br>            1）提高采样率（需要考虑代价）；<br>            2）反走样；</p>
<p>反走样：<br>    本质：<strong>采样前过滤掉高频信号</strong>；<br>    光栅化三角形反走样：<br>        <strong>平均像素值</strong>：<br>            1）一般采样的过程，光栅化三角形出现锯齿的地方是因为边界像素值为纯红或纯白；<br>            2）考虑将边界的像素值取中间值，使用平均像素值：<br>                <strong>三角形覆盖像素的面积</strong>，来计算<strong>平均像素值</strong>；<br>            （可是三角形覆盖了像素的多少，这在计算上比较复杂，而且需要对每个边界像素进行操作）<br>        <strong>超级采样</strong>：<br>            在一个像素中进行多次采样，计算他们的平均值作为像素值；<br>            例如：<br>                1）将一个像素分为$2\times 2$对四个子像素<br>                2）对每一个子像素中心点考察是否在三角形中，如果是则子像素在理论上是纯红，不是则是纯白；<br>                3）实际是最后考虑有几个子像素在三角形中，有几个不在，对他们的像素值做平均，得到一个像素的值；</p>
<p>遮挡与可见性问题：<br>    背景：<br>        1）前面描述视口变换的时候提到，是将x、y方向上的图像信息变换到屏幕空间下，但是z轴上对应的信息是不变的；<br>        2）于是根据<strong>z坐标的大小，显示在屏幕上的图像信息实际上是有远有近的</strong>；<br>        3）我们需要考虑对于相同x、y坐标，但z坐标不同的图像信息，近处的图像会遮挡远处的图像；（于是有了下面几个算法）<br>    <strong>画家算法</strong>：<br>        1）对场景中的多边形按照<strong>深度进行排序</strong>（时间复杂度O(nlogn)）<br>        2）由近远及近的光栅化物体信息，近处物体会遮挡远处物体，在帧缓冲器中重写即可<br>        （但是画家算法存在问题，考虑z轴对应空间，所属同一个图像的信息，可以<strong>部分的z坐标较大、部分的z坐标较小，例如存在如下图所示无法排序</strong>的情况）<br>        <img src="/Computer-Graphic/p3.png" alt="画家算法的问题"><br>    <strong>Z-buffer算法</strong>：<br>        1）假设z永远是正值，<strong>离相机越近z越小；离相机越远z越大</strong>；<br>        （要在实际情况下满足这种条件，可能需要在代码上进行一些变换处理）<br>        2）维护一个<strong>z-buffer，深度缓冲器</strong>，用来缓冲对应<strong>像素记录的图形信息对应深度值z</strong>；<br>        3）逐个光栅化物体，当需要使用当前图像信息设置对应像素的属性值时，先使用<strong>当前图像信息对应的深度值z，与z-buffer中缓存的该像素当前保存图像信息的深度值z，谁更小</strong>；<br>        4）若z-buffer中缓存的z值更小，则跳过该图像信息；<br>        5）若当前图像信息z值更小，则使用当前的图像信息设置相应像素的属性值，其间对使用到的像素，对应在z-buffer中记录该像素当前的深度值；<br>    Z-buffer算法形象的图像表示如下：<br>    <img src="/Computer-Graphic/p4.png" alt="Z-buffer算法"></p>
<p>Z-buffer算法的伪代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(each Traingle t)</span><br><span class="line">    <span class="keyword">for</span>(each sample(x,y,z) in t)</span><br><span class="line">        <span class="keyword">if</span>(z&lt;Zbuffer[x,y])</span><br><span class="line">            framebuffer[x,y] = rgb;</span><br><span class="line">            zbuffer[x,y]=z;</span><br><span class="line">        <span class="keyword">else</span> ;<span class="comment">//do nothing</span></span><br></pre></td></tr></table></figure>

<h2 id="着色"><a href="#着色" class="headerlink" title="着色"></a>着色</h2><p>引入：<br>    到目前为止：<br>        1）我们已经可以使用一系列变换将世界坐标系下的图像信息变换到屏幕坐标下，并且使用光栅化来在屏幕上显示图像来；<br>        2）但是正如我们上一节中对三角形的讨论，我们在设置像素值的时候是直接取纯红或纯白；<br>        3）这种方式显然不会应用在真正的图形显示上面，对像素值的操作太粗暴了<br>    下一步：<br>        1）这一节中我们要结合一些光学知识，更加细粒度地讨论如何设置像素值；<br>        2）目的是在屏幕上显示出有<strong>光照效果</strong>的图形；如下图所示：<br>        <img src="/Computer-graphic/p5.png" alt="纯红色的茶壶考虑光照影响后的光栅化效果"></p>
<p>一些基本的概念：<br>    着色：<strong>shading</strong>；<br>        严格来说在计算机图形学中，着色是指<strong>将材质应用到物体上</strong>的过程；<br>        （这里的物体大概是指光栅化后表示在屏幕上的物体）；<br>        （所以着色并非仅限于考虑光照的影响，还要考虑具体的材质，这在后续章节中会进行探讨）；<br>    着色器：<strong>shader</strong>；<br>    光照：<br>        高光：<strong>Specular highlights</strong>；光源直接照射；<br>        漫反射：<strong>Diffuse relection</strong>；光源照射后粗糙表面的反射；<br>        环境光：<strong>Ambient lighting</strong>；其他物体反射光源形成的间接光；<br>    注意：<br>        shading不是shadow，对于阴影shadow，我们后续章节也会进行讨论；</p>
<p>考虑光照的着色：<br>    着色点：<strong>shading point</strong><br>        1）我们需要就一个着色点考虑光照的情况；<br>        2）可以将着色点对应到物体图像信息中的一个局部点；<br>        3）对这些局部点考虑光照后，计算出着色信息存储在对应的图像信息中，光栅化设置像素属性值的时候使用；<br>        4）最终光栅化的整体图形可以呈现出光照的效果；<br>    常用的信息：<br>        1）<strong>观察方向v</strong>；<br>        2）<strong>表面法向n</strong>；<br>        3）<strong>光线方向l</strong>；<br>        4）<strong>表面参数</strong>；<br>    （<img src="/Computer-Graphic/p28.png" alt="相关向量方向">）<br>    Blinn-Phong反射模型：<br>        用来基于常用信息计算着色点的光照情况；</p>
<p>Blinn-Phong反射模型：<br>    前置知识：<br>        1）兰伯特余弦定理：<br>            1）作用：描述有多少光被表面接收到；<br>            2）公式：每个着色点接收到的光，是照射向该着色点点原始光的：<br>            $\cos\theta &#x3D; l \cdot n$；<br>        2）光的衰减：<br>            1）作用：描述光在扩散过程中的衰减；<br>            2）公式：光源发出的光在单位距离<strong>1处的Intensity为I</strong>，在距离光源距离为<strong>r处，对应的Intensity为$I&#x2F;r^2$</strong><br>            （<em>从后面辐射度量学的角度来看，这里应该是Irradiance，而非Radiant Intensity，但是后续的Blinn-Phong模型均用了I的描述，这是为什么呢？</em>）<br>    漫反射：<br>        1）公式：<br>            $L_d &#x3D; k_d(I&#x2F;r^2)max(0,n\cdot l)$；<br>            说明：<br>                1）$L_d$对应漫反射光；<br>                2）$k_d$是<strong>漫反射系数</strong>；<br>                3）$I&#x2F;r^2$对应的就是<strong>光的衰减</strong>；<br>                4）$n\cdot l$对应的是<strong>兰伯特余弦定理，与0取max是考虑一面受光</strong>；<br>        2）特点：<br>            1）光向各个方向均匀散射；<br>            2）<strong>所有观察方向看到的表面颜色是一致的；</strong><br>            3）因此$L_d$<strong>与$v$无关</strong>，但是与$l$有关；<br>    镜面高光：<br>        1）公式：<br>            $L_s &#x3D; k_s(I&#x2F;r^2)max(0,h\cdot n)^p$；<br>            说明：<br>                1）$k_s$是高光反射系数；<br>                2）$h &#x3D; \frac{l+v}{||l+v||}$，是<strong>半程向量</strong>；<br>                (这里的半程向量对应就是l、v夹角的角平分线，因为l、v是单位向量)<br>                3）$p$用来<strong>控制高光范围</strong>，参考<strong>余弦幂图</strong>进行理解；<br>                <img src="/Computer-Graphic/p6.png" alt="余弦幂图"><br>        2）特点：<br>            1）强度取决于观察方向，靠近镜面的反射方向更加明亮；<br>            2）观察<strong>向量v接近镜面反射方向，等价于半程向量h接近法线向量n</strong>;<br>            3）所以这里使用h与n的点乘；<br>    环境光：<br>        1）公式：<br>            $L_a &#x3D; k_a I_a$<br>            说明：<br>                1）$k_a$是环境光系数；<br>        2）特点：<br>            1）Blinn-Phong模型对环境光的处理是一种<strong>常量颜色</strong>；<br>            2）这是一种近似，并不真实；<br>    最终的Blinn-Phong模型：<br>        $L &#x3D; k_d(I&#x2F;r^2)max(0,n\cdot l) + k_s(I&#x2F;r^2)max(0,n\cdot h)^p + k_a I_a$</p>
<p>影响着色效果的因素：<br>    1）物体本身的面数（几何处理）：<br>        这与将现实世界中的物体通过几何处理，转换为多边形网格表示有关；<br>        网格的大小、网格的数量等本身就会影响着色处理等细粒度；<br>    2）着色频率（光栅化表示）：<br>        在已有物体的图像信息不改变的前提下，在着色过程中可以考虑：<br>            1）对每一个多边形着色，eg：三角形；<br>                1）多边形通常是平面<br>                2）不适合光滑的表面；<br>            2）对多边形的每一个顶点着色；<br>                1）三角形的各个顶点携带了颜色信息；<br>                2）但是三角形作为平面只有一个平面的法向信息，顶点的法向信息需要插值计算；<br>            3）对每一个像素着色；<br>                1）法向信息同样需要插值计算；<br>                2）在每一个像素上计算着色模型<br>        注意：<br>            上面三种频率的着色对应的专有名词为：<br>                1）Flat Shading；<br>                2）Gourand Shading；<br>                3）Phong Shading；<br>            （Phong Shading要与Blinn-Phong模型区别开，前者对应的是一种着色频率，后者对应的是在该着色频率下采取的具体的着色模型）；<br>    3）三种着色频率随物体面数变化的效果对比：<br>        <img src="/Computer-Graphic/p7.png" alt="着色效果">；</p>
<p>法向量的插值计算：<br>    1）顶点法向：<br>        公式：$N_v &#x3D; \frac{\sum_i N_i}{||\sum_i N_i||}$<br>        其中：<br>            1）$N_v$对应顶点的法向量；<br>            2）$N_i$对应与该顶点相邻的所有面的法向量；<br>            3）所以顶点法向的插值就是相邻面法向量的平均；<br>    2）像素法向量：<br>        需要使用重心插值，我们后续会进一步学习；</p>
<p>一种典型的图形管线：<br>    Application输入；<br>    1）Vertex Processing；顶点处理；<br>        1）应用输入的是3D世界空间中的一系列离散点，表示连续图形离散化后的信息；<br>        2）相关操作eg：MVP变换、着色器处理颜色信息（光照、纹理）保存到对应的顶点；<br>    2）Triangle Processing；三角形化；<br>        1）要显示完整的图像，我们要先用离散的点构建多边形网格；<br>        2）相关操作eg：几何处理；（后面会讨论）；<br>    3）Rasterization；光栅化；<br>        1）有了多边形网格之后，对于每一个多边形，例如三角形，我们可以做光栅化处理就像我们之前讨论的一样；<br>        2）相关操作eg：光栅化；<br>    4）Fragment Processing；片元处理；<br>        1）进一步对相关的像素构成的片元，使用着色器处理颜色信息（光照、纹理）；<br>        2）相关操作eg：MVP变换、着色（光照、纹理）；<br>    5）Framebuffer Operations；帧缓冲区处理；<br>        1）将处理完成后的各个像素的信息存入帧缓冲区，等待下一帧改变相应像素的信息为缓冲区中的对应值，显示图像；<br>        2）相关操作eg：画家算法、Z-buffer算法；<br>    输出显示；</p>
<p>纹理映射（Texture Mapping）<br>    含义：三维空间中的一点可以对应二维图像（纹理）上的一点，将二维图像（纹理）上的属性值应用到三维空间对应的点，即纹理映射；<br>    基本概念：<br>        纹理（Texture Mapping）；<br>        纹理坐标：<br>            为三维空间中的每个点计算一个纹理坐标(u,v)，对应的是纹理图像上的坐标值，可以确定纹理图像上的一点以获取对应的属性；<br>            三维空间中的点通常是网格化处理后的三维图形，的各个多边形网格中的点；<br>            eg：三角形的每个顶点、三角形内部的任意点；<br>        纹素&#x2F;纹理元素：<br>            纹理上的一个像素；<br>            （最终计算机应用的时候纹理图片也是以图形保存的，对应其实就是落实到屏幕空间下各个像素的属性是什么，理解纹素对于理解纹理的应用以及后续纹理贴图存在的问题很重要）<br>    纹理坐标映射的建立：<br>        三角形的顶点：<br>            按照纹理的使用方法，为三角形的每个顶点直接分配纹理坐标；<br>        三角形内部的任意点：<br>            问题：<br>                1）三角形的顶点是离散的、有限的，我们可以也应该为其直接分配相应的纹理坐标；<br>                2）三角形内部的任意点是连续的，不可能手动分配；<br>            解决方法：<br>                进行插值；<br>                    根据顶点的纹理坐标按照一定的方法，计算出合理的三角形内部的纹理坐标<br>                可以插值的对象：<br>                    1）纹理坐标（这也是我们这里引入插值的核心目的）；<br>                    2）颜色；<br>                    3）法向量；<br>                    4）深度；<br>                    5）材质属性；<br>            重心坐标插值法：<br>                重心坐标：<br>                1）使用三角形顶点表示空间中一点：<br>                    考虑三角形的三个顶点$A,B,C$，对应空间中的任意点可以在这三个顶点的基础上，使用一组坐标$\alpha,\beta,\gamma$进行表示，即任意点$P$：<br>                    $P &#x3D; \alpha A + \beta B + \gamma C,s.t.\alpha+\beta+\gamma&#x3D;1$；<br>                2）重心坐标的求法：<br>                    $\alpha &#x3D; \frac{S_A}{S_A+S_B+S_C}$；<br>                    $\beta &#x3D; \frac{S_B}{S_A+S_B+S_C}$；<br>                    $\gamma &#x3D; \frac{S_B}{S_A+S_B+S_C}$；<br>                    1）其中$S_A,S_B,S_C$分别对应顶点$A,B,C$对应的三角形面积；即由$K$与三个顶点相连形成的三个三角形，其中不与某顶点相邻的三角形，就是该顶点对应的三角形；<br>                    2）该面积为有向面积，有正负之分；（了解）；<br>                3）重心坐标的性质：<br>                    1）三角形内部顶点的重心坐标是非负的；<br>                    2）可以用任意点对应三角形的重心坐标来判断点在三角形的内部还是外部；<br>                    3）三角形重心的重心坐标是：$(1&#x2F;3,1&#x2F;3,1&#x2F;3)$；重心总是在三角形的内部；<br>                    4）在投影变换下，重心坐标无法保持不变，需要特殊的处理；</p>
<p>纹理简单应用的例子：漫反射颜色；<br><img src="/Computer-Graphic/p8.png" alt="伪代码"><br>    因此：<br>        实际上纹理映射不只是管线流程中最开始的3D模型可以将三维空间中一点映射到纹理空间；屏幕空间中的一点，或者是一个像素（它们都在屏幕空间中具有坐标）都能够被映射到纹理空间中的一点；</p>
<p>纹理使用中存在的问题<br>    纹理分辨率不足：<br>        纹理空间过小导致，映射后纹理坐标并不存在（没有对应的纹素）；<br>            eg：$1024\times 720$的光栅化图像使用$720\times 560$的纹理空间；假设使用1对1对映射，例如(1023,719)对应的像素点，在纹理空间中没有对应(1023,719)的纹理坐标，我们不知道该对这个像素点设置何种属性。这就是纹理分辨率不足带来的问题；<br>        直接的问题：<br>            放大了看可能感觉存在马赛克；<br>        解决方法：<br>            纹理放大：<br>                思想：通过一些操作，将像素点映射到一个或多个合理的纹理坐标，并基于对应的纹理属性给出像素点的属性；<br>                具体操作：<br>                    预处理：<br>                        将纹理空间放大，纹素保持均匀分布；只是改变纹素的空间分布情况，不会增加额外的纹理属性信息；<br>                        （试设想将$720\times 560$个像素点，分布情况拉伸到均匀分布与$1024\times 720$的平面空间；）<br>                    （实际上这一步就是纹理放大）<br>                    预处理基础上可选的几种操作：<br>                        1）最邻近方法(Nearest)：<br>                            1）针对映射后的纹理坐标(u,v)，对应到最近的纹素(x,y)；<br>                            2）将该纹素(x,y)的属性值作为纹理坐标(u,v)的属性值；<br>                        2）双线性插值(Bilinear)：<br>                            1）针对映射后的纹理坐标(u,v)，对应到最近的四个纹素(x,y)&#x2F;(x,y+dy)&#x2F;(x+dx,y)&#x2F;(x+dx,y+dy)；<br>                            2）将四个纹素的属性分别记做：<br>                                u00,u01,u10,u11；<br>                            3）考虑映射后的纹理坐标(u,v) &#x3D; (x,y)+(s,t)<br>                            4）使用双线性插值计算纹理坐标(u,v)对应的属性：<br>                                u0 &#x3D; lerp(t,u00,u01) &#x3D; u00 + t*(u01-u00);<br>                                u1 &#x3D; lerp(t,u10,u11) &#x3D; u10 + t*(u11-u01);<br>                                f(u,v) &#x3D; lerp(s,u0,u1) &#x3D; u0 + u1 + s*(u1-u0);<br>                                其中，u0、u1对应的是纹理属性值，中间变量；f(u,v)是纹理坐标(u,v)对应的纹理属性值；<br>                            注意：t的取值范围为0到1，对应边界取得两个插值项的值；<br>                            为了便于理解放置如下图像<img src="/Computer-Graphic/p9.png" alt="双线性插值"><em>图像中的符号记法与上述笔记描述不同，起因是老师的ppt缺少规范的描述，初看很模糊，所以我在自己理解的基础上写了上述笔记。能够将图像中的记法与上述笔记的记法对应起来也是一种很好的思辨</em>；<br>                        关键点：<br>                            <strong>区分</strong>：纹理坐标、纹素、纹理的属性；<br>                            上述引用纹素的时候，更多的是引用其作为纹理图像上的坐标性质（所以上述描述用纹素坐标更贴切），实际上纹素应该包含了纹理的属性；<br>                注意：<br>                    1）实际情况下，纹理空间与光栅化图像空间或者说3维图像的分布空间，究竟是什么关系，我们是不知道的，但也没有必要知道，这并非此处的讨论重点；<br>                    2）重点在于，当我们对光栅化图像的像素 or 3维图像，进行一个映射来到纹理空间之后，得到的纹理坐标(u,v)，可能无法对应到一个存在的纹素；<br>                    3）整个这一部分我们要讨论的都是这种问题；<br>    纹理分辨率过大：<br>        一个像素&#x2F;3维模型的点等，映射后的纹理坐标涉及范围内，包含多个纹素，此时应该如何设置纹理坐标的属性值。<br>            eg：<img src="/Computer-Graphic/p10.png" alt="纹理过大"><br>        直接的问题：<br>            出现采样伪迹（摩尔纹、锯齿），因为本质是发生了走样（样本频率变化高，采样频率低）；<br>        解决方法：<br>            超级采样：<br>                将一个像素划分为子像素，对子像素计算对应纹素的属性值，让一个像素捕获更多的纹理信息；<br>                （缺点在于开销较大）；<br>            Mipmap：<br>                Mipmap level：<br>                    预处理：<br>                        1）对原始的纹理图像按照层级进行处理；<br>                        2）层级的数量 Level Num &#x3D; log2(原始图像分辨率的宽或高)<br>                        eg:对于128*128的纹理图像，会有7层；<br>                        3）level0对应原始纹理图像；<br>                        4）level(n+1)对应纹理图像的分辨率是leveln的图像分辨率除以2；<br>                        5）具体的处理方式这里不展开，大致是将多个纹素的属性信息汇聚到周围的一个纹素属性信息上，形成分辨率更小的纹理图像；<br>                        （可以参照如下图像进行理解<img src="/Computer-Graphic/p11.png" alt="Mipmap">）<br>                    实际操作（针对屏幕空间-纹理空间的映射进行说明）：<br>                        1）对于每一个像素(x,y)，考虑其相邻两个像素(x+1,y+1)，将三个像素映射到纹理空间，得到(u,v)以及(u1,v1),(u2,v2)；<br>                        2）考虑(u,v)到(u1,v1)的距离是L1，(u,v)到(u2,v2)的距离是L2；<br>                        3）取L &#x3D; max(L1,L2)计算层级D &#x3D; round(log2(L))；<br>                        4）像素(x,y)对应的纹理坐标(u,v)应该在D层级，使用双线性插值，得到纹理属性f；<br>                    或者在2）之后的基础上三线性插值：<br>                        1）对于纹理坐标(u,v)在down(log2(L))层级使用双线性插值得到纹理属性f1；<br>                        2）对于纹理坐标在upper(log2(L))层级使用双线性插值得到纹理属性f2；<br>                        3）对于f1和f2进行单线性插值：f &#x3D; f1 + (L - down(L))(f2 - f1)；<br>                注意：<br>                    1）Mipmap的额外存储空间：<br>                        1）假设原始纹理图像所用空间为1；<br>                        2）每次分辨率减半（长、宽），所用空间变为上一层的1&#x2F;4<br>                        3）对应的所用空间：<br>                            $1 + (\frac{1}{4})^1 + (\frac{1}{4})^2 + \dots &#x3D; \frac{4}{3}[1 - (\frac{1}{4})^n] \rightarrow \frac{4}{3}, when:n \rightarrow inf$<br>                        4）即变为原来的4&#x2F;3，所以多用了1&#x2F;3的空间；<br>                    2）为什么使用D &#x3D; round(log(L))的方式来取层级；<br>                    3）由于我们是泛泛而学，里面仍然有一些细节不清晰：<br>                        1）层级数量计算的时候实际应该选择宽还是高；<br>                        2）对于三线性插值，如果D已经是最大层级了应该如何特殊处；<br>                        3）在三线性插值的最后一步f1和f2如何进行插值不太清楚；</p>
<p>纹理的应用：<br>    1）环境光照；<br>    2）环境贴图；<br>    3）球形环境贴图；<br>    4）立方体贴图；</p>
<p>纹理对着色的影响：<br>    纹理本身中存储了颜色信息，通过纹理为模型上色让模型看起来更逼真；<br>    （但是不止如此）<br>        凹凸&#x2F;法线贴图：<br>            作用：用于伪造凹凸不平的几何纹理；<br>            优点：添加表面细节但不改变任何几何信息，不会增加三角形的数目；<br>            （不改变模型的几何形状（顶点位置），而是通过一张纹理贴图来“欺骗”光照计算，改变每个像素点（片段）的表面法线方向。因为光照效果（漫反射、高光）极度依赖于法线，改变法线就能制造出凹凸不平的视觉假象。）<br>        2D方法：<br>            1）定义高度偏移：<br>                使用模型上的一点$p$，以及该点处的法向量$n$，代表高度偏移；<br>                eg：<br>                    表面法线 $n(p) &#x3D; (0,1)$；<br>                    注意：这个法线代表高度偏移，是从p点出发的二维上的(0,1)向量（法向量）；<br>            2）计算扰动后的法向量：<br>                1）原始法线 $n(p) &#x3D; (0,1)$；<br>                2）p点处的导数 $dp &#x3D; c*(h(p+1)-h(p))$；<br>                3）扰动后的法线 $n(p) &#x3D; (-dp,1).normalized$；<br>                其中：<br>                    1）n(p)对应的是原始法向量；<br>                    2）dp对应的是p点处的导数；<br>                    3）h是曲线；<br>                    （注意这种导数计算方法，c是一个常数参数，这是一种近似的方法）；<br>        3D方法：<br>            扰动后的法向量：<br>                1）原始表面法线：$n(p) &#x3D; (0,0,1)$；<br>                2）p点处的偏导数：<br>                    $dp&#x2F;du&#x3D;c1*(h(u+1)-h(u))$；<br>                    $dp&#x2F;dv&#x3D;c2*(h(v+1)-h(v))$；<br>                    （这里类似h(u+1)的含义应该是在p点的u坐标上+1，然后对应到一个新的点？）<br>                3）扰动后的法线：<br>                    $n(p) &#x3D; (-\frac{dp}{dv},-\frac{dp}{du},1).normalized$；<br>                注意：<br>                    <strong>似乎3D下的符号表示与2D下的符号表示有一些矛盾？前者采用了分量的形式，后者直接使用点p，来表示函数值，形成函数曲线；</strong><br>    凹凸&#x2F;法线贴图的问题：<br>        1）在模型边缘处不能很好地模拟凹凸效果；<br>        2）阴影效果是由真实的集合信息计算出的，导致阴影与物体相矛盾；<br>    更好的选择：<br>        位移贴图：<br>            优点：可以解决凹凸&#x2F;法线贴图的两个问题；<br>            原理：在于位移贴图真正地移动了三角形的顶点；<br>            缺点：<br>                1）对三角形数目有要求；<br>            改进：<br>                1）动态细分曲面；</p>
<h2 id="几何"><a href="#几何" class="headerlink" title="几何"></a>几何</h2><p>几何的表示方法：<br>    隐式表示：<br>        1）代数曲面：<br>            将表面表示成x、y、z多项式的零集；<br>            <img src="/Computer-Graphic/p12.png" alt="代数曲面">；<br>            （缺点是不能表示复杂的几何体）；<br>        2）构造实体几何：<br>            通过布尔运算组合隐式几何；<br>            <img src="/Computer-Graphic/p13.png" alt="构造实体几何">；<br>        3）距离函数：<br>            给出从任何地方到物体的最小距离，然后距离函数逐渐将曲面融合在一起；<br>            <img src="/Computer-Graphic/p14.png" alt="距离函数">；<br>            eg：利用距离函数混合（线性插值）移动边界；<br>        4）水平集：<br>            对于复杂形状，将逼近函数的值存储在格子中，通过插值得到曲面；<br>            <img src="/Computer-Graphic/p15.png" alt="水平集">；<br>            eg：利用水平集编码医疗数据、气液距离<br>        5）分形：<br>            在所有尺度上展现自相似性；<br>            <img src="/Computer-Graphic/p16.png" alt="分形">；<br>    显示表示：<br>        1）参数方程：<br>            通过参数映射给出几何体上的所有点；<br>            <img src="/Computer-Graphic/p17.png" alt="参数方程">；<br>        2）点云；<br>            最简单的表示形式，就是点(x,y,z)点列表；<br>            优点：<br>                1）方便的表示各种几何类型；<br>                2）适用于大数据集合；<br>            缺点：<br>                1）通常需要转换为<strong>多边形网格</strong>；<br>                2）在欠采样区域难以绘制；<br>        3）多边形网格：<br>            存储顶点和多边形（常用三角形、四边形），这是图形学中<strong>最常用的表示方式</strong>；<br>            优点：<br>                1）易于进行处理&#x2F;模拟、自适应采样；<br>            缺点：<br>                1）相较于点云需要更加复杂的数据结构；<br>        4）其他：<br>            Bezier曲面（线）、细分曲面、NURBS；</p>
<p>代数曲面与参数方程的对比：<br>    1）代数曲面本质上是描述了，空间中坐标点的限制关系，满足这些限制关系的点就在多项式零集对应的几何体上；<br>    2）参数方程本质上是用给定范围的参数，直接查询对应的空间中对应的坐标点；<br>    反映隐式表示与显示表示的优缺点：<br>        隐式表示：<br>            优点：内外测试容易，因为有代数曲面的多项式零集，只需要将相应的坐标点带入多项式中；<br>                1）如果为正，则在曲面外；<br>                2）如果为负，则在曲面内；<br>                3）如果为0，则在曲面上；<br>            缺点：采样困难，不容易找到哪些点在曲面上（因为本质上就是要解方程，这并不简单）；<br>        显示表示：<br>            优点：采样简单，因为只要给出一组参数就可以计算出空间中曲面上对应的坐标点（并且参数的范围是知道的）；<br>            缺点：内外测试困难；</p>
<p>曲线：<br>    曲线的应用：<br>        1）相机路径；<br>        2）动画曲线；<br>        3）定义字体；<br>        4）贝塞尔曲线；<br>    贝塞尔曲线：<br>        de Casteljau算法（贝塞尔曲线的定义）<br>            1）考虑一系列控制点$b_0,b_1,\dots,b_n$；<br>            2）相邻控制点之间进行线性插值，使用参数t插入一个新的点；<br>            3）用相邻控制点，构成新的控制点，相邻之间又使用线性插值（仍然用参数t），插入新的点；<br>            4）重复过程3），持续插值，递归，直到最后只插入了一个点（这个过程中持续使用参数t）；<br>            （于是最终我们得到了一个使用参数t控制的，移动的点，即最后一个插入的点，其移动的轨迹就是<strong>贝塞尔曲线</strong>）<br>            算法过程：<br>                <img src="/Computer-Graphic/p20.png" alt="递归地进行新点插入"><br>            注意：<br>                由于线性插值前面已有，所以这里没有过多赘述，线性插值点参数t点取值范围仍然是0到1；<br>        eg：<br>            三个控制点的贝塞尔曲线：<br>            <img src="/Computer-Graphic/p18.png" alt="贝塞尔曲线"><br>        贝塞尔曲线的名称：<br>            最初有n个控制点的曲线对应称为<strong>n-1次贝塞尔曲线</strong>；<br>        控制点的命名规范：<br>            1）最初的控制点命名为：b1、b2、…、bn；<br>            2）递归的确定所有控制点的变化范围之后，可以采用“倒推法”命名；（<strong>自己发现的规律，还不太确定原理</strong>，简单来说就是从最初控制点序列中的最后一个控制点开始，倒推，每倒推一次就对应到当前控制点所在序列，构造的下一个序列，并将下标减1，上标加1，直到下标为0；参考该图：<img src="/Computer-Graphic/p19.png" alt="倒推法">）；<br>        贝塞尔曲线的代数公式：<br>            $b^n_0(t) &#x3D; \sum_{j&#x3D;0}^n B_j^n(t)b_j$；<br>            其中：<br>                1）$b^n_0$ 就是定义中递归到最后一个插值点，即贝塞尔曲线上的点，其位置由t控制；（<strong>可以简写为：</strong>$b^n$）；<br>                2）$B_j^n(t)$ 为贝塞尔曲线基函数：<br>                    $B_j^n(t) &#x3D; C_n^j t^j (1-t)^{(n-j)}$；<br>                3）$b_j$ 是最初的第控制点j；（从0开始）；<br>        贝塞尔曲线的性质：<br>            1）端点位置：<br>                1）当t&#x3D;0的时候，为曲线端点，在第一个控制点p0处；<br>                2）当t&#x3D;1的时候，为曲线另一个端点，在最后一个控制点pn处（n+1次贝塞尔曲线）；<br>            2）端点切向量：<br>                1）在p0处，切向量可以对应是$n(p_1-p_0)$<br>                2）在p1处，切向量可以对应是$n(p_n - p_{n-1})$<br>                其中：n对应归一化；<br>            3）仿射变换性质：<br>                通过变换点控制点达到变换曲线的目的；<br>            4）凸包性质：<br>                得到的贝塞尔曲线一定在控制点的凸包内部；<br>        高阶贝塞尔曲线存在的问题：<br>            不直观、难以控制，并不常用！<br>        分段贝塞尔曲线：<br>            思想：通过连接多段低阶贝塞尔曲线来实现；<br>            eg：分段三次贝塞尔曲线；<br>            <img src="/Computer-Graphic/p21.png" alt="分段三次贝塞尔曲线"><br>            连续性：<br>                有几种连续性级别：<br>                    1）C0连续：$a_n &#x3D; b_0$；<br>                    <strong>前一段的终点与后一段的起点相同</strong><br>                    <img src="/Computer-Graphic/p22.png" alt="C0连续"><br>                    2）C1连续：$a_n &#x3D; b_0 &#x3D; \frac{1}{2}(a_{n-1}+b_1)$；<br>                    <strong>前一段终点与后一段起点相同，且交点处，在前一段的切向量与后一段的切向量共线、等长（相等）</strong><br>                    <img src="/Computer-Graphic/p23.png" alt="C1连续"><br>        贝塞尔曲线的问题：<br>            1）控制点较多时，控制点减弱，多项式阶数增大；<br>            2）局部控制能力较差；</p>
<p>样条：<br>    优于贝塞尔曲线之处：<br>        1）局部修改能力强；<br>        2）易于拼接；<br>    eg：<br>        B样条、NURBS；</p>
<p>贝塞尔曲面：<br>    双三次贝塞尔曲面：实际上就是在空间中的一个平面内先通过递归插值得到贝塞尔曲线的控制点（不同曲面、不同曲线，相同的控制参数u），然后在各个贝塞尔曲线的控制点之间引入另一个控制参数v，进行递归插值；最终两个控制参数对应一个曲面；<br>    <img src="/Computer-Graphic/p24.png" alt="双三次贝塞尔曲面"></p>
<p>几何处理：<br>    含义：对传统数字信号处理的扩展，用于对几何信号进行处理；<br>    常见的集合处理：<br>        1）重建：<br>            给定几何样本，重建表面；<br>            eg：给定点、法线，基于轮廓重建；<br>        2）上采样：<br>            通过插值提高分辨率；<br>            eg：双线性插值、三线性插值、<strong>网格细分</strong>；<br>        3）下采样：<br>            降低分辨率同时保持几何体形状外观；<br>            eg：最临近、双线性插值、双三线性插值；<br>            （虽然2、3都有插值，但是2可以类比用在纹理放大、3类比用在纹理缩小）<br>        4）重采样：<br>            修改样本分布，但保持多边形数目不变，以提高质量；<br>        5）过滤：<br>            消除噪声或强调重要特征；<br>        6）形状分析：<br>            识别&#x2F;理解图形中的语义；<br>    挑战：<br>        1）几何信息的欠采样破坏图形特征；<br>        2）几何信息的过采样会影响性能；<br>        3）重复重采样（先下采样再上采样）会导致信号质量变差；<br>    Loop细分：<br>        场景：针对三角形网格的常用细分方法；<br>        思想：增加三角形的顶点，然后调整顶点的位置，从而将一个三角形网格划分为更多的三角形网格；<br>        方法：<br>            1）插入<strong>边点</strong>：对于一个三角形网格，在其每条边的中点插入一个新的点，称为边点；<br>            2）连接插入点三个边点，将一个三角形一分为四；<br>            3）更新顶点的位置，新、旧顶点都要更新：<br>                1）新顶点（边点）：<br>                    $position &#x3D; \frac{3}{8}(x_0+x_1) + \frac{1}{8}(x_2+x_3)$<br>                    其中：<br>                        1）0、1对应该边点所在边点两个端点；<br>                        2）2、3对应与边点所在边相对的两个端点；<br>                    eg：<br>                        <img src="/Computer-Graphic/p25.png" alt="新顶点位置修改"><br>                2）旧顶点：<br>                    $position &#x3D; (1-n\beta)OriginalPosition + \beta \sum NeighborPosition$<br>                    其中：<br>                        1）n是顶点的度，即相邻边&#x2F;点数量；<br>                        2）beta是一个参数，可以由n确定，满足：<br>                            $1-n\beta + \beta &#x3D; 1$<br>                    eg：6个相邻点情况<br>                        <img src="/Computer-Graphic/p26.png" alt="旧顶点位置修改"><br>        <strong>另一种实现方式</strong>：<br>            1）以任意顺序分割原始网格点边；<br>            2）翻转接触<strong>新旧顶点</strong>的新边<br>                eg：在四边形ABCD中，一条四边形内的边连接AD，翻转后就连接BC了，即从一条对角线变成另一条对角线；<br>            （上面两步实际上就对应了插入新点、分割三角形）<br>            3）更新顶点的位置，参照上面的更新方法；<br>            结合图示理解<img src="/Computer-Graphic/p27.png" alt="通过分割、翻转边完成loop细分">；<br>    CatMull-Clark细分：<br>        场景：针对多边形网格，多用于四边形网格；<br>        方法：<br>            1）计算面点：<br>                为该面所有顶点位置的算数平均；<br>            2）计算边点：<br>                为该边的两个端点位置和相邻两个面的面面点，这四个点的算数平均；<br>            3）连接面点与相邻的边点，让一个四边形被划分为四个四边形；<br>            4）计算旧顶点的新位置：<br>                $v &#x3D; \frac{Q+2R+(n-3)S}{n}$；<br>                其中：<br>                    1）v为原始v点的新位置；<br>                    2）Q为原始点相邻面点的算数平均；<br>                    3）R为原始点相邻边点的算数平均；<br>                    4）S为原始点的坐标；<br>            注意：<br>                1）计算旧顶点的新位置的时候，本轮产生的面点和边点仅管已经通过连接变成顶点了，但是它们的位置不会再次更新；<br>                2）在下一轮中这些新的边点、面点会作为旧的顶点使用；<br>    网格简化：<br>        边塌陷：<br>            将边缩拢，两个端点变成一个，原来与两个端点相邻的边均与这一个点相邻；<br>        贪心算法：<br>            1）给每条边一个成本；<br>            2）每次对成本最小的边进行塌陷；<br>            3）重复知道简化到指定的元素（点&#x2F;边&#x2F;面）数目；</p>
<h2 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h2><p>阴影贴图：<br>    思想：不在阴影中的点必须同时被光源和相机看到；<br>    方法：<br>        第一步：从光源的“眼睛”看世界 - 生成深度快照（阴影贴图）<br>            1）将虚拟摄像机放在光源的位置，对准需要投射阴影的场景。像普通渲染一样，计算从光源到场景中每个可见点的距离（即深度值）。<br>            2）我们不关心这个点是什么颜色、什么材质，只关心它的深度。我们将这个深度值渲染到一张纹理（即阴影贴图）上。<br>            3）结果：这张阴影贴图本质上就是一张深度照片，记录了从光源视角看，离它最近的物体表面的<strong>深度信息</strong>。可以把它想象成光源的“记忆”——“我记得在这个方向上，最近的物体离我有多远”。<br>        第二步：从摄像机的眼睛看世界 - 进行深度比较<br>            1）现在回到我们正常的观察视角（摄像机视角）。对于屏幕上要渲染的每一个像素点P（对应世界空间中的一个点），我们需要判断它是否在阴影中。<br>            2）坐标变换：将点P的3D世界坐标，变换到第一步中光源的摄像机空间中。这样我们就得到了点P在光源视角下的坐标 (x_light, y_light, z_light)。<br>            3）投影与采样：将 (x_light, y_light) 归一化到纹理坐标，用它去采样第一步生成的阴影贴图，得到光源记忆中该方向上的最近深度值 d_map。<br>            4）深度比较：比较点P自己的深度 z_light 和阴影贴图记录的深度 d_map。<br>            如果 <strong>z_light &gt; d_map</strong>：说明点P比光源“记住”的最近表面还要远。这意味着在点P和光源之间有一个更近的物体挡住了光。点P在阴影中。<br>            5）如果 z_light ≈ d_map （在考虑一个微小偏差bias后）：说明点P就是光源“看见”的那个最近表面。点P被照亮。<br>    缺点：<br>        1）生成的是硬阴影，仅限于点光源；<br>        2）质量取决于阴影贴图的分辨率；<br>        3）涉及浮点深度的相等比较；<br>    优点：<br>        1）不需要知道场景的几何信息；</p>
<h2 id="光线追踪"><a href="#光线追踪" class="headerlink" title="光线追踪"></a>光线追踪</h2><p><code>光线、包围盒、求交，可能会出大题</code></p>
<p>使用光线追踪的原因：<br>    光栅化不能很好的处理全局信息，尤其是在光线在场景中多次弹射的时候：<br>        1）没有软阴影，是硬阴影；<br>        2）虽然效率高但是质量较差；</p>
<p>计算机图形学中对光线传播的假设：<br>    1）光线沿直线传播；<br>    2）光线交叉不会相互碰撞；<br>    3）光线从光源光源传播到眼睛；<br>    注意：<br>        前面两条在物理上实际上是错误的，最后一条在物理上是正确的（路径可逆）</p>
<p>光线投射算法Ray Casting算法：<br>    1）从视点或者像素出发，仅对穿过像素的光线反向追踪；<br>    2）当光线路径到达一个 离视点最近的 可见的 不透明物体的表面，则找到了屏幕上该像素对应的可见面；<br>    3）停止追踪；<br>    （缺点是没有考虑光线的反射和折射，阴影的判别实际上就和阴影贴图类似）<br>    <img src="/Computer-Graphic/p30.png" alt="光线投射算法">；</p>
<p>递归的光线追踪算法Whitted-Style光线追踪：<br>    基本思想：作为光线投射算法的延伸，通过追踪多条光线在场景中的路径，得到多个表面所产生的反射和折射的影响；<br>    基本过程：<br>        1）沿着到达视点的光线的相反方向追踪；<br>        2）经过屏幕上一像素点找到与视线所相交的物体表面点P0；<br>        3）继续追踪，找到影响P0处光强度所有光源；<br>        4）算出P0处精确的光线强度；<br>        5）结束条件：<br>            1）光线与光源相交；<br>            2）光线与漫反射表面相交；<br>            3）被追踪光线对第一个表面交点的光强贡献度趋近于0；<br>        <img src="/Computer-Graphic/p31.png" alt="递归的光线追踪算法">；</p>
<p>上述光线追踪算法的一个关键点：光线与物体求交；<br>    注意：<br>        一般的求交过程，是将光线与场景中所有物体尝试求交之后，对所有得到的交点排序，才能确定可见点；<br>        （传统的做法中，大部分工作量用在了求交上，因此求交的方法是我们优化的关键）；</p>
<p>光线求交：<br>    光线的定义：<br>        1）原点o；<br>        2）方向向量d；<br>        得到定义：光线上任意一点的计算公式 $r(t) &#x3D; o+td,0 \le t \l ∞$;<br>    光线与球面求交：<br>        将光线上一点带入球面方程求解；<br>        <img src="/Computer-Graphic/p29.png" alt="光线与球面求交"><br>    光线与隐式曲面求交：<br>        和与球面求交类似；<br>    光线与三角形网格求交：<br>        基本思路：考虑光线与每一个三角形求交；<br>        方法一：<br>            1）光线与三角形所在平面求交点；（平面也有自己的方程，和与球面求交类似）；<br>            2）判断交点是否在三角形内部（参考前面有很多方法）；<br>        方法二：<br>            直接利用重心坐标建立方程：<br>                $o + td &#x3D; (1-b_1-b_2)P_0+b_1 P_1 + b_2 P_2$<br>            如果：$0 &lt; b_1,b_2,1-b_1-b_2&lt;1$ 则光线与三角形相交；<br>        注意：<br>            方法二刚快，但是本质上两个方法是一样的，只是在重心坐标建立的方程中三角形的三个点又同时表征了平面；<br>    问题：<br>        1）光线与三角形网格求交是图形渲染管线中的常态；<br>        2）简单的光线求交方法，判断一条光线与哪个三角形网格相交，需要将这条光线与所有三角形求交，然后排序判断；<br>        3）问题的规模是：$像素数量 \times 三角形数量 \times 弹射数量(若有)$<br>            （对于一条光线就已经到这个规模了，很慢，需要加速！）；</p>

        


        <span>
          <a class="article-read" href="/2025/12/15/Computer-Graphic/"> Read more -->
          </span>
        </div>

        
    
    <div class="recent-post-item">

      <a href="/2025/12/05/Double-Cross/" class="item-title">Double Cross</a>
      
      <time datetime="2025-12-04T16:12:19.000Z">
        2025-12-05
      </time>
      
      <!-- <div class="article-digest"> -->
        <!-- 获取金币
治理家业，点数大于3，5金币
投资事件获取金币，20金币与队友，40金币
赌马、赌狗（全选月牙，最后只赌1个金币），双倍金币
空置的宅邸，放入治理家业可以有额外金币
金奢靡用净化之火，30金币
金币放入俺寻思，会有打工

获取情报
上朝
浴场
书店
玛希尔长期研究
情报卡放进俺寻思，触发情报卡事件可以获得

获取装备
空置宅邸，异国商人出租，卖装备
阿迪莱，带宝剑
净化之火，金纵欲、杀戮、征服；魅力8、社交8、隐匿8
妖精国的书，完成冒险得到提灯，放入俺寻思

获取道具
侠名大于等于10，生命权杖，选前两个
星空之镜、小鳄鱼
热气球，玛希儿研究
金猫战士，夏玛父亲讨伐
传承挂毯，异国商人处购买
黄金鸟
部落的奇珍，恶名大于等于10，傲慢之罪获得

人物属性增加
买书
野外事件
厨子哈比卜，做食物
绣娘，化妆
哈桑，写诗增加属性

队友收集
贝姬夫人、哈桑、热娜、马尔基娜、阿图娜尔（命运商店购买）
梅姬，妻子的不满，放饰品升级，或命运商店升级
鲁梅拉，书店门口的乞丐事件
扎齐尔，救两次法图娜
法图娜，不要教导扎齐尔不好的东西
玛希尔，资助两次
哲瓦徳，监狱解救
盖斯，监狱救出， -->
        <!-- </div> -->

        
        <h2 id="获取金币"><a href="#获取金币" class="headerlink" title="获取金币"></a>获取金币</h2><ol>
<li>治理家业，点数大于3，5金币</li>
<li>投资事件获取金币，20金币与队友，40金币</li>
<li>赌马、赌狗（全选月牙，最后只赌1个金币），双倍金币</li>
<li>空置的宅邸，放入治理家业可以有额外金币</li>
<li>金奢靡用净化之火，30金币</li>
<li>金币放入俺寻思，会有打工</li>
</ol>
<h2 id="获取情报"><a href="#获取情报" class="headerlink" title="获取情报"></a>获取情报</h2><ol>
<li>上朝</li>
<li>浴场</li>
<li>书店</li>
<li>玛希尔长期研究</li>
<li>情报卡放进俺寻思，触发情报卡事件可以获得</li>
</ol>
<h2 id="获取装备"><a href="#获取装备" class="headerlink" title="获取装备"></a>获取装备</h2><ol>
<li>空置宅邸，异国商人出租，卖装备</li>
<li>阿迪莱，带宝剑</li>
<li>净化之火，金纵欲、杀戮、征服；魅力8、社交8、隐匿8</li>
<li>妖精国的书，完成冒险得到提灯，放入俺寻思</li>
</ol>
<h2 id="获取道具"><a href="#获取道具" class="headerlink" title="获取道具"></a>获取道具</h2><ol>
<li>侠名大于等于10，生命权杖，选前两个</li>
<li>星空之镜、小鳄鱼</li>
<li>热气球，玛希儿研究</li>
<li>金猫战士，夏玛父亲讨伐</li>
<li>传承挂毯，异国商人处购买</li>
<li>黄金鸟</li>
<li>部落的奇珍，恶名大于等于10，傲慢之罪获得</li>
</ol>
<h2 id="人物属性增加"><a href="#人物属性增加" class="headerlink" title="人物属性增加"></a>人物属性增加</h2><ol>
<li>买书</li>
<li>野外事件</li>
<li>厨子哈比卜，做食物</li>
<li>绣娘，化妆</li>
<li>哈桑，写诗增加属性</li>
</ol>
<h2 id="队友收集"><a href="#队友收集" class="headerlink" title="队友收集"></a>队友收集</h2><ol>
<li>贝姬夫人、哈桑、热娜、马尔基娜、阿图娜尔（命运商店购买）</li>
<li>梅姬，妻子的不满，放饰品升级，或命运商店升级</li>
<li>鲁梅拉，书店门口的乞丐事件</li>
<li>扎齐尔，救两次法图娜</li>
<li>法图娜，不要教导扎齐尔不好的东西</li>
<li>玛希尔，资助两次</li>
<li>哲瓦徳，监狱解救</li>
<li>盖斯，监狱救出，和苏丹不一样，调查真相</li>
<li>奈布哈尼，在欢愉之馆销卡，用魅力5以上的角色销奢靡或纵欲卡；若奢靡卡，奴隶街纵火买哈布娜，救火派奈布哈尼，之后都让他去；若纵欲卡，最受欢迎的男人，主角魅力值大于5，蒙面人时奈布哈尼11点魅力以上，触发妓女事件，随机到朱娜或者夏玛，主角不去参加，过一段时间，触发浪子的悲哀，就可以让他入队，并且撕掉他的标签；（在前面的主角魅力值若最大，他也会入队，但是不能撕标签）</li>
<li>哲巴尔，打猎，征服卡，送战利品给他，拳击事件中击败他，则可以永久进队并撕掉标签</li>
<li>赛里曼，纵欲银妃，萨达尔尼，一系列事件最后放过赛里曼</li>
<li>法里斯，全选月牙，调查，触发唯一的答案，上朝纵欲女奴法徳耶，妻子接待，救赎事件放入幸福感，获得新月，法里斯可以撕掉标签并进队</li>
<li>阿迪莱，获得犀牛皮，猎场赢过她，送犀牛皮给她，培养战斗</li>
<li>流浪剑客，狭义大于等于9，劝说贵族</li>
<li>阿里木，小毛贼偷东西，放过他，人物对话夸奖他，白肚皮事件使用口哨，政敌事件，将小乞丐放进苗圃</li>
<li>拜玲耶，阴森的宅邸不放卡，夜的栖息地招募她</li>
<li>阿穆尔，阴森宅邸不放卡，发现凶手，胁迫加入</li>
<li>法尔达克，上朝15次，苏丹的捉弄，纵欲或奢靡，让他活下来，修完水渠后入队</li>
<li>拉伊德，杰莫尔，哈马尔，野外事件，击败，在监狱赎人</li>
<li>朱娜、贾丽娜，欢愉之馆，销卡，做后续人物</li>
<li>夏玛，+1激情，侠名大于等于10，征服她父亲</li>
<li>三个妖精，妖精国游记，妖精森林事件</li>
<li>芮尔，一直帮助她，谋反入队；如果没有触发奴隶纵火，在奈布哈尼线的肉体展览也可以选她，只是不能撕奈布哈尼的标签</li>
<li>索拉薇尔，奈布哈尼不靠谱的盟友，使用纵欲，选奴隶</li>
<li>伊曼，领受神恩10金币收祝福，第二次主角在有祝福的时候用纵欲卡，秘密幽会隐匿判定</li>
<li>召唤物，密教事件放进俺寻思，触发传教发展出密教徒词条，拜玲耶入队送献祭图纸，图纸放入俺寻思，四次之后获得召唤图纸，上祭品后获得召唤物</li>
<li>娜依拉，纵欲她，杀奴隶</li>
<li>古利斯，杀娜依拉</li>
<li>巴拉特，纵欲铜妃，安苏亚，做任务获得倒酒哑铃，给巴拉特</li>
</ol>
<h2 id="队友培养"><a href="#队友培养" class="headerlink" title="队友培养"></a>队友培养</h2><p>原则：单个人物培养两个属性；主角全面发展</p>
<p>化妆之后自带重投骰子：主角、主角的双胞胎、玛希尔、哈桑</p>
<h3 id="体魄-战斗"><a href="#体魄-战斗" class="headerlink" title="体魄+战斗"></a>体魄+战斗</h3><p>哈马尔、哲巴尔（基础属性高）</p>
<p>流浪剑客、阿迪莱（化妆后可以双持武器）</p>
<p>古利斯进队比较苛刻，如果入手了可以培养</p>
<p>拉伊德化妆后可以双持武器，但是基本属性是魅力比较突出</p>
<h3 id="魅力-社交"><a href="#魅力-社交" class="headerlink" title="魅力+社交"></a>魅力+社交</h3><p>阿图娜尔，任务自带升级</p>
<p>夏玛，化妆后有13点魅力+社交</p>
<p>法拉杰，化妆后有11点魅力+社交</p>
<p>伊曼，需要纵欲，一般走正教路线才会拉他</p>
<p>朱娜，化妆后属性高</p>
<p>奈布哈尼、梅姬，化妆完成后带双饰品栏</p>
<h3 id="体魄-生存"><a href="#体魄-生存" class="headerlink" title="体魄+生存"></a>体魄+生存</h3><p>主要用来啊赚钱</p>
<p>法里斯、杰莫尔、哲巴尔（化妆后生存+体魄高）</p>
<p>铁头后期做盒饭</p>
<p>小圆化妆后生存高，可以用来打工</p>
<h3 id="隐匿"><a href="#隐匿" class="headerlink" title="隐匿"></a>隐匿</h3><p>蒙面战士（赛里曼），化妆后隐匿高</p>
<p>快脚</p>
<p>阿穆尔（天生自带3点隐匿）</p>
<p>法图娜，化妆后带4点隐匿</p>
<p>阿里木、流浪剑客</p>
<h3 id="智慧"><a href="#智慧" class="headerlink" title="智慧"></a>智慧</h3><p>玛希尔、热娜天生需要智慧，用来研究和做装备</p>
<p>备用：主角、主角的双胞胎、伊曼、阿穆尔、哲瓦德</p>
<h3 id="魔力"><a href="#魔力" class="headerlink" title="魔力"></a>魔力</h3><p>鲁梅拉，飞升剧情魔力可以加到其他角色身上</p>
<p>拜铃耶</p>
<p>哈桑，前期自带1点魔力</p>
<p>有点加魔力的书籍必须要1点魔力才能阅读，所以最好注意入手一些带魔力的装备（古老丝质披风、微笑王冠、金羊耳环）</p>
<h2 id="声望"><a href="#声望" class="headerlink" title="声望"></a>声望</h2><p>一般是通过随机事件和固定的剧情来加</p>
<h3 id="善名"><a href="#善名" class="headerlink" title="善名"></a>善名</h3><p>20时可以出净化之火，销卡</p>
<p>30善名，在改革或保守的坏结局中被救</p>
<h3 id="恶名"><a href="#恶名" class="headerlink" title="恶名"></a>恶名</h3><p>恶之化身，大于20后触发仪式，变成恶魔</p>
<h3 id="权势"><a href="#权势" class="headerlink" title="权势"></a>权势</h3><p>3权势开监狱</p>
<p>小于5的时候每次上朝带金币可以加一点权势</p>
<p>权势大于等于5的时候有特殊判定</p>
<p>谋反线要权势6的时候触发政敌的清流交汇任务</p>
<h3 id="侠名"><a href="#侠名" class="headerlink" title="侠名"></a>侠名</h3><p>侠名高可以触发流浪剑客任务、舍屋的建造、玛希尔研究出生命权杖</p>
<h3 id="灵视"><a href="#灵视" class="headerlink" title="灵视"></a>灵视</h3><p>灵视关联：正教、密教、心灵之战等任务线</p>
<h2 id="销卡"><a href="#销卡" class="headerlink" title="销卡"></a>销卡</h2><p>一张金色、两张银色、两张铜色、两张岩石</p>
<h3 id="纵欲卡"><a href="#纵欲卡" class="headerlink" title="纵欲卡"></a>纵欲卡</h3><p>妃子：要准备东西</p>
<ol>
<li>法德耶：20金币 or 玛希尔</li>
<li>安苏娜：进入了巴拉特，寻找道具；三张铜、银情报</li>
<li>萨达尔尼</li>
<li>萨姬：30金币、奇珍、魅力3以上的装备、金色内幕、主角带上双头龙或荒唐的情诗上朝</li>
</ol>
<p>欢愉之馆：不同角色可以分别销一张</p>
<p>放如俺寻思，跟带激情的队友销卡；或者跟任意队友，只是要放荒唐的情诗</p>
<p>事件：娜依拉、法尔达克</p>
<p>妻子的约会</p>
<p>金纵欲：沙姬、流浪剑客（主角魅力大于6，判定点数少于5）、生命权杖选梅姬</p>

        


        <span>
          <a class="article-read" href="/2025/12/05/Double-Cross/"> Read more -->
          </span>
        </div>

        
    
    <div class="recent-post-item">

      <a href="/2025/12/01/Computer%20Network/" class="item-title">Computer Network</a>
      
      <time datetime="2025-12-01T10:45:39.000Z">
        2025-12-01
      </time>
      
      <!-- <div class="article-digest"> -->
        <!-- 期末复习，知识点记录
传输层端口号的作用；在TCP、UDP中的使用（SOCKET嵌套字）；熟知端口号范围；端口号的独立性；
传输层的功能；传输层复用和分用的体现；TCP与UDP差错检测的区别；传输层向应用层提供的两种服务的特点
常见应用层协议使用的传输层端口号：HTTP、FTP、TFTP、DNS；TELENT、SMTP；SNMP
有连接的传输、无连接的传输；可靠的传输、不可靠的传输；
UDP首部格式（8B）；伪首部的格式（12B）；UDP校验和计算方式（伪首部，0，17）；UDP使用校验和检错；
UDP与TCP的对比：1）首部长度2）是否支持报文的拆分、重装3）连接？可靠？拥塞控制？4）一对一？一对多？
TCP是面向字节流的（报文Y报文Z的例子）；MSS的含义（通常不会太大，避免IP分段；双方可以不同）
TCP报文：1）源端口、目的端口2）序号，含义（不一定从0开始）3）确认号，含义4）数据偏移，含义，单位5）URG，ACK，PSH，RST，SYN，FIN，含义；出现的时机；对应报文段段别称6）rwnd含义，具体情况下的计算7）TCP校验和计算（伪首部，0，6）；8）紧急指针，含义9） -->
        <!-- </div> -->

        
        <p><code>期末复习，知识点记录</code></p>
<h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p>端口号的作用；<br>在TCP、UDP中的使用（SOCKET嵌套字）；<br>熟知端口号范围；<br>端口号的独立性；</p>
<p>传输层的功能；<br>传输层复用和分用的体现；<br>TCP与UDP差错检测的区别；<br>传输层向应用层提供的两种服务的特点</p>
<p>常见应用层协议使用的传输层端口号：HTTP、FTP、TFTP、DNS；TELENT、SMTP；SNMP</p>
<p>有连接的传输、无连接的传输；<br>可靠的传输、不可靠的传输；</p>
<p>UDP首部格式（8B）；<br>伪首部的格式（12B）；<br>UDP校验和计算方式（伪首部，0，17）；<br>UDP使用校验和检错；</p>
<p>UDP与TCP的对比：<br>1）首部长度<br>2）是否支持报文的拆分、重装<br>3）连接？可靠？拥塞控制？<br>4）一对一？一对多？</p>
<p>TCP是面向字节流的（报文Y报文Z的例子）；<br>MSS的含义（通常不会太大，避免IP分段；双方可以不同）</p>
<p>TCP报文：<br>1）源端口、目的端口<br>2）序号，含义（不一定从0开始）<br>3）确认号，含义<br>4）数据偏移，含义，单位<br>5）URG，ACK，PSH，RST，SYN，FIN，含义；出现的时机；对应报文段段别称<br>6）rwnd含义，具体情况下的计算<br>7）TCP校验和计算（伪首部，0，6）；<br>8）紧急指针，含义<br>9）选项的作用（在握手1、2协商MSS etc）<br>10）填充段的长度计算（tip：数据偏移）</p>
<p>TCP校验和计算、UDP校验和计算 对比 IP校验和计算，相同点，不同点</p>
<p>TCP协议的主要阶段：<br>1）三次握手<br>2）全双工<br>3）四次挥手</p>
<p>三次握手的细节：<br>1）SYN、ACK、seq、ack的变化<br>2）第3次握手携带数据，携带多少B消耗多少序号，否则不消耗序号<br>3）第1、2次握手会消耗序号（影响seq、ack）<br>4）客户端、服务器开始发送数据的最短时间</p>
<p>四次挥手的细节：<br>1）FIN、ACK、seq、ack<br>2）挥手1、3可以不携带数据，但也要消耗一个序号<br>3）挥手2可以携带数据，挥手4不能携带数据<br>4）收到挥手4的一方立刻CLOSE；收到挥手3的一方，要等待2MSL时间（重新计时？）<br>5）服务器可以先发出挥手1<br>6）客户端从挥手1到CLOSE，最短RTT+2MSL；服务器从挥手1到CLOSE，最短1.5RTT（挥手2、3连续发出）</p>
<p>重传机制中的问题：<br>1）确认报文丢失<br>2）超时定时器设置过短</p>
<p>基本的超时定时器（重传时间）设置：<br>1）大于RTT<br>2）指数加权滑动平均法<br>3）超时倍增</p>
<p>TCP的流量控制：<br>1）流量控制的含义<br>2）流量控制的基本要求（公式，发送的字节数小于上次收到的窗口字段）<br>3）rwnd在流量控制中的作用（rwnd、seq、ack在互相发送过程中的变化）<br>4）零通知窗口与持续计时器<br>5）TCP报文发送的时机：3种控制方式</p>
<p>UDP没有流量控制</p>
<p>网络的拥塞控制<br>1）拥塞控制的含义<br>2）拥塞控制的方法（2个，哪个说TCP采用的）</p>
<p>TCP拥塞控制原理<br>1）最大发送窗口的设置（拥塞窗口、通知窗口）<br>2）有效发送窗口的计算<br>3）拥塞窗口的设置：累次增加、成倍减少（方法、问题）；慢开始（方法、问题）；拥塞避免（方法、阈值计算）<br>4）慢开始-&gt;到阈值-&gt;累次增加-&gt;超时重传-&gt;成倍减少(拥塞窗口？、阈值)-&gt;慢开始-&gt;累次增加-&gt;拥塞窗口到达最大的通知窗口值<br>5）？拥塞窗口减半 or 改为初始值，前者对应快重传（出现时机）<br>（<strong>综合运用，理解是否正确？</strong>）</p>
<h3 id="易错点"><a href="#易错点" class="headerlink" title="易错点"></a>易错点</h3><p>TCP数据偏移、UDP长度字段、MSS；对应的含义比较</p>
<h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>网络层的作用（目的）</p>
<p>网络层的功能（发送端和接收端；主机和路由器；执行、规划、建立连接）</p>
<p>网络层服务模型：虚电路网络、数据报网络</p>
<p>虚电路工作原理（转发表、信令协议）</p>
<p>路由器的主要功能：软件、硬件（输入端口（转发、排队）、交换结构、输出端口（缓存、调度机制））</p>
<p>路由器的三种交换结构：内存交换、总线交换、网络式交换</p>
<p>网络层的三大组件：<br>    IP协议（选路规则、数据报处理规则）<br>    路由协议（内部网关协议、外部网关协议）<br>    网络控制协议（ICMP）</p>
<p>接口interface（主机、路由器，对应IP）</p>
<p>IP点分十进制记法</p>
<p>几类地址的判断<br>    方法：IP地址第一Byte<br>    类型：A（0，8+24）、B（10，16+16）、C(110,24+8)、多播、实验开发</p>
<p>特殊：<br>网络号码，（全0本网络、0+111..环回测试），A类地址范围<br>主机号码，（全0当前主机、全1所有主机）</p>
<p>一些保留地址：本地主机测试、私有地址</p>
<p>ARP协议使用的背景</p>
<p>ARP表（表项的TTL）</p>
<p>ARP表的建立（广播查找 ARP请求、单播回应 ARP响应、TTL内使用）</p>
<p>DHCP协议（应用层，分配ID阶段、核实ID阶段）<br>    discover，68、654<br>    offer，67、654<br>    request，68、655<br>    ack，67、655<br>    （yiaddr、transaction ID）</p>
<p>IP数据报<br>    长度相关Header length、Datagram length（通常报头长度20B）<br>    Identifier、Flags、Offset（为什么要分组，如何分，8B）<br>    Upper-layer protocol(6 TCP、17 UDP)<br>    校验和（计算、检验）</p>
<p>常见数据链路可以承载的最大传输单元（MTU）<br>    与MSS类似，都是对应该层的最大数据长度（要考虑IP报头）；（与最大帧的区别是不考虑链路层报头）<br>    以太网1500B</p>
<p>路由器转发表、最长匹配原则（最佳匹配）</p>
<p>子网划分、网络地址计算（子网掩码）</p>
<p>Ipv4地址，CIDR表示法</p>
<p>分组转发算法（直接交付、特定主机路由、特定网络路由、默认路由；使用子网掩码匹配）；默认路由的子网掩码</p>
<p>超网聚合、路由聚合（多个C类地址子网聚合成超网），聚合后的地址数（注意去掉两个特殊的主机号）</p>
<p>路由聚合的好处（找到对应规模的网络地址所需的路由表项数目极大地减少）</p>
<p>最佳聚合（尽可能地将子网聚合在一起）</p>
<p>ICMP协议（网络层）：<br>    使用场景，网络中出现错误时进行测试<br>    测试过程（<br>        主机不断发送UDP报文，<br>        TTL逐渐增大，<br>        路由器据TTL丢弃报文并返回ICMP报文，<br>        主机计算对应RTT，<br>        直到目的主机返回ICMP “dest port unreachable”，因为目的端口通常使用较高的端口，不会有应用程序来处理它）<br>    ICMP报文由IP报文包裹（具体的信息处在IP的可选字段处）</p>
<p>路由选择协议（应用层，OSPF除外）<br>    关注：如何构建转发表（对比前面我们讨论的是如何转发）<br>    选路算法（全局 or 分布式；静态 or 动态）<br>        链路状态广播（LS），原理是Dijkstra；信息传播快，但是不易实现<br>        距离向量（DV），原理是Bellman-Ford方程；好消息传得快，坏消息传得慢（注意为什么）<br>    层次选路<br>        自治系统（路由器聚合而来），网关路由器（运行两种协议）<br>        intra-AS协议（域内选路协议，为内部节点设置表项目）、inter-AS协议（域间选路协议，为外部节点设置表项）</p>
<p>域内选路协议：IGP（内部网关协议）<br>    RIP协议<br>        基于DV，距离向量信息每30s通过响应报文在相邻节点间交换<br>        每次通告，距离向量最多包含25个AS内部的目的网络信息（Dx(y)，y可取的符号最多有25个，对应经过x可达的25个目的网络）<br>        由UDP提供服务<br>        好消息传播快，坏消息传播慢<br>    OSPF协议<br>        基于LS，使用可靠洪泛法（注意如何实现）将链路状态转发到所有其他相邻的路由器<br>        支持负载均衡（因为每个节点有全局信息）<br>        IP为其提供服务<br>        解决RIP坏消息传播慢的问题<br>    层次化的OSPF协议（Hierarchical OSPF）<br>        边界路由器，连接其他AS；<br>        主干路由器，主干网络上运行OSPF选路<br>        区域边界路由器，汇总自己到各网络的距离，通知其他区域边界路由器<br>        区域内路由器，区域内运行OSPF选路</p>
<p>域间选路协议：BGP（外部网关协议）<br>    路径向量协议<br>        边界网关通告它到达目的地的整个路径（边界网关X，目的地Z，Path(X,Z) &#x3D; X,Y1,Y2,…,Z））<br>        边界网关X可以发送路径向量给对等的边界网关W，推荐从X出发的路径（Path(W,Z) &#x3D; W,Path(X,Z)）<br>        eBGP，iBGP（不同AS的对等网关、相同AS的对等网关）</p>
<p>IPv6<br>    128位地址空间<br>    报头没有校验和<br>    没有分片机制</p>
<p>NAT网络地址翻译？</p>
<h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><p>物理层功能：高效地传输和接收01比特流，尽量不要出错，为数据链路层提供服务</p>
<p>数据通信模型<br>    全双工：点到点链路上可以同时传输两个比特流，每个方向传输一个<br>    半双工：一次仅支持数据向一个方向传输的点到点链路</p>
<p>网络适配器（数据链路层）<br>    网卡驱动程序对其进行管理<br>    基于网络的操作系统会完成网络协议的代码实现，为用户提供接口</p>
<p>物理层传输的具体链路<br>    物理介质：双绞线（电话线）、同轴电缆（电视连线）、光纤（高带宽、长距离）、空间（无线电破、微波、红外线电波等）</p>
<p>调制解调器<br>    功能：将代表01点信号放到链路上<br>    核心要求：抗干扰（因为发送到基带信号在传输过程中会失真，必须要求能够还原失真信号）<br>    调制方法：<br>        调幅（eg，幅度大是1，小是0）<br>        调频（eg，高频是1，低频是0）<br>        调相（eg，相位的不同变化对应0和1）</p>
<p>数据传输相关理论<br>    奈式准则<br>        理想低通信道的极限码元传输速率B&#x3D;2W（W是带宽）<br>        B的单位是Baud（码元&#x2F;秒）<br>        W的单位是Hz<br>        一个码元可能对应多个bit，和具体的信息调制、编码方式有关<br>    香农定理<br>        信道极限传输速率C&#x3D;Wlog2（1+S&#x2F;N）<br>        B的单位是bps<br>        S&#x2F;N是信噪比，转换为db做单位公式是10log10（S&#x2F;N）<br>    一个信号（码元）表示的bit数<br>        B&#x2F;C（对应该信号可能的状态有2^(B&#x2F;C)种）<br>        当B&#x2F;C不是整数的时候一般是向下取值，如果题目中有具体的暗示可能需要向上取值<br>    W是带宽，W&#x3D;频谱上限-频谱下限</p>
<p>正交振幅调制QAM<br>    含义：用振幅和相位对应一个信号（码元）<br>    M信号状态对应log2（M）个比特<br>    （书上16个信息状态的例子）</p>
<p>信道共享技术<br>    时分复用<br>        同步时分复用TDM（每个用户使用固定的时隙）<br>        统计时分复用技术SM（同意用户发送的数据帧不一定使用同一个时隙，但是要在时隙中加上目的地址）<br>    波分复用WDM<br>        常用于光纤中，不同波长的光波对应不同的信号<br>        掺耳光纤放大器：对衰减的光信号进行放大（物理层）<br>        DWDM，密集波分复用技术；eg，一根光缆中，放入100根一定速率的光纤，每根光纤使用16倍的DWDM（一个光纤同步传播16个不同波长的光线，对应16个不同的信号）<br>    码分复用技术CDMA<br>        每个用户使用不同的码型，使用相同的频带进行通信，但是互不干扰<br>        基本原理：<br>            一个比特划分成m个时间片（码片序列），序列中0对应-1，1对应+1<br>            用向量S表示该码片序列，其他用户的向量T，S与T”*“运算总为0，与原码卷积为1，与反码的卷积为-1<br>        传输：<br>            传输的过程中，传输方若使用S对应的码片序列，如果要传输0则用S反码，如果要传输1则用S对原码<br>            接收方接受到码片序列M，与S卷积运算，1）如果为0则是其他用户的数据，忽略；2）如果是+1则为1；3）如果是-1则为0</p>
<h2 id="期末重点"><a href="#期末重点" class="headerlink" title="期末重点"></a>期末重点</h2><p><code>根据老师划的重点整理的内容</code></p>
<h3 id="物理层-1"><a href="#物理层-1" class="headerlink" title="物理层"></a>物理层</h3><p>物理层的功能：<br>    高效、正确地传输01比特流，为链路层提供服务；</p>
<p>不同信道复用技术的区别：<br>    信道复用技术：<br>        频分复用、时分复用、统计时分复用、波分复用、码分复用；<br>        1）(FDM)频分复用的各路信号再同样的时间占用不同的带宽资源（频率带宽而非发送速率）；<br>        2）(TDM)时分复用的所有用户是在不同的时间占用同样的频带宽度；<br>        3）(FDMA)频分多址复用：在频分复用的基础上多个用户可以轮流使用同一频带，其中要包含地址信息；<br>        4）(TDMA)时分多址复用：在时分复用的基础上多个用户可以轮流使用同一时隙，其中要包含地址信息；<br>        5）(STDM)统计时分复用：使用STDM帧来传送数据，STDM帧不固定分配时隙，按需为每个用户动态分配时隙，其中要包含地址信息；<br>        （基本原理是一个STDM帧中有多个时隙，但小于总用户数量，用户有想发的数据就往集中器中发，集中器按顺序扫描输入缓冲，放入STDM帧的各个时隙中，当一个STDM帧的数据放满了就发送出去）<br>        6）(WDM)波分复用就是光的频分复用，但是由于光的频率很高，所以习惯用波长而不用频率这一概念，所以描述为波分复用；</p>
<p>FDM、TDM、FDMA、TDMA、STDM那种效率高：<br>    统计时分复用STDM的效率高，因为其对于每个用户没有固定使用的时隙，总是动态的进行分配，保证每一帧的时隙都被占用满，避免存在时隙有空便发送信号的情况，所以这种效率高；</p>
<h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><p>数据链路层的功能：<br>    正确地传输数据帧；</p>
<p>为了实现正确传输数据帧需要解决的三个基本问题：<br>    封装成帧、透明传输、差错检测；</p>
<p>封装成帧的含义：<br>    封装成帧就是在一段数据的前后分别添加首部和尾部，构成一个帧，使得接收方能够在收到物理层上交的比特流之后根据首部和尾部的标记，识别出帧的开始和结束；<br>    （首部、尾部的主要作用是帧定界）；<br>    （帧定数据部分有长度上限MTU，eg：以太网是1500B）；</p>
<p>透明传输的含义：<br>    无论什么样比特组合的数据，都能够按照原样没有差错地通过数据链路层进行正确地传输，不会因为数据中出现了与帧定界符相同的比特组合而导致传输的错误；</p>
<p>透明传输的方法：<br>    使用转义字符”ESC”，十六进制是0x1B；<br>    如果数据中有比特组合呈现出：SOH:0x01或EOT:0x04，则前面加上转义字符；<br>    如果数据中出现了ESC，也在前面加上ESC；</p>
<p>差错检测的含义：<br>    由于实际通信的链路并非是理想的，存在误码率，为了保证数据传输的可靠性，在计算机网络传输数据时，必须采用的手段，用于检测是否存在差错；</p>
<p>差错检测的方法：<br>    CRC循环冗余校验；<br>    发送方：<br>        1）原始k位01串数据；<br>        2）除数P，事先商量好n位；<br>        3）k位原数据+(n-1)个0作为被除数；<br>        4）被除数对除数进行模2除法；<br>        5）最终得到的n-1位余数，就是FCS（帧检验序列）<br>        6）k位原始数据+n-1位FCS，构成最终发送的数据；<br>    接收放：<br>        1）使用k+n-1位数据对约定好的除数做除法；<br>        2）如果余数为0则没有差错；<br>        3）否则存在差错；<br>    注意：<br>        1）n位余数可以用多项式生成，对应最高为X的n-1次方的多项式（因为有个常数）；<br>        2）eg：$p(X) &#x3D; X^3 + X^2$，对应：1100</p>
<p>传输差错：<br>    1）比特差错，差错检验可以避免；<br>    2）帧丢失、帧重复、帧失序；<br>        解决它们意味着：<br>            实现了可靠传输：数据链路层发送端发送什么，接收端就接收什么；<br>    注意：<br>        差错检验可以解决比特差错，但是这并不确保可靠传输；</p>
<p>PPP协议的组成：<br>    1）一个将IP数据包封装到串行链路的方法；<br>    （既支持同步传输（一连串比特连续传送），又支持异步传输（逐个字符的传输，8bit一字符，没有奇偶校验）<br>    2）用来建立、配置和测试数据链路连接的<strong>链路控制协议LCP</strong>；<br>    3）一套网络控制协议<strong>NCP</strong><br>    （其中的每个协议支持不同的网络层协议，例如IP、OSI的网络层）</p>
<p>PPP协议的数据帧：<br>    首部字段从前往后：<br>        1）标志字段F：0x7E（对应的就是首尾帧定界符）；<br>        2）地址字段A：0xFF，固定；<br>        3）控制字段C：0x03，固定；<br>        4）协议字段：<br>            1）紧接着控制字段；<br>            2）2个字节；<br>            3）表征当前信息字段的含义：<br>                0x0021，对应IP数据报；<br>                0xC021，对应链路控制协议LCP的数据；<br>                0x8021，对应网络层的控制数据（NCP协议）；<br>    尾部字段从前往后：<br>        1）FCS，两个字节，使用CRC；<br>        2）标志字段F：0x7E</p>
<p>PPP协议如何完成透明传输：<br>    对应的是组成的第一部分的作用（透明传输）；<br>    方法：<br>        字节填充：转义字符0x7D；<br>            1）若有0x7E，则修改为：0x7D，0x5E；<br>            2）若有0x7D，则修改为：0x7D，0x5D；<br>            3）若有小于0x20的字符，则修改为：0x7D，0x20+原字符<br>        零比特填充：<br>            1）尤其适用于同步传输的场景，传输一连串比特串；<br>            2）对于信息字段，只要发现有5个连续的1，则填入一个0（填在连续的1后面）<br>    通过这些方法：<br>        在所传a送的数据比特流中可以传送任意组合的比特流，而不会引起对帧边界的错误判断；</p>
<p>LCP链路配置协议的作用：<br>    用来建立、配置和测试数据链路连接；</p>
<p>NCP网络控制协议的作用：<br>    为新接入的用户个人电脑分配一个临时的IP地址；</p>
<p>PPP协议的工作状态：<br>    链路静止：<br>        1）PPP协议的起始和终止状态，这时用户个人电脑和ISP路由器不存在物理层的连接；<br>    链路静止-&gt;链路建立：<br>        个人电脑通过调制解调器呼叫路由器，路由器检测对应的载波信号，建立<strong>物理连接</strong>；<br>    链路建立-&gt;鉴别：<br>        进行LCP配置协商：<br>            链路的一端发送LCP配置请求帧，信息字段携带有特定的配置请求；<br>                eg：<br>                    1）最大帧长；<br>                    2）所使用的鉴别协议；<br>                    3）不实用PPP协议的地址和控制字段；<br>            链路的另一端发送：<br>                1）配置确认帧Ack：所有选项都接受；<br>                2）配置否认帧Nck：所有选项都理解但不接受；<br>                3）配置拒绝帧Reject：选项有的不能识别或无法接受，需要协商；<br>        注意：<br>            如果配置协商失败，<strong>链路建立-&gt;链路静止</strong>；<br>    鉴别：<br>        该状态只允许传送LCP协议的分组，鉴别协议的分组以及监测链路质量的分组；<br>        eg：<br>            使用PAP口令鉴别协议：<br>                要求发起通信方，发送身份标识符和口令，系统允许用户重试多次；<br>    鉴别-&gt;网络层协议：<br>        如果鉴别成功 or 不需要鉴别；<br>        注意：<br>            如果鉴别失败，<strong>鉴别-&gt;链路终止</strong>；<br>    网络层协议：<br>        PPP协议的两端的网络控制协议NCP根据网络层不同的协议，交换网络层特定的网络控制分组；<br>        （重要的一步，是路由器能够同时支持多种网络层协议的关键，从而让PPP协议两端端网络层在使用不同网络层协议的基础上，仍然使用同一个PPP协议进行通信）；<br>        eg：<br>            如果使用IP协议，则使用NCP中支持IP协议的IPCP（IP控制协议），将其封装成PPP帧，在链路上传送；<br>    网络层协议-&gt;链路打开：<br>        NCP配置协商完成；<br>    链路打开：<br>        1）链路的两个PPP端点可以向彼此发送分组；<br>        2）也可以发送给回送请求、回送回答对应的LCP分组，来检查链路状态；<br>    链路打开-&gt;链路终止：<br>        终止请求：<br>            1）数据传输结束后，由链路的一方发送终止请求LCP分组，请求终止链路；<br>            2）接收到终止请求的一方，发送终止确认LCP分组，确认终止；<br>            3）转到链路终止状态；<br>        链路故障；<br>    链路终止-&gt;链路静止：<br>        调制解调器的载波停止；</p>
<p>CSMA&#x2F;CD协议（载波监听多点接入&#x2F;碰撞检测 协议）<br>    背景：<br>        计算机之间在数据链路层端到端的通信，是通过总线实现的；<br>            尽力而为：<br>                1）这是无连接的工作方式，适配器对数据帧不编号、不要求确认，仅发送；<br>                2）以太网提供了尽最大努力的交付（不可靠交付），出现差错是否重传由高层决定；<br>                3）即使有重传帧，以太网也不知道，只是当作新的数据帧传输；<br>            总线传输：<br>                1）共用一个总线，在同一时间只能允许一台计算机发送数据；<br>                2）半双工通信；<br>            编码：<br>                使用曼彻斯特编码，用跳变来代表01<br>                （曼彻斯特编码跳变发生在虚线处、曼彻斯特编码跳变发生在虚线间）<br>    CSMA&#x2F;CD协议的作用：<br>        在上述背景下，以太网采用最简单的随机接入，所以需要一个协议来减少冲突发生的概率；<br>        （好像一个没有主持人的会议，大家想发言就发言，但是要找到一个规则，让大家的发言尽可能不同时发生，产生冲突；于是有了CSMA&#x2F;CD协议）；<br>    各部分的含义：<br>        CS：载波监听；<br>            边发送边监听，站点不管在发送数据之前，还是在发送数据之中，每个站都必须不停地检测信道；<br>            （在发送之前监听，是为了<strong>碰撞避免</strong>）；<br>            （在发送中监听，是为了<strong>碰撞检测</strong>）；<br>        MA：多点接入；<br>            说明这是总线型网络，许多计算机以多点点方式连接在一根总线上；（这就是一个背景，CS、CD才是协议的实质关键）；<br>        CD：碰撞检测；<br>            适配器边发送数据边检测信道上的信号电压变化情况；<br>            （当两个站点同时发送数据的时候，总线上信号电压的幅度会变大）<br>    CSMA&#x2F;CD协议的内容：<br>        1）准备发送：网卡从网络层接收数据报，封装成帧；<br>        2）检测信道：<br>            如果网卡监听到信道空闲（96比特时间，信道上没有信号），则开始传送帧；<br>            如果监听到信道忙，则等待信道空闲（从没有信号开始，经过96比特时间）才开始传送帧；<br>            96比特时间称为<strong>帧间最小间隔</strong>；<br>        3）边听边发：<br>            如果在<strong>争用期</strong>内一直未检测到碰撞，就认为发送成功（尽管此时可能还没发送完，接着发送完毕即可），回到1）；<br>            （接收方如果发现数据帧有差错就直接丢弃，等待高层来处理）；<br>            如果<strong>争用期</strong>内检测到碰撞，就立刻停止发送数据，并按规定发送<strong>人为干扰信号</strong>，然后适配器执行<strong>截断二进制指数退避算法</strong>，等待r倍争用期之后，回到步骤2）；<br>            如果重传达到<strong>16次</strong>，仍然不能成功，停止重传向上报错；<br>            （在10Base5以太网中，对应的争用期是512比特时间，计算如下）；<br>            <img src="/Computer-Network/p1.png" alt="争用期计算"><br>        关键概念：<br>            1）帧间最小间隔，96比特时间；<br>            2）争用期：<br>                1）是对于发送端而言的时间概念；<br>                2）从发送端开始发送，一个RTT的时间（2倍总线端到端的传播时延）；<br>                3）这个时间就是发送站发送数据之后，最迟要经过多长的时间才能知道自己发送的数据和其他站发送的数据有没有发生碰撞；<br>            3）截断二进制指数退避算法：<br>                作用：决定冲突后等待，重新开始检测信道的时间；<br>                算法：<br>                    1）从离散集合 $[0,1,\dots,2^{k-1}-1]$ 中随机挑选一个数r；<br>                    2）其中 $k &#x3D; min(10，重传次数)$；<br>                    3）推后r倍的争用期（ $r \times RTT$ ），然后开始重新检测信道；<br>                （当重传次数达到16次之后会停止重传，向高层汇报）；<br>            4）强化碰撞：<br>                发送<strong>32比特或48比特</strong>的人为干扰信号，以便让所有用户都知道现在已经发送了碰撞；<br>            5）最短帧长：<br>                目的：为了确保载波监听可以发现争用期内的冲突；<br>                eg：<br>                    如果某站发送了一个很短的帧，但在发送完毕之前没有检测出碰撞（即载波监听时间内没有发现冲突），但是在向前传播到目的站之前和别动站发生了冲突（目前仍然在争用期以内），因而目的站会接收到有差错的帧，并将它丢弃；但是发送站不知道这个帧发生了碰撞，因而不会重传这个帧；<br>                本质原因：<br>                    1）发送的帧太短了，完全用不了一个争用期的时间；<br>                    2）而载波监听只会在发的时候进行；<br>                    3）如果有冲突发生，理论最迟监听到的时间是一个争用期的时间；<br>                    4）所以至少要让发送时间大于一个争用期；<br>                于是最短帧长：<br>                    L&#x2F;发送速率 &gt;&#x3D; RTT（争用期）；<br>                注意：<br>                    1）如果发送的数据不足最短帧长，则必须加入一些填充字节；<br>                    2）小于最短帧长的数据都被站点认为是，由于冲突而异常终止的无效帧，收到后会立刻丢弃；<br>                    （10Base5的以太网，对应的就是64字节，512比特）；</p>
<p>相关设备：<br>    网桥（链路层）：<br>        作用：对收到的帧根据MAC帧目的地址进行转发和过滤；<br>        不能隔离冲突域；<br>    转发器、集线器（物理层）：<br>        不能隔离冲突域；<br>    以太网交换机（链路层）<br>        实质：多端口网桥；<br>        工作方式：全双工；<br>        作用：让相互通信的主机可以独占传输媒体，无碰撞地传输数据；<br>        原理：<br>            多端口负责接收数据和转发数据，自学习构建转发表；<br>            存储支持暂存再发送，从而隔离冲突域，用户尽管往交换机发；<br>        可以隔离冲突域；<br>    路由器（网络层）<br>        可以隔离冲突域；</p>
<h3 id="网络层-1"><a href="#网络层-1" class="headerlink" title="网络层"></a>网络层</h3><p>网络层的主要功能：<br>    完成不同网络中的两个主机之间的通信；</p>
<p>路由器之间传送信息：<br>    1）转发源主机和目的主机之间所传送的数据（将源主机发送的分组一个一个路由器的转发，直到转发到目的主机）；<br>    2）传送路由器信息（根据路由选择协议所使用的路由算法，彼此不断地交换路由信息分组，从而建立路由表）；</p>
<p>ipv4几个类网络地址：<br>    网络地址+主机地址；开头；<br>    1）A：8+24；0；<br>    2）B：16+16；10；<br>    3）C：24+8；110；<br>    其他：<br>        1）D：1110+多播地址；<br>        2）E：1111+实验开发；<br>    注意：<br>        <strong>如何通过开头的地址判断网络类型</strong>；<br>    特殊号码：<br>        1）A类中00000000网络号码，代表<strong>本网络</strong>；<br>        2）A类中01111111网络号码，代表<strong>本地环回测试</strong>；<br>        （B类、C类没有这个问题）；<br>        3）网络号不为全0主机号为全0，代表某个<strong>特定网络</strong>；<br>        4）网络号为全0主机号不为全0，代表<strong>当前网络特定主机</strong>；<br>        5）网络号和主机号均为0，代表<strong>当前主机</strong>；<br>        6）网络号不为全1，主机号为全1，<strong>特定网络的所有主机</strong>；<br>        7）网络号全为1，主机号全为1，代表<strong>当前网络所有主机</strong>；<br>        （注意6、7都可以指广播地址，要注意具体的应用场景）；<br>        8）127.0.0.1，本地主机测试地址；<br>    按照某类地址给机构划分子网：<br>        1）可以使用二叉树划分法；<br>        2）注意划分的时候主机号全0全1不能用；<br>        （对应特殊号码的3、6）</p>
<p>ipv4 IP数据包报头：<br>    1）Version（版本号）：<br>        1）0100-ipv4；<br>        2）0110-ipv6；<br>    2）Header length（首部长度）：<br>        1）标识首部长度，<strong>单位是4字节</strong>，ip数据报头最短是20字节，所以该字段最小为5；<br>    3）type of service（区分服务）：<br>        1）一般情况下不会使用这个字段；<br>    4）datagram length（数据报）：<br>        1）数据包总长度，<strong>单位是字节</strong>，该字段是16位，所以ip数据包最长是<strong>65535字节</strong>；<br>        2）如果ip数据包进行了分片，则该字段是当前分片（ip报头+分片数据）的总长度；<br>    5）identifier（标识）：<br>        1）当ip数据报需要分片的时候，来自于同一数据报的分片数据报该字段相同，用来<strong>标识分片身份</strong>；<br>        2）实际的赋值机制，是每产生一个数据报计数器就加1（未分片），然后对该数据报进行分片，完成后，将这个字段的值复制到每一个分片；<br>    6）flag（标志）：<br>        1）3位只有两位有意义；<br>        2）最低位MF，1代表后面还有分片，0代表没有分片；<br>        3）中间位DF，1代表不能分片，0代表可以分片；<br>    7）Fragmentation offset（位偏移）：<br>        1）指出分片后，当前分片在原始数据报中的相对位置；<br>        2）偏移<strong>单位是8字节</strong>，也就是说除了最后一个分片其他分片的长度一定是8的倍数；<br>        3）该字段实际使用的时候，字段值是多少就代表该分片的数据部分，第一个字节，在原始数据中是第<strong>字段值乘8+1</strong>字节；<br>            eg：offset &#x3D; 0，则原来是第一个字节；<br>                offset &#x3D; 1，则原来是第65个字节；<br>        （当然如果直接考虑偏移量，使用第0个字节的表述，并以其作为开头的话，实际上offset*8的值就代表，当前分片开始的字节，在原始数据报中是第几个字节）；<br>        4）在分片的时候不能忘记，每个分片都要添加报头，<strong>报头在考虑最大分片长度</strong>的时候很重要；<br>        5）但是在计算offset的时候，不能加入报头，<strong>offset纯粹的使用数据部分进行计算</strong>；<br>        6）<strong>当前分片offset值 &#x3D; 前面所有分片的数据部分和，字节数&#x2F;8</strong>；<br>    8）TTL（生存时间）<br>        1）功能是作为跳数限制，防止不能到达目的地的IP数据报在互联网中兜圈子，浪费资源；<br>        2）当数据报到达一个路由器，<strong>在路由器转发它之前将TTL–，然后检查TTL是否等于0</strong>，如果等于0则丢弃；<br>        3）如果一个数据报只允许在局域网中转发，那么将TTL设置为1（到达该局域网的路由器的时候，TTL减为0就会被丢弃）；<br>        4）一个数据报能经过（到达）的路由器最大数量是255；<br>    9）upper-layer protocal（协议）<br>        1）指出当前IP数据报携带的数据来自于什么上层协议；<br>        2）常用的：<br>            ICMP-1；TCP-6；UDP-17；EGP-8；IGP-9；OSPF-89；<br>    10）check sum（首部检验和）<br>        1）只检验数据报的首部，不包括数据部分；<br>        2）每经过一个路由器就要重新计算首部检验和；<br>        3）计算方法是16位一组，相加，最高位有进位要回卷，结果取反；<br>        （接收方检验方法是16位一组相加，再取反，如果结果是0则没有出错，否则认为出错，丢弃）<br>    11）source address（源地址）<br>        1）32位，发送主机的IP地址；<br>        2）32位，接收主机的IP地址；</p>
<p>最长匹配原则</p>
<p>分组转发算法 路由表项的排列 特定主机路由 默认路由（若有 若无）</p>
<p>二叉线索<br>    1）用给定的几个IP（或网络前缀）构造二叉线索树；<br>    2）是否与唯一前缀匹配；（对应到叶节点）；<br>    3）与掩码运算-&gt;是否与网络前缀匹配；<br>    4）转发 or 默认转发 or 丢弃；</p>
<p><strong>ppt上的内容？</strong></p>
<p>RIP协议<br>    1）基于距离向量的选路协议；<br>    2）距离的定义（跳数、路由器数）<br>    3）不可达距离 16<br>    4）适用小型网络<br>    5）特点：和谁交换信息？交换哪些信息？（1、2、3）何时交换信息（1、2）？</p>
<p>距离向量算法：<br>    1）路由器维护的表项目、交换报文（RIP报文）的内容（1、2、3）；<br>    2）收到报文的操作：<br>        1）修改报文项目（1、2）；<br>        2）若无目的网络-更新表项目；<br>        3）若有目的网络-下一跳路由器？<br>        4）若是X-更新；<br>        5）若不是X-距离更小则更新；<br>    3）3分钟-不可达；</p>
<p>一个RIP报文最多25个路由-25个表项；</p>
<p>坏消息传得慢-例子（RIP报原始内容）</p>
<p>OSPF：<br>    1）使用链路状态协议；<br>    2）和谁交换信息（可靠的洪泛法）、交换哪些信息（1、2）、何时交换信息（30分钟）</p>
<p>OSPF收敛得快</p>
<p>OSPF使用层次结构区域划分<br>    1）主干区域：主干区域路由器&#x2F;区域边界路由器&#x2F;自治系统边界路由器（可同时）；<br>    2）其他区域；<br>    3）主干区域标识符号0.0.0.0，其他区域；</p>
<p>负载均衡：如果到同一个目的网络有多条相同代价的路径，那么可以将通信量分配给这几条路径；</p>
<p>OSPF五种类型的分组：<br>    1）问候分组（10s一次，40s没有则不可达）；作用？（初始时）；<br>    2）数据库描述分组；（交换链路状态摘要信息，用来确认哪些没有）；<br>    3）链路状态请求分组；（针对没有的请求）；<br>    4）链路状态更新分组；<br>    5）链路状态确认分组；</p>
<p>可靠的洪泛法：<br>    1）发送；<br>    2）转发（除了上游）；<br>    3）确认（忽略重复）；</p>
<p>为什么使用BGP？<br>    1）巨大规模的互联网，自制系统AS之间选路；<br>    2）考虑相关策略（可达性而非代价）</p>
<p>BGP使用：路径向量选路策略</p>
<p>BGP报文内容（到达AS1对应的前缀、发送报文的路由器、路由器所在的自治系统AS1）<br>BGP协议路由表（前缀X，下一跳路由器）-含义是下一跳经过路由器，前缀X可达；</p>
<p>eBGP、iBGP（区别，适用路由器）</p>
<p>iBGP的全连通</p>
<p>RIP OSPF BGP<br>1）RIP不能使用多条路由 OSPF可以负载均衡，每一个路由器都知道全网有多少路由器，哪些是相连的，代价是多少<br>2）RIP、OSPF是工作在一个AS内的 BGP工作在不同AS之间<br>3）使用的协议不同；<br>4）OSPF在网络层 RIP、BGP在应用层（分别由UDP、TCP服务）<br>5）OSPF、RIP属于IGP 对应BGP</p>
<h3 id="传输层-1"><a href="#传输层-1" class="headerlink" title="传输层"></a>传输层</h3><p>运输层的两个主要协议：<br>    1）TCP传输控制协议：提供可靠的、面向连接的运输服务；<br>    2）UDP用户数据报协议：无连接，实时、快速高效；</p>
<p>TCP报文中有一个可选项MSS：<br>    这是最大报文长度字段，代表的是数据字段的最大长度，这个字段要加上TCP首部的长度才是TCP报文的总长度；<br>    <em>考虑这个字段与拥塞控制的关系</em>；</p>
<p>TCP流量控制<br>    1）含义：让发送方的速率不要太快，要让接收方来得及接收；<br>    2）实现方式：滑动窗口；<br>    3）一些细节：<br>        1）发送方的发送窗口大小不能超过接收方给出的接收窗口rwnd；<br>        2）TCP窗口单位是字节不是报文段；<br>        3）当rwnd为0时对应零窗口报文段，发送方不允许再发送数据，直到接收方重新发送一个新的窗口值为止；<br>    4）什么时候会发送零窗口通知：<br>        1）接收端将接收到的数据放入缓冲区，如果上层应用不及时读取，缓冲区满了的时候；<br>        2）当接收方检测到可用窗口为0的时候；<br>        3）出现1、2两种情况的时候发送方在对于先前数据的确认报文中会通知rwnd&#x3D;0；<br>    5）零窗口的死锁问题：<br>        描述：<br>            接收方向发送方发送了零窗口报文段之后不久，接收方释放了一些空间，向发送方发送了rwnd&#x3D;400的报文段；但是报文段在传送中丢失了，发送方一直在等待接收方发送非零窗口报文段，接收方一直在等待发送方发送数据，陷入死锁；<br>        解决方法：<br>            TCP为每个链接设立的——持续时间计时器；<br>            机制：<br>                只要TCP连接的一方收到了零窗口报文段，就启动持续计时器，如果计时器时间到了就发送一个零窗口探测报文段（仅携带1字节数据），对方会在确认探测报文段时给出当前窗口值，如果仍是零，则重置计时器，否则死锁局面解除；</p>

        


        <span>
          <a class="article-read" href="/2025/12/01/Computer Network/"> Read more -->
          </span>
        </div>

        
    
    <div class="recent-post-item">

      <a href="/2025/11/07/Intro-of-AI/" class="item-title">Intro_of_AI</a>
      
      <time datetime="2025-11-07T05:33:57.000Z">
        2025-11-07
      </time>
      
      <!-- <div class="article-digest"> -->
        <!-- ch1 绪论ch2 搜索ch3：对抗搜索及博弈棋类介绍及分类棋类：完备信息的动态博弈；牌类：不完备信息的动态博弈；
棋类的特点：    可以决出胜负；    规则简单明确；    博弈过程透明、公平；    智力与经验决定胜负；    变化无穷；
一些具体的棋类特点：    象棋：60步不吃子判和；    国际象棋：相对子力；    围棋：规则最简单，计算机博弈难度最大；（1919）；    五子棋：已被证明先手必胜，有禁手；（1515）；    六子棋：先手下一子，之后每手下两子；（19*19）；
棋类的分类：    参与人数划分：        双人：象棋、围棋、五子棋等；        多人：跳棋；    按兵种分：        单一兵种：围棋、五子棋、六子棋；        多兵种：国际象棋、中国象棋；    按着法分：        走子类：开局摆好棋子后，轮流走动棋子；象棋等；        添子类：开局盘面无子，轮流落子；围棋等；        吃子类：对局过程中可以吃掉对方的子；象棋、围棋等；        混合类：在添子的过程中可以吃子、在走子的过程中可以吃子还可以 -->
        <!-- </div> -->

        
        <h2 id="ch1-绪论"><a href="#ch1-绪论" class="headerlink" title="ch1 绪论"></a>ch1 绪论</h2><h2 id="ch2-搜索"><a href="#ch2-搜索" class="headerlink" title="ch2 搜索"></a>ch2 搜索</h2><h2 id="ch3：对抗搜索及博弈"><a href="#ch3：对抗搜索及博弈" class="headerlink" title="ch3：对抗搜索及博弈"></a>ch3：对抗搜索及博弈</h2><h3 id="棋类介绍及分类"><a href="#棋类介绍及分类" class="headerlink" title="棋类介绍及分类"></a>棋类介绍及分类</h3><p>棋类：完备信息的动态博弈；<br>牌类：不完备信息的动态博弈；</p>
<p>棋类的特点：<br>    可以决出胜负；<br>    规则简单明确；<br>    博弈过程透明、公平；<br>    智力与经验决定胜负；<br>    变化无穷；</p>
<p>一些具体的棋类特点：<br>    象棋：60步不吃子判和；<br>    国际象棋：相对子力；<br>    围棋：规则最简单，计算机博弈难度最大；（19<em>19）；<br>    五子棋：已被证明先手必胜，有禁手；（15</em>15）；<br>    六子棋：先手下一子，之后每手下两子；（19*19）；</p>
<p>棋类的分类：<br>    参与人数划分：<br>        双人：象棋、围棋、五子棋等；<br>        多人：跳棋；<br>    按兵种分：<br>        单一兵种：围棋、五子棋、六子棋；<br>        多兵种：国际象棋、中国象棋；<br>    按着法分：<br>        走子类：开局摆好棋子后，轮流走动棋子；象棋等；<br>        添子类：开局盘面无子，轮流落子；围棋等；<br>        吃子类：对局过程中可以吃掉对方的子；象棋、围棋等；<br>        混合类：在添子的过程中可以吃子、在走子的过程中可以吃子还可以添子；日本将棋等；<br>    （通常情况下下棋的双方轮流走子，但是有的棋可以一次下多步，连续施着称为轮）<br>    按胜负判决分类：<br>        擒获首领：如象棋；<br>        摆成形状：如五子棋；<br>        占领领域：如围棋；<br>        剩余子粒：如黑白棋；<br>        活动剩余：如亚马逊；<br>        到达目标地：如跳棋；</p>
<h3 id="计算机博弈"><a href="#计算机博弈" class="headerlink" title="计算机博弈"></a>计算机博弈</h3><p>将搜索应用于博弈的思想：<br>    1）任何一方搜索时都要考虑对方可能的走步；<br>    2）优秀的搜索，不应该只考虑对方一步，而是考虑若干步；<br>    3）这个过程动态进行，当考虑对方若干步走了一子之后，待对方走子后，要重新进行考虑若干步；<br>    （即若干步的向后考虑只影响当前步的走子）</p>
<p>我们关注的博弈满足如下特点：<br>    1）双人对弈，双方轮流走步；<br>    2）信息完备，双方看到的棋局是一样的；<br>    3）零和博弈，非合作博弈，一方的收益必然意味着另一方的损失；</p>
<p>博弈的基本原理（普遍、基本、其他规律的基础）<br>    1）棋类要素，棋盘、棋子、棋规（着法与胜负规则）；<br>    2）弈棋要素，用着法推演局面，从有利局面中选择着法；<br>    3）局面评估，指标分析，根据棋种不同而具体分析；<br>    （实际上这三个点构成了我们后续博弈树的基础）</p>
<p>弈棋过程的形式化描述：</p>
<ol>
<li>$S_n$：n手之后的局面</li>
<li>$q_{n+1}$：第n+1手</li>
<li>$Q$：棋谱$q$的集合</li>
<li>$Q_odd,Q_evn$：红方与黑方的着手</li>
</ol>
<p>棋局状态展开（计算机基于搜索的博弈过程）？<br>    1）在当前棋局状态上，使用着法生产器，由具体的着法算子生成可能的着法；<br>    2）使用对应的着法，考虑转移后的棋局状态，即博弈树展开；<br>    3）根据具体的搜索策略，在博弈树上做搜索；<br>    4）对搜索到的叶节点做状态评估，最终确定着法？</p>
<h3 id="棋局要素的数据结构"><a href="#棋局要素的数据结构" class="headerlink" title="棋局要素的数据结构"></a>棋局要素的数据结构</h3><p>计算机博弈数据结构主要涉及：<br>    1）对棋盘、棋子、棋局进行编码；<br>    2）对着法、规则、知识等进行编码；<br>    3）编码得到数据元素，将各种数据元素以特定关系构成数据结构；</p>
<p>常见的编码方法：<br>    1）棋盘：棋位编码（eg，数字对应位置）<br>    2）棋子：角色和方（eg，二元组）<br>    3）着法：棋位序列（eg，数字向量）<br>    4）局面：棋位棋子对的向量（eg，1）、2）构成的二元组，形成的向量）<br>    5）对局过程：着法形成的向量<br>    （当然具体的棋要考虑具体的编码方式）</p>
<p>局面（盘面）存储的最好方式：<br>    Zobrist哈希技术：将盘面转换为哈希数，哈希数即key、盘面即value；<br>        1）基本原理<br>            1）每个棋子的位置、颜色（所属方）、角色，转换为64位随机数；<br>            2）将棋盘上的每个棋子对应的随机数异或求和；<br>            3）得到的结果作为64位哈希数，key，作为盘面的索引值（Zborist键值）；<br>        2）好处：<br>            根据哈希数的定义，当盘面变化的时候只需要用当前盘面的哈希数与相应变化棋子的哈希数异或一次，就可以得到新的盘面对应的哈希数；<br>        3）关键点：<br>            1）在转换为64位随机数的时候，我们要使用到哈希算法，本质是将任意长度的二进制值映射为固定长度的较小二进制值，即哈希值；（eg，因为棋子本质上经过编码在计算机中最终是以01的形式存储的，它可能是一段很长的01串，被我们转换为了一个64位的01串）<br>            2）哈希算法要求对应的散列空间，满足：想找到两个不同的输入可以满足有相同的散列值，在计算上是不可能的；<br>        4）注意：<br>            1）我们无法直接将Zobrist的哈希数key直接转换为value，也没必要这样做，因为设计Zobrist表的目的本身是为了指纹而非压缩；通常可以将盘面作为value存储起来，key即哈希数，建立一个“一一映射”，就像我们开头提到的一样；（这样我们能够给基于一个key，快速找到一个盘面，当然如果是之前没有保存过的key-value，是找不到的）<br>            2）Zobrist技术的应用通常是为了：<br>                1）快速识别：判断两个局面是否相同；<br>                2）重复检测：检测是否到达过某个局面；<br>                3）查表加速：在置换表中快速查找局面的评估值；<br>                （而非完全把弈棋过程转换为异或运算，抛弃其他信息；这也是肯定做不到的，因为信息就不对等）</p>
<p>位棋盘（Bit Board）<br>    应用场景：在着法生成是需要对棋局进行评估，评估的时候时常只关心一些棋子的分布，这是可以用比特棋盘（位棋盘）；<br>    使用方式：本质就是棋子状态条件的布尔表示；<br>    形式化表示：$B &#x3D; {b_{i,j}}<em>{m \times n}$，其中$b</em>{i,j} &#x3D; 1,when:s_{i,j} &#x3D; true$，以及$b_{i,j} &#x3D; 0,when:s_{i,j}&#x3D;false$；而$s_{i,j}$就是棋位$(i,j)$的布尔条件；<br>    eg：当关注某些棋位上是否有黑车时，条件就可以是在$(i,j)$上有黑车时，$s_{i,j}&#x3D;true$；</p>
<h3 id="博弈树展开与分析"><a href="#博弈树展开与分析" class="headerlink" title="博弈树展开与分析"></a>博弈树展开与分析</h3><p>博弈树的基本概念：<br>    博弈树：树枝和节点组成的单向无环图；<br>    树枝：对应着法；<br>    节点：对应着法生成的局面；<br>    <strong>博弈树的展开：着法的生成，代表从当前局面的演化和发展，是进行局面分析的基础</strong>；（当前局面作为根节点）；<br>        常见的着法生成策略（展开策略）：<br>            1）选择生成：根据当前局面，生成部分可行的着法，不考虑其他着法；（eg：象棋被将军的情况下要避将）；<br>            2）渐进生成：先生成一些着法，沿着某个着法沿伸下去，直到足以中止，再考虑其他着法；（eg：象棋先考虑吃子，再考虑非吃子）<br>            3）完全生成：一次产生所有的着法；</p>
<p>具体的着法生成方法：<br>    走子类：<br>        1）棋盘扫描法：<br>            在当前局面中逐一考虑可行的落子点；<br>            通常没有实战意义；<br>        2）模板匹配法：<br>            对于有特殊要求的走子类，根据具体的棋子与要求，逐一找到可行的落子点；<br>        3）预置表法：<br>            将全部棋子在所有棋位上的着法预先放在表中，开局自动生成放入内存，弈棋过程中直接查找；<br>            空间换时间的做法；<br>    添子类：<br>        通常比较直观，在盘面上合法的空位处即可落子；<br>        （略）</p>
<p>博弈树展开的分析：<br>    分子因子：<br>        节点所对应的局面，有多少种着法就有多少种分支；eg：国际象棋的平均分支因子大约是35；<br>    节点的层数：<br>        博弈树展开的深度；<br>    （分支因子越大、层数越多，博弈树规模就越庞大）<br>    树的复杂度：<br>        将博弈树完全展开，从当前的初始局面，到分出胜负时，博弈树上的节点树；eg：五子棋大约是225；<br>    状态复杂度：<br>        全部可行局面的数量；eg：五子棋大约是2225；<br>    <strong>（由于博弈树种有大量重复的状态，所以树的复杂度远高于状态复杂度）</strong>？为什么五子棋的不是，是特例吗？</p>
<h3 id="计算机博弈求解的基本搜索方法"><a href="#计算机博弈求解的基本搜索方法" class="headerlink" title="计算机博弈求解的基本搜索方法"></a>计算机博弈求解的基本搜索方法</h3><p>优化搜索与博弈搜索：<br>    优化搜索的特点：<br>        1）单一决策主体，即性能指标函数；<br>        2）明确的目标函数与约束条件，可以使用数学模型描述；<br>        3）主要用于解决基本规划和优化问题；<br>        4）进行单步考虑；<br>    博弈搜索：<br>        1）主要特点：<br>            1）两个非合作主体构成；<br>            2）涉及多步考虑；<br>            3）对弈双方对立，零和，是对决策目标的约束；<br>            4）目标函数难以用数学模型描述；<br>        2）主要方法：<br>            使用博弈树对博弈过程进行描述，在博弈树中搜索当前的最佳着法，并亦步亦趋地进行下去。<br>            （即目标是找到最好的“根着法”，并且这不是一个目标，而是当前的目标）</p>
<p>极大极小搜索算法<br>    基本思想：<br>        1）将当前状态作为初始状态，建立一个深度为h的搜索树，h可以表征“视野“，时间允许范围内能看到的最大深度；<br>        2）对所有叶节点的状态进行评价；<br>        3）叶节点回推到根节点，选择其中最好的一个动作决策；<br>    使用到的术语：<br>        1）节点 or 结点；<br>        2）根节点 or 顶节点；<br>        3）叶节点 or 端节点；<br>        4）MAX着棋，MIN着棋：通常分别对应我方、对方<br>        5）评估函数f：当f&gt;0时对MAX方有利；f&lt;0时对MIN方有利；f&#x3D;0时双方势均力敌；f绝对值越大对一方越有利，另一方越不利；<br>    具体的算法流程：<br>        1）从根节点开始按照所有可能的着法，扩展博弈树；使用的着法视哪一方着棋而定，MAX、MIN交替着棋；<br>        2）根节点深度h&#x3D;0，每次往下扩展深度+1，到达深度阈值后停止扩展，此时的节点为叶节点；<br>        3）对所有的叶节点按照评估规则计算估值f；<br>        4）逐层上推非叶子节点的估值，按照规则：<br>            1）若非叶子节点对应局面由MAX着棋，则选择其儿子节点中最大的估值作为自己的估值<br>            2）若非叶子节点对应局面由MIN着棋，则选择其儿子节点中最小的估值作为自己的估值<br>            （这就是选择对自己最有利的动作决策）；<br>        5）上推到根节点时，根节点按照4）中的确定估值规则，选择最好的估值，对应的着法就是当前MAX or MIN方使用的着法；<br>        （于是就完成了一次最大最小搜索，找到了当前最好的动作决策）</p>
<p><strong>棋局评估</strong>：</p>
<p>棋局评估：若叶子节点不能够给出胜-负-和的结果，那么有利局面需要依靠棋局评估</p>
<p>静态估值函数f定义的基本规则：</p>
<ol>
<li>有利于MAX为正</li>
<li>有利于MIN为负</li>
<li>势均力敌为0</li>
<li>根据势态的优劣进行定义，从而完成对叶节点的价值度量</li>
<li>若f(p) &#x3D; +∞则MAX赢，若f(p) &#x3D; -∞则MIN赢</li>
</ol>
<p>对一个棋局状态s的评估函数通常是考虑不同类型的知识后，对每种考虑因素进行估值，最后进行加权求和得到的。</p>
<p>即：$e(s) &#x3D; \sum w_i f_i(s)$</p>
<p>其中估值函数$f_i$可以对应：</p>
<ol>
<li>子力</li>
<li>位置</li>
<li>空间</li>
<li>机动</li>
<li>拍节</li>
<li>威胁</li>
<li>形状</li>
<li>图案</li>
</ol>
<p>等等。</p>
<p>值得注棋局性能 &#x3D; <strong>知识✖️速度</strong>意的是，考虑的因素越多，花费的时间必然越多，这个时候时间就会成为掣肘。而有时候考虑得少，时间少速度快，搜索的速度更快，深度更深。</p>
<h3 id="alpha-beta剪枝"><a href="#alpha-beta剪枝" class="headerlink" title="alpha-beta剪枝"></a>alpha-beta剪枝</h3><h4 id="剪枝思想"><a href="#剪枝思想" class="headerlink" title="剪枝思想"></a>剪枝思想</h4><p>极小极大搜索算法随着搜索深度的增长，节点数会成指数增长，所以要考虑一种剪枝算法</p>
<p>alpha-beta剪枝算法的思想</p>
<ol>
<li>将向下生成和倒推计算结合起来</li>
<li>根据一定的条件判定，尽早地修剪一些无用的分支</li>
<li>生成到达规定深度的节点时立刻计算其估值，一旦某个非端节点有条件计算其倒推值则立刻计算</li>
</ol>
<h4 id="具体规则"><a href="#具体规则" class="headerlink" title="具体规则"></a>具体规则</h4><p><code>需要进一步补充一下具体的例子</code></p>
<ol>
<li>alpha，MAX节点的估值下界，随着子节点生成alpha只可能上升</li>
<li>beta，MIN节点的估值下界，随着子节点生成beta只可能下降</li>
<li>alpha剪枝，MIN节点的beta 小于等于 <strong>先辈</strong>的MAX节点的alpha；则终止MIN子节点向下的搜索，令其估值为beta</li>
<li>beta剪枝，MAX节点的alpha 大于等于 <strong>先辈</strong>的MIN节点的beta；则终止MAX子节点向下的搜索，令其估值为alpha</li>
</ol>
<p>注意：</p>
<ol>
<li>仅在MAX、MIN两种不同类型的节点间比较，同一类型不能比较</li>
<li>不仅要和直接的父节点比较，要和直系的所有先辈比较</li>
<li>当估值被确定后，才能向上传递</li>
<li>这种剪枝方法的结果和极小极大的方法是一致的</li>
</ol>
<h3 id="负极大值搜索"><a href="#负极大值搜索" class="headerlink" title="负极大值搜索"></a>负极大值搜索</h3><h4 id="负极大值搜索的思想"><a href="#负极大值搜索的思想" class="headerlink" title="负极大值搜索的思想"></a>负极大值搜索的思想</h4><p>父节点的估值是各子节点估值的变号极大值，从而避免奇数层极大、偶数层极小的情况。（实际上这样的话每次只用从子节点中挑选MIN的估值，对MAX节点的子节点，MIN意味着负的越多，取正越大；对MIN节点的子节点，MIN意味着正的越少，取负越大）</p>
<p>并且由于实际上，这样处理估值后，无论MAX、MIN都是做的MIN节点的搜索，找子节点中估值最小的，于是只需要实现beta剪枝</p>
<h3 id="蒙特卡洛树搜索"><a href="#蒙特卡洛树搜索" class="headerlink" title="蒙特卡洛树搜索"></a>蒙特卡洛树搜索</h3><h4 id="Mento-Carlo的基本思想"><a href="#Mento-Carlo的基本思想" class="headerlink" title="Mento Carlo的基本思想"></a>Mento Carlo的基本思想</h4><ol>
<li>从某一棋局出发，随机走棋</li>
<li>走棋必须按照对应的规则，但不需要任何策略</li>
<li>进行非常多次对局后，可以基于统计，给出该棋局的固有胜率和胜率最高的着法</li>
</ol>
<h2 id="ch4：局部搜索"><a href="#ch4：局部搜索" class="headerlink" title="ch4：局部搜索"></a>ch4：局部搜索</h2><p>引入：<br>    无信息or有信息的搜索：<br>        1）问题的解是一个路径（动作序列）；<br>        2）关注的是路径的代价；<br>        3）环境是可观测的、确定、静态、已知的；<br>    局部搜索：<br>        1）问题的解是一个状态；<br>        2）不需要关注到达该状态的过程；<br>        eg：<br>            1）八皇后问题，只关注最终皇后的排列位置；<br>            2）优化问题求解，只关注最终的解是什么；<br>            3）作业空间调度，只关注调度的方案是什么；<br>            4）旅行商问题，寻找一条满足条件的路径；<br>        （注意甄别，问题的解是路径，这里的路径是指搜索过程的状态序列 or 动作序列；当然动作序列就对应了状态序列，只需要按照动作依次进行状态转移即可；而不是指具体的什么路径。虽然旅行商问题中最终也要找到一条路径，但是那条路径实际上是一个状态）<br>    局部搜索算法的思想：<br>        1）目标：在状态空间（所有状态的集合）中搜索一个最大的状态；<br>        2）思想：从单独的一个状态出发，通常只移动到与之相邻的状态，并且不保留解的路径；<br>        （简单来说，维持当前状态，不断改进；）<br>    局部搜索算法的优点：<br>        1）需要很少的内存；<br>        2）可以从很大、无限的状态空间中找到合适的解；</p>
<p>优化问题与状态空间地形图：<br>    优化问题：<br>        1）目标函数的目标：最高峰，全局最大值；<br>        2）代价函数的目标：最低谷，全局最小值；<br>    目标函数对应的状态空间地形图：<br>        1）shoulder；<br>        2）Global maximum；<br>        3）Local maximum；<br>        4）“flat” local maximum；<br>    对应如图：<br>    <img src="/Intro-of-AI/p1.png" alt="状态空间地形图">;</p>
<p>局部搜索算法1：爬山法<br>    思想：随机选择一个位置爬山，每次朝着更高的方向移动，直到到达山顶；<br>    具体的算法：<br>        1）将当前节点的估值与邻居节点进行比较；<br>        2）如果当前节点估值最好，则返回当前节点作为最大值（山峰）<br>        3）否则使用估值更好的邻居节点，替换当前节点；<br>        4）循环这个过程直到退出；<br>    伪代码如图所示：<br>    <img src="/Intro-of-AI/p2.png" alt="爬山搜索"><br>    eg：<br>        8皇后问题：<br>            目标：任何一个皇后都不会攻击到其他的皇后；<br>            耗散值h：存在冲突的皇后对数；<br>            状态转移（决定相邻节点）：<br>                考虑皇后只能在该列上移动，$8\times 8$的棋盘，则有56个后继状态；<br>            局部搜索求解：<br>                每次考虑相邻状态中耗散值最小的，直到找到耗散值为0的状态，即目标状态；<br>    存在的问题：<br>        局部最优解问题，locl maximum or flat local maximum（山脊与高原）；</p>
<p>局部搜索算法2：随机重启爬山法<br>    思想：在到达局部最优的时候，通过随机生成初始状态来引导爬山法搜索；<br>    具体的算法：<br>        注意：<br>            1）实际上是否处于局部最优在某些情况下比较难判断，我们这里假设全局最优已知；<br>            2）如果我们已经知道了全局最优，为什么还要搜索？实际上这里的全局最优已知，指的是全局最优满足的条件是知道的，我们可以判断是否到达了全局最优；<br>            3）eg，八皇后中，耗散值为0的状态一定是全局最优，尽管我们不知道具体的状态是什么；<br>        步骤：<br>            1）设定一个搜索步数阈值；<br>            2）使用爬山法，但是返回的不是当前估值最好的节点，而是必须返回满足全局最优的节点；<br>            3）如果不是全局最优，则继续搜索；<br>            4）超过搜索步数则随机重置初始状态；<br>    完备性：<br>        完备性在概率上接近1，因为理论上总会随机到最优解作为初始状态；</p>
<p>局部搜索算法3：模拟退火算法<br>    物理背景：<br>        1）学习的冶金学中金属加热-冷却的过程，模拟了物理退火的过程；<br>        2）加热、等温、冷却；<br>        3）<br>    基本思想：<br>        1）与前面两种相同，属于一种贪心的算法，只是在搜索过程中引入了随机因素，迭代更新的时候会以一定的概率接受一个比当前解更差的解，因此有希望跳出局部最优，到达全局最优；<br>        如图所示：<img src="/Intro-of-AI/p3.png" alt="模拟退火算法"><br>    具体过程：<br>        1）初始化：初始温度t0，初始状态s0，全局轮次k；<br>        2）状态产生函数，产生新状态<br>        3）状态接受函数，判断是否接受新状态；<br>        4）抽样稳定准则，判断是否退温；<br>            是则进入5）；<br>            否则回到2）；<br>        5）适当退温，更新t，k&#x3D;k+1；<br>        6）算法终止准则，判断是否终止；<br>            是则终止；<br>            &#x2F;&#x2F;或许可以记录过程中的最好状态，最后返回，尽管这里没提到；<br>            否则回到2）；<br>    关键点：<br>        三函数+两准则+初温：<br>            1）代价函数 or 目标函数C<br>                原则：<br>                    1）代价 or 代价函数，更好的解对应越小，坏的解对应越大；（当然可以更改）；<br>                作用：衡量解的好坏；<br>            2）状态产生函数<br>                原则：产生的候选解可以遍布状态空间；<br>                方法：在当前状态的领域结构用一定概率方式产生新状态；<br>            3）状态接受函数：<br>                原则：<br>                    1）固定温度下，接受好的解的概率更大；<br>                    2）随温度下降，接受坏的解的概率下降；<br>                    3）当温度接近0，只能接受更好的解；<br>                方法：<br>                    通常采用$min[1,exp(-\Delta C&#x2F;t)]$；<br>                    1）对于好的新状态，该函数值为1，必定会接受；<br>                    2）对于坏的新状态，t较大时，该函数值在0～1之间，以概率值接受；<br>                    3）当t较小时，对于好的新状态函数值为1，必定会接受；坏的新状态，函数值接近0，基本不会接受；<br>                具体使用：<br>                    if $min[1,exp(\Delta C&#x2F;t)] &gt; rand(0,1)$:<br>                        s &#x3D; si;&#x2F;&#x2F;新状态；<br>            4）抽样稳定准则（内循环终止准则）：<br>                常用方法：<br>                    1）检验目标函数均值是否稳定；<br>                    （可能需要维护一个目标函数均值，在状态变化的时候不不断更新）；<br>                    2）连续若干步的目标值变化较小；<br>                    （可能需要记录状态变化时的目标值变化）<br>                    3）按一定的步数抽样；<br>                    （这种就类似给内循环设置次数？）<br>            5）外循环终止准则：<br>                常用方法：<br>                    1）设置终止温度阈值，低到一定值；<br>                    2）设置外循环迭代次数；<br>                    3）算法搜索到的最优值连续若干步保持不变；<br>                    4）概率分析？<br>            6）初温设置：<br>                常用方法：<br>                    1）均匀抽样一组状态，用状态的目标值C到方差作为初温；<br>                    2）随机产生一组状态，计算两两状态间的目标值差的最大值，根据差值利用一定函数确定初温；<br>                    3）利用经验公式；<br>        物理学背景：<br>            1）在温度T，分子停留在状态r满足玻尔兹曼概率，这意味着同一温度下，分子停留在能量小的状态比停留在能量大的状态概率更大；<br>            <img src="/Intro-of-AI/p4.png" alt="模拟退火物理学背景公式"><br>            2）从这种概率关系下，引出了Metropolis准则——“以一定概率接受新的状态”</p>
<p>局部性搜索算法4：遗传算法</p>
<h2 id="ch5：不确定性推理"><a href="#ch5：不确定性推理" class="headerlink" title="ch5：不确定性推理"></a>ch5：不确定性推理</h2><p>不确定性推理：<br>    含义：<br>        从不确定的初始证据出发，运用不确定的知识，最终推出以某种不确定度成立的结论的过程；<br>    不确定环境：<br>        不确定性推理进行的环境；<br>        包括：<br>            证据不确定：<br>                证据是初始证据或推出的证据；<br>                不确定性：<br>                    歧义性、不完全性、不精确性、随机性、不一致性；<br>            规则不确定：<br>                规则是启发类的知识，描述由已有的证据可以推得的结论；<br>                不确定性：<br>                    证据组合、规则自身、结论；<br>    推理不确定的体现：<br>        知识不确定性的动态积累和传播；<br>    一个关键的问题：<br>        如何计算不确定程度（不确定度）<strong>定量的对不确定性进行描述，这是本章展开的关键</strong>；</p>
<p>贝叶斯决策论：<br>    一种使用概率框架进行决策的不确定推理工具；<br>    作用：<br>        针对分类问题，在所有概率已知的理想情况，贝叶斯决策考虑如何基于这些概率和误判损失来选择最优的类别标记；<br>    问题的形式化描述：<br>        1）$N$种类别标记：$y &#x3D; {c_1,c_2,\dots,c_n}$；<br>        2）误判损失（将$c_j$判为$c_i$）：$\lambda_{ij}$；<br>        3）后验概率：$P(c_i|x)$<br>        （对于一个具体的样本，其属于一个类的概率）<br>        4）条件风险（将样本x分类为$c_i$的期望损失）：<br>            $R(c_i|x) &#x3D; \sum_{j&#x3D;1}^N \lambda{ij} P(c_j|x)$；<br>            （简单理解就是，该样本有概率是1～N中的任意一类，但是现在分类为$c_i$，必然要承担相应的损失）<br>        5）目标：<br>            找到判定准则：<br>                $h:X\rightarrow Y$；<br>            使得总体风险最小：<br>                $argmin_{h} E_x[R(h(x)|x)]$；<br>            （实际上就是最小化对于样本x这一随机变量的随机变量函数——条件风险的期望）<br>    贝叶斯最优分类器：<br>        用来实现贝叶斯决策论目标的工具；<br>        贝叶斯判定准则：<br>            内容：为了最小化总体风险，只需要在每个样本上选择那个能使条件风险$R(c|x)$最小的类别标签；<br>            形式化描述：<br>                即对样本x，其标签应该是：<br>                $h^* &#x3D; argmin_{c\in y} R(c|x)$；<br>        注意：<br>        1）满足贝叶斯判定准则的分类器即<strong>贝叶斯最优分类器</strong>；<br>        2）此时总体风险称为<strong>贝叶斯风险</strong>；<br>        3）贝叶斯风险能够表征模型的最好性能，是机器学习的理论上限；<br>        （<em><em>1 - R(h</em>)是这里的3）的描述，但是应该不太准确？</em><em>）<br>    问题转换：<br>        一个具体的情况：<br>            $\lambda{ij} &#x3D; 0 if:i&#x3D;j;else:lambda{ij} &#x3D; 1$；<br>            （没有误判的时候不存在损失，其他情况损失都是1）<br>        这时条件风险为：<br>            $R(c|x) &#x3D; 1 - P(c|x)$；<br>        此时贝叶斯最优分类器对于样本x：<br>            给出的标签满足：<br>                $h^</em>(x) &#x3D; argmax_{c \in y}P(c|x)$；<br>            注意：<br>                1）简单来说，我们选择的标签是要让后验概率最大的标签；<br>        注意：<br>            1）这种情况下，贝叶斯最优分类器称为<strong>贝叶斯最小化错误率分类器</strong><br>            2）问题的关键被转换到了关注如何选择一个<strong>后验概率</strong>更大的标签上；<br>    后验概率：<br>        定义：<br>            想要清晰的理解它比较困难，这是随着统计学的演进逐渐被明确的概念，属于现代统计学奠基石部分的概念；<br>            于是简单放一个参考在这里<img src="/Intro-of-AI/p5.png" alt="后验概率"><br>        简单理解：<br>            先验概率：<br>                “先”于证据的概率。它是基于历史数据、长期经验或领域知识，在获得当前观测证据之前，对事件发生可能性的一般性估计。它代表了我们的初始信念。<br>            （<strong>先验概率可以直接按照频率估计</strong>）<br>            后验概率：<br>                “后”于证据的概率。它是我们在获得了特定观测数据x之后，利用<strong>贝叶斯定理</strong>对先验概率进行更新后得到的概率。它代表了结合新证据后，我们对事件发生的修正信念。<br>            后验概率是在先验概率与实验数据的基础上，由贝叶斯定理导出的概率；<br>    机器学习的目标：<br>        在现实中后验概率是无法直接得出的，机器学习实际上要做的就是基于有限的样本尽可能准确地估计出后验概率；</p>
<p>估计后验概率从而实现分类的两种策略模型：<br>    判别式模型：<br>        1）给定x，通过直接建模$p(c|x)$来预测c；<br>        eg：决策树、BP神经网络、支持向量机<br>        （分类的结果，对于一个样本，通常就是其属于各个类别的概率，然后取概率最大的）<br>    生成式模型：<br>        1）先对<strong>联合概率分布</strong>P(x,c)进行建模，再由条件概率的定义得到后验概率：$P(c|x) &#x3D; \frac{P(x,c)}{P(x)}$</p>
<p>基于生成式模型的问题转换：<br>    我们知道后验概率：$P(c|x) &#x3D; \frac{P(x,c)}{P(x)}$<br>    贝叶斯定理：$P(c|x) &#x3D; \frac{P(x|c)P(c)}{P(x)}$<br>        1）其中$P(c)$是先验概率，可通过各类别出现的频率估计（大数定理）<br>        2）$P(x)$是证据因子，样本、实现现象，与类标记c无关；<br>        3）$P(x|c)$是类c中出现样本x的<strong>类条件概率</strong>；<br>        （先确定了一个类别，其中出现一个具体的样本的概率）<br>    问题转换：<br>        如何估计<strong>类条件概率</strong>：$P(x|c)$；</p>
<p>极大似然估计：<br>    作用：估计类条件概率的常用策略；<br>    思想：<br>        假定类条件概率具有某种确定的概率分布形式，基于训练样本对概率分布参数进行估计；<br>    问题转换：<br>        假设$P(x|c)$具有确定形式，被参数$\theta_c$唯一确定，我们的任务就是要使用训练集$D$估计参数$\theta_c$；<br>        （概率模型的训练过程就是参数的估计过程）</p>
<p>估计确定类条件概率的参数：<br>    频率主义学派的思想：<br>        参数虽然未知，但是存在客观值，可以通过优化似然函数等准则来确定参数；<br>    具体的做法：<br>        $\hat{\theta}<em>c &#x3D; argmax</em>{\theta_c} LL(\theta_c)$<br>        其中：<br>            1）$LL(\theta_c) &#x3D; \log P(D_c|\theta_c) &#x3D; \sum_{x \in D_c} \log P(x|\theta_c)$<br>            2）训练集中第c类样本的一个子集$D_c$<br>            3）假设集合中的样本是独立的，原本的式子是：<br>                $P(D_c|\theta_c) &#x3D; \prod_{x\in D_C}P(x|\theta_c)$；<br>            4）为了避免连乘溢出，所以改为了对数似然；<br>            5）实际上就是<strong>我们通过实验找到了这么多的样本，那么就应该尽量让参数接近使得这种情况出现的概率较大的情况</strong><br>            （枪响了，兔子死了，很大概率是枪打死了兔子）<br>    eg：<br>        <img src="/Intro-of-AI/p6.png" alt="极大似然估计例子"><br>    贝叶斯学派的思想：<br>        认为参数是未观察到的随机变量、其本身也可由分布，因此可假定参数服从一个先验分布，然后基于观测到的数据计算参数的后验分布。<br>    <strong>最终使用(生成式模型，类条件概率)<strong>：<br>        1）我们现在有很多样本x以及对应的标签c；<br>        2）那么对于标签c的类条件概率P(x|c)可以使用极大似然进行估计；<br>        （</strong>这两步就类似于在对分类器进行训练</strong>）<br>        3）从而我们可以对于一个新来的样本x，按照P(x|c)的参数表达式进行计算；<br>        4）进一步可以估计后验概率P(c|x)；<br>        5）对于新来的样本x，考虑所有标签，分别按照上述步骤计算后验概率，选择后验概率最大的对应的标签；</p>
<p>朴素贝叶斯分类器：<br>    含义：基于类条件概率和属性条件独立性假设的贝叶斯最优分类器；<br>    目标：<br>        1）与贝叶斯最优分类器一样；<br>        2）满足分类结果让后验概率最大（总体风险最小）的分类器；<br>    属性条件独立性假设：<br>        每个属性独立地对分类结果发生影响；<br>    方法：<br>        1）基于类条件概率和贝叶斯定理可以将后验概率展开；<br>        2）使用属性条件独立性假设，将类条件概率展开为属性条件概率；<br>    具体表达式：<br>        $P(c|x) &#x3D; \frac{P(c)}{P(x)} P(x|c)$；<br>        进一步：$\frac{P(c)}{P(x)} \prod_{i&#x3D;1}^d P(x_i|c)$；<br>        其中：<br>            1）后验概率、先验概率、类条件概率，不多赘述；<br>            2）$P(x_i|c)$ 是属性条件概率，即对于该类，出现了一个具体属性的概率；<br>            3）$x$是具体的样本，$x_i$是它的一个属性，一共有d个属性；<br>    最终的分类器：<br>        分类结果对于所有样本x，得到的标签c满足如下表达式的分类器，就是贝叶斯朴素分类器：<br>        $h_{nb}(x) &#x3D; argmax_{c\in y} P(c)\prod_{i&#x3D;1}^d P(x_i|c)$；<br>        注意：<br>            1）去掉了后验概率展开为属性条件概率的式子中的$P(x)$，因为无论是否考虑它，优化都是等价的；<br>    属性条件概率的计算：<br>        1）离散属性：使用频率直接进行估计；<br>            eg：<img src="/Intro-of-AI/p7.png" alt="离散属性条件概率的计算">;<br>        2）连续属性计算：按照分布进行计算；（当然，分布参数又可以按照类条件概率的估计那样，使用极大似然法进行计算）<br>            eg：<img src="/Intro-of-AI/p8.png" alt="连续属性条件概率的计算">;<br>    <strong>最终的使用(朴素贝叶斯分类器)</strong><br>        1）对于已有的样本x，以及其对应的标签c；<br>        2）使用已有所有样本的属性xi，以及对应的标签c，计算：<br>            1）离散属性条件概率（直接按照频率进行计算）；<br>            2）估计连续属性条件概率的概率分布（或许可以用极大似然）；<br>        （<strong>对于朴素贝叶斯分类器的训练</strong>）<br>        3）对于新来的样本x；<br>        4）考虑样本属于类别c<br>            按照前面计算的离散属性条件（属性属于该类别）概率，设置其新样本各离散属性的条件概率（对应相等）；<br>            按照前面估计的连续属性概率分布，将新样本的连续属性带入概率分布表达式，计算出连续属性条件概率；<br>        5）根据计算出的所有属性条件概率，计算类别c对应的后验概率；<br>        6）按照上面3～5的步骤，考虑所有的类别，取后验概率最大的类别作为该样本x的类别；</p>
<p>拉普拉斯修正：<br>    目的：<br>        修正先验概率和离散属性条件概率的计算；<br>    背景：<br>        若某个属性值在训练集中没有与某个类同时出现过，则直接计算会出现问题，比如“敲声&#x3D;清脆”测试例，训练集中没有该样例，因此连乘式计算的概率值为0，无论其他属性上明显像好瓜，分类结果都是“好瓜&#x3D;否”，这显然不合理。<br>    修正方法：<br>        1）类先验概率：$\hat{P(c)} &#x3D; \frac{|D_c|+1}{|D|+N}$；<br>        2）离散属性条件概率：$\hat{P}(x_i|c) &#x3D; \frac{|D_{c,x_i}|+1}{|D|+N_i}$；<br>        其中：<br>        1）$|D_c|$是数据集中类别c对数据数量；<br>        2）$|D|$是所有数据的数量；<br>        3）$N$是所有可能的类别数量；<br>        4）$N_i$是属性i所有可能的取值数量；</p>
<p>贝叶斯网络：<br>    含义：<br>        1）结点间增加了连接强度的因果关系网；<br>        2）贝叶斯网络&#x3D;网络结构+CPT<br>    其中：<br>        1）连接强度对应的是条件概率；<br>            eg：<br>                1）$P(B|A)$：A到B到连接强度；<br>                2）$P(B|AC)$：A、C对B到联合作用；<br>        2）CPT：条件概率表；<br>    一个贝叶斯网络的例子：<br>        <img src="/Intro-of-AI/p9.png" alt="贝叶斯网络"><br>    贝叶斯网络的性质：<br>        条件独立：<br>            含义：有结点A、B和C，若 P(A|BC) &#x3D; P(A|B)，则称A和C在B条件下独立、A在B条件下独立于C，或A和C关于B独立。<br>        几种典型的条件独立情况：<br>            1）串行连接：如图，B确定的时候，A与C关于B条件独立；<br>            <img src="/Intro-of-AI/p10.png" alt="串行连接"><br>            2）分叉连接：如图，给定父节点确定的时候，各子节点条件独立；<br>            <img src="/Intro-of-AI/p11.png" alt="分叉连接"><br>            3）汇集连接：如图，后继节点<strong>不确定</strong>的时候，同一后继的前驱节点间条件独立；（<strong>即使后继节点的再后继的某个结点确定，前驱节点就不独立了</strong>）<br>            <img src="/Intro-of-AI/p12.png" alt="汇集连接"><br>    贝叶斯网络常见的推理模式：<br>        1）因果推理：已知父节点，计算子节点的条件概率；<br>        （在父节点确定了，子节点出现某种状态的概率）<br>        2）诊断推理：已知一个子节点，计算父节点的条件概率；<br>        （子节点确定了，计算父亲节点出现某种状态的概率）<br>        3）辩解推理：已知父节点和子节点，计算其他父节点的条件概率；<br>        （后继节点以及一个前驱节点确定了，计算该后继节点的另一个前驱节点出现某种状态的概率）<br>    注意：<br>        1）<strong>贝叶斯网络不允许包含因果循环</strong>；<br>        2）在这些推理的过程中，可以使用条件概率的一系列性质，来计算出需要推理访问的节点的状态；</p>
<h2 id="机器学习概述"><a href="#机器学习概述" class="headerlink" title="机器学习概述"></a>机器学习概述</h2><p>机器学习：<br>    定义：用机器来模拟人类学习活动，本质是要从大量数据中学习到隐藏的模式，最终要用这种模式对新的样本进行判别和预测；<br>    不同流派：<br>        1）符号主义：用符号、规则和逻辑来表征知识进行推理；<br>        2）贝叶斯派：基于贝叶斯定理；<br>        3）连接主义：神经网络；<br>        4）进化主义：用计算机模拟进化过程；<br>        5）行为类推主义：根据约束条件来优化函数；<br>    目标：<br>        预测事物；</p>
<p>基本概念：<br>    特征：<br>        特征变量：用来描述问题一种性质的属性；<br>        属性值：特征变量的一个具体取值；<br>        特征向量：由多个特征变量组成的，用来描述问题对象的整体性质；<br>        特征空间：变量组成的空间；<br>    数据集合：<br>        样本空间：特征空间中的一组示例；<br>            记法：$D &#x3D; {x_1,x_2,\dots,x_m}$；<br>        标记空间：标签变量or预测变量的取值集合；<br>            记法：$Y$；<br>        样例集合：特征向量（样本）与标签变量对集合；<br>            记法：$D &#x3D; {(x_1,y_1),(x_2,y_2),\dots,(x_m,y_m)}$；<br>        数据集：<br>            用于训练的样例构成的集合，是样例集合的子集；<br>        测试集：<br>            用来对学习到的模型进行检测的样例构成的集合，是样例集合的子集；<br>    常见的学习任务：<br>        1）分类；<br>            1）Y是离散值；<br>            2）常见二分类、多分类；<br>        2）回归；<br>            1）Y是连续值；<br>            2）目标是预测；<br>        3）聚类；<br>            1）无监督学习（1、2是有监督），没有Y信息；<br>        4）强化学习；<br>            1）通过与环境交互逐步学习；<br>        5）泛化能力；<br>            1）考量学习结果对新样本的适应能力（本质就是对样本空间的描述能力，ps不是对样例空间）<br>    假设空间：<br>        机器学习的结果是一个<strong>从样本空间到标记空间的映射</strong>，所有可能映射的集合是假设空间；<br>        记法：$H,s.t.f:G\rightarrow H,f\in H$；<br>    版本空间：<br>        假设空间的一个子集，<strong>与训练样例一致</strong>的所有假设的集合；（这里的假设就是映射）；<br>    归纳偏好：<br>        在机器学习算法学习中，可能有多种假设均满足训练样例，但是具体的算法会偏好于其中一个；<br>            1）奥卡姆剃刀：当有多个假设与观察结果一致的时候，选择最简单的那个；<br>            2）NFL定理：总误差与算法无关，不可能找到一个适用于所有场景的算法，具体的问题选择具体的算法</p>
<p>机器学习的基本流程：<br>    1）定义分析目标；<br>    2）收集数据；<br>    3）数据预处理；<br>        数据中可能存在噪声、不一致、异常等问题，需要数据清洗；<br>    4）数据建模；<br>        算法本身没有绝对的好坏，不同算法有各自适用的范围（NFL定理）<br>    5）模型训练；<br>    6）模型评估；<br>    7）模型应用；</p>
<p>模型评估：<br>    目标：评估机器学习结果在多大程度上能够帮助实现业务目标，量化相关评估结果；<br>    常用量化指标：<br>    （注意：<strong>这些指标没有明确说明的，默认是在测试集上的表现</strong>）<br>        错误率：<br>            1）分类错误的样例占样例总数；<br>            2）$E &#x3D; a&#x2F;m$；<br>        精度：<br>            1）$acc &#x3D; 1 - E$；<br>        误差：预测输出与真实情况的差异<br>            1）训练误差（经验误差）：在训练集上的误差；<br>            2）泛化误差：在测试集（新样本）上的误差；<br>    常见问题：<br>        1）过拟合，过度学习了训练样例中的细节特征，导致泛化能力下降；<br>            eg：认为必须边缘有锯齿的才是树叶；<br>        2）欠拟合，没有充分学习到训练样例的特征，导致泛化能力下降；<br>            eg：认为绿色的大树也是树叶；<br>    训练集与测试集的划分：<br>        1）留出法：<br>            1）直接讲数据集D拆分为两个互斥的集合，其中S是训练集，T是测试集；<br>            2）$D &#x3D; S \cap T$；<br>        2）交叉验证：<br>            1）按照一定的分布规律，将数据集D依次排列为互斥子集；<br>            2）几个互斥的子集组成一组，其中有训练集和测试集；<br>        3）自助法；<br>            1）直接从原始的数据集中自助采样样例，生成训练集；<br>            2）注意采样之后会放回，所以一个样本m可能被多次采到；<br>            3）某个样本永远不会被采到的概率是$1&#x2F;e$；（等概率采样）；<br>    参数调优：<br>        一些算法中存在人为设置的超参数，需要手动进行调节；<br>    针对分类问题性能度量：<br>        已知：<br>            1）数据集 $D &#x3D; {(x_1,y_1),(x_2,y_2),\dots,(x_m,y_m)}$；<br>            2）机器学习器 $f:y &#x3D; f(x)$；<br>        性能度量：<br>            1）错误率：$E(f,D) &#x3D; \frac{1}{m} \sum \textbf{1}_{f(x_i)\ne y_i}$<br>            2）精度：$acc(f,D) &#x3D; 1 - E(f,D)$；<br>            3）混淆矩阵：<br>                1）从二分类问题出发，样例的标签有正例、反例；<br>                2）根据<strong>预测</strong>的正反情况与<strong>实际</strong>的正反情况，我们给出基本混淆矩阵的元素；<br>                    1）TP：真正，预测正确，为正例；<br>                    2）FN：假反，预测为反，实际为正；<br>                    3）TN：真反，预测正确，为反例；<br>                    4）FP：假真，预测为正，实际为反；<br>                3）元素名称规律：<br>                    1）T&#x2F;F，代表预测的正确&#x2F;错误；<br>                    2）P&#x2F;N，代表预测结果为正&#x2F;反；<br>                    （组合起来当然也可以推断实际结果）；<br>            4）查准率（precision 准确率）：<br>                1）预测为正的，有多少正确；<br>                2）$P &#x3D; TP&#x2F;(TP+FP)$；<br>                3）理解：声称找到的好东西，里面有多少是真的；<br>                4）eg：邮件过滤通常追求查准率，FP越大代表实际上为垃圾邮件但被判断为重要邮件的数量越大，惩罚越大；（追求准确，宁缺毋滥）<br>            5）查全率（recall 召回率）：<br>                1）实际为正的，有多少被我们预测到了；<br>                2）$R &#x3D; TP&#x2F;(TP+FN)$；<br>                3）理解：对于所有的好东西，你找到了多少；<br>                4）eg：疾病诊断通常追求查全率，FN越大代表实际上有病但是被诊断为每有病的数量越大，惩罚越大；（追求全面，宁可错杀）<br>            5）平衡指标：<br>                F1:<br>                    1）查准率和查全率的调和平均；<br>                    2）$F_1 &#x3D; \frac{2PR}{P+R}$；<br>                    3）当P、R均较高时F1会较高；当P、R偏差较大时F1较小，当P、R均较小时F1较小，用来施加惩罚；<br>                $F_\beta$:<br>                    1）查准率与查全率的加权调和平均；<br>                    2）$F_\beta &#x3D; \farc{(1+\beta^2)PR}{\beta^2 P + R}$<br>                    3）通常设置：<br>                        1）$\beta &#x3D; 1$ 平衡；<br>                        2）$\beta &#x3D; 2$ 重视查全率；<br>                        3）$\beta &#x3D; 0.5$ 重视查准率；</p>
<p>混淆矩阵补充：</p>
<table>
<thead>
<tr>
<th>实际 \ 预测</th>
<th>预测为正类</th>
<th>预测为负类</th>
</tr>
</thead>
<tbody><tr>
<td>实际为正类</td>
<td>TP</td>
<td>FN</td>
</tr>
<tr>
<td>实际为负类</td>
<td>FP</td>
<td>TN</td>
</tr>
</tbody></table>
<p><code>重要点：常用评价指标（分类正确率、回归均方误差、acc、auc、二维表格对应几个指标）</code></p>
<h2 id="ch7：监督学习-决策树"><a href="#ch7：监督学习-决策树" class="headerlink" title="ch7：监督学习-决策树"></a>ch7：监督学习-决策树</h2><p><code>重点？决策树的基本思想、算法过程</code></p>
<p>决策树的基本思想：<br>    1）决策树通过把数据样本分配到某个叶子结点来确定数据集中样本所属的分类</p>
<p>决策树的算法过程：<br>    1）从决策树根结点出发，自顶向下移动，<strong>在每个决策结点都会进行一次划分</strong>，通过划分的结果将样本进行分类，导致不同的分支，最后到达个叶子结点，这个过程就是利用决策树进行分类的过程；</p>
<p>决策树的基本结构：<br>    1）决策结点表示在样本的<strong>一个属性上进行的划分</strong>；<br>    2）分支表示对于决策结点进行划分的输出；<br>    3）叶结点代表经过分支到达的分类结果；</p>
<p>ID3算法：<br>    分支处理：<br>        1）分支属性 选择：对决策节点上选择哪一个属性来对数据集进行划分；<br>        2）分类属性 标签 计算信息熵以及影响算法是否终止<br>            选取原则：<br>                1）要求每个分支中样本的类别纯度尽可能高；<br>                2）不要产生样本数量太少的分支；<br>        2）衡量指标：<br>            信息熵：度量样本纯度的指标<br>            <img src="/Intro-of-AI/p17.png" alt="信息熵"><br>            (<strong>公式与作用</strong>)<br>    算法流程：<br>        1）计算当前分支节点信息熵；<br>        2）选择分支属性，得到当前分支节点的子节点（分支节点）；<br>        3）计算各个子分支节点的信息熵加权和，权重是样本的数量；<br>        4）直到得到的分支节点只有一类标签，则得到了一个叶节点，该标签就是这个叶节点对应的标签；<br>        （or 达到了要求的分类条件：深度限制、样本数量较少，如果此时还有多类标签，则取样本数量最多的标签为对应的标签）；<br>    注意：<br>        ID3算法在完成一次根据某个分支属性进行分类之后，在分支节点中（对应自己的样本集合），再次进行划分，<strong>各个分支节点是独立不相互影响</strong>，即再次考虑信息熵增益最大的时候只需要考虑各个分支节点，自己再次划分的时候信息熵增益最大（<strong>此时对应信息熵计算使用的样本集合D就是分支节点所具有的全部样本组成的</strong>）。</p>
<p>扩展算法的基本思想<br>    1）C4.5算法：使用信息增益率代替信息增益作为划分度量，解决ID3算法往往选择取值较多的分支属性的情况；<br>    <img src="/Intro-of-AI/p18.png" alt="C4.5">（注意图中的例子）；<br>    2）CART算法：二分循环切割，无论选择什么分支属性，都<strong>只分出两个分支</strong>，即构建二叉树；如果分支属性取值不止两个的话，就进行一些组合，最后保留两个组合；使用的是<strong>Gini指数</strong>；<br>    <img src="/Intro-of-AI/p19.png" alt="CART">（注意例子）；</p>
<h2 id="ch8：监督学习-支持向量机"><a href="#ch8：监督学习-支持向量机" class="headerlink" title="ch8：监督学习-支持向量机"></a>ch8：监督学习-支持向量机</h2><p><code>重点？</code><br><code>注意这一节不只涉及支持向量机</code></p>
<p>重要点：<br>    线性回归：<br>        最小二乘法存在闭式解<br>    支持向量机：<br>        大间隔<br>        核函数（四种核函数，不知道该用什么的一般用高斯核函数，sigmod核函数使用比较少）<br>    KNN算法：<br>        多数表决，由输入的k个近邻训练实例多数所属的类来决定</p>
<h2 id="ch9：无监督学习-聚类"><a href="#ch9：无监督学习-聚类" class="headerlink" title="ch9：无监督学习-聚类"></a>ch9：无监督学习-聚类</h2><p>无监督学习：<br>    含义：在没有标签（标注）的样本上进行的学习；<br>    最常用的方法：聚类；</p>
<p>聚类：<br>    目标：<br>        1）将数据样本划分为若干个不相交（通常）的“簇”（Cluster）<br>        2）簇内样本的相似度尽可能的高，簇间样本的相似度尽可能的低；<br>        3）簇内样本与中心的距离尽可能的小，簇间的距离尽可能的大；<br>    一些基本概念：<br>        衡量指标：<br>            外部指标：<br>                使用事先指定的聚类模型作为参考来评判聚类结果的好坏；<br>            内部指标：<br>                不依赖于任何外部知识，只使用参与聚类的样本来评判聚类结果的好坏；<br>        簇的属性：<br>            作用：用来对簇的一些性质进行描述；<br>            1）聚类中心：簇中所有样本的均值（质心）；<br>            2）簇大小：簇中含有样本的数量；<br>            3）簇密度：簇中样本的紧密程度；<br>            4）簇描述：簇中样本的业务特征；</p>
<p>聚类的常见外部指标：<br>    情景：对于含有n个样本点的数据集S，其中的两个不同样本点(xi,xj)，假设C是聚类算法给出的簇划分结果，P是外部参考模型给出的簇划分结果。对于(xi,xj)样本点来说，存在以下四种关系：<br>        1）SS，在结果C、P中(xi,xj)在相同的簇中；<br>        2）SD，在结果C中(xi,xj)在相同的簇中，在结果P中不在相同的簇中；<br>        3）DS，在结果C中不在相同的簇中，在结果P中在相同的簇中；<br>        4）DD，在结果C中不在相同的簇中，在结果P中不在相同的簇中；<br>    四种关系的数量关系：<br>        客观事实：对于任意两个不同的样本(xi,xj)，它们一定只能满足SS&#x2F;SD&#x2F;DS&#x2F;DD四种关系中的一种；<br>        假设：对应令四种关系成立的样本数量对为a、b、c、d；<br>        关系：$a+b+c+d &#x3D; C_n^2$（实际上就是样本对的数量）；<br>    在四种关系的数量关系之上建立的外部指标：<br>        1）Rand统计量：<br>            英文术语：R-Statistc<br>            公式：$R &#x3D; \frac{a+d}{a+b+c+d}$；<br>            含义：？<br>        2）F值：<br>            英文术语：F-Measure；<br>            公式：$F &#x3D; \frac{(\beta^2 + 1)PR}{\beta^2P + R}$；<br>            含义：<br>                1）P表示准确率$P &#x3D; \frac{a}{a+b}$；<br>                2）R表示召回率$R &#x3D; \frac{a}{a+c}$；<br>                （注意区分召回率和Rand Statistic）；<br>                3）$\beta$是参数，当其为1的时候对应F1-Measure；<br>        3）Jaccard系数：<br>            英文术语：Jaccard Coefficient；<br>            公式：$\frac{a}{a+b+c}$；<br>        4）FM指数：<br>            英文术语：Fowlkes and Mallows Index；<br>            公式：$\sqrt{\frac{a}{a+b} \frac{a}{a+c}}$；<br>        四种外部指标的意义：<br>            这四个度量指标的值越大，表明聚类结果和参考模型直接划分的结果越吻合，聚类结果越好；</p>
<p>聚类常见的内部指标：<br>    情景：考虑在聚类分析中，对于两个m维的样本xi &#x3D; (xi1,xi2,…,xim)，xj &#x3D; (xj1,xj2,…,xjm)，对于任意两个样本xi，xj，我们可以考虑距离度量；<br>        1）欧几里得距离；<br>        2）曼哈顿距离；<br>        3）切比雪夫距离；<br>        4）明可夫斯基距离；<br>            公式：$dis_{mind} &#x3D; (\sum_{k&#x3D;1}^m |x_{ik} - x_{jk}|^p)^{\frac{1}{p}}$；<br>            注意：<br>                1）这是距离度量的最一般形式；<br>                2）当p &#x3D; 1的时候，即曼哈顿距离；<br>                3）当p &#x3D; 2的时候，即欧几里得距离；<br>                4）当$p \rightarrow \inf$的时候，即切比雪夫记录；<br>    针对距离度量得出的聚类性能度量内部指标：<br>        1）紧密度(CP)：<br>            英文术语：Compactness；<br>            公式：$CP_c &#x3D; \frac{1}{n} \sum_{i&#x3D;1}^n ||x_i - w_c||$；<br>            含义：<br>                1）$w_c$是簇c的聚类中心，可以用样本加和求平均得到；<br>                2）$CP_c$对应的是簇c的紧密度；<br>                3）对于整个聚类结果的紧密度为：<br>                    $CP &#x3D; \frac{1}{n} \sum_i^n CP_i$；<br>                4）这里两个样本的距离使用的曼哈顿距离，也可以用其他距离替换；<br>            意义：<br>                紧密度的值越小，表示簇内样本点的距离越近，簇内样本的相似度越高；<br>        2）分隔度(SP)：<br>            英文术语：Seperation；<br>            公式：$SP &#x3D; \frac{2}{k^2 - k}\sum_{i&#x3D;1}^k\sum_{j&#x3D;i+1}{k} ||c_i - c_j||$；<br>            含义：<br>                1）聚类的结果是k个簇；<br>                2）其中$c_i$对应的是簇i的聚类中心；<br>            意义：<br>                分隔度的值越大，表示各聚类聚类中心相互之间的距离越远，簇间相似度越低，效果越好；<br>        3）戴维森堡丁距离：<br>            作用：衡量任意两个簇的簇内距离和簇间距离之比，求最大值；<br>            意义：DBI的值越小，表示簇内样本之间距离越小，同时簇间距离越大，即簇内相似度高，簇间相似度低，说明聚类结果越好；<br>        4）邓恩指数：<br>            作用：任意两个簇的样本点的最短距离与任意簇中样本点点最大距离之商；<br>            意义：DVI的值越大，表示簇间样本距离越远，簇内样本距离越近，效果越好；<br>        5）意义总结：<br>            1）CP越小越好；<br>            2）SP越大越好；<br>            3）DBI越小越好；<br>            4）DVI越大越好；</p>
<p>聚类方法一：基于划分的方法<br>    特点：<br>        1）基于划分的方法是最简单、常用的聚类算法；<br>        2）将对象划分为簇进行聚类，每个对象属于且仅属于一个簇；<br>        3）划分追求的结果是，簇间相似度低，簇内相似度高；<br>    常用的基于划分的算法：<br>        1）k-means；<br>        2）k-medoids；<br>        3）k-prototype；<br>    k-means算法：<br>        思想：计算样本点与类簇质心的距离，与类簇质心相近的样本点划分为同一类簇；<br>            1）类簇是指还没有完成最终划分之前的各个簇；<br>            2）常常使用簇中所有样本的均值来表征簇；<br>        算法流程：<br>            1）选取k个类簇，用户指定或随机选取指定k个质心；<br>            2）对剩余样本点，计算到各个质心的欧式距离，将其归入距离最小的质心对应的类簇；<br>            3）每次确定一个样本点所属的类簇，都立刻更新该类簇的质心；<br>            4）所有样本点都划分完毕后，每个簇都有了新的质心；<br>            5）根据新的质心，重新对所有的样本进行划分；<br>            6）重复2～5，直到划分结果基本保持不变，返回结果；<br>        Q：<br>            如何确定划分结果基本保持不变？<br>        优点：<br>            运行效率比较高、容易解释适合高维数据聚类；<br>        缺点：<br>            1）容易局部收敛（贪心策略）；<br>            2）对离群点和噪声点非常敏感；<br>            3）初始聚类中心的选取对算法结果影响很大；<br>            4）不适用于，离散的类别数据；<br>                因为最基础的度量指标是基于距离得到的；<br>                需要做哑变量处理；<br>            5）不适用于非图面形状（非球形）的数据集，尤其是长条形的数据集（结果会与初始目标有非常大的差别）；<br>        注意：<br>            1）变量处理：<br>                离散变量要做哑变量处理，将不能定量处理的变量量化；<br>                原始数据要做标准化处理（防止量纲带来的影响）；<br>            2）k值的选择：<br>                即最终结果应该聚为几个类，这是人为确定的；<br>                通常可以：<br>                    1）使用层次聚类法得到初始的k值，以及初始的簇中心；<br>                    2）使用系统演化的方法；<br>    k-means++算法：<br>        思想：为了克服k-means结果依赖于初始类簇的选择，而提出的；<br>        算法流程：<br>            1）从样本集合中随机选择一个样本点ci，作为第1个聚类中心；<br>            2）计算其他样本点x到“已有的，最近的聚类中心的距离”，d(x)；<br>            3）以概率$\frac{d(x)}{\sum_i^n d(x)}$选择x作为新的聚类中心；（概率越大被选中概率越大）；<br>            4）重复2～3，直到选出k个聚类中心；<br>            5）使用这k个聚类中心，进行k-means算法；</p>
<p>聚类方法二：基于层次聚类<br>    BIRCH算法<br>    CURE算法</p>
<p>聚类方法三：基于密度聚类<br>    思想：<br>        将样本中的高密度区域（样本点分布稠密的区域）划分为簇，将簇看作样本空间中被稀疏区域（or 噪声）分隔开的稠密区域；<br>    优点：<br>        基于样本分布的稠密程度进行聚类，可以克服基于划分&#x2F;层次的聚类方法通常智能用于挖掘球状簇的问题；<br>    DBSCAN算法<br>        ？<br>    OPTICS算法<br>        优点：改进了DBSCAN，降低了其对于输入参数的敏感程度；<br>    DENCLUE算法<br>        优点：综合了基于划分、层次、密度的方法；</p>
<p>聚类方法四：基于网格聚类（了解）</p>
<p>聚类方法五：基于模型聚类（了解）</p>
<p><code>聚类模型前三个比较重要（划分、层次、密度），k-means很重要，CF-tree很重要（构建CF-tree，更新CF-tree），BIRTCH方法很重要、CURE算法知道即可、基于密度聚类很重要</code>   </p>
<h2 id="ch10：神经网络模型"><a href="#ch10：神经网络模型" class="headerlink" title="ch10：神经网络模型"></a>ch10：神经网络模型</h2><p><code>前馈神经网络是我们学习的重点，神经网络的结构，怎样使用</code>；<br><code>前向过程，评价指标：回归（最小二乘法）/分类（交叉熵）</code></p>
<p>神经网络：<br>    人工神经网络的思想：<br>        由简单神经元经过相互连接形成网络结构，通过调节各个连接的权重值来改变连接的强度，进而实现感知和判断；<br>    基本分类：<br>        1）前馈神经网络；<br>        2）反馈神经网络；<br>        3）自组织神经网络；<br>    基本概念：<br>        1）激活函数；<br>        2）损失函数；<br>        3）学习率；<br>        etc.</p>
<p>前馈神经网络：<br>    含义：一种单向多层的网络结构；<br>    （信息层开始，逐层向一个方向传递，直到输出层结束）；<br>    特点：<br>        1）前馈过程中不会调整各层的权重参数；<br>        2）反向传播的时候会将误差向后传递调整权重；<br>            eg：BP算法反向传播，理论上可以逼近任何连续函数；<br>    感知器：一种最简单的前馈神经网络；<br>        构成：<br>            1）可以接收n个输入（n维特征向量）；<br>            2）对应有n个权重值$\omega_i$；<br>            3）偏置项阈值b；（防止溢出？）；<br>            4）激活函数f；<br>            （整个过程就是n个输入根据n个权重，加权求和，最后得到一个值，将其输入激活函数，得到输出）<br>            eg：$y &#x3D; f(x\omega^T+b)$；<br>        作用：<br>            1）用于作为神经元，构造更加复杂的神经网络；<br>            2）如果直接使用可以理解为直线划分；<br>            3）单个感知器甚至不能解决最简单的非线性问题（异或问题）；<br>    BP神经网络<br>        含义；一种具体的前馈神经网络，但是权重值只由反向传播学习算法进行调整；<br>        拓扑结构组成：<br>            1）输入层；<br>            2）隐层；<br>            3）输出层；<br>        激活函数：<br>            1）必须满足处处可导的条件；<br>            eg：sigmoid函数：<br>                1）连续可微，单调递增；<br>                2）输出值在0～1之间；<br>                3）$\sigma(x) &#x3D; \frac{1}{1+e^{-x}}$；<br>            2）可能的问题：梯度消失问题；<br>        eg：<img src="/Intro-of-AI/p13.png" alt="BP神经网络的结构"><br>        BP神经网络训练流程：<br>            1）初始化网络权值和神经网络阈值；<br>            2）前向传播<br>            ？？？</p>
<h2 id="ch11：深度学习"><a href="#ch11：深度学习" class="headerlink" title="ch11：深度学习"></a>ch11：深度学习</h2><p><code>什么是卷积，怎么卷（运算），什么是循环，怎么做</code></p>
<p>深度学习与前馈神经网络的区别：<br>    1）传统的BP算法仅有几层网络，需要<strong>手工指定特征</strong>且易出现<strong>局部最优问题</strong>，而深度学习引入了<strong>概率生成模型</strong>，可<strong>自动地从训练集提取特征</strong>，解决了手工特征考虑不周的问题，而且<strong>初始化了神经网络权重</strong>，采用反向传播算法进行训练，与BP算法相比取得了很好的效果。<br>    2）特征工程与特征学习：<br>        1）特征工程由人类专家根据现实任务来设计, <strong>特征提取与识别</strong>是分开的两个阶段（传统）；<br>        2）特征学习通过深度学习自动产生有益于分类的特征, 是一个<strong>端到端</strong>的学习框架（深度学习）；</p>
<p>深度学习基本思想与优缺点<br>    idea来源：<br>        1）多层前馈网络有强大的表示能力（”万有逼近性”）；<br>        2）仅需<strong>一个包含足够多神经元的隐层</strong>, 多层前馈神经网络就能以任意精度逼近任意复杂度的连续函数 [Horniket al., 1989]；<br>    于是增加模型复杂度有两种思路：<br>        1）模型宽度：增加隐层神经元的数目；<br>        2）模型深度：增加隐层数目；<br>    深度学习使用的是方法2），而非方法1），原因是？<br>        老师说：层数的增加可以有更多的抽象，层级式的抽象可以升维，带来更好的表示的方式；<br>        deepseek：参数效率与表示效率，这是最核心的理论原因。深度网络可以用指数级更少的神经元（参数）来表示一个复杂函数，而一个浅层网络可能需要指数级更多的神经元。<br>    复杂模型的挑战：<br>        1）梯度消失的问题：深度网络难以直接用经典算法（例如BP算法）进行训练, 因为误差在多隐层内传播时会出现梯度消失问题（即梯度迅速为0），难以收敛到稳定状态<br>    （<strong>这些是理论无法解决的问题，需要trick</strong>）<br>    训练技巧（trick）：<br>        1）<strong>预训练+微调</strong>：预训练阶段，每次训练时将上<strong>一层隐层结点的输出作为输入, 本层隐结点的输出作为输出，仅训练一层网络</strong>；预训练全部完成后，对整个网络进行<strong>微调训练</strong>，一般采用BP算法；<br>        2）<strong>新型激活函数（LeakyReLU）</strong>：求导更容易，缓解梯度消失；<br>        3）<strong>Dropout</strong>：当训练一个深度神经网络时，我们可以随机丢弃一部分神经元以及其对应的连接边；<br>    基本思想：<br>        idea1）+思路2）<br>    缺点：<br>        挑战<br>    优点：<br>        idea 1）</p>
<p>卷积神经网络的基本思想：<br>    1）启发：卷积神经网络是人工神经网络的一种，由对猫的视觉皮层的研究发展而来，视觉皮层细胞对视觉子空间更敏感，<strong>通过子空间的平铺扫描实现对整个视觉空间的感知。</strong>；</p>
<p>卷积神经网络特点：<br>    1）优势在于具有共享权值的网络结构和局部感知（也称为稀疏连接）的特点，能够降低神经网络的运算复杂度。</p>
<p>卷积神经网络的结构：<br>    1）输入：卷积层和子采样器提取得到的特征；<br>    2）低层：子采样器和卷积层交替得到的；<br>    3）更高层：全连接层；<br>    4）输出：可以是分类器 or 逻辑回归；</p>
<p>卷积层：<br>    1）输入；<br>    2）<strong>卷积核</strong>（如何运算）；<br>    3）步长；<br>    4）确定输出维度；<br>    （<strong>注意相关参数影响，输入维度、步长</strong>）<br>eg：<strong>卷积核</strong><br>输入7,7 -&gt; 输出3,3（<strong>要会算这个例子</strong>）<br>1 2 3 4 5 6 7<br>1 2 3<br>    1 2 3<br>        1 2 3<br><img src="/Intro-of-AI/p14.png" alt="卷积层运算过程"></p>
<p>RNN的基本思想（循环神经网络）<br>    思想：<br>        1）循环神经网络是一种用于处理序列数据的神经网络结构，其基本原理在于网络中存在循环连接，使得网络具有记忆能力，能够捕捉时间序列中的依赖关系。<br>        2）RNN不同于前向神经网络，它的层内、层与层之间的信息可以双向传递，更高效地存储信息，利用更复杂的方法来更新规则，通常用于处理信息序列的任务。</p>
<p>RNN的基本结构<br>    1）RNN主要用来处理序列数据，在传统的神经网络模型中，是从输入层到隐含层再到输出层，每层内的节点之间无连接，<strong>循环神经网络中一个当前神经元的输出与前面的输出也有关</strong>，网络会对前面的信息进行记忆并应用于当前神经元的计算中，<strong>隐藏层之间的节点是有连接的</strong>，并且<strong>隐藏层的输入不仅包含上层的输出还包含上一时刻隐藏层的输出</strong>。<br>    2）公式表示：<br>        $h_t &#x3D; f_w(h_{t-1},x_t)$；<br>        含义：<br>            1）$h_t$：新的目标状态；<br>            2）$h_{t-1}$：前一目标状态；<br>            3）$x_t$：当前输入向量；<br>            4）$f_w$：权重参数函数；<br>    3）图像表示：<br>        <img src="/Intro-of-AI/p15.png" alt="RNN的结构">；</p>
<p>RNN的每次执行会作为下次执行输入的一部分：<br>    一个RNN可认为是同一网络的多次重复执行，每一次执行的结果是下一次执行的输入。<br>    即输入为：$x_t$以及$W_{s_{t-1}}$<br>    <img src="/Intro-of-AI/p16.png" alt="隐层连接展开">；</p>
<p>RNN的特点是循环连接和共享参数：<br>    1）循环连接就是隐层节点之间的连接；<br>    2）共享参数是指无论输入序列有多长，使用的都是同一套结构的权重；<br>        W_hh: 连接上一个隐状态 (h_{t-1}) 到 当前隐状态 (h_t) 的权重。<br>        W_xh: 连接当前输入 (x_t) 到 当前隐状态 (h_t) 的权重。<br>        W_hy: 连接当前隐状态 (h_t) 到 当前输出 (o_t) 的权重（如果有输出的话）。</p>
<p>由于上述特点RNN通常用于处理<strong>序列</strong>式的任务，在图像识别、自然语言处理很好；</p>
<h2 id="ch12：强化学习"><a href="#ch12：强化学习" class="headerlink" title="ch12：强化学习"></a>ch12：强化学习</h2><p><code>最后一节课会划重点</code></p>

        


        <span>
          <a class="article-read" href="/2025/11/07/Intro-of-AI/"> Read more -->
          </span>
        </div>

        
    
    <div class="recent-post-item">

      <a href="/2025/11/02/%E6%90%AD%E5%BB%BA%E5%90%84%E7%A7%8D%E7%8E%AF%E5%A2%83%E7%9A%84%E8%AE%B0%E5%BD%95/" class="item-title">搭建各种环境的记录</a>
      
      <time datetime="2025-11-02T08:50:02.000Z">
        2025-11-02
      </time>
      
      <!-- <div class="article-digest"> -->
        <!-- 随着大学课程的进行，每学期总是会被要求搭建各种各样的运行环境，但在学习完成之后通常我不会再用到它们，所以用这篇blog来记录我搭建过的一些环境，简单描述它们的过程，以便我后续能记得我做过哪些改动，从而可以更好地管理我的电脑空间。
default我在Mac上安装了命令行工具、Vscode，配置了C&#x2F;C++的基本环境（参照[bilibili]）
于是这一部分我想记录一些命令行常用命令

查看当前目录的大小du -sh .，这个命令会显示磁盘使用情况，包括当前目录以及所有子目录

搭建hexo（Mac）
从github上clone了homebrew的仓库
在用户目录下，修改了.zshrc与.bashrc文件，配置了homebrew在tuna的镜像源
运行了homebrew仓库的脚本文件，安装了homebrew，另外仓库中还有卸载用的文件
使用包管理器homebrew安装了node以及其附带的nmp
使用nmp为全局配置了hexo环境
将为win上的blog源码打包，传到Mac上，并使用nmp install，索引到package.json文件，完成了依赖包的安装
使用git为全局配 -->
        <!-- </div> -->

        
        <p><code>随着大学课程的进行，每学期总是会被要求搭建各种各样的运行环境，但在学习完成之后通常我不会再用到它们，所以用这篇blog来记录我搭建过的一些环境，简单描述它们的过程，以便我后续能记得我做过哪些改动，从而可以更好地管理我的电脑空间。</code></p>
<h2 id="default"><a href="#default" class="headerlink" title="default"></a>default</h2><p>我在Mac上安装了命令行工具、Vscode，配置了C&#x2F;C++的基本环境（参照[<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1U741157Rd/?spm_id_from=333.1387.favlist.content.click&vd_source=80df09f481ef5f0671e5e0e35d02e33e">bilibili</a>]）</p>
<p>于是这一部分我想记录一些命令行常用命令</p>
<ol>
<li>查看当前目录的大小<code>du -sh .</code>，这个命令会显示磁盘使用情况，包括当前目录以及所有子目录</li>
</ol>
<h2 id="搭建hexo（Mac）"><a href="#搭建hexo（Mac）" class="headerlink" title="搭建hexo（Mac）"></a>搭建hexo（Mac）</h2><ol>
<li>从github上clone了homebrew的仓库</li>
<li>在用户目录下，修改了.zshrc与.bashrc文件，配置了homebrew在tuna的镜像源</li>
<li>运行了homebrew仓库的脚本文件，安装了homebrew，另外<strong>仓库中还有卸载用的文件</strong></li>
<li>使用包管理器homebrew安装了node以及其附带的nmp</li>
<li>使用nmp为全局配置了hexo环境</li>
<li>将为win上的blog源码打包，传到Mac上，并使用<code>nmp install</code>，索引到package.json文件，完成了依赖包的安装</li>
<li>使用git为全局配置了用户名与邮箱</li>
<li>使用<code>ssh-keygen -t rsa -C 我的邮箱</code>，生成了公私钥，<strong>同时在本地设置了访问该私钥的密码</strong>，相关文件均在用户目录中隐藏，密码同我的Mac密码</li>
<li>在github我的主页setting中，添加了访问仓库用的公钥</li>
<li>完成了所有配置，并写下这篇blog，上传到了github</li>
</ol>
<h2 id="搭建java环境（Mac）"><a href="#搭建java环境（Mac）" class="headerlink" title="搭建java环境（Mac）"></a>搭建java环境（Mac）</h2><ol>
<li>在网址<a href="%5Btext%5D(https://www.oracle.com/java/technologies/downloads/#jdk25-mac)">ORACLE</a>，中下载了<strong>ARM64 DMG Installer</strong>，对应的是Mac M系列芯片，jdk25.0.1的安装包（170MB）</li>
<li>启动安装包，选择安装位置<strong>为所有用户安装</strong>，相关依赖安装在路径&#x2F;Library&#x2F;Java下（300MB左右），可以使用命令<code>/usr/libexec/java_home -V</code>，该命令用于列出所有已安装的jdk版本及路径</li>
<li>注意由于为选择了为所有用户安装，所以对应依赖谁在系统级的Library下，而非用户级别的Library下</li>
<li>然后我在Vscode中安装了扩展<strong>Extension Pack for Java</strong>，对应一共为我自动安装了7个扩展项目（30MB左右），在Vscode中点开扩展清空搜索栏，默认会显示已经安装的扩展</li>
<li>最后我在我的Mac用户目录下创建了<strong>Java_projects</strong>用来存放我的各种java项目，并创建了一个test项目，完成了测试。此外，实际上在运行的时候要依赖于我签名安装的扩展项目中的java run，如果要使用debug的话则依赖于java debug。（但我注意到也可以使用run code运行，这个插件是我前面为了运行C&#x2F;C++而安装的，不过如果使用它运行，它会将为的java源文件先编译成一个.class的文件）</li>
</ol>
<h2 id="搭建Vue环境（Mac）"><a href="#搭建Vue环境（Mac）" class="headerlink" title="搭建Vue环境（Mac）"></a>搭建Vue环境（Mac）</h2><ol>
<li>检查了我的Mac电脑上具有node.js的环境，以及npm的包管理器</li>
<li>于是我使用npm下载了Vue CLI(一个Vue项目的命令行工具)，使用命令<code>npm install -g @vue/cli</code>，在全局安装了这个命令行工具</li>
<li>我在用户目录下创建了Vue_projects，用于存放Vue的项目，并在此文件夹下使用<code>vue create test-project</code>创建了一个测试项目，选择了默认配置Vue2;</li>
<li>在创建Vue项目的时候遇到了提示<code>yesys@MacBookAir Vue_projects % vue create test-project?  Your connection to the default npm registry seems to be slow. Use https://registry.npmmirror.com for faster installation? (Y/n) </code>，提示我使用npm下载包使用的默认源，较慢，建议我切换到镜像源；于是我切换到了<code>https://registry.npmmirror.com</code>，如果要切换回默认源可以使用<code>npm config set registry https://registry.npmjs.org</code></li>
<li>接下来cd到我的项目目录，并使用<code>npm run serve</code>打开了我的项目，可以使用浏览器，以及本地的端口号<code>http://localhost:8080/</code>进行访问</li>
<li>后续我可以使用Vscode在项目文件夹下进行开发工作，使用5中运行项目的命令可以实时查看效果；最后如果项目完成了的话可以使用<code>npm run build</code>生成生产版本</li>
<li>为了在Vscode中进行Vue开发，我安装了Vue(Official)的插件</li>
<li>注意：使用vue create project—name创建的项目，所有相关依赖都在该项目文件夹下（node_modules中），当然也有创建全局依赖的方法；总之明确这一点可以帮助我管理好空间。</li>
</ol>
<h2 id="搭建微信小程序开发环境（Mac）"><a href="#搭建微信小程序开发环境（Mac）" class="headerlink" title="搭建微信小程序开发环境（Mac）"></a>搭建微信小程序开发环境（Mac）</h2><ol>
<li>我在微信公众平台<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/">WeChat</a>，为我即将开发的小程序注册了一个账号；</li>
<li>成功注册后进入了小程序发布流程界面，完成了前置的一些信息设置，并根据引导下载了<code>普通小程序开发工具</code>，网址是<a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/devtools/stable.html">小程序开发工具下载</a>，下载了<strong>macOS ARM64</strong>的开发工具，dmg文件390.1MB</li>
<li>我使用dmg文件安装了微信小程序开发app，名为<code>微信开发者工具</code>，并推出了安装器，删除了dmg文件；</li>
<li>使用开发工具，在我的用户目录下创建了<code>WeChatProjects</code>文件夹以及我的项目文件<code>EasyCN</code>，使用的是基础模版；</li>
<li>在Vscode中安装了一个名为<code>微信小程序开发工具</code>的扩展，大概200多MB；</li>
</ol>
<h2 id="Py环境"><a href="#Py环境" class="headerlink" title="Py环境"></a>Py环境</h2><p>在vsc中安装了py扩展包，大概200MB</p>
<p><strong>我的mac环境中自带了python3，或许是和系统开发工具一起安装的</strong></p>
<p>一般的开发流程中需要先配置虚拟环境并手动选择</p>
<p>配置虚拟环境</p>
<ol>
<li>使用vsc命令面板，Python: Create Environment；</li>
<li>选择Venv，选择python解释器版本，设置环境名称；（或者直接使用终端命令<code>python -m venv env_name</code>）</li>
<li>选择是否安装requirements文件中的内容（如果有的话，.txt .yaml）等</li>
<li><code>source env_name/bin/activate</code> 激活虚拟环境（激活环境之后vsc当前语法检测这一项目会显示目前使用的虚拟环境，或者使用命令<code>which python</code>可以直接查看）；</li>
<li>使用<code>pip install -r requirements.txt</code>安装环境（如果3中没有选择）；</li>
</ol>
<p>使用虚拟环境</p>
<ol>
<li>创建项目配置文件<code>.vscode/settings.json</code></li>
<li>添加虚拟环境有关配置如下，其中<code>$&#123;workspaceFolder&#125;</code>会自动指向VSCode中打开的项目目录；</li>
</ol>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;python.defaultInterpreterPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;/venv/bin/python&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// Windows用户使用：</span></span><br><span class="line">    <span class="comment">// &quot;python.defaultInterpreterPath&quot;: &quot;$&#123;workspaceFolder&#125;/venv/Scripts/python.exe&quot;,</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 其他有用的Python设置</span></span><br><span class="line">    <span class="attr">&quot;python.terminal.activateEnvironment&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;python.terminal.activateEnvInCurrentTerminal&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;python.analysis.extraPaths&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;./src&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;[python]&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;editor.formatOnSave&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;editor.defaultFormatter&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ms-python.autopep8&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="虚拟环境lx-back-env"><a href="#虚拟环境lx-back-env" class="headerlink" title="虚拟环境lx_back_env"></a>虚拟环境lx_back_env</h3><p>用来做软件工程课设的虚拟环境，里面有一些dj的框架；</p>
<p>虚拟环境~&#x2F;Py_projects&#x2F;THINKPADSTROE-BACKEND&#x2F;lx_back_env</p>
<p>整个环境大概几十MB</p>
<h2 id="配置Mac桌面平铺功能"><a href="#配置Mac桌面平铺功能" class="headerlink" title="配置Mac桌面平铺功能"></a>配置Mac桌面平铺功能</h2><p>配置yabai：</p>
<ol>
<li>使用homebrew安装yabai<code>brew install koekeishiya/formulae/yabai </code>；</li>
<li>将yabai初始配置文件&#x2F;opt&#x2F;homebrew&#x2F;opt&#x2F;yabai&#x2F;share&#x2F;yabai&#x2F;examples&#x2F;yabairc移动到本地~&#x2F;.yabai</li>
<li>编辑文件~&#x2F;.yabai可以编辑yabai的配置；</li>
<li>我在开机的时候按住电源键（长按直到出现选项界面），进入了恢复模式，打开终端使用<code>crsutil disable</code>，关闭了系统完整性保护SIP；</li>
<li>使用命令<code>shasum -a 256 $(which yabai)</code>，查看了yabai的哈希值，并使用命令<code>sudo code /etc/sudoers</code>编辑该文件，给yabai添加sudo权限；在&#x2F;ect&#x2F;sudoers文件的最后新添加了一行<code>yesys ALL=(root) NOPASSWD:sha256:7f17e8ff8a6131368c013af4029f3831a8e57723d5e2413a3e3f6cc1b8cdae52 /opt/homebrew/bin/yabai --load-sa</code>；</li>
<li>使用命令<code>yabai --start-service</code>便可以启动yabai服务；</li>
<li>使用命令<code>sudo yabai --load-sa</code>让yabai将自己的功能注入到系统中；</li>
<li>使用命令<code>yabai --stop-service</code>可以停止yabai的进程，系统的窗口管理恢复正常；</li>
</ol>
<p>使用的时候遇到过yabai不能获得完整的窗口管理权限的问题，参考解决方案<img src="https://blog.gitcode.com/7853f91c8ad85cb1610aae8074028280.html" alt="git"></p>
<p>配置skhd：</p>
<ol>
<li>使用<code>brew install</code>安装skhd；</li>
<li>在~&#x2F;.skhd中编写skhd的配置文件；</li>
<li>使用<code>skhd --start-service</code>启动skhd服务；</li>
</ol>
<h3 id="yabai常用命令"><a href="#yabai常用命令" class="headerlink" title="yabai常用命令"></a>yabai常用命令</h3><p><code>yabai -m space --focus 2</code>切换到第二个桌面</p>
<p><code>yabai --stop-service</code>终止yabai服务</p>
<p><code>yabai --start-service</code>启动yabai服务</p>
<p><code>yabai --restart-service</code>重新启动yabai服务</p>
<h2 id="配置Mac个性化终端"><a href="#配置Mac个性化终端" class="headerlink" title="配置Mac个性化终端"></a>配置Mac个性化终端</h2><p>首先是一个全新的终端</p>
<ol>
<li>使用命令<code>brew install --cask wezterm</code>安装wezterm</li>
<li>不再使用终端，而是使用wezterm</li>
<li>创建一个文件保存配置文件在~&#x2F;.config&#x2F;wezterm&#x2F;wezterm.lua</li>
</ol>
<p>其次是终端的提示效果</p>
<ol>
<li>使用<code>brew install starship</code>安装了starship，安装信息：“zsh completions have been installed to:<br>  &#x2F;opt&#x2F;homebrew&#x2F;share&#x2F;zsh&#x2F;site-functions”；</li>
<li>编辑～目录下的.zshrc文件（在安装homebrew的时候也创建过），配置starship在zsh启动时生效，加入<code>eval &quot;$(starship init zsh)&quot;</code>；</li>
<li>在~&#x2F;.config目录下创建starship.toml，用来配置starship（然后在starship.rc网站中下载了一个预设的toml文件使用）</li>
</ol>
<p>终端的文字高亮</p>
<ol>
<li>使用命令<code>brew install zsh-syntax-highlighting zsh-autosuggestions</code>安装zsh高亮提示工具</li>
<li>在.zshrc中配置了初始化启动，以及相关效果设置</li>
</ol>
<p>终端命令自动补全</p>
<ol>
<li>使用命令<code>brew install zsh-autocomplete</code>下载zsh自动补全插件；</li>
<li>在.zshrc中添加相关配置；</li>
</ol>
<h3 id="wezterm的常用操作"><a href="#wezterm的常用操作" class="headerlink" title="wezterm的常用操作"></a>wezterm的常用操作</h3><ol>
<li>ctrl+shift+n新开一个窗口</li>
<li>Ctrl+Shift+T：新建一个标签页</li>
<li>ctrl+tab：切换到下一个标签页（循环切换）</li>
<li>我配置了ctrl+h、l左右切换，然后使用alt+数字切换1～9标签；</li>
</ol>
<h2 id="配置系统级进程监视工具htop"><a href="#配置系统级进程监视工具htop" class="headerlink" title="配置系统级进程监视工具htop"></a>配置系统级进程监视工具htop</h2><ol>
<li>使用<code>brew install htop</code>安装htop</li>
</ol>
<p>htop使用</p>
<ol>
<li>使用命令<code>htop</code>可以开启它；</li>
<li>上下左右可以移动选中条；</li>
<li>空格可以选中F9+return可以结束进程</li>
</ol>
<h2 id="配置个性化导航栏"><a href="#配置个性化导航栏" class="headerlink" title="配置个性化导航栏"></a>配置个性化导航栏</h2><ol>
<li>使用<code>brew install sketchybar</code>安装了sketchybar;</li>
<li>我clone了一个大佬的仓库到本地<code>git clone https://github.com/FelixKratz/dotfiles.git /tmp/felix_dotfiles_complete</code>;</li>
<li>导航到需要提交的特定版本<code>cd /tmp/felix_dotfiles</code>以及<code>git checkout e6288b3f4220ca1ac64a68e60fced2d4c3e3e20b</code></li>
<li>复制 sketchybar 配置到你的配置目录 <code>cp -r .config/sketchybar ~/.config/</code></li>
<li>安装了一系列外部依赖：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 安装必备命令行工具</span></span><br><span class="line">brew install jq              <span class="comment"># JSON处理 (必需)</span></span><br><span class="line">brew install sf-symbols      <span class="comment"># Apple系统图标 (必需)</span></span><br><span class="line">brew install gh              <span class="comment"># GitHub CLI (用于某些插件)</span></span><br><span class="line">brew install switchaudio-osx <span class="comment"># 音频设备切换 (用于音频插件)</span></span><br><span class="line">brew install cava            <span class="comment"># 音频频谱可视化</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意：`background-music` 可能需要额外步骤，请访问其GitHub页面安装</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 安装 Nerd Fonts (图标字体，必需!)</span></span><br><span class="line">brew tap homebrew/cask-fonts</span><br><span class="line">brew install --cask font-hack-nerd-font font-sf-pro</span><br><span class="line"><span class="comment"># 安装后，务必打开【字体册】应用，确保这些字体已激活。</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="设置导航栏的音乐组件"><a href="#设置导航栏的音乐组件" class="headerlink" title="设置导航栏的音乐组件"></a>设置导航栏的音乐组件</h3><ol>
<li>使用<code>brew install --cask blackhole-2ch</code>安装blackhole；</li>
<li>使用<code>brew install ffmpeg</code>安装ffmpeg（这个依赖似乎比较多有100多MB）；</li>
<li>配置音频路由，让音频不仅输出到扬声器、耳机，还输出到balckhole；</li>
<li>配置多输出设备（输出到我原始的设备以及balckhole）这是为了让blackhole能够捕捉到信号，并将blackhole设置为主设备，全部使用48khz；</li>
<li>编写相应的plugins和items脚本，名为：audio_dynamic_item.sh audio_beat_item.sh以及dynamic_audio_bar.sh；</li>
<li>reload sketchybar；</li>
</ol>
<p>显示当前播放的信息：</p>
<ol>
<li>使用<code>brew install nowplaying-cli</code>安装nowpalying工具；</li>
<li>。。。。先搁置吧</li>
</ol>
<h2 id="配置yazi"><a href="#配置yazi" class="headerlink" title="配置yazi"></a>配置yazi</h2><ol>
<li>使用<code>brew install yazi</code>安装yazi；</li>
<li>创建文件夹~&#x2F;.config&#x2F;yazi</li>
<li>在yazi中复制粘贴了github仓库中的默认配置文件yazi-default.toml、keyboard-defualt.toml、dark-theme.toml；</li>
<li>在~&#x2F;.local&#x2F;bin&#x2F;yazi-copy-files-macos中编写yazi的快捷键脚本（为了将yazi中复制粘贴的内容放到finder的粘贴板）</li>
<li>赋予脚本执行权限<code>chmod +x ~/.local/bin/yazi-copy-files-macos</code>；</li>
</ol>
<dl><dt>yazi的使用：<br>类别	    按键	                            功能<br>基础导航	h j k l &#x2F; 方向键	左、下、上、右移动 &#x2F; 进入文件夹<br>Enter	进入目录或打开文件<br>q	退出 Yazi<br>文件操作	<Space>	标记&#x2F;取消标记文件（用于批量操作）<br>y	复制标记的文件<br>x	剪切标记的文件<br>p	粘贴文件<br>d	将文件移至回收站<br>D	永久删除文件（慎用）<br>a	新建文件&#x2F;文件夹（新建文件夹需以&#x2F;结尾）<br>r	重命名文件<br>视图与高级	.	显示&#x2F;隐藏隐藏文件（以点开头的文件）<br>~ 或 F1	打开内置帮助菜单，忘记快捷键时随时查阅<br>Tab	切换标签页</Space></dt><dd>执行 Shell 命令</dd></dl><h2 id="配置typst"><a href="#配置typst" class="headerlink" title="配置typst"></a>配置typst</h2><ol>
<li>在vsc安装typst扩展Tinymist Typst；</li>
<li>使用<code>brew install typst</code>安装typst编译器；</li>
</ol>

        


        <span>
          <a class="article-read" href="/2025/11/02/搭建各种环境的记录/"> Read more -->
          </span>
        </div>

        
    
    <div class="recent-post-item">

      <a href="/2025/10/23/OS/" class="item-title">OS</a>
      
      <time datetime="2025-10-23T11:27:33.000Z">
        2025-10-23
      </time>
      
      <!-- <div class="article-digest"> -->
        <!-- 这篇blog用来记录我于大三秋季学期，学习操作系统时，了解到的知识，以备复习以及增强自己的专业素养
操作系统的基本概念L1操作系统需要解决的问题
作为用户与计算机硬件系统之间的接口（例如上层的编程者使用系统调用完成相关工作）
对计算机系统资源进行管理（eg. 管理硬件CPU、存储器、外设，管理软件程序、数据；管理资源状态，如PCB、TCB；采取相关策略，对资源分配、回收等）
在需要的时候马上对计算机资源进行抽象（通过逻辑功能扩展物理功能，如在裸机上附加外设管理、文件管理、存储管理、处理器管理）

一些启发的问题：

直接使用计算机是很不方便的，因为计算机是一个复杂精密的仪器，而大部分人只需要计算机的部分功能，无需去了解整个计算机系统的工作原理
计算机衍生出各种不同的资源，显示器、音响、打印机，各种外设，资源多样意味着，1）资源管理复杂，那么管理应该落到谁身上？使用者？某种软件？；2）不同厂家生产的设备需要纳入计算机的体系协同工作，缺少统一标准，谁来负责与不同的接口交互？

操作系统的位置
OS是配置在硬件上的第一层软件，是对硬件系统的首次扩充
OS工作在内核态

操作系统的发展过程未配 -->
        <!-- </div> -->

        
        <p><code>这篇blog用来记录我于大三秋季学期，学习操作系统时，了解到的知识，以备复习以及增强自己的专业素养</code></p>
<h2 id="操作系统的基本概念L1"><a href="#操作系统的基本概念L1" class="headerlink" title="操作系统的基本概念L1"></a>操作系统的基本概念L1</h2><h3 id="操作系统需要解决的问题"><a href="#操作系统需要解决的问题" class="headerlink" title="操作系统需要解决的问题"></a>操作系统需要解决的问题</h3><ol>
<li>作为用户与计算机硬件系统之间的接口（例如上层的编程者使用系统调用完成相关工作）</li>
<li>对计算机系统资源进行管理（eg. 管理硬件CPU、存储器、外设，管理软件程序、数据；管理资源状态，如PCB、TCB；采取相关策略，对资源分配、回收等）</li>
<li>在需要的时候马上对计算机资源进行抽象（通过逻辑功能扩展物理功能，如在裸机上附加外设管理、文件管理、存储管理、处理器管理）</li>
</ol>
<p>一些启发的问题：</p>
<ol>
<li>直接使用计算机是很不方便的，因为计算机是一个复杂精密的仪器，而大部分人只需要计算机的部分功能，无需去了解整个计算机系统的工作原理</li>
<li>计算机衍生出各种不同的资源，显示器、音响、打印机，各种外设，资源多样意味着，1）资源管理复杂，那么管理应该落到谁身上？使用者？某种软件？；2）不同厂家生产的设备需要纳入计算机的体系协同工作，缺少统一标准，谁来负责与不同的接口交互？</li>
</ol>
<h3 id="操作系统的位置"><a href="#操作系统的位置" class="headerlink" title="操作系统的位置"></a>操作系统的位置</h3><ol>
<li>OS是配置在硬件上的第一层软件，是对硬件系统的首次扩充</li>
<li>OS工作在内核态</li>
</ol>
<h3 id="操作系统的发展过程"><a href="#操作系统的发展过程" class="headerlink" title="操作系统的发展过程"></a>操作系统的发展过程</h3><h4 id="未配置操作系统的计算机系统"><a href="#未配置操作系统的计算机系统" class="headerlink" title="未配置操作系统的计算机系统"></a>未配置操作系统的计算机系统</h4><p>工作方式：用户作为计算机专业人员，使用机器语言编程，输入输出如纸带。</p>
<p>工作特点：用户独占资源，资源不能在用户间共享；CPU等待用户手工装、卸纸带，利用率很低。</p>
<h4 id="单道批处理系统"><a href="#单道批处理系统" class="headerlink" title="单道批处理系统"></a>单道批处理系统</h4><p>动机：为充分利用计算机系统，应尽量让系统连续运行，以减少空闲时间</p>
<p>工作方式：一批作业，脱机输入道磁带，监督程序控制有序处理</p>
<p>工作特点：内存中只保持一个作业运行，先进先出（单道）；成批处理作业（批处理，或许是指一批作业同时输入）</p>
<p><strong>注</strong>：单道批处理系统是最早出现的一种OS，单严格来说只能算OS前身，并非人们现在所理解的OS</p>
<h4 id="多道批处理系统"><a href="#多道批处理系统" class="headerlink" title="多道批处理系统"></a>多道批处理系统</h4><p>动机：单道批处理系统中内存中仅有一道作业，每次处理完一个作业，程序发出I&#x2F;O请求的时候CPU都处于等待状态，无法充分利用资源</p>
<p>工作方式：作业成批进入内存，按照一定策略由程序调度，轮流使用CPU</p>
<p>工作特点：内存中维护多个作业，交替使用CPU（多道性）；作业进出顺序不定（无序性）；作业经历两次调度（作业调度、进程调度）</p>
<p><strong>注</strong>：为了完成这样的工作方式，实际上牵扯到许多问题，包括处理器争用、内存分配和保护、IO设备分配、文件组织管理、作业管理、用户与系统接口等等，<strong>所以应该增加一组软件来解决这些问题，于是这些软件构成了现代意义上的操作系统</strong></p>
<h4 id="分时系统"><a href="#分时系统" class="headerlink" title="分时系统"></a>分时系统</h4><p>动机：多个程序员围着一台批处理系统的主机，缺乏一些机制来很好地为每个用户作业分配时间、为程序员提供良好的<strong>交互</strong>体验，有时一个逗号的编译错误会浪费程序员半天的时间，他们希望自己的程序可以更快地得到响应</p>
<p>工作方式：在多道批处理系统的基础上，将系统资源在时间上进行分割，每个时间段称为一个时间片，每个用户依次轮流使用时间片</p>
<p>工作特点：多个终端共享一个主机（多路性）；各个用户独立操作，互不干扰（独立性）；请求能在很短的时间得到响应（及时性）；用户可以通过中断与系统进行人机交互（交互性）</p>
<p><strong>注</strong>：实际上分时系统已经很接近如今我们使用的操作系统了，或者说就是在其基础上加入了更多的现代化改进，而下面的实时系统则是为了应对一些特殊的场景</p>
<h4 id="实时系统（特殊，仅作了解）"><a href="#实时系统（特殊，仅作了解）" class="headerlink" title="实时系统（特殊，仅作了解）"></a>实时系统（特殊，仅作了解）</h4><p>动机：在一些场景下我们特别强调作业处理的及时响应，甚至不再是及时性，而是实时性与可靠性，例如武器装备、订票系统等场景</p>
<p>实时任务种类：硬实时任务、软实时任务，前者要求系统必须满足任务对<strong>截止日期</strong>的要求，后者可以偶尔错过截止日期</p>
<h4 id="微机操作系统（了解存在）"><a href="#微机操作系统（了解存在）" class="headerlink" title="微机操作系统（了解存在）"></a>微机操作系统（了解存在）</h4><p>略</p>
<h2 id="操作系统的特性"><a href="#操作系统的特性" class="headerlink" title="操作系统的特性"></a>操作系统的特性</h2><p>并发、共享是最基本的特征</p>
<h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>并发的含义：指处理多个同时性活动的能力</p>
<ol>
<li>针对单核CPU讨论，具体来说：宏观上是这些程序同时在执行，微观上是每个时刻实际只有一个程序在执行，程序轮流使用CPU</li>
<li>并发不同于并行，后者是不同程序同一时刻在多个硬件部件上执行，例如多核CPU</li>
</ol>
<h3 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h3><p>共享的含义：操作系统与多个用户的程序共同使用计算机中的有限资源</p>
<p>共享的分类：互斥共享（打印机）、同时共享（读文件）</p>
<h3 id="虚拟"><a href="#虚拟" class="headerlink" title="虚拟"></a>虚拟</h3><p>虚拟的含义：一个物理实体映射为若干多个对应逻辑实体</p>
<p>虚拟的实现方法：分时 分空间</p>
<p>对应的具体例子：时分CPU，在每个进程看来是一个虚拟处理机；空分存储器，每个进程拥有独立的虚拟地址空间；</p>
<h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>异步的含义：操作系统必须随时对不可预测的次序发生的事件进行响应和处理</p>
<ol>
<li>多个进程发生与运行速度的不可知，导致了在操作系统视角下，整个系统在每时每刻的状态都是难以重现的</li>
<li>操作系统需要保证，只要环境相同，进程的运行结果就要一致（进程对复杂、不可重现的整个系统是感知不到的，系统对进程是透明的）</li>
<li>更准确一点来说，异步是操作系统面对的挑战</li>
</ol>
<h2 id="操作系统的功能"><a href="#操作系统的功能" class="headerlink" title="操作系统的功能"></a>操作系统的功能</h2><p>总的来说，其需要保证多道程序，有条不紊地运行，提高系统中各种资源的利用率，并方便用户的交互。</p>
<h3 id="处理器管理"><a href="#处理器管理" class="headerlink" title="处理器管理"></a>处理器管理</h3><p>进程控制：以进程为基本单位进行处理机的分配和运行</p>
<p>具体而言：</p>
<ol>
<li>为作业创建进程</li>
<li>撤销已经结束的进程</li>
<li>控制进程在运行过程中的状态转换</li>
</ol>
<p>注：在现代OS中，进程控制除了这些以外还有关于线程的管理，后续会学习到</p>
<p>进程同步：通过<strong>进程同步机制</strong>，协调进程间的资源共享，推进并发进程执行</p>
<p>进程同步的主要方式：</p>
<ol>
<li>互斥方式，各进程在对<strong>临界资源</strong>访问的时候应该采取互斥的方式</li>
<li>同步方式，有的进程之间需要<strong>相互合作</strong>，同步机制来协调她们的次序</li>
</ol>
<p>进程通信：让多个相互协作的进程可以交换信息</p>
<p>例如：I-C-P，三个进程互相通信，I为C提供数据，C为P提供结果，P进行打印</p>
<p>进程调度：控制作业、进程的运行切换，从而高效地利用处理机资源提高系统性能</p>
<ol>
<li>作业调度：从<strong>后备队列</strong>上按照一定的算法，选择出若干个作业，为其分配必要的资源</li>
<li>进程调度：从<strong>就绪队列</strong>上，挑选出一个新进程，将处理机分配给它，并为其设置好运行现场，使其投入运行</li>
</ol>
<h3 id="存储器管理"><a href="#存储器管理" class="headerlink" title="存储器管理"></a>存储器管理</h3><p>内存分配：为多道程序分配内存，提高存储器利用率</p>
<ol>
<li>静态分配：内存空间在作业装入时确定，不允许作业再申请新的内存空间，也不允许作业在空间中移动</li>
<li>动态分配：允许作业在运行过程中申请新的内存空间，适应程序和数据的动态增长，也允许作业在内存中“移动”</li>
</ol>
<p>内存保护：确保每个进程在自己的内存空间运行，互不干扰</p>
<p>例如：设置两个界限寄存器，用来存放正在执行进程的上下界，系统对每条指令访问的地址进行检查，如果有越界行为则停止程序执行</p>
<p>地址映射：将逻辑地址分配给进程，让用户可以通过逻辑地址透明地访问物理地址</p>
<p>实际上就是一种虚拟化</p>
<p>内存扩充：借助<strong>虚拟存储技术</strong>，从逻辑上扩充内存容量，让用户感知道的内存容量比实际容量大得多</p>
<h3 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h3><p>管理计算机所有的外围设备</p>
<p>缓冲区管理：解决CPU和I&#x2F;O设备速度不匹配的问题</p>
<p>设备分配：控制设备的分配和回收</p>
<p>设备处理：实现CPU和设备控制器之间的通信</p>
<p>（设备在操作系统中同样会被映射为地址）</p>
<h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h3><p>文件存储空间管理：为每个文件分配必要的外存空间，对空间进行回收（通常采用离散分配的方式）</p>
<p>目录管理：就为了让用户能方便地在外存上找到所需文件，系统为文件建立目录项</p>
<p>读写保护：文件读写管理，以及防止文件被非法窃取、破坏</p>
<h3 id="用户接口"><a href="#用户接口" class="headerlink" title="用户接口"></a>用户接口</h3><p>联机用户接口：为联机用户提供的接口，由一组键盘命令及命令解释程序组成</p>
<p>脱机用户接口：为批处理作业的用户提供的接口（这类用户无需实时交互）</p>
<h3 id="其它功能"><a href="#其它功能" class="headerlink" title="其它功能"></a>其它功能</h3><p>系统安全、网络功能与服务、支持多媒体</p>
<p><code>写在操作系统功能的最后：实际上操作系统功能这一块可以作为一张地图使用，我们后续的学习实际上就是在这个框架上的展开，一步步去学习操作系统是怎么具体地将这些功能进行实现的</code></p>
<h2 id="操作系统的结构设计"><a href="#操作系统的结构设计" class="headerlink" title="操作系统的结构设计"></a>操作系统的结构设计</h2><p><code>这一部分需要补充一下</code></p>
<h2 id="L3进程的基础概念"><a href="#L3进程的基础概念" class="headerlink" title="L3进程的基础概念"></a>L3进程的基础概念</h2><h3 id="进程引入的原因"><a href="#进程引入的原因" class="headerlink" title="进程引入的原因"></a>进程引入的原因</h3><p>引入进程的根本原因，程序的并发执行会破坏程序执行的：</p>
<ol>
<li>顺序性；</li>
<li>封闭性；</li>
<li>可再现性</li>
</ol>
<p>前驱图：</p>
<ol>
<li>节点：表示1）一句语句；2）程序段；3）进程</li>
<li>有箭头的边：节点之间的前躯关系，后继节点的执行一定是依赖于前躯节点的</li>
<li>初始节点、终止节点：没有前躯、后继的节点</li>
</ol>
<p>并发执行的程序：</p>
<ol>
<li>执行过程交替进行</li>
<li>共享资源部具有封闭性</li>
<li>不具有可再现性（当然是在当前，我们没有加任何限制条件）</li>
<li>程序之间<strong>间接或直接相互制约</strong></li>
</ol>
<p>我们以程序为基础，为了让程序可以并发执行，引入进程的概念，来对并发程序进行描述与控制</p>
<h3 id="进程的描述"><a href="#进程的描述" class="headerlink" title="进程的描述"></a>进程的描述</h3><h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h4><p>进程 &#x3D; <strong>程序（数据段+程序段）+ PCB（进程控制模块）</strong></p>
<p>创建、撤销进程：实际上就是创建、撤销了PCB模块</p>
<p>进程的严格定义：进程是进程实体的运行过程，是系统进行资源分配和调度的基本单位</p>
<p>（除了最小微内核作为程序始终存放在内存中一直运行，例如原语操作、时钟管理、进程管理等，其他都作为进程管理）</p>
<p>进程的特性：</p>
<ol>
<li>动态性</li>
<li>并发性</li>
<li>独立性（资源调度）</li>
<li>异步性（各进程间的执行情况）</li>
</ol>
<p>一个程序可以对应多个进程，一个进程可以包含多个程序</p>
<h4 id="进程的基本状态与转换"><a href="#进程的基本状态与转换" class="headerlink" title="进程的基本状态与转换"></a>进程的基本状态与转换</h4><ol>
<li>创建状态：为要执行的程序作业创建PCB，创建进程</li>
<li>终止状态：执行完毕，回收相关资源</li>
<li>就绪状态：进入了就绪队列，等待执行，得到了除CPU以外的所有资源</li>
<li>执行状态：获得了CPU，正在被执行</li>
<li>阻塞状态：因为某些原因无法继续执行，放弃了CPU了使用，进入了一种暂停等待的状态</li>
</ol>
<p>相关状态转换如下图：</p>
<p><img src="/OS/ProcessStateTransform1.png" alt="进程状态转换1"></p>
<p>挂起：将内存中的进程临时保存到外存</p>
<p>当由于某些原因，例如内存不够了、用户需要等等，这时就需要做挂起操作</p>
<p>有了挂起之后进程有7种基本状态，其中活动、静止分别对应 在内存中 和 被挂起</p>
<ol>
<li>创建状态</li>
<li>终止状态</li>
<li>活动就绪状态</li>
<li>静止就绪状态</li>
<li>活动阻塞状态</li>
<li>静止阻塞状态</li>
<li>执行状态</li>
</ol>
<p>相关状态转换如下图：</p>
<p><img src="/OS/ProcessStateTransform2.png" alt="进程状态转换2"></p>
<p>注意：<strong>各状态的转换要很熟悉</strong></p>
<p>其实可以记住以下几个关键点：</p>
<p>无挂起</p>
<ol>
<li>执行可以到 就绪 阻塞</li>
<li>就绪可以到 执行</li>
<li>阻塞可以到 就绪</li>
</ol>
<p>在无挂起的基础上，有挂起</p>
<ol>
<li>静止到对应的活动 静止阻塞可以到静止就绪</li>
<li>执行可以到静止就绪，不能到静止阻塞</li>
</ol>
<p>此外，作为阻塞原因的常用例子是<strong>IO</strong></p>
<h4 id="进程管理到数据结构"><a href="#进程管理到数据结构" class="headerlink" title="进程管理到数据结构"></a>进程管理到数据结构</h4><ol>
<li>操作系统管理进程的数据结构：资源信息表&#x2F;进程信息表</li>
<li>进程自己的数据结构：PCB的数据结构</li>
</ol>
<p>关于PCB</p>
<ol>
<li>PCB是进程存在的唯一标识</li>
<li>能提供进程控制、调度、互相通信的信息</li>
<li>能够用于实现间断运行</li>
</ol>
<h3 id="进程的控制"><a href="#进程的控制" class="headerlink" title="进程的控制"></a>进程的控制</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>进程控制：进程的创建、终止以及状态的切换（基本状态和挂起）</p>
<p>进程控制的实现：操作系统<strong>内核</strong>中的<strong>原语</strong>来实现的</p>
<p>用户态：目态，权限较低，执行规定指令，访问指定寄存器和存储区；一般应用程序的执行状态，不去执行OS区域与指令</p>
<p>管态：内核态，高特权，执行所有指令，访问所有寄存器和存储区；<strong>传统OS</strong>都在管态，<strong>常驻于内存之中</strong></p>
<p>操作系统内核提供的功能：</p>
<ol>
<li>中断处理</li>
<li>时钟管理</li>
<li>原语操作</li>
</ol>
<p>操作系统内核依托于自己的功能进行的管理：</p>
<ol>
<li>进程管理</li>
<li>存储器管理</li>
<li>设备管理</li>
</ol>
<h4 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h4><p>一个典型的例子：多道批处理系统中，内核进行作业调度，将作业装入内存</p>
<p>创建的步骤：申请空PCB、分配资源、初始化PCB信息、插入就绪队列</p>
<p>进程可以继续创建进程，于是就有了父进程与子进程</p>
<h4 id="进程的终止"><a href="#进程的终止" class="headerlink" title="进程的终止"></a>进程的终止</h4><ol>
<li>正常终止</li>
<li>异常终止（出现错误）</li>
<li>外界干预（如死锁时）</li>
</ol>
<h4 id="阻塞与唤醒"><a href="#阻塞与唤醒" class="headerlink" title="阻塞与唤醒"></a>阻塞与唤醒</h4><p>原语是<strong>block和wakeup</strong></p>
<p>引起阻塞的事件：（这个可以仔细了解一下）</p>
<ol>
<li>请求OS服务，不能立刻被满足，如IO</li>
<li>启动OS的某种操作，等待OS操作完成</li>
<li>数据尚未到达</li>
<li>无新工作可做</li>
</ol>
<p>引起唤醒的事件与引起阻塞的事件相对应</p>
<h4 id="挂起与激活"><a href="#挂起与激活" class="headerlink" title="挂起与激活"></a>挂起与激活</h4><p>原语时<strong>suspend和active</strong></p>
<p>阻塞与激活一般是OS进行处理，挂起和激活可以由用户干预</p>
<h2 id="L4–L5进程同步和经典同步问题"><a href="#L4–L5进程同步和经典同步问题" class="headerlink" title="L4–L5进程同步和经典同步问题"></a>L4–L5进程同步和经典同步问题</h2><h3 id="进程同步（进本概念）"><a href="#进程同步（进本概念）" class="headerlink" title="进程同步（进本概念）"></a>进程同步（进本概念）</h3><p>进程同步的基本概念：对多个相关进程在执行次序上进行协调，使<strong>并发执行</strong>的诸进程之间能够按照一定的规则（或时序）<strong>共享系统资源</strong>，并能很好的<strong>相互合作</strong>，从而使得程序的执行具有<strong>可再现性</strong>。</p>
<p>两种形式的制约关系</p>
<ol>
<li>直接相互制约关系（源于进程之间的合作）</li>
<li>间接相互制约关系（源于进程对资源共享）</li>
</ol>
<p>临界资源：多个进程采用互斥的方式访问的资源（例如打印机）</p>
<p>对临界资源要进行<strong>互斥访问</strong>：即一个进程在使用该资源的时候其他进程不允许使用该资源</p>
<p>临界区：每个进程中访问临界资源的代码段</p>
<p>实现互斥访问临界资源：保证每个进程互斥地进入自己的临界区</p>
<p>同步机制：进程互斥地进入自己临界区的机制</p>
<p>同步机制要遵循的规则</p>
<ol>
<li>空闲让进（临界资源空闲的时候，允许希望访问的进程进入自己的临界区）</li>
<li>忙则等待（临界资源被占用的时候，希望访问的进程不能进入临界区，而需要等待）</li>
<li>有限等待（等待的进程不能一直等待，最终一定要能够访问到临界资源）</li>
<li>让权等待（拿不到临界资源的进程要释放处理机，不要忙等）</li>
</ol>
<p>当无进程处于临界区时，表明临界资源处于空闲状态，应允许一个请求进入临界区的进程立即进入自己的临界区。</p>
<p>当已有进程进入临界区时，表明临界资源正被访问，因而其它试图进入临界区的进程必须等待，以保证对临界资源的互斥访问。</p>
<p>对要求访问临界资源的进程，应保证在有限的时间内能进入自己的临界区，以免陷入“死等”状态。</p>
<p>当进程不能进入自己的临界区时，应立即释放处理机，以免进程陷入“忙等”状态。</p>
<h3 id="进程同步机制：硬件机制"><a href="#进程同步机制：硬件机制" class="headerlink" title="进程同步机制：硬件机制"></a>进程同步机制：硬件机制</h3><ol>
<li>关中断</li>
<li>Test and Set指令</li>
<li>Swap指令</li>
</ol>
<p>硬件实现不可被打断</p>
<p>后面两种方法的共同点是为临界资源维护公共变量lock</p>
<p>硬件实现的缺点：当临界资源被占用的时候，其他进程会<strong>不断进程测试</strong>，浪费处理器资源，属于<strong>忙等</strong>状态，不符合<strong>让权等待</strong>。</p>
<h4 id="关中断"><a href="#关中断" class="headerlink" title="关中断"></a>关中断</h4><p>在进入锁测试前关闭中断，直到完成锁测试才能打开中断。这样，进程在临界区执行期间，计算机系统不响应中断，从而不会发生调度。</p>
<p>缺点很多：限制CPU交叉执行能力、在多核CPU中不适用</p>
<h4 id="Test-and-Set指令"><a href="#Test-and-Set指令" class="headerlink" title="Test and Set指令"></a>Test and Set指令</h4><p>lock是临界资源的全局boolean变量</p>
<p>记忆点就在<strong>while(TS(&amp;lock));</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">while</span>(TS(&amp;lock));</span><br><span class="line">    critical section;</span><br><span class="line">    lock = FALSE;</span><br><span class="line">    remainder section;</span><br><span class="line">&#125;<span class="keyword">while</span>(TRUE)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">boolean TS(boolean *lock)&#123;</span><br><span class="line">    boolean old = *lock;</span><br><span class="line">    *lock = TRUE;</span><br><span class="line">    <span class="built_in">return</span> old;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Swap指令"><a href="#Swap指令" class="headerlink" title="Swap指令"></a>Swap指令</h4><p>lock是临界资源的全局boolean变量</p>
<p>swap就是单纯的交换功能</p>
<p>关键的记忆点在<strong>do{…}while(key !&#x3D; FALSE)</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    key = TRUE;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        swap(&amp;lock,&amp;key);</span><br><span class="line">    &#125;<span class="keyword">while</span>(key != FALSE)</span><br><span class="line">    critical section;</span><br><span class="line">    lock = FALSE;</span><br><span class="line">    ...</span><br><span class="line">&#125;<span class="keyword">while</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void swap(boolean* lock, boolean* key)&#123;</span><br><span class="line">    boolean temp = *lock;</span><br><span class="line">    lock = *key;</span><br><span class="line">    key = *temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="进程同步机制：信号量机制（Semaphore）"><a href="#进程同步机制：信号量机制（Semaphore）" class="headerlink" title="进程同步机制：信号量机制（Semaphore）"></a>进程同步机制：信号量机制（Semaphore）</h3><h4 id="整型信号量"><a href="#整型信号量" class="headerlink" title="整型信号量"></a>整型信号量</h4><p>基本思想：在OS中维护一个整型变量作为信号量，通过改变整型变量的值来标记临界资源是否可以访问。</p>
<p>实现细节：</p>
<ol>
<li>整型变量S只能通过wait(S), signal(S)来访问</li>
<li>S的初始值只能是1或者更大值，来标记临界资源的剩余量</li>
<li>wait、signal操作由系统原语实现，执行时不可中断</li>
</ol>
<p>关于wait、signal</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">wait</span>(S):&#123;</span><br><span class="line">    <span class="keyword">while</span>(S&lt;0);</span><br><span class="line">    S--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">signal(S):&#123;</span><br><span class="line">    S++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>整型信号量的缺点在于<strong>不满足让权等待</strong>，没有获得处理器的进程会不断执行while循环，访问信号量</p>
<h4 id="记录型信号量"><a href="#记录型信号量" class="headerlink" title="记录型信号量"></a>记录型信号量</h4><p>基本思想：使用一个整型变量value保存剩余临界资源的数量，维护一个链表L对应阻塞队列，将无法获得临界资源的进程进行阻塞，防止忙等。</p>
<p>实现细节：</p>
<ol>
<li>整型变量value，与整型信号量类似，只能用signal、wait访问（但signal、wait实现有所不同）</li>
<li>维护一个等待进程的队列</li>
</ol>
<p>关于数据结构</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">type</span> semaphore = record</span><br><span class="line">value <span class="built_in">integer</span>;</span><br><span class="line">L : list of process;</span><br><span class="line">end</span><br><span class="line">//其实落到做题上不一定要这样写</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>关于wait、siganl</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">wait</span>(S):</span><br><span class="line"></span><br><span class="line">var S:semaphore;</span><br><span class="line">begin</span><br><span class="line">    S.value := S.value-1;</span><br><span class="line">    <span class="keyword">if</span> S.value &lt; 0 <span class="keyword">then</span></span><br><span class="line">        block(S.L);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">signal(S):</span><br><span class="line"></span><br><span class="line">var S:semaphore:</span><br><span class="line">begin</span><br><span class="line">    S.value := S.value+1;</span><br><span class="line">    <span class="keyword">if</span> S.value &gt;= 0 <span class="keyword">then</span></span><br><span class="line">        wakeup(S.l);</span><br><span class="line">end</span><br><span class="line">//不需要完全背住这两个实现，但是在多个进程运行的情况下，理解它们对<span class="built_in">wait</span>、signal的调用以及执行效果，对于理解这种信号量机制的运行原理很有帮助；</span><br><span class="line">//后续同步问题会直接将它们作为一种默认的存在直接调用</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>记录型信号量的缺点是如果操作不当可能出现死锁，例如进程A、B执行均需要两个临界资源，A、B各自拿到一个，等待另一个点时候陷入阻塞且持有资源，于是A、B死锁，谁也无法继续下去。<strong>这种情况尤其容易在两个进程的wait顺序不同时发生</strong></p>
<p>注意：</p>
<ol>
<li>记录型信号量虽然有缺点，但是缺点是在不当的代码编写时发生的；不像整型信号量的硬性缺陷；所以这种方式还是比较常用的，并且我们后续各种同步问题的解决，基本上都是用这种方法</li>
<li>使用的时候要自己定义value的数据结构，但是L、wait、signal不用自己声明，它们上默认存在的</li>
</ol>
<h4 id="AND型信号量"><a href="#AND型信号量" class="headerlink" title="AND型信号量"></a>AND型信号量</h4><p>基本思想：AND型信号量是为了解决记录型信号量可能导致死锁而引入的，方法就是将所有的临界资源一次性分配给需要的进程，不允许一个进程一次持有部分临界资源，要么全有了，要么一个都没有。</p>
<p>原语操作：</p>
<ol>
<li>Sswait(s1,s2,…,sn)</li>
<li>Ssignal(s1,s2,…,sn)</li>
</ol>
<h4 id="信号量集"><a href="#信号量集" class="headerlink" title="信号量集"></a>信号量集</h4><p>提出的背景；可能产生死锁？</p>
<p>原语操作：s、t、d的含义</p>
<ol>
<li>Swait(s1,t1,d1,s2,t2,d2,…,sn,tn,dn)</li>
<li>Ssignal(s1,d1,s2,d2,…,sn,dn)</li>
</ol>
<p>注：t作为进程设置的下限，如果资源量低于该下限还给对应的进程分配，可能造成死锁，想一想提出的背景</p>
<p>几种特殊的信号量集合</p>
<ol>
<li>Swait(S,d,d)</li>
<li>Swait(S,1,1)</li>
<li>Swait(S,1,0)</li>
</ol>
<h4 id="信号量机制的应用"><a href="#信号量机制的应用" class="headerlink" title="信号量机制的应用"></a>信号量机制的应用</h4><p>进程互斥：</p>
<ol>
<li>定义信号量（这里要做初始化），通常初始化为1</li>
<li>分进程，wait与signal在同一进程中成对出现</li>
<li>将各进程对临界资源访问的代码放在wait和signal之间<br>注意：</li>
<li>缺少wait导致系统混乱</li>
<li>缺少signal导致阻塞进程无法被唤醒</li>
<li>此时信号量称为互斥信号量</li>
</ol>
<p>进程协调：</p>
<ol>
<li>定义信号量初始化，通常初始化为0</li>
<li>分进程，wait与signal在两个进程中分别出现，作为一对（先执行的完成后signal，后执行的先wait）</li>
<li>signal出现在对临界资源访问的代码之后，wait出现在对临界资源访问的代码之前<br>注意：</li>
<li>此时信号量称为同步信号量</li>
<li>应用同步信号量可以实现复杂前驱关系</li>
</ol>
<p>通常我们说到互斥信号量的时候，对应的就是进程互斥；<br>说到同步信号量的时候，就是前驱关系；</p>
<p>信号量S的含义：</p>
<ol>
<li>S&gt;0，可用资源的数量</li>
<li>S&#x3D;0，无可用资源，无等待进程</li>
<li>S&lt;0，|S|为阻塞的进程数量</li>
</ol>
<h3 id="管程机制：另一种进程同步的方法"><a href="#管程机制：另一种进程同步的方法" class="headerlink" title="管程机制：另一种进程同步的方法"></a>管程机制：另一种进程同步的方法</h3><p>基本印象&amp;与信号量机制的点：</p>
<ol>
<li>管程外面有锁，开则可以进入管程，关则进程在锁队列上等待；对应互斥信号量</li>
<li>管程使用公共变量记录资源数量；对应信号量</li>
<li>管程使用条件变量实现进程同步；对应同步信号量</li>
<li>管程的wait、signal操作只会阻塞、唤醒进程；没有类似对信号量的操作</li>
</ol>
<h2 id="L6经典的进程同步问题"><a href="#L6经典的进程同步问题" class="headerlink" title="L6经典的进程同步问题"></a>L6经典的进程同步问题</h2><p>问题入手的思路（一般情况下）：<br>    考虑存在的问题：互斥？同步？局部资源？<br>        其中局部资源可以类比到哲学家用餐问题，所有哲学家持有自己左边的筷子时；即大家都持有局部的资源而不释放造成的死锁问题；<br>    考虑设置几个信号量：<br>        互斥问题：一个互斥信号量对应一个临界资源；<br>        同步问题：一个同步信号量对应一个前驱关系；<br>    信号量如何初始化？<br>    使用什么信号量机制？<br>    是否需要更加复杂的逻辑？<br>        例如应对局部资源问题；<br>    其他必要的变量和初始化？</p>
<p>生产者消费者问题：<br>    背景：<br>        数据结构：环形缓冲区；<br>            缓冲区：buffer[0,…,n-1]；<br>            缓冲区满：counter&#x3D;n;<br>            缓冲区空：counter&#x3D;0;<br>        生产者：生产商品放置到缓冲区；<br>            放入一个商品：in &#x3D; (in+1)mod n;<br>        消费者：从缓冲区取走商品；<br>            取走一个商品：out &#x3D; (out+1)mod n;<br>    存在的问题：<br>        进程互斥：缓冲区不能同时被多个进程访问；（因为这些进程都要修改缓冲区，相当于都要写，不能同时写）<br>        进程同步：在特殊情况下存在前驱关系，即缓冲区空时，只能先生产再消费；缓冲区满时，只能先消费再生产；<br>    使用的信号量：<br>        互斥信号量：<br>            mutex，用于缓冲区的互斥访问；<br>        同步信号量：<br>            full，标识缓冲区中是否有商品，对应前驱关系：生产-&gt;消费；<br>            empty，标识缓冲区是否有空位，对应前驱关系：消费-&gt;生产；<br>    解决方案1：使用记录型信号量<br>        相关代码在最后；<br>        注意事项：<br>            1）wait(mutex)和signal(mutex)成对出现；<br>            2）wait(full)和signal(full)在消费者和生产者之间成对出现；<br>            3）wait(empty)和signal(empty)在生产者和消费者之间成对出现；<br>            4）注意mutex、empty、full的初始化；<br>            5）<strong>一种约定成俗</strong>对互斥变量的操作写在最靠近对临界资源的访问的位置；<br>    解决方案2：使用AND型信号量<br>        相关代码在最后；<br>        注意事项：<br>            1）注意Swait、Signal的使用方法</p>
<p>生产者消费者问题：记录型信号量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ini：</span></span><br><span class="line"><span class="type">int</span> mutex = <span class="number">1</span>;<span class="comment">//互斥访问缓冲区</span></span><br><span class="line"><span class="type">int</span> empty = n;<span class="comment">//可用的空位</span></span><br><span class="line"><span class="type">int</span> full = <span class="number">0</span>;<span class="comment">//可用的商品</span></span><br><span class="line"><span class="type">int</span> in,out = <span class="number">0</span>;<span class="comment">//初始指针；</span></span><br><span class="line">Array buffer[n];<span class="comment">//缓冲区0～n-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//生产者</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    wait(empty);</span><br><span class="line">    wait(mutex);</span><br><span class="line">    buffer[in] = product;</span><br><span class="line">    in = (in+<span class="number">1</span>) mod n;</span><br><span class="line">    signal(mutex);</span><br><span class="line">    signal(full);</span><br><span class="line">    <span class="keyword">if</span>(stop)<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费者</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    wait(full);</span><br><span class="line">    wait(mutex);</span><br><span class="line">    product = buffer[out];</span><br><span class="line">    out = (out+<span class="number">1</span>)mod n;</span><br><span class="line">    siganl(mutex);</span><br><span class="line">    signal(empty);</span><br><span class="line">    </span><br><span class="line">    consume(product);</span><br><span class="line">    <span class="keyword">if</span>(stop)<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>生产者消费者问题：AND型信号量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ini：</span></span><br><span class="line"><span class="type">int</span> mutex = <span class="number">1</span>;<span class="comment">//互斥访问缓冲区</span></span><br><span class="line"><span class="type">int</span> empty = n;<span class="comment">//可用的空位</span></span><br><span class="line"><span class="type">int</span> full = <span class="number">0</span>;<span class="comment">//可用的商品</span></span><br><span class="line"><span class="type">int</span> in,out = <span class="number">0</span>;<span class="comment">//初始指针；</span></span><br><span class="line">Array buffer[n];<span class="comment">//缓冲区0～n-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//生产者</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    Swait(empty,mutex);</span><br><span class="line">    buffer[in] = product;</span><br><span class="line">    in = (in+<span class="number">1</span>) mod n;</span><br><span class="line">    Ssiganl(full,mutex);</span><br><span class="line">    <span class="keyword">if</span>(stop)<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费者</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    Swait(full,mutex);</span><br><span class="line">    product = buffer[out];</span><br><span class="line">    out = (out+<span class="number">1</span>) mod n;</span><br><span class="line">    Ssignal(empty,mutex);</span><br><span class="line">    consume(product);</span><br><span class="line">    <span class="keyword">if</span>(stop)<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>哲学家进餐问题：<br>    背景：<br>        哲学家与筷子：<br>            1）5个哲学家围成一圈，进行吃饭和思考；<br>            2）相邻哲学家之间有一支筷子，一共有5支筷子；<br>            3）哲学家吃饭的时候要拿起与自己相邻的两只筷子；<br>            4）哲学家吃饭和思考交替进行；<br>    存在的问题：<br>        1）进程互斥：筷子是公共资源，不能同时访问；<br>        2）局部资源：只有一支筷子不能进餐，需要避免所有人都获得部分资源而不释放，造成死锁的情况；<br>    使用的信号量：<br>        1）互斥信号量：<br>            chpsitck[i]，对应第i支筷子的互斥信号量<br>    解决方案1：<br>        记录型信号量，至多4位哲学家拿起左边的筷子；<br>        需要额外使用的信号量：<br>            互斥信号量：conut，左边的筷子最多同时被四个进程访问；<br>            （相当于抽象了一个资源数量为4的临界资源，这个操作的逻辑要互斥锁来实现）；<br>    解决方案2：<br>        AND型信号量；<br>    解决方案3：<br>        记录型信号量，区分奇偶编号，奇数哲学家先拿左边的筷子，偶数哲学家先拿右边的筷子；<br>    注意事项：<br>        1）访问左边筷子与右边筷子的下标（i与i+1）；<br>        2）一定要拿到左右筷子之后才能吃饭；</p>
<p>解决方案1:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ini</span></span><br><span class="line"><span class="type">int</span> count = <span class="number">4</span>;</span><br><span class="line"><span class="type">int</span> chopstick[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="comment">//第i个哲学家</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    wait(count);</span><br><span class="line">    wait(chopstick[i]);<span class="comment">//左边的筷子;</span></span><br><span class="line">    wait(chopstick[i+<span class="number">1</span>]);<span class="comment">//右边的筷子</span></span><br><span class="line">    eat();</span><br><span class="line">    signal(chopstick[i+<span class="number">1</span>]);</span><br><span class="line">    signal(chopstick[i]);</span><br><span class="line">    signal(chop)</span><br><span class="line">    siganl(count);</span><br><span class="line">    think();</span><br><span class="line">    <span class="keyword">if</span>(stop)<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决方案2:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ini</span></span><br><span class="line"><span class="type">int</span> chopstick[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="comment">//第i个哲学家</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    Swait(chopstick[i],chopstick[i+<span class="number">1</span>]);</span><br><span class="line">    eat();</span><br><span class="line">    Ssignal(chopstick[i],chopstick[i+<span class="number">1</span>]);</span><br><span class="line">    think();</span><br><span class="line">    <span class="keyword">if</span>(stop)<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决方案3:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ini</span></span><br><span class="line"><span class="type">int</span> chopstick[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(i mod <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">        wait(chopstick[i+<span class="number">1</span>]);</span><br><span class="line">        wait(chopstick[i]);</span><br><span class="line">        eat();</span><br><span class="line">        signal(chopstick[i]);</span><br><span class="line">        signal(chopstick[i+<span class="number">1</span>]);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        wait(chopstick[i]);</span><br><span class="line">        wait(chopstick[i+<span class="number">1</span>]);</span><br><span class="line">        eat();</span><br><span class="line">        signal(chopstick[i+<span class="number">1</span>]);</span><br><span class="line">        signal(chopstick[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    think();</span><br><span class="line">    <span class="keyword">if</span>(stop)<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>读者写者问题：<br>    问题背景：<br>        1）读者进程，可以读取数据文件；<br>        2）写者进程，可以写入数据文件；<br>    存在问题：<br>        1）多个读者进程可以同时访问；<br>        2）只要有一个写者进程访问，其他读者进程、写者进程就不能访问；<br>    解决方案1:<br>        1）维护一个写锁write；<br>        2）写进程获取write的时候其他进程都只能等待；<br>        3）读进程获取到write的时候，其他读进程可以访问临界区，写进程需要等待；<br>            1）维护读者计数器reader_count，表示当前在读进程；<br>            2）只需要检查reader_count的情况就可以判断当前是否有读进程在工作；<br>            3）如果有读进程在工作，其他读进程可以直接访问临界区；<br>            4）对于reader_count作为公共资源，也需要一个锁来控制；<br>            （注意reader_count的维护，意味着对于读者进程来说，第一个开始读的进程要负责获取到write，最后一个读完的进程要负责释放write）<br>        存在的问题：<br>            1）读者优先；<br>            2）可以看作读者和写者都在一个队列上；<br>            3）但是只要前面有读者，那么新来的读者就会插队到写者的前面；<br>    解决方案2：<br>        1）在解决方案1的基础上维护一个排队排队信号量prior，放在开始；<br>        2）无论读者写者，获得这个信号量才能往下执行；<br>        3）这样在写者持有prior的时候读者就不能直接增加reader_count，导致“插队”了；<br>        存在的问题：<br>            1）读写平等；<br>            2）大多数情况下写意味着更高的权限，所以应该是写者优先，而不应该是平等；<br>    解决方案3:<br>        1）在解决方案2的基础上维护一个写者计数writer_count；<br>        2）如果有写者获得了prior的排队权，那么后面的写者可以直接排队；<br>        3）第一个写者等待prior，最后一个写者释放prior；<br>        4）读者必须要等待到prior才能开始排队；</p>
<p>解决方案1:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ini:</span></span><br><span class="line"><span class="type">int</span> mutex = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> reader_count = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> write = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//reader:</span></span><br><span class="line"><span class="comment">//我写的这种似乎有点问题，因为要访问reader_count的值都应该在获取到mutex之后；</span></span><br><span class="line"><span class="comment">//就好像没有拿到锁就直接读取了文件数据</span></span><br><span class="line"><span class="comment">// while(1)&#123;</span></span><br><span class="line"><span class="comment">//     if(reader_count &gt; 0)&#123;</span></span><br><span class="line"><span class="comment">//         wait(mutex);</span></span><br><span class="line"><span class="comment">//         reader_count++;</span></span><br><span class="line"><span class="comment">//         signal(mutex);</span></span><br><span class="line"><span class="comment">//         read_file();</span></span><br><span class="line"><span class="comment">//         wait(mutex);</span></span><br><span class="line"><span class="comment">//         reader_count--;</span></span><br><span class="line"><span class="comment">//         signal(mutex);</span></span><br><span class="line"><span class="comment">//     &#125;else&#123;</span></span><br><span class="line"><span class="comment">//         wait(write);</span></span><br><span class="line"><span class="comment">//         wait(mutex);</span></span><br><span class="line"><span class="comment">//         reader_count++;</span></span><br><span class="line"><span class="comment">//         signal(mutex);</span></span><br><span class="line"><span class="comment">//         read_file();</span></span><br><span class="line"><span class="comment">//         wait(mutex);</span></span><br><span class="line"><span class="comment">//         readr_count--;</span></span><br><span class="line"><span class="comment">//         signal(mutex);</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//     if(readr_count==0)</span></span><br><span class="line"><span class="comment">//         signal(write);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//reader:（教材上的写法）</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    wait(mutex);</span><br><span class="line">    <span class="keyword">if</span>(reader_count == <span class="number">0</span>)</span><br><span class="line">        wait(write);</span><br><span class="line">    reader_count++;</span><br><span class="line">    signal(mutex);</span><br><span class="line">    read_file();</span><br><span class="line">    wait(mutex);</span><br><span class="line">    reader_count--;</span><br><span class="line">    <span class="keyword">if</span>(reader_count == <span class="number">0</span>)</span><br><span class="line">        signal(write);</span><br><span class="line">    signal(mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//writer:</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    wait(write);</span><br><span class="line">    write_file();</span><br><span class="line">    signal(write);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决方案2:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ini:</span></span><br><span class="line"><span class="type">int</span> reader_count = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> write = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> mutex = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> prior = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//reader:</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    wait(prior);</span><br><span class="line">    wait(mutex);</span><br><span class="line">    <span class="keyword">if</span>(reader_count == <span class="number">0</span>)</span><br><span class="line">        wait(write);</span><br><span class="line">    reader_count++;</span><br><span class="line">    signal(mutex);</span><br><span class="line">    signal(prior);</span><br><span class="line"></span><br><span class="line">    read_file();</span><br><span class="line">    wait(mutex);</span><br><span class="line">    reader_count--;</span><br><span class="line">    <span class="keyword">if</span>(reader_count == <span class="number">0</span>)</span><br><span class="line">        signal(write);</span><br><span class="line">    signal(mutex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//writer:</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    wait(prior);</span><br><span class="line">    wait(write);</span><br><span class="line">    write_file();</span><br><span class="line">    signal(write);</span><br><span class="line">    signal(prior);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//prior释放的位置应该比较随意，只要确保，wait(prior)和signal(prior)将wait(write)和reader_count++包裹了就好；</span></span><br><span class="line"><span class="comment">//wait(write)理解为排队，那么prior就是来防止插队的，reade_count++就是在插队，所以要将其获取给包裹起来；</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>解决方案3</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ini:</span></span><br><span class="line"><span class="type">int</span> reader_count = <span class="number">0</span>,writer_count = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> reader_mutex = <span class="number">1</span>,writer_mutex = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> prior = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> writer = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//reader:</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    wait(prior);</span><br><span class="line">    wait(reader_mutex);</span><br><span class="line">    <span class="keyword">if</span>(reader_count == <span class="number">0</span>)</span><br><span class="line">        wait(write);</span><br><span class="line">    reader_count++;</span><br><span class="line">    signal(reader_mutex);</span><br><span class="line">    read_file();</span><br><span class="line">    signal(prior);</span><br><span class="line">    wait(read_mutex);</span><br><span class="line">    reader_count--l</span><br><span class="line">    <span class="title function_">if</span><span class="params">(reader_count == <span class="number">0</span>)</span></span><br><span class="line">        <span class="title function_">signal</span><span class="params">(write)</span>;</span><br><span class="line">    signal(read_mutex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//writer:</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    wait(writer_mutex);</span><br><span class="line">    <span class="keyword">if</span>(writer_count == <span class="number">0</span>)</span><br><span class="line">    <span class="comment">//&#123;</span></span><br><span class="line">        wait(prior);</span><br><span class="line">        <span class="comment">//wait(write);</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    writer_count++;</span><br><span class="line">    signal(writer_mutex);</span><br><span class="line">    wait(write);<span class="comment">//注意writer优先获取的只是排队权；注释掉的逻辑其实是一个写者有了write，其他也可以写，这显然错误；</span></span><br><span class="line">    write_file();</span><br><span class="line">    signal(write);</span><br><span class="line">    wait(writer_mutex);</span><br><span class="line">    write_count--;</span><br><span class="line">    <span class="keyword">if</span>(write_count == <span class="number">0</span>)</span><br><span class="line">        signal(prior);</span><br><span class="line">    signal(wirter_mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><h3 id="进程通信的类型"><a href="#进程通信的类型" class="headerlink" title="进程通信的类型"></a>进程通信的类型</h3><p>进程通信的含义：<br>    <strong>高效大量且方便（透明）</strong>的进程之间消息交换；<br>    eg：<br>        进程同步（可以看作一种低级的信号机制，信号量机制就是一种简单的消息，并且<strong>不透明</strong>，用户感知得到，并且需要用户操作；并发时手动上锁belike）</p>
<p>进程通信的类型：<br>    共享存储器系统：<br>        1）基于共享数据结构的通信方式；<br>        （低效、适合少量数据传输，程序员手动管理）<br>        2）基于共享存储区的通信方式；<br>        （高级，进程通过对存储区数据的读写来进行通信）<br>    管道系统：<br>        首创于UNIX，一切皆文件的思想；<br>        管道：<br>            一个共享文件（pipe文件），用来连接一个发送进程和一个接收进程，实现通信；<br>        管道的性质：<br>            1）互斥，一个进程读写管道，其他进程必须等待；<br>            2）同步，发送进程，写入一定数量后就会阻塞自己，接收进程接收后再唤醒；接收进程遇到空管道会阻塞，等待有内容后再唤醒；<br>            3）可靠性，双方都确认对方存在再通信；<br>        （管道的性质机制由管道自己控制，不由通信双方控制，满足透明性）<br>        消息传递系统：<br>            进程不借助任何共享存储区或数据结构，使用message格式数据进行交换，由OS提供通信命令；<br>            方式：<br>                1）直接通信方式：直接消息传递系统；<br>                    方法：OS提供相关原语；<br>                        1）Send(Receiver,message);<br>                        2）Receive(Sender,message);<br>                2）间接通信方式：信箱通信；<br>                    方法：通过共享数据结构——信箱，用消息暂存的方式实现通信；<br>                        1）信箱创建、撤销；<br>                        2）发送原语：send(receiver,a);&#x2F;&#x2F;a是发送区地址；<br>                        3）接收原语：receive(b);&#x2F;&#x2F;b是接收区地址</p>
<h3 id="线程的基本概念和实现方式"><a href="#线程的基本概念和实现方式" class="headerlink" title="线程的基本概念和实现方式"></a>线程的基本概念和实现方式</h3><p>引入线程的原因：<br>    使用进程效率太低了：<br>        1）进程独立拥有资源，创建消亡的时候需要分配和回收进程；<br>        2）进程切换需要CPU保存状态代价巨大；<br>    如果不独立分配资源呢？<br>        共享资源依赖于进程通信，依然很复杂，就像我们上一节讨论的一样；</p>
<p>线程：<br>    <strong>线程 &#x3D; 进程-共享资源</strong>；<br>    线程的特性：<br>        1）实体之间并发地执行；<br>        2）实体之间共享相同的地址空间；<br>    与进程的关系：<br>        1）资源与调度；<br>            1）引入线程后，进程最主要的作用是将一组相关的资源组合起来，形成资源平台（代码段、数据段、打开文件的操作），线程就是进程中真正执行的流程；<br>            2）所以，<strong>资源分配&#x2F;调度 的基本单位：进程&#x2F;线程</strong><br>            3）但是线程还是必须持有必不可少的，保证独立运行的资源；<br>                eg：TCB（线程控制模块）、PC、保留局部变量、状态参数以及返回地址的一组寄存器和堆栈；<br>                （这些就像进程在堆栈中动态分配时所需要的，只是免去了大量的静态资源）；<br>        2）并发性：<br>            1）支持多线程的OS中，同一进程不同线程可以并发；<br>            2）多CPU系统中，单进程多线程可以多核并发；<br>        3）独立性：<br>            1）进程和进程之间独立；<br>            2）线程和线程之间不独立；<br>        4）系统开销：<br>            1）进程切换开销大，线程切换开销小；<br>            2）进程通信开销大，同一进程不同线程通信开销小。<br>        5）安全性：<br>            1）只使用进程更安全，在使用线程的时候一个线程崩溃，会导致整个进程崩溃；<br>        6）高效性：<br>            1）使用线程更加高效，可以减少并发执行的时间和空间；<br>            （线程的并发可以在很多情况下代替从前需要进程并发执行的工作）<br>            eg：<br>                MP3播放软件，三个核心模块（从MP3中读取数据、解压数据、将解压后的数据转换为音频数据播放）</p>
<p>线程的状态：<br>    三个基本状态：执行、就绪、阻塞；<br>    TCB：线程控制模块</p>
<p>操作系统角度看线程：<br>    等价概念：<br>        1）传统的进程——单线程方法；<br>        eg：传统的UNIX；<br>        2）每个进程支持多个线程——多线程方法；<br>        eg：Windows2000<br>    如何看待进程：<br>        进程是拥有资源的基本单位，是一个不可执行的实体，进程的状态是线程执行的状态；</p>
<p>线程的实现方式：<br>    1）内核支持线程KST；<br>        内核完成线程的管理；<br>    2）用户级线程ULT；<br>        一组用户级的线程库函数，帮助用户自己管理线程的管理；<br>    3）组合方式ULT&#x2F;KST；</p>
<h2 id="处理机调度"><a href="#处理机调度" class="headerlink" title="处理机调度"></a>处理机调度</h2><h3 id="处理机调度的层次和调度算法的目标"><a href="#处理机调度的层次和调度算法的目标" class="headerlink" title="处理机调度的层次和调度算法的目标"></a>处理机调度的层次和调度算法的目标</h3><p>处理机调度：<br>    含义：采用一定的算法从就绪队列中，选择一个作业&#x2F;进程，让CPU执行它；<br>    （本质就是面对大量作业&#x2F;进程，如何将有限的CPU合理地分配给它们使用）<br>    层次：<br>        1）高级调度<br>            别名：作业调度、长程调度；<br>            调度对象：作业；<br>            适用的操作系统：多道批处理系统；（单道、分时中没有）；<br>            发生的时机：在一批作业已运行完毕退出，需要将一批新的作业调入<strong>内存</strong>的时候；<br>            特点：<strong>运行频率较低、允许较复杂；</strong><br>        2）中级调度<br>            别名：内存调度（挂起和激活，对应存储器管理那一块）；<br>            调度对象：进程；<br>            发生的时机：<br>                1）内存紧张的时候，将暂时不能运行的进程调至外存；<br>                2）内存空闲的时候，将具备运行条件的进程重新调入内存；<br>            特点：运行频率适中，算法复杂度适中；<br>        3）低级调度<br>            别名：进程调度、短程调度；<br>            调度对象：进程（内核级线程）；<br>            使用操作系统：多道批处理、单道、分时都有；<br>            发生的时机：决定<strong>就绪队列中</strong>哪个进程获得<strong>处理机</strong>；<br>            特点：<strong>运行频率非常高，不允许很复杂；</strong><br>        从进程调状态看调度层次：<br>            <img src="/OS/p1.png" alt="处理机调度层次"><br>    目标：<br>        批处理系统：<br>            平均周转时间短、系统吞吐量高、处理机利用率高；<br>                相关概念：<br>                    周转时间：<br>                        1）作业提交给OS的时间到作业完成的时间；<br>                        2）作业在后备队列的时间+作业在就绪队列的等待时间+作业在阻塞队列的等待时间+作业的执行时间；<br>                    平均周转时间：<br>                        1）周转时间按照作业数量平均；<br>                    带权周转时间：<br>                        1）针对一个作业；<br>                        2）作业周转时间&#x2F;作业获得CPU的时间（执行时间）；<br>                    平均带权周转时间：<br>                        带权周转时间按照作业数量平均；<br>                    系统吞吐量：<br>                        单位时间内系统完成的作业数；<br>        分时系统：<br>            响应时间快、均衡性好；<br>                注意：<br>                    均衡性对应根据任务的复杂度不同，等待的容忍度不同；<br>                        1）复杂任务允许等待时间长；<br>                        2）简单任务允许等待时间短；<br>                （买15个煎饼果子的人愿意等买1个多，反之不然）；<br>        实时系统：<br>            截止时间的保证、可预测性；<br>        共同目标：<br>            1）资源利用率：CPU利用率 &#x3D; CPU有效工作时间&#x2F;(CPU有效工作时间+CPU空闲等待时间)<br>                （计算量大的作业越多，即长作业越多，上下文切换的工作量会减少，CPU利用率越高）<br>            2）公平性：每个进程都应该获得合理的CPU时间，不会发生进程饥饿现象；<br>            3）平衡性：CPU和I&#x2F;O设备都能经常处于忙碌状态，系统资源使用平衡；<br>            4）策略强制执行；</p>
<h3 id="作业与作业调度"><a href="#作业与作业调度" class="headerlink" title="作业与作业调度"></a>作业与作业调度</h3><p>作业：<br>    定义：<strong>程序+数据+作业说明书</strong>；<br>        1）作业是从外存调入内存的基本单位；<br>        2）调入之前称为作业，调入之后就是进程；<br>    作业步：<br>        编译-链接装配-运行；<br>        （调入之前必要的步骤）<br>    作业控制块：JCB；<br>    作业多三个阶段和三种状态：<br>        1）收容阶段：<br>            1）对应后备状态；<br>            2）系统把用户提交的作业放入硬盘，建立JCB，放入后备队列；<br>        2）运行阶段：<br>            1）对应运行状态；<br>            2）作业被选中，为其分配资源，<strong>建立进程</strong>，进入就绪队列；<br>            3）从第一次进入就绪队列到运行完毕，都属于运行阶段（状态）；<br>        3）完成阶段：<br>            1）对应完成状态；<br>            2）系统回收资源和JCB；<br>            3）作业结果形成输出文件后输出；</p>
<p>作业调度：<br>    挑战：作业数量多少的平衡；<br>        1）如果数量少，并行（发？）效率低，CPU利用率低；<br>        2）如果数量多，中断多，上下午切换频繁，CPU利用率低；<br>    相关算法：<br>        1）FCFS先来先服务算法<br>            思想：谁先来，先服务；<br>            特点：有利于长作业，不利于短作业；长作业愿意等短作业，反之不然；<br>            相关计算：<br>                1）到达时间（给定）；<br>                2）服务时间（给定）；<br>                3）开始执行时间（上一个进程的的完成时间）；<br>                4）完成时间（开始执行时间+服务时间）；<br>                5）周转时间（完成时间-到达时间）；<br>                6）带权周转时间（周转时间&#x2F;服务时间）；<br>            eg：<br>                <img src="/OS/p2.png" alt="FCFS例题">；<br>        2）SJF短作业优先算法<br>            思想：作业越短优先级越高；<br>            特点：利于短作业，长作业可能会出现饥饿现象；<br>        3）PSA优先级调度算法<br>            思想：基于作业等紧迫程度，外部赋予作业优先级；<br>            类型：静态优先级、动态优先级；<br>            动态优先级算法：<br>                高响应比优先算法(HRRN)：<br>                    <strong>优先权 &#x3D; (等待时间+要求服务时间)&#x2F;要求服务时间;</strong><br>                特点：<br>                    1）等待时间相同，要求服务时间越短优先权越高，有利于短作业；<br>                    2）要求服务时间相同，长作业随着等待时间越长，优先权增大，不会让其出现饥饿现象；</p>
<h3 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h3><p>进程调度实现的关键机制：<br>    1）排队器：<br>        1）按照策略将进程分为一个或多个队列；<br>        2）排出就绪队列；<br>    2）分派器：<br>        1）按照策略从队列中选出特定的进程；<br>        2）是从就绪队列中选；<br>    3）上下文切换：<br>        1）切换的时候不只要保存执行的进程还要保存分派器的进程；<br>        2）主要是对PCB与相关寄存器的操作；</p>
<p>进程调度的方式：<br>    1）非抢占式调度；<br>        一旦CPU分配个某个进程，就一直运行它；<br>        发生调度的原因：<br>            1）进程执行完毕；<br>            2）I&#x2F;O请求；<br>            3）wait、block、wakeup等系统调用；<br>            4）其他不能继续执行的原因；<br>    2）抢占式调度：<br>        按照某种原则暂停当前进程，执行另一个；<br>        常见抢占原则：<br>            1）优先权；<br>            2）短进程抢占长进程；<br>            3）时间片原则；<br>        抢占的实现机制：<strong>中断</strong></p>
<p>进程调度算法：<br>    1）轮转调度算法：<br>        1）系统将就绪进程按先来先服务排成队列；<br>        2）每次调度将CPU按一个时间片分给队首进程；<br>        3）时间片完成，中断，更新队列（队首到队尾）<br>        4）重复上述步骤；<br>        注意：<br>            1）时间片大小选择很重要，过短有利于短作业但是上下文切换频繁，过长有利于长作业但是退化为FCFS；<br>            2）TIP：选择略大于一次典型交互所需的时间为时间片大小；<br>        <strong>计算：</strong><br>            1）RR Q时间片大小；<br>            2）其他关键量化值与作业调度中FCFS一样；<br>            3）计算的时候要注意时间片的切换；<br>            eg：<img src="/OS/p3.png" alt="轮转调度算法">；<br>    2）优先级调度算法：<br>        1）静态；<br>        2）动态；<br>        注意：都不常用，因为进程调度追求简单；<br>    3）多级反馈队列调度算法：<br>        1）设置多个就绪队列（按优先级划分），<strong>优先级越高（队列序号小），获得时间片越小，反之越大</strong>；<br>        2）新进程进入系统后，放入第一个队列，按FCFS原则等待；<br>        3）进程在第i个队列的时间片执行完成，就放入i+1队列的队尾；<br>        4）当前面的队列为空的时候，从后面的队列进行调度（可以抢占式）；<br>        特点：<br>            1）性能较好；<br>            2）能满足各类用户需求，短进程在一两个时间片完成，长进程不用担心长期得不到处理；<br>    4）基于公平原则的调度算法<br>        1）保证调度算法：<br>            思想：系统中有n个进程，保证每个进程都获得处理机时间的1&#x2F;n；<br>            算法：<br>                1）计算每个进程自创建以来应该获得处理机的时间：<br>                    应获得处理机时间 &#x3D; 创建以来时间&#x2F;n；<br>                2）计算实际执行时间和应获得时间的比率：<br>                    实际执行时间&#x2F;应获得时间；<br>                3）选择比率值最小的调度获得时间片；<br>            注意：<br>                1）应获得处理机时间的n，要分段考虑，因为进程进入的时间不同，在前面的时间段不会考虑后面时间段才出现的进程；<br>                2）根据比率情况，可能有多个最小比率相等的，对应有多个应该最优先调度的进程。（这时实际的处理是随机选择一个）<br>            计算：<br>                <strong>哪个进程是当前应该优先调度的</strong>；<br>                eg：<img src="/OS/p4.png" alt="保证调度算法"><br>            缺点：<br>                在每个用户拥有进程数不同的时候，按照保证调度的方法分配，对用户不公平；<br>        2）公平分享调度算法：<br>            思想：分别按照顺序，依次对不同用户的进程按照保证调度算法进行调度；<br>            eg：<br>                用户1有ABCD四个进程，用户2有E；<br>                则：A E B E C E D E调度；<br>            注意：<br>                当然根据一些具体的情况，可以设置轮到一个用户的时候允许调度的次数；<br>                eg：<br>                    用户1付了两倍的钱；<br>                    则A B E C D E调度；</p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="死锁的基本概念"><a href="#死锁的基本概念" class="headerlink" title="死锁的基本概念"></a>死锁的基本概念</h3><p>死锁：<br>    含义：多个进程在运行过程中，因争夺资源而造成的一种僵局。当进程处于这种僵持状态时，如果没有外力作用，它们都无法再向前推进；<br>    死锁的例子：<br>        1）竞争不可抢占资源引起死锁；（P1持有R1，需要R2，P2持有R2，需要R1）<br>        2）竞争可消耗资源引起死锁；（P1消耗S1来制造S2，P2要消耗S2才能制造S1）<br>        3）不合理的有限资源分配引起死锁；<br>            <img src="/OS/p5.png" alt="资源分配图1"><br>            <img src="/OS/p6.png" alt="资源分配图2"></p>
<p>造成死锁的原因：<br>    四大必要条件：只有同时满足时，才会死锁；<br>        1）互斥条件：<br>            进程使用某资源的时候，不允许其他进程使用；<br>        2）请求和保持：请求保持了一个自己获得的资源，请求另一个资源的时候，无法获得，不释放自己的资源便进行阻塞；<br>        3）不剥夺条件：资源使用完之前，不允许剥夺，直至用完；<br>        4）环路等待条件（循环等待）：发生死锁，一定会有“进程-资源”的环形链；</p>
<p>处理死锁的方法：<br>    四种类型：对应的是不同的处理方法；<br>    1）预防死锁：<br>        设置限制条件，破坏四个条件中的一个或几个；<br>        问题：限制条件比较严格，会影响效率；<br>        eg：哲学家用餐问题，通过一定的规则确保一定不会出现死锁；<br>    2）避免死锁：<br>        按照一定条件动态分配资源时，防止系统推进过程中进入不安全状态；<br>        问题：实现较难；<br>        eg：银行家算法，天才的Dijkstra～<br>    3）检测死锁：<br>        不用任何限制条件，不检查系统是否进入安全区。允许死锁发生，使用机制及时检测；<br>    4）解除死锁：<br>        撤销或挂起一些进程，以便回收资源，再将其重新分配给陷入死锁的进程；<br>    （其中3、4一般是一起使用的）；</p>
<h3 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h3><p>依次考虑破坏四个必要条件：<br>    1）互斥条件：<br>        <strong>不可破坏</strong>：因为资源的互斥是非共享设备必须的属性，是OS的重点保护对象，所以不可破坏；<br>        （无法让一个打印机同时打印两份资料）<br>    2）请求和保持条件：<br>        1）协议一：运行前，必须一次性获得整个运行过程的所有资源；<br>            1）如果获得了，不再申请，破坏请求条件；<br>            2）只要一种不能获得，其他也不允许分配，破坏保持条件；<br>            问题：<strong>浪费资源，进程饥饿</strong>；<br>        2）协议二：进程获得初期的资源后开始运行，必须释放全部资源后才能申请新的；（这种比较难实现）<br>    3）不可抢占性：<br>        1）当已经保持的某些不可抢占资源时，如果请求的新资源不能满足，则必须释放自己的不可抢占资源；<br>        问题：<br>            1）实现机制复杂，代价极大；<br>            2）有些不可抢占资源如果前段实效，后面的工作是无法继续的；<br>            （比如打印机，你不能要求它只打印一半）；<br>    4）环路等待条件（循环等待）<br>        1）对系统中的所有资源进行线性排序，对每个资源赋予唯一的一个序号，每个进程必须按照资源递增的顺序进行资源的获取；<br>        问题：<br>            1）如果系统有新增资源，排序无法稳定；<br>            2）资源的使用顺序和系统排序有出入时造成资源的浪费（没有意义的申请）；<br>            3）对用户不透明，破坏了虚拟化和共享，用户需要了解到资源编号才能正确编程；<br>    问题：<br>        <strong>总的来说，预防死锁添加的限制比较多，代价比较大</strong>；</p>
<h3 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h3><p>基本概念：<br>    避免死锁含义：按照一定条件动态分配资源，防止系统推进过程中进入不安全的状态；<br>    避免死锁实质：避免安全状态向不安全状态的转换；<br>    安全序列：<br>        系统能按某种进程的顺序，为各个进程分配所需的资源，分配时满足每个进程对资源的最大需求，最终每个进程都可以顺利完成。这这组进程顺序就是一个<strong>安全序列</strong>。<br>    系统安全状态：<br>        如果系统能够找到一个安全序列，则系统处于安全状态，否则系统处于不安全状态；<br>        （<strong>当我们考虑一个时刻系统是否安全的时候，实际上是考虑是否能够找到一个安全序列</strong>）</p>
<p>避免死锁的算法：银行家算法<br>    思想：<br>        用户申请一组资源的时候，系统首先判断如果把这些资源分配出去，系统是否处于安全状态。如果是则可以分配，如果不是则申请暂时不予满足；<br>    使用的数据结构：<br>        1）可用资源向量Available[1…m]：<br>            1）初始值是第1～m个资源的全部数量；<br>            2）系统运行过程中保存的是当前可用的数量；<br>        2）最大需求矩阵Max[1…n,1…m]<br>            1）Max[i,j]代表第i个进程对于第j个资源的<strong>最大</strong>需求量；<br>        3）已分配矩阵Allocation[1…n,1…m]<br>            1）Allocation[i,j]代表第i个进程对于第j个资源已经获得的数量；<br>            2）Allocation也可以称作Work<br>        4）需求矩阵Need[1…n,1…m]<br>            1）Need[i,j]代表第i个进程对于第j个资源还需要多少个；<br>        显然，根据定义上述数据满足：<br>            $Max[i,j] &#x3D; Allocation[i,j]+Need[i,j]$<br>    算法步骤：<br>        1）进程申请资源：<br>            进程i使用Request[j]向系统申请资源j<br>        2）合理性检查：<br>            系统检查Request[j]是否小于等于Need[i,j]，如果是则分配；否则认为进程申请了不必要的资源，拒绝；<br>        3）资源存量检查：<br>            系统检查Request[j]是否小于等于Allocation[j]，如果是则予以分配；否则系统认为资源存量不足以分配，进程必须等待；<br>        4）虚拟分配：<br>            将资源分配给该进程，更新数据结构：Available、Allocation、Need；<br>        5）安全性算法：<br>            检查此次资源分配后，系统是否处于安全状态。如果安全则<strong>真正分配</strong>，如果不安全则不予分配，进程必须等待；<br>    安全性算法：<br>        1）可以在任何时刻，根据Allocation(Work)、Need、Available、Max执行安全性算法，判断系统在当前时刻是否安全；<br>        2）<strong>主要是掌握表格的结构，有多种可用的表格结构，在最后展示一种我常用的；</strong><br>        3）注意有时候Need需要根据Max和Allocation进行推导，<strong>Max一般不用于表格中</strong>；<br>        4）Allocation+Available是比较特别但是必要的，代表该进程结束后，系统的可用资源情况，可以看作一个过渡的中间变量，其会作为考虑下一个进程时的Available；<br>        5）按照安全序列的定义，在寻找安全序列的时候有一定顺序，但是实际考察<strong>通常使用顺序执行</strong>；</p>
<p>银行家算法-安全性算法表格结构：</p>
<table>
<thead>
<tr>
<th>进程 \ 资源</th>
<th>Available(Work)</th>
<th>Need</th>
<th>Allocation</th>
<th>Available+Allocation</th>
</tr>
</thead>
<tbody><tr>
<td>P1</td>
<td>(1,2,3)</td>
<td>(0,0,1)</td>
<td>(1,1,1)</td>
<td>….</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>….</td>
</tr>
</tbody></table>
<h3 id="死锁的检测与解除"><a href="#死锁的检测与解除" class="headerlink" title="死锁的检测与解除"></a>死锁的检测与解除</h3><p>资源分配图（RAG）：用于检测死锁的工具；<br>    定义：RAG是一个有向图，其中的点集合V对应的是进程集合，边集合E对应的是资源集合；<br>    边点类型：<br>        1）分配边缘：由资源指向进程；<br>        2）请求边缘：由进程指向资源；<br>        （注意都是有向边）；<br>    具体表示：<br>        1）进程点，通常使用<strong>圆形</strong>；<br>        2）资源点，通常使用<strong>矩形</strong>，矩形中有点，点的数量代表<strong>资源的数量</strong>；<br>        3）分配边缘，由资源的<strong>点</strong>，指向具体的进程；<br>        4）请求边缘，由进程指向代表资源的<strong>矩形</strong>；</p>
<p>死锁检测：<br>    通过资源分配的化简，如果能化简则不存在死锁，如果不能化简则存在死锁；<br>    化简方法：<br>        1）在资源分配图中找到，一个仅持有资源，不请求资源点非孤立进程点；该进程持有所有必须的资源，可以正常执行，释放它持有的资源，将它变成孤立点；<br>        2）进行资源分配，将1）中释放的资源也纳入考虑，考虑当前剩余资源的数量，考虑分配给可以满足的进程；得到必须资源的进程，可以正常执行，释放它持有的资源，将它变成孤立点；<br>        3）重复1）、2），直到所有点都变成孤立点，则化简成功过；否则化简失败；<br>    应用：<br>        主要是合理地将进程和资源进行抽象，然后对对应到资源分配图的情况，考虑是否可以化简；<br>        eg：<img src="/OS/p7.png" alt="资源分配图的应用">；</p>
<p>死锁解除算法：<br>    思想：按照某种顺序，逐个终止进程，知道拥有足够的资源，打破循环等待，将系统从死锁状态解除；<br>    问题：终止所有死锁进程代价巨大；<br>    选择终止进程的原则：<br>        1）进程优先级；<br>        2）进程已经执行的时间；<br>        3）进程已使用的资源和未来要使用的资源；<br>        4）进程是交互式还是批处理式；</p>
<h2 id="存储器管理-1"><a href="#存储器管理-1" class="headerlink" title="存储器管理"></a>存储器管理</h2><p><code>从这里开始，只记录相应节的知识点名称，不详细记录</code></p>
<h3 id="存储器的层次结构"><a href="#存储器的层次结构" class="headerlink" title="存储器的层次结构"></a>存储器的层次结构</h3><p>内存和外存的区别：<br>1）易失？<br>2）容量<br>3）速度<br>4）CPU操作方式</p>
<p>存储器层次结构：<br>1）6个层次<br>2）三种类别<br>3）所在位置</p>
<p>高速缓存的作用？<br>磁盘缓存的作用？真实存在？</p>
<p>SRAM和DRAM的区别</p>
<h3 id="程序的装入和链接"><a href="#程序的装入和链接" class="headerlink" title="程序的装入和链接"></a>程序的装入和链接</h3><p>源程序运行需要经过的步骤？</p>
<p>什么是装入？</p>
<p>三种装入方式：<br>1）绝对装入（含义）<br>2）可重定位装入（含义，运行时地址不变）<br>3）动态运行时的装入（含义，重定位寄存器作用）</p>
<p>什么是链接？</p>
<p>三种链接方式：<br>1）静态链接（含义，缺点）<br>2）装入时动态链接（含义，优点，缺点）<br>3）运行时动态链接（含义，优点）</p>
<h3 id="连续分配存储管理方式"><a href="#连续分配存储管理方式" class="headerlink" title="连续分配存储管理方式"></a>连续分配存储管理方式</h3><p>什么是连续分配？</p>
<p>四种连续分配存储的方式：<br>1）单一连续分配（内存情况，缺点）<br>2）固定分区分配（分区相等、分区不等；内存情况，缺点）<br>3）动态分区分配（空闲分区表 or 链；<br>    首次适应算法：内存情况，最小不可分区域，优点，缺点<br>    循环首次适应算法：内存情况，查找指针，优点，缺点<br>    最佳适应算法：内存情况，分后排序<br>    最坏适应算法：内存情况，分后排序；<br>    回收合并（4种相邻情况）<br>    伙伴系统（判断前一块 or 后一块）<br>4）动态可重定位分区分配（与动态分区分配的区别）</p>
<h3 id="对换"><a href="#对换" class="headerlink" title="对换"></a>对换</h3><p>对换的含义</p>
<p>两种对换方式：<br>1）整体对换（含义）<br>2）部分对换（含义）</p>
<p>文件区与对换区：作用、区别</p>
<h3 id="分页存储管理方式"><a href="#分页存储管理方式" class="headerlink" title="分页存储管理方式"></a>分页存储管理方式</h3><p>进程逻辑地址空间、内存物理地址空间，分页（块）处理<br>（页大小与块大小一致，通常前者划分称页、后者划分称块）</p>
<p>页内碎片</p>
<p>页面小～大，优点、缺点</p>
<p>地址结构：页号、位移量；计算</p>
<p>页表：内容？给谁建立？建立的时机？保存的位置？用什么找到页表？</p>
<p>地址变化机构：<br>    作用？重定位；<br>    操作过程，无快表（两次访问内存）<br>    快表，使用方式</p>
<h3 id="分段存储管理方式"><a href="#分段存储管理方式" class="headerlink" title="分段存储管理方式"></a>分段存储管理方式</h3><p>分段与分页的区别（划分依据？大小固定？地址空间维度？）</p>
<p>分段的优势（支持共享）</p>
<p>地址结构：段号、偏移量</p>
<p>段表：内容？</p>
<p>地址变换过程（两次访问内存）</p>
<p>段页式存储：<br>    如何划分<br>    地址结构<br>    地址变换过程（3次访问内存，2维地址空间）</p>
<h2 id="虚拟存储管理"><a href="#虚拟存储管理" class="headerlink" title="虚拟存储管理"></a>虚拟存储管理</h2><h3 id="虚拟存储器概述"><a href="#虚拟存储器概述" class="headerlink" title="虚拟存储器概述"></a>虚拟存储器概述</h3><p>为什么要引入虚拟存储管理？<br>    常规存储管理要求一次性和驻留性，这对于作业很大、很多作业需要同时执行的场景是有问题的，并且与局部性原理相矛盾；<br>    一次性，即程序一次性装入内存；驻留性，即程序运行期间一直被保存在内存中；<br>    局部性原理<br>        时间局部性：某条指令，该指令及其上下指令很可能再次被访问<br>        空间局部性：一旦程序访问了某个存储单元，这不久后附近的存储单元也将被访问</p>
<p>虚拟存储器的定义？<br>    功能描述上来说：虚拟存储技术允许程序、数据、堆栈能够超过内存大小，用户程序可以在自己感知到的充足的空间下运行；<br>    具体实现来说：但实际的内存没有那么大的空间，而是通过“常规分页（段）存储器+请求调入功能+置换功能”实现了虚拟存储器<br>        当有了虚拟存储之后，CPU访问对应的内存单元，会将地址发送给MMU（由MMU将虚拟地址翻译为物理地址，并进行缺页处理等操作，再供CPU访问）<br>        而不是直接将地址送到内存地址总线上进行访问</p>
<p>虚拟存储的逻辑容量：内存容量+外部扩充的存储量<br>    其最大容量是由计算机的地址结构决定的（总线位数）</p>
<p>虚拟存储器的优点：<br>    让程序足以执行的充足空间<br>    为每个用户建立一个虚拟存储器，每个用户可以在自己的地址空间中编程</p>
<p>虚拟存储器的实现方式：<br>    请求分页系统：硬件（页表、缺页中断机构、地址变换机构）；软件（请求调页、页置换）<br>    请求分段系统：硬件（段表、缺段中断机构、地址变换机构）；软件（请求调段、段置换）<br>    虚拟段页系统</p>
<h3 id="请求分页存储管理方式"><a href="#请求分页存储管理方式" class="headerlink" title="请求分页存储管理方式"></a>请求分页存储管理方式</h3><p><code>上面三个虚拟存储器中，我们重点了解请求分页系统</code></p>
<p>页表（PT）<br>    入参：虚拟页号（VPN）<br>    输出：物理页号（PPN）<br>    页表项（PTE）<br>        页号：物理块号：状态位P：访问字段A：修改位M：外存地址<br>            P，该页是否调入内存<br>            A，该页在一定时间内的被访问次数<br>            M，该页调入内存后是否被修改过<br>            外存地址，该页在外存上的地址</p>
<p>缺页中断机构（由硬件支持）<br>    处理流程：<br>        1）访问页面不在内存中；2）产生缺页中断；3）保存现场；4）分析中断原因；5）转入中断处理程序；6）调入页面<br>    缺页中断与一般的中断不同：<br>        其是在指令执行的过程中产生和处理中断信号；而不同于一般的中断是在每次指令之后检测是否有中断；<br>        一次指令执行可能产生多次缺页中断；<br>        交换操作：<br>            缺页中断除了保护现场以外还需要判断内存中是否有足够的存储空间来保存所需的段或页，然后再调入内存，否则需要执行交换操作；<br>            而一般的只需要保护现场；<br>        返回位置：缺页中断返回时，执行产生中断的当前指令（保存返回地址的时候是当前指令的地址）；一般的是执行下一条</p>
<p>地址变换机构的工作流程<br>    页命中<br>        1）CPU生成虚拟地址VA；2）VA给到MMU，查询到对应的页表项地址PTEA给到CPU；3）CPU读取PTE，给到MMU；4）MMU将PTE中的物理页框号（PPN）复制到寄存器高位，并将PTE中的偏移量（VPO）复制到寄存器低位，构成物理地址，供CPU访问；5）CPU根据物理地址访问数据<br>    页未命中<br>        在上面的4）中，发现PTE有效位是0，转入缺页中断处理；<br>        缺页程序检查，虚拟页号是否合法，是否有空闲的物理页框PPN可以映射给虚拟页面，否则进行置换<br>        从磁盘调入新的页面到内存，更新PTE<br>        重新执行先前的指令<br>    有快表且快表命中<br>        在页命中的流程中，2）MMU直接根据VA从TLB中取出PTE，执行后面的步骤<br>    有快表且快表未命中<br>        3）MMU拿到PTE之后，会放入快表TLB，供下次使用（可能需要置换）<br>（主要注意，MMU要借助CPU在内存或快表中找到PTE，以及物理地址使用了虚拟地址中的偏移量）</p>
<p>请求分页中的内存分配：<br>    保证进程运行的最小物理块数<br>        直接寻址：指令页面和数据页至少两个；<br>        间接寻址：指令页面、地址页面、数据页面，至少三个<br>        （长指令可能会跨页面，具体的块数主要取决于指令的格式、功能和寻址方式）<br>    进程执行过程中分配给进程的物理块数是固定的还是可变的？<br>        固定分配局部置换，分配固定的物理块数，置换的时候置换自己的<br>        可变分配全局置换，根据具体情况，分配需要的物理块数，运行的时候根据需要从所有页面中进行置换<br>        可变分配局部置换，根据具体情况分配需要需要的物理块数，运行的时候从自己的页面中进行置换<br>    内存给进程分配物理块遵循的原则？<br>        平均分配：按照进程数量<br>        按比例分配：按照进程所占页面的比例分配<br>        优先权分配：按照重要性和紧迫性</p>
<p>内存调入策略<br>    系统应该在何时调入：预调页策略、请求调页（发生缺页时调入，主流）<br>    系统从哪里调入：<br>        1）如果有足够的对换区，全部放到对换区，结束后写入文件区<br>        2）如果对换区不够，不会被修改的从文件区调入，可能被修改的换出放在对换区，调入从对换区调入，结束后写入文件区<br>        3）UNXI方式，未运行过的，从文件区读，运行过又被换出的，放到对换区<br>    如何调入：页面置换算法</p>
<h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><p><code>前面提到了内存调入策略的关键问题是如何进行调入，对应的就是页面置换算法，这一部分重点讨论这些</code></p>
<p>什么时候需要置换：当内存空间用完之后，或者是分配给某个进程的空间用完了。</p>
<p>涉及的算法：</p>
<ol>
<li>最佳置换算法</li>
<li>先进先出置换算法</li>
<li>最近最久未使用算法</li>
<li>Clock置换算法</li>
</ol>
<p>最佳置换算法<br>    方法：从内存中移除永远不需要再访问的页面 or 最长时间不需要访问的页面<br>    注意：不是实际上的方法，具有理论上的最佳意义，可以作为衡量优劣的标准</p>
<p>FIFO算法<br>    方法：先进入内存的页面先淘汰<br>    注意：可能出现Belady现象，分配的页面数增多，缺页率反而提高</p>
<p>最近最久未使用算法（LRU）<br>    方法：选择最近一段时间内最久不使用的页面进行淘汰<br>    实现机制<br>        1）寄存器实现：为每个页面配置一个移位寄存器，每次访问所有移位寄存器右移1位，访问到的页面的寄存器最高位置1；挑选寄存器中值最小的淘汰；<br>        2）栈实现：保存页号，访问的时候从栈内取出，再压入栈顶；淘汰的时候淘汰栈底对应的页面</p>
<p>Clcok置换算法<br>    1）在发生缺页的时候：<br>        检查表指针指向的页面，如果R&#x3D;0则淘汰该页面替换入新页面，新页面R&#x3D;1；如果R&#x3D;1，则令R&#x3D;1；<br>        表指针向下移动<br>    2）没有发生缺页的时候：<br>        被访问的页面R&#x3D;1<br>    注：Clock算法有一种改进<br>        改进：考虑置换代价，将前面的R替换为(A,M)，A与R功能类似，M代表页面是否有被修改过；具体来说(0,0)&#x2F;(0,1)&#x2F;(1,0)&#x2F;(1,1)分别对应：1）最近未被访问，未修改，置换代价最小，优先置换；2）最近未被访问，被修改过，置换代价较大，可以置换；3）、4）最近被访问过不宜置换，尤其是4）被访问同时也被修改过<br>        被修改意味着：将该页换处的时候要将修改内容写回磁盘上，这个样子的话花费较多</p>
<p>评价指标：<br>    1）缺页次数（原本没有该页面也算缺页）；<br>    2）缺页率：缺页次数&#x2F;访问次数</p>
<p>访问内存的有效时间EAT（查找快表的时间：$\lambda$，访问实际物理地址的时间$t$，缺页中断的时间$\epsilon$）</p>
<ol>
<li>页表项在快表中，页在内存中：$EAT &#x3D; \lambda + t$</li>
<li>页表项不在快表中，页在内存中：$EAT &#x3D; \lambda+t+\lambda+t$</li>
<li>页不在内存中：$EAT &#x3D; \lambda + t + \epsilon + \lambda + t$（缺页中断可以将内存、快表一并补齐）</li>
<li>快表命中率$\alpha$，缺页率$f$，考虑EAT期望（<strong>可以问一下老师，当时上课讲的好像有一点问题，但可能不是那么重要</strong>）</li>
</ol>
<h3 id="抖动与工作集"><a href="#抖动与工作集" class="headerlink" title="抖动与工作集"></a>抖动与工作集</h3><p>抖动<br>    定义：页面在内存与磁盘之间频繁地调度，使得调度页面所需的时间比进程实际运行的时间还多，系统效率极具下降<br>    造成的结果：随着多道程序度的增加，处理器的利用率先上升后下降的现象<br>    产生的原因：页面置换算法、页面本身的大小、程序编制的方式（行优先、列优先）、驻留集的大小</p>
<p>驻留集<br>    定义：分配给进程使用的物理块的数量（可以对应到前面考虑各种置换算法的时候，同一时刻最多维持的页面的数量）<br>    注意：通常情况下，缺页率随着驻留集的增大而下降，但是这种效果逐渐减弱</p>
<p>工作集<br>    定义：在某段时间间隔$\Delta$里，进程实际要访问的页面的集合<br>    符号记法：工作集$W(t,\Delta)$，其中$t$是时刻，$\Delta$是尺窗口（要会找工作集对应的页）<br>    注意：<br>        1）工作集是基于局部性原理提出的，程序对页面的访问并不均匀；<br>        2）工作集的大小会变化<br>        3）对于变化而言相对稳定和快速变化的阶段会交替出现（一段时间稳定在一个局部性的页面，当局部位置变化的时候工作集快速变化，然后又进入一段时间的稳定）<br>        4）找到一个作业的最大工作集，可以帮助设计驻留集的大小</p>
<p>预防抖动的方法<br>    1）局部置换策略<br>    2）将工作集算法融入处理器调度中<br>    3）尽量让平均的执行时间等于缺页服务的时间，如果前者过大内存可能利用不够充分（因为相当于充足的内存给到了部分进程，其实还可以同时执行其他进程的）；如果后者过大，缺页过多，缺页服务时间太长，系统效率下降</p>
<h3 id="请求分段的存储方式"><a href="#请求分段的存储方式" class="headerlink" title="请求分段的存储方式"></a>请求分段的存储方式</h3><p>请求分段的存储方式<br>    构成：在基本分段方式上加入了：1）请求分段；2）段置换机制</p>
<p>硬件机制：<br>    1）请求段表机制；<br>    2）缺段中断机制；<br>    3）地址变换机构；</p>
<p>请求段表机制：<br>    段表与页表的不同点：<br>        在原本表项中加入了：1）存取方式（只读&#x2F;只写&#x2F;读写）；2）增补位（是否动态增长）<br>        （新增表项切合了段面向程序划分的需求）</p>
<p>缺段中断机构：<br>    缺段中断与缺页中断的区别：<br>        1）不会出现一条指令或一组信息在两个段的情况（页可能有这种情况）</p>
<p>地址变换机构：<br>    分段的地址变换与分页的区别：<br>        1）段的长度不是固定的</p>
<p>共享段表（分段的特色所在）<br>    由于段是面向程序划分的，所以段可以支持进程的共享（如需要访问相同的库函数）<br>    工作方式：<br>        分配：当某进程需要访问某段时，如果内存中没有则调入；会在共享段表中存储其信息，当其他进程需要的时候优先查共享段表，如果有的话直接使用；共享段表中会记录当前使用该段的进程和进程数量<br>        回收：一个进程不再使用该段的时候会在共享段表中消除它的记录，当共享段表中记录进程数量为0的时候，对应段的内存空间就被回收。<br>    注意：<br>        区别共享段表和进程自己使用的段表项</p>
<p>分段保护：<br>    共享段表需要进行保护<br>        1）越界检查；<br>        2）存取控制检查；<br>        3）环保护</p>
<h2 id="输入输出系统"><a href="#输入输出系统" class="headerlink" title="输入输出系统"></a>输入输出系统</h2><h3 id="I-O系统的功能、模型和接口"><a href="#I-O系统的功能、模型和接口" class="headerlink" title="I&#x2F;O系统的功能、模型和接口"></a>I&#x2F;O系统的功能、模型和接口</h3><p>I&#x2F;O系统的功能<br>    管理I&#x2F;O设备，包括打印机、键盘、屏幕等交互设备，以及磁盘等存储设备；<br>    基本功能：<br>        1）隐藏物理设备细节；<br>        2）与设备无关性；<br>        3）提高处理器和I&#x2F;O设备等利用率；<br>        4）设备控制；<br>        5）设备共享；<br>        6）错误处理；</p>
<p>I&#x2F;O软件的层次：<br>    1）用户层软件：产生I&#x2F;O请求、格式化I&#x2F;O、Spooling（假脱机系统）；<br>    2）设备独立性软件：主要是几个表，为了实现设备无关性；<br>    3）设备驱动程序：操作系统的一部分，用来启动设备<br>    4）中断处理程序：执行I&#x2F;O时用户进程、驱动程序被阻塞，I&#x2F;O完成后触发中断，由CPU唤醒驱动程序进行后续处理；<br>    5）硬件：执行I&#x2F;O操作；</p>
<h3 id="I-O设备和设备控制器"><a href="#I-O设备和设备控制器" class="headerlink" title="I&#x2F;O设备和设备控制器"></a>I&#x2F;O设备和设备控制器</h3><p>I&#x2F;O设备的类型：<br>    数据传输单位分：<br>        1）块设备；<br>        2）流设备（字符设备）；<br>    共享属性上分：<br>        1）独占设备；<br>        2）共享设备；</p>
<p>控制方式<br>    1）无通道：<br>        CPU与设备控制器通信；<br>        设备控制器与设备通信；<br>    2）有通道<br>        I&#x2F;O通道：可以通过访问内存，取指令执行；<br>            1）算一种特殊的处理机；<br>            2）但是可执行指令单一，并且没有自己的内存（和CPU共享内存）；<br>        CPU向通道发出一条I&#x2F;O指令，通道直接访问内存，从中取出本次所需的I&#x2F;O程序执行，执行完毕后再触发中断告诉CPU；</p>
<p>I&#x2F;O设备寻址问题：<br>    I&#x2F;O设备寻址的时候，CPU怎么定位I&#x2F;O设备里的寄存器；<br>    1）特定I&#x2F;O指令，定制指令集，因为访问的内存不一样；<br>    2）内存映象I&#x2F;O，在编制方式上不去分内存和设备控制器的寄存器地址，进行统一编址，只是范围不同，例如以n为界限；</p>
<h3 id="中断机构和中断处理程序"><a href="#中断机构和中断处理程序" class="headerlink" title="中断机构和中断处理程序"></a>中断机构和中断处理程序</h3><p>与I&#x2F;O相关的中断应用场景：<br>    阻塞式系统调用：用户进程、驱动程序即将开始进行I&#x2F;O操作，调用I&#x2F;O程序然后将自己阻塞，当I&#x2F;O程序执行完毕之后，使用中断让CPU恢复用户进程、驱动程序；</p>
<p>中断处理的过程：<br>    中断处理程序：<br>        1）每当指令执行完，检测是否有未处理的中断信号；若有则转入中断处理程序；<br>        2）保护现场，保护CPU当前执行到的地址、寄存器的状态等；<br>        3）转入处理程序，找到中断源，发出确认信号，<strong>取消中断信号</strong>；<br>        4）中断处理；<br>        5）恢复线程并退出中断；</p>
<p>一个大概的I&#x2F;O过程：<br>    1）用户进程请求I&#x2F;O设备；<br>    2）操作系统调用驱动程序；<br>    3）<strong>驱动程序启动设备</strong>，发出控制命令，将<strong>自己阻塞，继而用户进程也被阻塞</strong>；<br>    4）进程切换，CPU执行其他进程；<br>    5）<strong>I&#x2F;O设备执行完成，发出中断信号</strong>；<br>    6）CPU检测到中断信号，开始处理：<br>        唤醒驱动、确认中断源、取消中断信号，驱动程序进行后续处理（这就是在中断处理）、恢复现场…</p>
<h3 id="设备驱动程序"><a href="#设备驱动程序" class="headerlink" title="设备驱动程序"></a>设备驱动程序</h3><p>设备驱动程序的作用：<br>    1）通信程序：驱动程序是I&#x2F;O系统的高层和设备控制器之间的通信程序；<br>    2）指令转换：接收抽象的I&#x2F;O指令，将其转换为具体的适合硬件的指令和参数；</p>
<p>驱动程序对I&#x2F;O设备的控制方式：<br>    1）程序控制方式；<br>        使用轮询的可编程I&#x2F;O方式：<br>            基本思想：CPU发出一条I&#x2F;O指令之后，令寄存器busy&#x3D;1；CPU不断对busy进行检查，如果busy为1则<strong>一个字符</strong>的I&#x2F;O没有完成，直到busy&#x3D;0，CPU才继续处理<strong>下一个字符</strong>的IO；<br>        缺点：忙等，CPU一直在询问，无法解脱；<br>    2）中断驱动方式；<br>        使用中断的可编程I&#x2F;O方式<br>            基本思想：I&#x2F;O设备处理数据中，无需CPU干预，CPU与I&#x2F;O设备并行工作，只有I&#x2F;O完成之后CPU才回来用极少的时间处理中断信号；<br>            （具体的过程和前面中断部分，I&#x2F;O的大概过程类似）；<br>        缺点：按字为单位进行的I&#x2F;O，每个输入完成之后就会有一次中断，效率本应该更高；<br>    3）DMA方式；<br>        直接存储器方式：<br>            基本思想，增大传输的基本单位，CPU与I&#x2F;O设备之间每次至少传输一个数据块，数据由<strong>DMA控制器</strong>控制，直接送入内存；<strong>只在每个数据块处理的开始和结束需要CPU的干预</strong>；<br>        优点：<br>            仅在传送一个或多个数据块多开始和结束为止需要使用到中断，大大提高了效率；<br>        （2、3对比：前者以字节为单位，后者以数据块为单位；前者数据传送到内存，由CPU控制，后者由DMA控制器控制）；<br>        缺点：<br>            DMA方式是以数据块为单位，这意味着每个数据块的开始和结束时需要CPU进行干预，如果一次能直接处理一组数据块会更加高效；<br>    4）I&#x2F;O通道控制方式；<br>        基本思想：属于DMA方式的发展，把对一个数据块的读写改为对一组数据块的读写；CPU要执行一组数据块的读写的时候，给通道发送一条指令，给出通道程序首地址和设备号，通道自行执行通道程序，并操作内存；</p>
<h3 id="与设备无关的I-O软件"><a href="#与设备无关的I-O软件" class="headerlink" title="与设备无关的I&#x2F;O软件"></a>与设备无关的I&#x2F;O软件</h3><p>与设备无关的I&#x2F;O软件主要目的是实现：<br>    1）对独立设备的分配和回收（实现设备的复用）；<br>    2）主要的方式使用独立于设备的逻辑数据块（隐藏设备的具体参数细节向高层提供统一操作的“对象”）；</p>
<p>主要的表与表结构：<br>    设备控制表（DCT）：每个I&#x2F;O设备都有自己的控制表，里面有设备相关的信息；<br>    控制器控制表（COCT）：例如DMA控制器；<br>    通道控制表（CHCT）：例如I&#x2F;O通道；<br>    （指向关系：DCT-&gt;COCT-&gt;CHCT）；<br>    系统控制表（SCT）：全局表，DCT可以看作SCT都表目；<br>    逻辑设备表（LUT）：为每个用户分配的，里面的表项是相关设备的逻辑名称以及对应的物理名词；</p>
<p>设备分配的过程：<br>    1）用户在自己的LUT中找到要用设备的逻辑名，以及对应的物理名，例如&#x2F;dev&#x2F;打印机对应5；<br>    2）使用物理名去查SCT，找到对应的DCT；<br>    3）DCT找到对应的COCT，COCT找到对应的CHCT；<br>    4）全部确认没问题了，先分配：设备，再分配：控制器，最后分配：通道；</p>
<h3 id="用户层软件"><a href="#用户层软件" class="headerlink" title="用户层软件"></a>用户层软件</h3><p>假脱机系统：<br>    组成：<br>        1）输入井和输出井：在硬盘上分出的存储区域；<br>        2）输入缓冲区和输出缓冲区：在内存上的数据中转站；<br>        3）输入进程和输出进程：模拟外围机；<br>        4）井管理程序：直接和用户打交道；<br>    使用流程：<br>        1）输入进程 输入数据 到用户进程：<br>            1）输入进程控制设备输入到输入缓冲区；<br>            2）然后转移到输入井；<br>            3）用户进程通过井管理程序从输入井中读取数据；<br>        2）用户进程 输出数据 到输出设备：<br>            1）用户进程通过井管理程序输出到输出井；<br>            2）输出进程从输出井将数据读入输出缓冲区；（在设备空闲时）<br>            3）输出设备读取输出缓冲区的数据输出；</p>
<h3 id="缓冲区的管理"><a href="#缓冲区的管理" class="headerlink" title="缓冲区的管理"></a>缓冲区的管理</h3><p>缓冲区是<strong>设备独立性软件</strong>管理的资源；<br>（属于设备无关层，设备独立性软件层）</p>
<p>引入缓冲区的原因：<br>    1）缓解CPU和I&#x2F;O设备速度不匹配的问题；<br>    2）减少CPU的中断频率；<br>    3）解决数据粒度不匹配的问题；<br>    4）提高CPU与I&#x2F;O设备的并行性；（越多并行越强）；</p>
<h3 id="磁盘存储器的性能和调度"><a href="#磁盘存储器的性能和调度" class="headerlink" title="磁盘存储器的性能和调度"></a>磁盘存储器的性能和调度</h3><p>磁盘的基本结构：<br>    1）磁盘包括一个或多个盘面；<br>    2）每个盘面有两个存储面；<br>    3）每个面按同心圆环组织，对应环就是磁道，每条磁道上存储相同数目的二进制位；<br>    4）每条磁道从逻辑上划分为多个扇区，一个扇区称为一个盘块；</p>
<p>磁盘容量的计算：<br>    已知：1）8个双面盘片，2）每面16384个磁道，3）64个扇区，4）每个扇区512个字节；<br>    按照基本结构：<br>        容量 &#x3D; 8 16384 64 512B 累乘 -&gt; 8GB<br>    （注意<strong>64个扇区是指每个磁道64个扇区</strong>）；</p>
<p>注意：现代磁盘为了提升容量不会将内外磁道算作相同的存储容量，外磁道显然会大一些，提供给OS的是抽象后的几何信息，这些会由驱动器处理；</p>
<p>磁盘调度算法：<br>    衡量指标：<br>        磁道x，y之间的距离（磁头从x-&gt;y的移动距离） &#x3D; |x-y|；（其中x、y是编号）；<br>        平均寻道长度 &#x3D; 一系列磁道读写完成之后，磁头移动距离之和 &#x2F; 磁头移动次数；<br>    1）FCFS（先来先服务）：<br>        按照对于磁道请求读写的时间顺序先后，依次移动磁头道对应磁道进行读写；<br>    2）SSTF（最短寻道优先算法）：<br>        按照一系列磁道读写请求中，距离当前所在磁道的距离进行选择，下一次选择距离当前最近的磁道；<br>    3）SCAN（扫描算法）：<br>        对于一系列读写请求，磁头按照当前读取<strong>方向（磁道号增大或减小）</strong>，继续读取同一方向的磁道，直到读完该方向最大&#x2F;最小 的磁道，再改变反向；<br>        （注意方向，以及改变方向不是轮回，而是掉头）；<br>    4）CSCAN（循环扫描算法）：<br>        对于一系列读写请求，磁头总是沿着一个方向移动，增大&#x2F;减小，直到最大&#x2F;最小，磁头立马移动道最小&#x2F;最大处，重新开始；<br>        （注意方向，并且这个改变方向也是掉头，只是掉头直接走到底，再重新扫一遍）；</p>
<h2 id="文件管理-1"><a href="#文件管理-1" class="headerlink" title="文件管理"></a>文件管理</h2><p>文件的相关操作：<br>    1）最基本操作：<br>        1）创建文件；<br>        2）删除文件；<br>        3）读文件；<br>        4）写文件；<br>        5）设置文件读&#x2F;写位置；<br>    2）文件的“打开”和“关闭”操作；<br>    3）其他操作；</p>
<p>文件的打开操作：<br>    引：<br>        1）在没有打开操作之前，对文件操作我们需要检索目录，找到文件的属性和它在外存上的属性；<br>        2）缺点是对文件进行多次操作，每次都要重新检索目录，于是OS发明了“打开”文件这一概念；<br>    文件的打开：<br>        1）OS将指定文件的属性（包括物理位置）从外村拷贝到内存的“打开文件表”，作为一个表目，并将这个表目的索引&#x2F;编号，返回给用户；<br>        2）让用户对文件操作的时候，可以使用这个索引向OS进行请求，OS可以直接利用这个索引查找到对应的文件，避免了二次检索；</p>
<p>文件的关闭操作：<br>    对应着打开：<br>        当用户不需要对该文件再操作时，利用关闭的系统调用，将文件关闭，OS把该文件对应的表目从“打开文件表”中删除；</p>
<p>文件的逻辑结构：<br>    作用：记录数据在一个文件中的组织方式；<br>    按照记录的组织方式划分：<br>        1）顺序文件：<br>            含义：一条接一条的记录顺序组合在一起；<br>            两种结构：<br>                1）串结构：依据时间最先存储的作为第一个记录，然后是第二个记录，以此类推；<br>                2）顺序结构：按照关键字（词）排序，例如关键词长短、英文的顺序；<br>            两种寻址方式：<br>                1）隐式寻址：一条一条记录查找，直到找到想要的记录；<br>                2）显示寻址：对记录实现直接或随机访问（可以直接定位到记录）；<br>                注意：显示寻址只能对<strong>定长</strong>对记录实现，不能对变长的记录实现（注意变长是指一个记录的长度可以变，而一个文件有多个记录）；<br>        2）索引文件：<br>            含义：针对变长记录文件，配备一个索引表，按记录的关键字排序，表项可以直接索引到记录；<br>            注意：索引表本身是一个定长记录文件；（表项长度固定）；<br>        3）索引顺序文件：<br>            含义：将顺序文件中的所有记录分组，为每组建立一个索引项，指向每组的第一个记录；<br>            本质上就是有一定额外逻辑结构，但是没有记全的索引文件（它们的结构实际上也是一样的）；<br>            优点：克服了在文件中记录较多时，出现大量索引的，检索费事的问题；</p>
<p>（索引顺序文件）多级索引下文件访问时间问题：<br>    1）n条记录的文件，顺序访问，平均查找次数是n&#x2F;2；<br>    2）建立了一级索引：均分的来说，应该有$\sqrt{n}$个索引项，对应每组有$\sqrt{n}$条索引记录；<br>        所以平均查找次数是 $\sqrt{n}&#x2F;2 + \sqrt{n}&#x2F;2 &#x3D; \sqrt{n}$；<br>    3）如果建立了二级索引，考虑均分，应该有 $n^{1&#x2F;3}$ 个二级索引，每个二级索引对应同样数量个一级索引，每个一级索引对应同样数量个记录项；<br>        所以平均查找次数是 $n^{1&#x2F;3}*3&#x2F;2$</p>
<p>文件目录：<br>    本质：定长顺序文件；<br>    组成：文件控制块（FCB）；<br>        1）基本信息：文件名、文件物理位置、文件逻辑结构、文件物理结构；<br>        2）存取控制信息：各种用户的存取权限；<br>        3）使用信息：例如上一次修改的日期、创建日期etc.<br>        （文件控制块就是“文件目录”这个定长顺序文件中的记录）；<br>    改进：<br>        问题：如果文件较多，文件目录中记录很多，导致系统将文件目录调入内存时占用空间很大，效率很低；<br>            （操作系统开机的时候就是读取目录，后续根据需要读取文件）；<br>        解决方案：索引节点；<br>            1）索引节点中记录FCB中的信息（UNIX中称为i节点）；<br>            2）文件目录中只记录文件名和索引节点的编号；<br>            （相当于在需要一个文件详细记录的时候，再根据索引节点编号，索引到索引节点，其中记录了原始FCB会有的信息）；<br>    常见的文件目录：<br>        1）一级文件目录：<br>            整个文件系统建立一张目录表，每个文件占一个目录项，目录项中是文件的meta info；<br>            优点：<br>                实现了按名存取；<br>            缺点：<br>                速度慢，不允许重名；<br>        2）二级文件目录：<br>            为每个用户单独建立一个文件目录表UFD，系统中建立一个主文件目录MFD，MFD中存了用户名和对应的指针，UFD中存到是文件名以及对应的指针（索引），类似于索引节点的方式；<br>            优点：<br>                1）提高了检索速度，不同用户可以使用相同文件名；<br>                2）不同用户可以使用不同用户名来访问共享文件；<br>        3）树形文件目录：<br>            唯一的根目录，其他每个文件、目录有唯一的父目录；一个目录中指向子目录的记录类似于MFD，指向文件的记录类似于UFD（即类似索引节点）；<br>            （其中文件是树叶、目录是树的节点）；<br>            路径名：<br>                1）绝对路径名：在树形文件目录中，从根目录到任何数据文件都有唯一的路径名；<br>                2）相对路径名：从当前目录开始直到数据文件为止构成的路径名；<br>            路径名的表示方式：<br>                1） “.&#x2F;“ 当前目录；<br>                2） “..&#x2F;“ 上级目录；<br>                3） “&#x2F;“ 根目录；<br>            <img src="/OS/p8.png" alt="文件路径名的例子">；</p>
<p>文件目录的查找：<br>    注意哈希法不适用于有通配符的模糊查找；</p>
<p>文件共享：<br>    含义：系统应该允许多个用户共享一个文件，这样系统只用保存一份文件的副本；<br>    基于索引节点实现共享：<br>        利用索引节点，只需要不同用户的某个记录项索引指向同一索引节点，即可实现文件共享；<br>    改进：基于符号链接Link文件实现共享：<br>        问题：<br>            这种方式需要记录一个当前文件的用户使用数量，只有在数量为0的时候才删除文件；这带来了拥有者问题，当一个文件的Onwer不需要该文件了，如果有其他用户在共享这个文件，那么文件就无法删除，这是不公平的（A消费，B买单）；而强行删除的话会带来悬空指针问题；<br>        方法：<br>            只有拥有者指向索引节点，<strong>共享者</strong>创建一个Link型文件用于记录指向实际文件的路径，共享者可以访问到的是该Link型文件的索引节点；<br>            （相当于共享者只有共享文件的路径，实际的文件掌握在拥有者手中，如果拥有者删除文件，系统就会因为找不到文件而访问失败，让用户删除自己是失效的Link型文件）；</p>
<h2 id="随堂测试"><a href="#随堂测试" class="headerlink" title="随堂测试"></a>随堂测试</h2><p><code>这门课老师貌似不布置作业，但其实随堂测试基本上涵盖了每一章的知识点，在这里进行记录</code></p>
<h3 id="第四次随堂测试：存储器管理"><a href="#第四次随堂测试：存储器管理" class="headerlink" title="第四次随堂测试：存储器管理"></a>第四次随堂测试：存储器管理</h3><h4 id="1-1）"><a href="#1-1）" class="headerlink" title="1.1）"></a>1.1）</h4><p>动态分区分配中，系统回收一块内存需要修改空闲分区表，造成空闲区数减1的是：</p>
<p>C. 既有上邻空闲区，也有下邻空闲区。</p>
<p>原因是当内存回收后，新增的一块和原来的两块合并成一块了，就相较于原来少了一块。</p>
<h4 id="1-2）"><a href="#1-2）" class="headerlink" title="1.2）"></a>1.2）</h4><p>在页式存储管理方案中，使用？实现地址变换</p>
<p>页表</p>
<h4 id="1-3）"><a href="#1-3）" class="headerlink" title="1.3）"></a>1.3）</h4><p>根据存储区分配所用基本单位的不同，可以将离散分配方式为？</p>
<p>分页、分段、段页式</p>
<h4 id="1-4）"><a href="#1-4）" class="headerlink" title="1.4）"></a>1.4）</h4><p>在一个页式存储管理系统中，页表内容如图。若页大小为4K，则地址变换机构将逻辑地址0变换为物理地址为？</p>
<p>页号    块号<br>0       2<br>1       1<br>2       6<br>3       3<br>4       7</p>
<p>4K * 2 &#x3D; 8K &#x3D; 8 * 1024 &#x3D; 8192</p>
<h4 id="1-5）"><a href="#1-5）" class="headerlink" title="1.5）"></a>1.5）</h4><p>在一个页式存储管理系统中，页表保存在内存中，CPU每存取一个数据，都需要？次访问内存</p>
<p>2次</p>
<h4 id="2-1）"><a href="#2-1）" class="headerlink" title="2.1）"></a>2.1）</h4><p>在程序装入方式中的可重定位装入方式可以实现进程在内存中位置的移动</p>
<p>错误</p>
<p>可重定位是在放入内存的时候改地址，放入后不能再更改地址。</p>
<h4 id="2-2）"><a href="#2-2）" class="headerlink" title="2.2）"></a>2.2）</h4><p>静态链接方式形成的完整的装入模块是可执行文件</p>
<p>正确</p>
<h4 id="2-3）"><a href="#2-3）" class="headerlink" title="2.3）"></a>2.3）</h4><p>装入时的动态链接方式便于实现对目标模块的共享</p>
<p>正确</p>
<p>什么时候装，什么时候链接，可以实现目标共享</p>
<h4 id="2-4）"><a href="#2-4）" class="headerlink" title="2.4）"></a>2.4）</h4><p>页式存储比段式存储更利于实现对目标模块的动态链接</p>
<p>错误</p>
<p>说反了，段式有逻辑，更适合动态链接，共享</p>
<h4 id="2-5）"><a href="#2-5）" class="headerlink" title="2.5）"></a>2.5）</h4><p>装入时的动态链接比运行时的动态链接更加节省内存空间</p>
<p>错误</p>
<p>运行时动态链接更节省，只有执行到的会被装入，前者所有需要的都会被装入</p>
<h4 id="3-1）"><a href="#3-1）" class="headerlink" title="3.1）"></a>3.1）</h4><p>给定一个逻辑地址为A&#x3D;2170B，若页面大小为1KB，则该地址所对应的页号为？页内地址为？</p>
<p>页号：2170&#x2F;1024 &#x3D; 2，页内地址：2170-2048&#x3D;122</p>
<p>2048在2号页中，页内地址为0；地址实际上都是偏移，从0开始，页号也是从0开始</p>
<h4 id="3-2）"><a href="#3-2）" class="headerlink" title="3.2）"></a>3.2）</h4><p>在动态分区分配算法中，如果采用最佳适应算法，需要将空闲分区链按照？顺序排列，如果按照最坏适应算法，则需要将空闲分区链按照？顺序排列。</p>
<ol>
<li>递增</li>
<li>递减</li>
</ol>
<p>递增排列，来了程序从前往后遍历，第一次找到可行的分区空间，就是最小能适合它的空间，所以最佳；递减顺序含义类似。</p>
<h4 id="3-3）"><a href="#3-3）" class="headerlink" title="3.3）"></a>3.3）</h4><p>在具有对换空间的操作系统中，磁盘空间分为对换区和文件区两个部分，其中对换区采用？分配方式，而文件区采用？分配方式。</p>
<ol>
<li>连续</li>
<li>离散</li>
</ol>
<p>对换区要求时间效率高，因为调度频繁，所以使用连续分配方式；文件区要求空间利用率高，因为文件需要长时存储，且访问不频繁，所以使用离散分配的方式。</p>
<h4 id="3-4）"><a href="#3-4）" class="headerlink" title="3.4）"></a>3.4）</h4><p>在段页式系统中，如果段表和页表都在内存中，那么CPU完成一次数据或指令的读取，需要？次访问内存。</p>
<p>需要3次访问内存</p>
<p>1次访问段表，获得页表地址，第2次反问页表获得物理地址，第3次访问物理地址读取内容；</p>
<h4 id="3-5）"><a href="#3-5）" class="headerlink" title="3.5）"></a>3.5）</h4><p><code>这里需要再明确一下</code></p>
<p>只采用分页方式的用户地址空间是？维的，而采用分段方式的用户地址空间是？维的。</p>
<ol>
<li>2 改 1</li>
<li>2</li>
</ol>
<p>页号+位移量，段号+位移量，都是两个维度</p>
<p>注：段页式也是2维   分页式是1维的</p>
<h4 id="4-1）"><a href="#4-1）" class="headerlink" title="4.1）"></a>4.1）</h4><p>某OS采用动态分区分配存储管理方法，用户区为512K,且始址为0。若分配时采用分配空闲区低地址部分的方案，且初始时用户的512K空间空闲，对下述申请序列:申请300K，申请100K，释放300K，申请150K，申请30K，申请40K,申请60K，释放30K回答:</p>
<ol>
<li>采用首次适应算法，空闲分区中有哪些空块（给出始址、大小）？</li>
<li>采用最佳适应算法，空闲分区中有哪些空块（给出始址、大小）？</li>
<li>如再申请100K，针对（1）和(2)各有什么结果？</li>
</ol>
<p>Q1:</p>
<p>申请300K后：空闲块1，起始地址：300K&#x3D;300*1024&#x3D;307200，大小212K</p>
<p>申请100K后：空闲块1，起始地址：400K&#x3D;400*1024&#x3D;409600，大小112K</p>
<p>释放300K后：空闲块1，起始地址：0，大小300K；空闲块2，起始地址：409600，大小112K</p>
<p>申请150K后，空闲块1，起始地址：150K，150*1024&#x3D;153600，大小150K；空闲块2，起始地址：409600，大小112K</p>
<p>申请30K后，空闲块1，起始地址：180K，大小120K，空闲块2，起始地址，400K，大小112K</p>
<p>申请40K后，空闲块1，起始地址，220K，大小80K，空闲块2，起始地址，400K，大小112K</p>
<p>申请60K后，空闲块1，起始地址，280K，大小20K，空闲块2，起始地址，400K，大小112K</p>
<p>释放30K后，空闲块1，起始地址，150K，大小30K，空闲块2，起始地址280K，大小20K，空闲块3，起始地址400K，大小112K</p>
<p>若再申请100K，空闲块1，起始地址，150K，大小30K，空闲块2，起始地址280K，大小20K，空闲块3，起始地址500K，大小12K</p>
<p>Q2是类似的，只是<strong>每次内存从较小的空闲块开始出</strong>，最后的答案是：</p>
<p><strong>注意，最佳适应法最后给答案的时候，空闲块也要按照从小到大给</strong>；<br><strong>最坏适应法，按从大到小给</strong>；<br><strong>首次适应法，按照地址空间低到高给</strong>；</p>
<p>空闲块1:400K～430K，30K，空闲块2：470K～512K，42K，空闲块3：210K～300K，90K</p>
<p>若再申请100K，是给不出来的</p>
<h4 id="4-2）"><a href="#4-2）" class="headerlink" title="4.2）"></a>4.2）</h4><p>设有一块页式存储管理系统，向用户提供的逻辑地址空间最大为64页，每页1024B，内存总共有32存储块，试问逻辑地址至少应为多少位？内存空间有多大？</p>
<p>逻辑地址：（页号）（页内偏移）：2^6 2^10，故16位</p>
<p>内存空间：32*1024 &#x3D; 2^15 Byte</p>
<p>从这里可以看到实际内存是小于逻辑地址的，那么当进程尝试使用的空间大于实际内存，计算机是如何处理的呢？</p>
<h4 id="4-3）"><a href="#4-3）" class="headerlink" title="4.3）"></a>4.3）</h4><p>如果分段式地址具有如下结构，在该地址中，允许一个作业最长有多少个段？每个段的最大长度是多少？</p>
<p>（63～32段号）（31～0段内地址）</p>
<p>2^32 &#x3D; 4G</p>
<p>2^32 &#x3D; 4G</p>
<h4 id="4-4）"><a href="#4-4）" class="headerlink" title="4.4）"></a>4.4）</h4><p><code>再理解一下，虽然记住做法是很简单的</code></p>
<p>在采用伙伴系统的动态分区算法中，有一个大小为128的块，其地址为640，其伙伴块的地址是什么？</p>
<p>形成的块大小是256，判断当前地址是否能整除640</p>
<p>如果能整除，则它是靠前的，否则它是靠后的</p>
<p>640 MOD 256 !&#x3D; 0</p>
<p>所以它是靠后的，则伙伴块地址为640-128&#x3D;512</p>
<h3 id="第五次随堂测试：虚拟存储管理器"><a href="#第五次随堂测试：虚拟存储管理器" class="headerlink" title="第五次随堂测试：虚拟存储管理器"></a>第五次随堂测试：虚拟存储管理器</h3><p>1）虚拟存储器的最大容量是由？</p>
<p>由计算机的地址结构决定的</p>
<p>注：虚拟存储器会尝试解析处理任意输入的地址，也就是说其感知到的可寻址空间由输入地址的范围决定，计算机的地址结构就决定了这个输入地址的上、下限</p>
<p>2）在虚拟存储系统中，若进程在内存中占3块（开始时为空），采用FIFO算法，当执行访问页号序列为1、2、3、4、1、2、5、1、2、3、4、5、6时，将产生几次缺页</p>
<p>进程的内存块随访问页号变化如下</p>
<p>1、12、123、234、341、412、125、125、125、253、534、534、346</p>
<p>每一次改变对应一次缺页，有10次改变，3次未变，所以一共缺页10次</p>
<p>3）系统“抖动”现象的发生可能是由？引起的</p>
<p>抖动现象可能产生的原因是：</p>
<ol>
<li>置换算法的选择不当</li>
<li>页面本身的大小有问题</li>
<li>程序的编写不当</li>
<li>驻留集大小不当</li>
</ol>
<p>所以这里的答案是，置换算法选择不当</p>
<p>4）实现虚拟存储器的目的是</p>
<p>扩充内存容量</p>
<p>注：实际上扩充内存容量是伴随虚拟存储器出现的好处，初衷是为了解决常规存储管理模式中<strong>一次性、驻留性</strong>的问题</p>
<p>5）作业在执行中发生了缺页中断，经操作系统处理后，应让其执行？指令</p>
<p>被中断的指令</p>
<p>因为发生了中断，该指令还没有得到执行，所以要执行它</p>
<p>6）在请求分页存储管理中，若采用FIFO页面淘汰算法，但分配的页面数增加时，缺页中断的次数将</p>
<p>可能增加也可能减少</p>
<p>FIFO算法存在发生belady现象的可能</p>
<p>7）虚拟存储管理系统的基础上程序的？理论</p>
<p>局部性</p>
<p>时间局部性、空间局部性、局部性原理</p>
<p>8）下述？页面淘汰算法会产生Belady现象</p>
<p>先进先出</p>
<p>即FIFO</p>
<p>9）在页式存储管理方案中，采用？实现地址变换</p>
<p>页表</p>
<p>10）在请求分页系统中，主要的硬件支持有请求分页的页表机制，缺页中断机构和？</p>
<p>地址变换机构</p>
<p>11）假设某程序的页面访问序列为1、2、3、4、5、2、3、1、2、3、4、5、1、2、3、4且开始执行时内存中没有页面，则在分配给该程序的物理块数是3且采用FIFO方式时，缺页次数是？，在分配给该程序的物理块数是4且采用FIFO方式时，缺页次数是？，在分配给该程序的物理块数是3且采用LRU方式时，缺页次数是？，在分配给该程序的物理块数是4且采用LRU方式时，缺页次数是？</p>
<p><strong>老师说写序列的时候最好按照访问页面序列写，先将序列抄下来，每访问一个页面在对应序号下面写当前内存块中的序列</strong>。</p>
<p>物理块数为3时</p>
<p>FIFO：1、12、123、234、345、452、523、231、231、231、314、145、145、452、523、234：13次<br>LRU：1、12、123、234、345、452、523、231、231、231、423、235、351、512、123、234：14次</p>
<p>物理块为4时</p>
<p>FIFO：1、12、123、1234、2345、2345、2345、3451、4512、5123、1234、2345、3451、4512、5123、1234：14次<br>LRU：1、12、123、1234、2345、！3452、！4523、5231、！5312、！5123、1234、2345、3451、4512、5123、1234：12次</p>
<p>12）在段页式存储管理系统中，每道程序都有一个？表和一组？表</p>
<p>维护一个段表，一组页表</p>
<p>先将程序划分为段，然后将一个段划分为若干页，最终使用的都是页表，所以先用段表索引到对应页表存储的位置，然后用页表索引到实际的物理内存，那么就应该是一个段表、一组页表，即每个段都有自己的页表。</p>
<p>13）设谋进程的页面访问串为1、3、1、2、4，分配的物理块是3块，采用FIFO置换算法时，访问页面4时，要淘汰？号页面</p>
<p>1、13、13、32、24</p>
<p>所以淘汰的是3号页面</p>
<p><strong>？</strong></p>
<p>14）上一题，若采用LRU算法，则应该淘汰？号页面</p>
<p>1、13、31、12、24</p>
<p>淘汰1号页面</p>
<p><strong>？</strong></p>
<p>注：<strong>这一部分没有涉及最佳置换算法的考察，注意复习</strong></p>
<h3 id="第六次随堂测试：I-O系统"><a href="#第六次随堂测试：I-O系统" class="headerlink" title="第六次随堂测试：I&#x2F;O系统"></a>第六次随堂测试：I&#x2F;O系统</h3><h4 id="选择题"><a href="#选择题" class="headerlink" title="选择题"></a>选择题</h4><ol>
<li>以下哪个功能是操作系统的输入输出管理功能？</li>
</ol>
<p>设备管理对应输入输出管理；进程、内存、文件系统管理不是</p>
<ol start="2">
<li>操作系统的输入输出系统中，设备驱动程序的作用是？</li>
</ol>
<p>与硬件交互，提供统一接口给上层应用。</p>
<ol start="3">
<li>在操作系统中，哪种设备属于块设备</li>
</ol>
<p>硬盘属于块设备，键盘、显示器属于流设备</p>
<p><strong>似乎打印机也属于块设备？</strong>（来自AI）</p>
<p>（从数据传输单位上区分，块设备和流设备，流设备又叫做字符设备）</p>
<ol start="4">
<li>在I&#x2F;O设备的管理中，以下哪个不是缓冲区的作用？</li>
</ol>
<p>进行内存的保护不是缓冲区的作用，感觉缓冲区本身还可能带来溢出的危险</p>
<ol start="5">
<li>以下关于I&#x2F;O控制器的说法，哪一项是正确的？</li>
</ol>
<p>I&#x2F;O控制器负责将高层输入输出请求转化为硬件指令</p>
<p>（对应的应该是I&#x2F;O设备与设备控制器的部分，这里将设备控制器称为I&#x2F;O控制器？）</p>
<ol start="6">
<li>操作系统中，缓冲区的作用是？</li>
</ol>
<p>缓解设备和CPU的速度差异</p>
<ol start="7">
<li>以下哪个设备属于字符设备？</li>
</ol>
<p>键盘</p>
<p>注意，打印机应该也是块设备</p>
<ol start="8">
<li>操作系统中，I&#x2F;O中断的作用是？</li>
</ol>
<p>让CPU暂停当前进程，处理I&#x2F;O事件</p>
<ol start="9">
<li>在磁盘管理中，哪个算法取决于磁头移动的顺序？</li>
</ol>
<p>SCAN，该算法会考虑当前磁头的移动方向</p>
<p>FCFS，先来先服务，该变方向就变方向</p>
<p>还有SSTF（确保距离最短），以及CSCAN（不变换方向，循环扫描）</p>
<ol start="10">
<li>假脱机技术主要用于</li>
</ol>
<p>在硬盘上提供一个区域存储I&#x2F;O请求，并通过输入输出进程按照顺序执行。</p>
<h4 id="判断题"><a href="#判断题" class="headerlink" title="判断题"></a>判断题</h4><ol>
<li>I&#x2F;O管理的核心是通过中断机制来处理I&#x2F;O请求</li>
</ol>
<p>错，感觉中断只是I&#x2F;O管理的一部分</p>
<ol start="2">
<li>设备驱动程序是操作系统与硬件之间的桥梁</li>
</ol>
<p>对</p>
<ol start="3">
<li>硬件和操作系统之间不需要任何交互</li>
</ol>
<p>错</p>
<ol start="4">
<li>在输入输出系统中，CPU对设备的访问是直接的</li>
</ol>
<p>错</p>
<ol start="5">
<li>缓冲区能够提高设备和CPU之间的速度匹配</li>
</ol>
<p>对</p>
<ol start="6">
<li>操作系统使用轮训机制来处理I&#x2F;O请求是比较高效的</li>
</ol>
<p>对</p>
<ol start="7">
<li>I&#x2F;O设备的驱动程序只能用于一个特定型号的设备</li>
</ol>
<p>对</p>
<ol start="8">
<li>中断机制使CPU在处理I&#x2F;O操作时完全停止运行，直到I&#x2F;O完成</li>
</ol>
<p>错</p>
<ol start="9">
<li>假脱机技术通过输入和输出进程和内存缓冲区实现从硬盘到其他I&#x2F;O外设的数据传输</li>
</ol>
<p>对</p>
<ol start="10">
<li>逻辑设备表用于记录实际物理设备的设备号、状态以及对应的物理设备信息</li>
</ol>
<p>错</p>
<h4 id="填空题"><a href="#填空题" class="headerlink" title="填空题"></a>填空题</h4><ol>
<li>I&#x2F;O系统的层次结构包括：I&#x2F;O硬件、中断处理程序、（驱动）程序、设备独立性软件、用户层软件</li>
<li>I&#x2F;O设备与控制器：数据信号线、控制信号线、状态信号线；控制器与处理器：数据信号线、控制信号线、地址信号线</li>
<li>I&#x2F;O通道是一种特殊的处理机，具有执行I&#x2F;O指令的能力，但是与一般处理机不同在于：1）指令较为简单；2）没有自己的内存空间与处理机共享</li>
<li>中断分为中断和陷入，也称为外中断和内中断</li>
<li>对于多中断源的情况处理方式有：1）屏蔽中断；2）嵌套中断；中断处理的过程：1）检测有没有中断信号，2）保存现场，3）中断复位，4）转入中断处理程序，5）恢复现场</li>
<li>设备驱动程序的主要功能是</li>
</ol>

        


        <span>
          <a class="article-read" href="/2025/10/23/OS/"> Read more -->
          </span>
        </div>

        
    
    <div class="recent-post-item">

      <a href="/2025/09/30/DBS/" class="item-title">DBS</a>
      
      <time datetime="2025-09-30T11:17:29.000Z">
        2025-09-30
      </time>
      
      <!-- <div class="article-digest"> -->
        <!-- 我在大学三年级的秋季学期选修了数据库系统导论这门课程，这篇blog用来记录：1）我对于相关知识点复习的梳理；2）一些习题；3）考试的重点
复习梳理复习梳理≠照搬原文，内容阐释点到为止，最重要的是达成两个目的1）梳理整体知识脉络，形成框架；2）标记重点，便于回到资料中复习；所以最后阶段的背诵记忆，应该用这份梳理为参考结合老师的资料进行
绪论这一章主要有4个部分，从前往后，1）在数据库系统概述中了解了与数据库有关的基本概念；2）在此基础上，为了把现实世界中的事物抽象为数据保存，我们学习了数据模型；3）有了抽象的数据模型之后，我们回到抽象的数据库系统，从整体上，探讨了数据库系统的三级模式；4）最后从细节上，了解了数据库系统的组成
数据库系统概述一些与数据库有关的基本概念
数据：定义&amp;基本对象、特点（语义）    数据库中存储的基本对象，描述事物的符号记录；数据库：定义（具有4个特点的集合）    数据库是长期存储在计算机内部的，有组织、可共享的大量数据的集合；数据库管理系统：定义（某位置的软件）；缩写DBMS；能力（了解）    位于用户与操作系统之间的一层数据库管理软件；数据库系统 -->
        <!-- </div> -->

        
        <p><code>我在大学三年级的秋季学期选修了数据库系统导论这门课程，这篇blog用来记录：1）我对于相关知识点复习的梳理；2）一些习题；3）考试的重点</code></p>
<h2 id="复习梳理"><a href="#复习梳理" class="headerlink" title="复习梳理"></a>复习梳理</h2><p><code>复习梳理≠照搬原文，内容阐释点到为止，最重要的是达成两个目的1）梳理整体知识脉络，形成框架；2）标记重点，便于回到资料中复习；所以最后阶段的背诵记忆，应该用这份梳理为参考结合老师的资料进行</code></p>
<h2 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h2><p>这一章主要有4个部分，从前往后，1）在数据库系统概述中了解了与数据库有关的基本概念；2）在此基础上，为了把现实世界中的事物抽象为数据保存，我们学习了数据模型；3）有了抽象的数据模型之后，我们回到抽象的数据库系统，从整体上，探讨了数据库系统的三级模式；4）最后从细节上，了解了数据库系统的组成</p>
<h3 id="数据库系统概述"><a href="#数据库系统概述" class="headerlink" title="数据库系统概述"></a>数据库系统概述</h3><p><code>一些与数据库有关的基本概念</code></p>
<p>数据：定义&amp;基本对象、特点（语义）<br>    数据库中存储的基本对象，描述事物的符号记录；<br>数据库：定义（具有4个特点的集合）<br>    数据库是<strong>长期存储</strong>在计算机内部的，<strong>有组织</strong>、<strong>可共享</strong>的<strong>大量数据</strong>的集合；<br>数据库管理系统：定义（某位置的软件）；缩写DBMS；能力（了解）<br>    位于用户与操作系统之间的一层数据库管理软件；<br>数据库系统：定义；构成（4）<br>    数据库+数据库管理系统+应用系统+数据库管理员；<br><em>关于数据库系统定义的理解（例如使用MySQL来管理数据的基础上，开发了一个实际的应用，就可以叫做数据库系统）</em>；</p>
<p><code>关于数据管理技术的发展，主要得注意DBS阶段和文件系统阶段的对比，以及数据库系统的特点</code></p>
<p>发展的阶段（3个阶段）</p>
<p><strong>阶段对比</strong>：</p>
<p>共享程度（无共享，很多冗余-差共享，多冗余-多共享，低冗余）；</p>
<p>独立性（不独立，依赖程序-差独立，数据逻辑结构改变需修改程序-高度物理独立性与一定的逻辑独立性）；</p>
<p>结构化情况（无结构-记录内有结构，整体无结构-整体结构化）；</p>
<p>数据控制能力（应用控制-应用控制-数据库管理系统自己控制）</p>
<p><em>讨论独立性的时候，讨论的是数据与应用程序的独立性</em>；</p>
<p><strong>数据库系统的特点（4个特点，对应前面四种对比的维度）</strong>：</p>
<p>数据结构化：主要特点之一；不局限某一个应用；最小存取单位，数据项</p>
<p>共享程度：面向整个系统，多个用户、应用</p>
<p>独立性：物理独立性（数据物理存储、应用程序）；逻辑独立性（数据库逻辑结构、应用程序）；保障（二级映像）</p>
<p>数据由DBMS统一管理：安全性、完整性、并发控制、错误恢复（稍微了解概念，每一点在后面都会作为章节展开）</p>
<h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><p>数据模型：通俗概念；工具定位</p>
<p><strong>数据模型的分类</strong>：</p>
<p>两类数据模型：概念模型（信息模型）&amp;逻辑模型和物理模型</p>
<p>概念模型的一种表示方法：实体-联系方法</p>
<p>逻辑模型包括：层次、网状、关系、面向对象、对象关系模型（逻辑模型是常用的，其中的关系模型更是我们重点学习的，因为其可以用于DBMS的实现）；<em>它们都是常用的数据模型</em></p>
<p>物理模型定位：对数据的最底层抽象，数据在系统内部或磁盘磁带上的存储方式与存取方法</p>
<p><strong>数据模型的组成要素</strong>：</p>
<p>数据结构：定义；对系统静态特性的描述</p>
<p>数据操作：定义；操作类型（查询、更新：插入、删除、修改）；对系统动态特性的描述</p>
<p>数据的完整性约束条件：定义（一组完整性规则的集合）；目的（数据正确、有效、相容）<br><em>有效对应符合规定的条件，相容对应满足数据间的一致性</em></p>
<p><strong>概念模型</strong>：</p>
<p>概念模型用途：信息世界建模</p>
<p>信息世界基本概念：实体（客观存在、可区别的事物）；属性（实体的特性）；码（<strong>唯一</strong>标识实体的<strong>属性集</strong>）；域（属性取值范围）；实体型；实体集；联系（事物内部、事物之间-属性间、实体集间）</p>
<p>联系的分类：一对一联系、一对多联系、多对多联系</p>
<p>E-R图：基本图形表示；各类联系的表示；码的表示；联系可以有属性</p>
<p><strong>层次模型</strong>：</p>
<p>数据库系统中最早出现的数据模型</p>
<p>满足的基本条件：1）有且仅有一个结点没有双亲结点，根结点；2）除根结点，其它结点有且只有一个双亲</p>
<p><strong>网状模型</strong>：</p>
<p>网状数据库系统的组织方式，网状模型；<em>层次模型是网状模型的特例</em></p>
<p>满足的基本条件：1）允许一个以上的结点无双亲；2）一个结点可以有多于一个双亲结点</p>
<p><strong>关系模型</strong>：</p>
<p>关系数据库系统的组织方式，关系模型；<em>几乎与所有计算机厂商退出的DBMS都支持关系模型，伟大无需多言~</em></p>
<p>关系模型的数据结构：关系（对应一张表，元组的集合）；元组（表中的一行）；属性（表中的一列，有名字）；码（属性组，唯一确定元组）；域；分量（元组的一个属性值）；</p>
<p>关系模型的操作：查询、插入、删除、更新；<em>集合操作，操作对象与结果都是关系，即元组的集合</em></p>
<p>关系模型的完整性约束：实体完整性、参照完整性、用户定义的完整性</p>
<p>关系模型的存储结构：实体以及联系都用表来进行（这也是关系模型的优点，概念单一）；<em>突然出现实体、联系的描述，我的理解：概念模型完成了对信息的建模，现在使用逻辑模型中的关系模型让这些抽象的信息建模具有逻辑关系，这里的逻辑关系指的是面向计算机编程的抽象逻辑，其对立面是真实的物理情况，而非抽象信息建模之间的逻辑关系（在概念模型的阶段就完成了）</em></p>
<p>关系模型的缺点：存取路径对用户隐蔽，可能导致用户使用效率较低的查询<br>关系的描述：关系模式；</p>
<p>关系的规范化：必需确保；<em>最基本的规范条件是，关系的每一个分量是不可分的数据项，绝不允许表中有表。否则就是非规范关系</em></p>
<h3 id="数据库系统的结构"><a href="#数据库系统的结构" class="headerlink" title="数据库系统的结构"></a>数据库系统的结构</h3><p>数据库系统的结构：三级模式结构，外模式-模式-内模式，外模式&#x2F;模式映像（逻辑独立性），模式&#x2F;内模式映像（物理独立性）</p>
<p>模式：数据库中<strong>全体数据</strong>的逻辑结构和特征的描述；需要对型进行描述；相对稳定；反映数据结构和联系</p>
<p>外模式：用户能够看见的局部数据的逻辑结构和特征描述</p>
<p>内模式：数据物理结构和存储方式的描述</p>
<p>型：对数据结构及属性的说明；（类比实体型，都是类似于“类”的概念）</p>
<p>值：型的具体赋值</p>
<p>实例：将模式整体看作一个型，实例就是值；反映了数据库某一个时刻的状态</p>
<h3 id="数据库系统的组成"><a href="#数据库系统的组成" class="headerlink" title="数据库系统的组成"></a>数据库系统的组成</h3><p>组成：数据库DB、数据库管理系统（及开发工具）DBMS、应用系统、数据库管理员DBA</p>
<h3 id="小结重点"><a href="#小结重点" class="headerlink" title="小结重点"></a>小结重点</h3><p>数据库系统概述：1）数据库基本概念；2）数据管理的发展过程</p>
<p>数据模型：1）数据模型的三要素；2）概念模型，E-R模型；3）三种主要数据库模型（层次、网状、关系，当然关系最重要）</p>
<p>数据库系统的结构：1）三级模式结构；2）数据库系统两层映像系统结构</p>
<p>数据库系统的组成</p>
<h2 id="关系数据库"><a href="#关系数据库" class="headerlink" title="关系数据库"></a>关系数据库</h2><h3 id="关系数据结构及形式化定义"><a href="#关系数据结构及形式化定义" class="headerlink" title="关系数据结构及形式化定义"></a>关系数据结构及形式化定义</h3><h4 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h4><p>关系模型的数据结构：关系，<strong>在用户角度</strong>，关系是一张二维表，列对应属性，行对应元组</p>
<p>关系定义的前置知识：</p>
<ol>
<li>域（Domain）：一组具有相同数据类型的值的集合</li>
<li>笛卡尔积：给定一组域，其笛卡尔积为一个集合，其中的元素形式为(d1,d2,…,dn)，di为分量，是来自域Di的值，将所有域中的进行组合得到类似的元素，然后形成的集合就是笛卡尔积</li>
<li>元组，2.中提到的元素就是元组</li>
<li>分量，元组的分量的值，简称分量</li>
</ol>
<p>于是，笛卡尔积可以表示为一个二维表，其中的每一行对应一个元组，每一列的值来自一个域</p>
<p>关系：域D1、D2、…、Dn的笛卡尔积的子集，即在D1，D2，…，Dn上的关系，表示为R(D1,D2,…,Dn)，其中R就是关系名，而n可以叫做<strong>关系的目或度</strong>（n&#x3D;1时为单元关系，n&#x3D;2时为二元关系）</p>
<p>元组的表示：通常用t进行标识</p>
<p>关系的表示：可以将关系看作一个二维表，行对应元组，列对应域</p>
<p>属性：属性的引入是类似给域取了一个名字，毕竟域作为一个值的集合本身并没有名字，我们给它取一个名字可以反映这组值代表的含义。（这也是我们通常更关注的东西，例如对于一列元组的字符串分量值，比起关心它们都是字符串，我们更关心它们的实际含义，例如它们都代表名字）</p>
<p>码：<br><em>后面的章节中有更加严谨的定义，这里看看就好</em>；</p>
<ol>
<li>候选码：关系中某一属性组的值能够唯一标识一个元组，则该属性组是候选码</li>
<li>全码：当一个关系的候选码是所有属性构成的属性组时，该属性组称为全码</li>
<li>主码：如果一个关系有多个候选码的时候，则选定一个作为主码（注意，候选码本身也可能是属性组）</li>
<li>主属性：候选码对应属性组中的各个属性都是主属性（主属性不是主码的属性）</li>
<li>非主属性：不包含在任何候选码中的属性，即非主属性</li>
</ol>
<p>三类关系：</p>
<ol>
<li>基本关系：基本表，实际存在的表</li>
<li>查询表</li>
<li>视图表：由基本表或其他视图表导出的表，是虚表，不对应实际存储的数据</li>
</ol>
<p>基本关系的性质：</p>
<ol>
<li>列是同质的（相同数据类型、性质）</li>
<li>不同列可以出自同一个Domain</li>
<li>行、列顺序无所谓</li>
<li>任意两个元组的候选码不能相同</li>
<li>分量必须取原子量，不可再分（不能表中有表）</li>
</ol>
<h4 id="关系模式"><a href="#关系模式" class="headerlink" title="关系模式"></a>关系模式</h4><p>关系模式实际上就是对关系的描述，<strong>关系模式是型，关系是值</strong></p>
<p>关系模式形式化表示：R(U,D,DOM,F)</p>
<ol>
<li>R关系名</li>
<li>U属性名集合</li>
<li>D属性 来自的 域 的集合</li>
<li>DOM属性向域的映像集合</li>
<li>F属性间依赖关系集合</li>
</ol>
<p>关系模式常用表示：R(A1,A2,…,An)</p>
<ol>
<li>R是关系名</li>
<li>A1～An是属性名<br>（实际使用的时候通常将<strong>候选码写在前面，分别用下划线强调</strong>；如果是关系组形成的候选码则下划线不间断）</li>
</ol>
<p>关系模式是静态的、稳定的；关系是动态的、变化的</p>
<h4 id="关系数据库-1"><a href="#关系数据库-1" class="headerlink" title="关系数据库"></a>关系数据库</h4><p>定义：给定应用领域，所有实体及实体之间的联系 的关系 的集合 构成一个关系数据库<br><strong>结合实验1进行理解</strong></p>
<h3 id="关系操作"><a href="#关系操作" class="headerlink" title="关系操作"></a>关系操作</h3><p>常用操作分为两大类：</p>
<ol>
<li>查询</li>
<li>数据更新</li>
</ol>
<p>查询包括：1）选择；2）投影；3）并；4）差；5）笛卡尔积；6）连接；7）除；8）交</p>
<p>注：<strong>上述前五种是基本操作</strong></p>
<p>数据更新包括：1）插入；2）删除；3）修改</p>
<p>关系操作的特点：操作的所有对象以及结果都是<strong>集合</strong>（这是很自然的，因为关系本身就是集合）</p>
<p>常用的关系数据库语言：</p>
<ol>
<li>关系代数语言ISBL</li>
<li>关系演算语言</li>
<li>具有1、2的双重的语言，如SQL</li>
</ol>
<h3 id="关系的完整性"><a href="#关系的完整性" class="headerlink" title="关系的完整性"></a>关系的完整性</h3><p>关系有三类完整性约束：</p>
<h4 id="实体完整性"><a href="#实体完整性" class="headerlink" title="实体完整性"></a>实体完整性</h4><p>实体完整性规则：一个或一组属性A是<strong>基本关系</strong>R的<strong>主属性</strong>，则A<strong>不能取空值</strong></p>
<p>细节说明：</p>
<ol>
<li>实体完整性针对基本表（对应现实世界实体集合）</li>
<li>主码不可重复，让实体可区分</li>
<li>关系模型中主码作为唯一标识（这里已经不再强调候选码了，尽管其仍然存在）</li>
<li>主属性不能取空值</li>
</ol>
<h4 id="参照完整性"><a href="#参照完整性" class="headerlink" title="参照完整性"></a>参照完整性</h4><p>关系间的引用：由于实体 实体间的联系 都被抽象为关系，所以可能存在关系间的引用（尤其是在表示联系的时候，考虑一下SC和Student、Course就明白了）</p>
<p><strong>外码</strong>：F是R的属性，且非主码  对应了S的主码   则F是R的外码</p>
<ol>
<li>R是<strong>参照关系</strong></li>
<li>S是<strong>被参照关系</strong></li>
</ol>
<p>注意：</p>
<ol>
<li>参照关系与被参照关系<strong>不一定是不同关系</strong>（班长的例子）</li>
<li>外码 与 对应的主码 一定在同一Domain</li>
<li>通常：1）若参照关系与被参照关系上同一关系，外码与对应主码不同名；2）若参照关系与被参照关系不是同一关系，外码与主码同名</li>
</ol>
<p><strong>参照完整性约束</strong>：若属性是基本关系的<strong>外码</strong>，则其 或<strong>取空值</strong> 或等于<strong>对应主码的某个值</strong></p>
<h4 id="用户定义的完整性约束"><a href="#用户定义的完整性约束" class="headerlink" title="用户定义的完整性约束"></a>用户定义的完整性约束</h4><p>结合实验2的表项自己的限制 or 表项之间的限制 理解即可</p>
<h3 id="关系代数"><a href="#关系代数" class="headerlink" title="关系代数"></a>关系代数</h3><p><em>这里的笔记只是一些基础概念，要结合试题进行练习，期末会考察10分</em></p>
<p>关系代数是一种具体的关系数据库语言，具备相应的关系操作（<strong>关系代数中称为关系运算</strong>），以及完整性约束？或许，总之在这一部分我们学习了一种具体的关系数据库语言，并且着重关注其中的关系运算部分。（后续还有关系演算、SQL标准语言）</p>
<h4 id="运算符的前置知识"><a href="#运算符的前置知识" class="headerlink" title="运算符的前置知识"></a>运算符的前置知识</h4><p>它们的作用主要是作为一种语言，来对下面的各个运算符进行定义</p>
<ol>
<li>关系$R$</li>
<li>元组$t$</li>
<li>属性$A$</li>
<li>元组的属性值$t[A_i]$</li>
<li>剩余属性组</li>
<li>$t_r$与$t_s$连接的新元组</li>
<li><strong>象集</strong>$Z_x$，若属性Z、X是关系R的属性，则在R上象集$Z_x$是X属性值为x的元组的Z属性值的集合</li>
</ol>
<p>象集对于理解除运算很重要，其实就是属性值的集合，只是要明白这个属性值时如何取出来的</p>
<h4 id="集合运算符"><a href="#集合运算符" class="headerlink" title="集合运算符"></a>集合运算符</h4><ol>
<li>并 $\cup$</li>
<li>交 $\cap$</li>
<li>差 $\sub$</li>
<li>笛卡尔积 $\times$</li>
</ol>
<p>并、交、差：若关系R、S进行前三种运算，则<strong>R、S具有的属性一定相同</strong><br>笛卡尔积：$R\times S$，运算规则类似双重for循环，对R的每一个元组，与S的每一个元组完成一次组合，生成一个新的元组，其各属性名为$R.XXX…S.YYY…$</p>
<h4 id="专门的关系运算符"><a href="#专门的关系运算符" class="headerlink" title="专门的关系运算符"></a>专门的关系运算符</h4><ol>
<li>选择 $\sigma_F$</li>
<li>投影 $\Pi_A$</li>
<li>连接 $\bowtie$（自然连接的符号）</li>
<li>除 $\div$</li>
</ol>
<p>前三个符号的说明：</p>
<ol>
<li>选择是单目运算符 运算时对每个元组 判断逻辑表达式F对真假 为真则选中保留进入结果表格</li>
<li>投影是单目运算符 运算时对整个关系 保留选定的属性（组）A 进入结果表格</li>
<li>连接符号是双目运算符 运算时对关系R的每个元组 进行类似笛卡尔积时的双重循环 但完成一对元组的连接并纳入结果表 条件是逻辑表达式F被满足（普通的连接符号在$\bowtie$下面有逻辑表达式F）</li>
</ol>
<p>对连接进行补充：</p>
<ol>
<li>自然连接 额外的条件是进行运算的两个关系<strong>一定有相同的属性（组）</strong>，连接条件默认是元组的相同属性（组）值，相同即连接</li>
<li>左外连接，以左边为准进行双重for循环的遍历，即使右侧没有出现满足条件的元组，可以让外层for循环，当前选中的左侧元组，也要保留该元组值，对应新元组的右侧关系属性值设置为NULL</li>
<li>右外连接，与左外连接类似，以右侧为标准（将右侧关系的元组放在双重for循环的外层）</li>
<li>外连接，左外连接与右外连接结果的并</li>
</ol>
<p>注：上面对for循环的描述只是为了大脑思考的时候便于理解，实际上把谁放在外层循环，先做后做都是等价的</p>
<p><strong>关于除运算</strong>：</p>
<ol>
<li>R与S进行除运算的条件，R与S有相同的属性（组）</li>
<li>$R(X,Y)\div S(Y,Z)$的结果是以$X$的属性值，形成的元组的集合</li>
<li>满足条件的属性值，要求关系S的$Y$是R上象集$Y_x$的子集</li>
</ol>
<p>除运算的过程，对于R的每一个元组，找到其X属性值，然后看一看对应的象集$Y_x$，即同样具有该属性值的所有元组的所有Y值有哪些，如果这些值覆盖了S的所有Y值，那么该X属性值可以纳入结果。</p>
<h3 id="关系演算"><a href="#关系演算" class="headerlink" title="关系演算"></a>关系演算</h3><p>以数理逻辑的谓词演算为基础，主要是两种类型</p>
<ol>
<li>元组关系演算（ALPHA）</li>
<li>域关系演算（QBE）</li>
</ol>
<p>我们学习过的是元组关系演算</p>
<p><strong>这一部分可以稍作了解，但是最重要的是明确——理解关系演算对SQL查询语句的执行很有帮助</strong>。</p>
<h2 id="数据库系统"><a href="#数据库系统" class="headerlink" title="数据库系统"></a>数据库系统</h2><h3 id="SQL概述"><a href="#SQL概述" class="headerlink" title="SQL概述"></a>SQL概述</h3><p><em>SQL语句拿不准的要写注释</em></p>
<p>SQL：结构化查语言，关系数据库的标准语言</p>
<p>SQL的特点：</p>
<ol>
<li>综合统一：DDL、DQL、DML、DCL集于一体</li>
<li><strong>高度非过程化</strong>：只需要注意做什么，无需关注怎么做</li>
<li>面向集合的操作方式：操作的对象与结果都是元组的集合</li>
<li>同一种结构提供多种功能：既是独立语言也是嵌入式语言</li>
<li>语言简洁，易学易用：9个核心动词，完成核心功能（对应的就是<strong>DDL</strong> CREATE DROP ALTER、<strong>DQL</strong> SELECT、<strong>DML</strong> INSERT DELETE UPDATE、<strong>DCL</strong> GRANT REVOKE）</li>
</ol>
<p>注意理解<strong>非过程化</strong>、<strong>面向集合</strong></p>
<p>SQL对于关系模式数据库的支持：SQL的存储文件对应内模式、基本表对应模式、视图对应外模式，由SQL统一管理</p>
<ol>
<li>存储数据库组织关系数据库的内模式、物理结构对用户透明</li>
<li>基本表，对应SQL一个关系，本身独立存在</li>
<li>视图，数据库中只存放视图的定义，不存放视图对应的数据，视图是一个虚表</li>
</ol>
<h3 id="DDL语句"><a href="#DDL语句" class="headerlink" title="DDL语句"></a>DDL语句</h3><p>DDL：数据定义语言</p>
<p>在SQL的DDL语言如下</p>
<ol>
<li>CREATE</li>
<li>DROP</li>
<li>ALTER</li>
</ol>
<h4 id="模式DDL"><a href="#模式DDL" class="headerlink" title="模式DDL"></a>模式DDL</h4><p>这一部分了解就好，知道有一个<strong>模式</strong>SCHEMA的存在，类似于命名空间。</p>
<p>每一个基本表都属于某一个模式</p>
<p>一个模式可以包含多个基本表</p>
<h4 id="基本表DDL"><a href="#基本表DDL" class="headerlink" title="基本表DDL"></a>基本表DDL</h4><p><strong>创建基本表</strong>的基本范式</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">CREATE TABLE &lt;name &gt;</span><br><span class="line">(</span><br><span class="line">    &lt;col name &gt; &lt;data <span class="built_in">type</span> &gt; [列级完整性约束]</span><br><span class="line">    [, ...] [...]</span><br><span class="line">    [, 表级完整性约束]</span><br><span class="line">    [, ...]</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注：如果完整性约束涉及多个列，那必须定义在表级</p>
<p>在这一部分<strong>应该掌握的语句</strong></p>
<ol>
<li>基本范式的最基础使用</li>
<li>常用的data type：CHAR(length) SMALLINT INT REAL DATE TIME</li>
<li>指定某一列为主码，指定多个列一起作为主码</li>
<li>指定某一列取值唯一</li>
<li>指定某一列不能为空值</li>
<li>指定外码</li>
</ol>
<p><strong>修改基本表</strong>的基本范式</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ALTER TABLE &lt;name &gt;</span><br><span class="line">[ADD &lt;col name&gt; &lt;data <span class="built_in">type</span>&gt; &lt;完整性约束&gt;] //增加新列</span><br><span class="line">[DROP &lt;col name&gt; &lt;完整性约束&gt;] //删除列，注意删除的时候要附上该列的完整性约束</span><br><span class="line">[ALTER COLUMN &lt;col name&gt; &lt;data <span class="built_in">type</span>&gt;]; //更改列的数据类型</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注：</p>
<ol>
<li>新增加的列在已有元组中默认为空值NULL</li>
<li>ADD有直接添加完整性约束的用法，类似<code>ADD UNIQUE(Cname)</code></li>
</ol>
<p><strong>删除基本表</strong>的基本范式</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">DROP TBALE &lt;name &gt;</span><br><span class="line">[CASCADE | RESTRICT];</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注：</p>
<ol>
<li>CASCADE对应级联删除，删除该表的同时其所有的依赖对象（FOREIGN KEY引用、VIEW…都会被一起删除）</li>
<li>RESTRICT，如果该表还有其他依赖的话则erro，否则删除</li>
</ol>
<h4 id="索引DDL"><a href="#索引DDL" class="headerlink" title="索引DDL"></a>索引DDL</h4><p><code>关于索引也是了解就好，知道有这个东西的存在</code></p>
<p>索引的目的：加快查询速度</p>
<p>索引的分类</p>
<ol>
<li>唯一索引</li>
<li>非唯一索引</li>
<li>聚簇索引</li>
</ol>
<p>索引是关系数据库的内部实现技术，属于内模式的范畴，常用的实现方式有B+树索引、HASH索引等</p>
<p>注：<strong>一个基本表上最多只能建立一个聚簇索引</strong></p>
<h3 id="DQL语句"><a href="#DQL语句" class="headerlink" title="DQL语句"></a>DQL语句</h3><p>这一部分是数据查询语言，基本上都是在基本表上进行的</p>
<p>基本范式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SELECT [DISTINCT|ALL]&lt;目标列表表达式 &gt; [,&lt;目标列表表达式&gt;...] </span><br><span class="line">FROM &lt;表名 or 视图名 &gt; [,&lt;表名 or 视图名 &gt;...]</span><br><span class="line">[WHERE &lt;条件表达式&gt;]</span><br><span class="line">[GROUP BY &lt;col name&gt;]</span><br><span class="line">[HAVING &lt;条件表达式&gt;]</span><br><span class="line">[ORDER BY &lt;col name&gt; [ASC|DESC]];</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="单表查询"><a href="#单表查询" class="headerlink" title="单表查询"></a>单表查询</h4><p><code>单表查询部分在逻辑上理解不困难，难点主要是掌握各种语句的用法，这里主要采用列举例题与对应知识点的形式，复习的时候要做到看到例题能够想到考察的知识点与对应的查询语句是什么</code></p>
<p>选择指定列<br>    eg：查询学生表中的学号、姓名；</p>
<p>查询全部列<br>    eg：查询学生表的信息；</p>
<p>查询经过计算的表达式<br>    算数表达式<br>        eg：查询学生的出生年份<br>    字符串常量<br>        主要作用是对结果进行修饰，对应输入的字符串常量在结果中单独占一列，其相对于其他列的位置由查询语句确定，独占的一列从属性名到所有的属性值都是该字符串常量<br>    函数：LOWER、UPPER等（作用是对相应的属性列中的属性值，全部显示经过函数处理该属性值的结果）<br>        eg：查询学生姓名以及对应的所在院系，院系名称全部用小写<br>    列别名：别名紧跟在属性名之后，不加逗号；（对比查询不同属性列时用逗号隔开）<br>        eg：查询所有学生的出生日期，并使用列别名让结果对用户更友好</p>
<p>选中表中的若干元组<br>    对查询结果去重与否<br>        SELECT DISTINCT&#x2F;ALL Sno…（缺省默认ALL）<br>    查询满足条件的元组<br>        WHERE<br>            比较：&#x3D; &gt; &lt; &gt;&#x3D; &lt;&#x3D; !&#x3D; &lt;&gt; !&gt; !&lt;<br>                eg：查询计算机专业的学生<br>            确定范围：BETWEEN AND&#x2F; NOT BETWEEN AND<br>                eg：查询年龄在13到15的学生<br>            与集合的关系：IN&#x2F; NOT IN<br>                eg：查询是计算机或信息技术或数学系的学生<br>            字符匹配：LIKE&#x2F; NOT LIKE<br>                eg：查询姓刘的学生；查询姓欧阳并且全名三个字的学生<br>            空值：IS NULL&#x2F; IS NOT NULL<br>            多重条件：AND&#x2F; OR&#x2F; NOT</p>
<p>对查询结果排序<br>    ORDER BY 指定排序参考的属性，默认ASC升序、DESC是降序<br>    当排序含有空值的时候，若为ASC空值会最后显示；若为DESC空值会最先显示（空值被作为了最大值）<br>    可以有多个排序条件（靠前的条件优先级更高，当靠前的条件对应的属性值是相同的时候则会使用下一个条件进一步排序；结果就好像每个元组被分为了一个个整体，并且整体内有序）<br>    eg：查询全体学生情况，结果按所在系的系号升序排序，同一系中的学生按年龄降序排序</p>
<p>对查询的属性列使用聚集函数<br>    COUNT<br>        DISTINCT&#x2F; ALL是可选的，后者是默认的；<br>        COUNT的效果是统计查询到的元组的个数 or 某属性列值的个数，对应的结果是仅有一个数字属性的元组，代表原先有多少元组；<br>        所以COUNT一般是单独使用的；<br>        eg：查询学生的总人数；查询选修了课程的学生人数<br>    SUM<br>        DISTINCT&#x2F; ALL是可选的，前者是默认的；<br>        计算一列值的总和，要用于数值型的属性列<br>        eg：查询1号学生选修课程的总学分<br>    AVG<br>        DISTINCT&#x2F; ALL是可选的，前者是默认的；<br>        计算一列值的平均值，要用于数值型的属性列<br>        eg：计算1号学生的平均成绩<br>    MAX<br>        求一列中的最大值，一般用于数值型<br>        eg：查询1号学生选修课程的最高分<br>    MIN<br>        求一列中的最小值，一般用于数值型</p>
<p>分组查询<br>    GROUP BY语句，目的是为了让聚集函数可以更加细粒度地进行使用<br>    一般不会单独使用，不会有视觉上的“分组效果”，如果要有的话应该使用多层排序<br>    两种用法：<br>        分组+聚集函数，聚集函数的作用效果上组内的所有元组<br>            eg：查询选修每个课程对应的学生人数<br>        分组+聚集函数+筛选组，HAVING语句，以组为单位进行筛选<br>            eg：找出选修了5门及以上课程的学生学号<br>            （注意HAVING与WHERE的区别）</p>
<h4 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h4><p><code>要求与单表查询类似，只是要深入理解连接的作用与效果</code></p>
<p>各种连接查询的共同点<br>    在FROM之后有多个表<br>    如果表中有相同的属性的话，使用的时候要用TABLE_NAME.COL的形式<br>    在WHERE之后使用来自各表中的属性，规定连接条件<br>    在脑海中考虑连接查询的过程，要先根据连接条件在脑子里有一个连接后的表的印象，然后将其考虑为单表，在其上进一步查询</p>
<p>等值连接（自然连接）与非等值连接<br>    等值连接<br>        在WHERE连接条件中，出现来自各表等属性满足“&#x3D;”关系<br>    自然连接<br>        在等值连接的基础上，来自各表的属性是同一属性<br>        eg：查询每个学生及其选修课的情况<br>    非等值连接（不常用）</p>
<p>自身连接<br>    一个表与自己连接，要求：给表取别名，用别名访问属性，这样才能区别开<br>    eg：查询一门课的先修课的先修课</p>
<p>外连接<br>    使用语句FROM ? LEFT OUTER JOIN ? ON (F)，这是左外连接，左边的是主表，F是外连接的条件；区别在于即使不满足条件的时候也会将主表保留下来，对应元组在连接后的表中没有的属性值置为空值<br>    类似的还有RIGHT OUTER JOIN<br>    eg：查询每个学生及其选修课程（当然不能因为没选修课程而将对应的学生忽略）</p>
<p>多表连接<br>    FROM后跟有多个表名，对应的要在WHERE中注明连接条件<br>    考虑的时候，可以先考虑两个表连接成一张大表，在考虑这张大表与下一张表做对应的连接</p>
<h4 id="嵌套查询"><a href="#嵌套查询" class="headerlink" title="嵌套查询"></a>嵌套查询</h4><p>查询块：<br>    一个SELECT语句作为一个完整的查询块（当然可以配套其他关键字使用）</p>
<p>嵌套查询：<br>    将一个查询块嵌套在另一个查询块的WHERE子句或者HAVING短语条件中<br>    eg：查询选修了课程名为IS的课程的学生的学号</p>
<p>不相关子查询：<br>    定义：子查询的查询条件不依赖于父查询<br>    处理：这种可以逐层考虑，因为各层查询基本上是独立的</p>
<p>相关子查询<br>    定义：子查询的条件依赖于父查询<br>    处理：<br>        1）这种考虑的时候通常，按上层查询的元组进行考虑，对于上层查询的每一个元组会做一次子查询；而元组则作为子查询可能用到的条件（就像将元组作为参数去调用作为函数的查询一样）<br>        2）上层查询和下层查询如果用到了同一关系，需要给关系取别名<br>    eg：查询学生选课记录中，学生高于自己选修课程的平均分的选课记录中的学号和课程号</p>
<p>子查询的限制：<br>    1）不能使用ORDER BY子句，因为ORDER BY子句只能对最终结果进行排序<br>    2）子查询一定要在比较符之后（写SQL语句的时候，不能头重脚轻）</p>
<p>常见的嵌套查询：<br>    1）带IN谓词的子查询<br>        应用场景：通常用于检查上层查询中的某个元组的某属性是否在一些满足特定条件的集合中，由于集合的构造逻辑比较复杂所以要用一个子查询来进行描述。<br>        eg：<br>            1）查询所有与刘晨同学在相同系进行学习的学生学号、姓名和年龄<br>            2）查询选修了“信息系统”这门课程的学生的学号和姓名<br>    2）带有比较运算符的子查询<br>        应用场景：<br>            一般是用于上层元组的可比较属性需要满足特定条件时，该条件的构造比较复杂所以用子查询描述；<br>            子查询要返回一个单值；<br>            需要使用IN的场景，并且子查询返回的是单值，可以用”&#x3D;”<br>        eg：<br>            查询每个学生超过他自己所有选修课程的平均成绩的课程号<br>    3）带有ANY（SOME）或ALL谓词的子查询<br>        应用场景：<br>            常与带有比较运算符的子查询一起用，使用ANY（SOME）or ALL来描述上层查询需要满足的更加复杂的条件<br>            ANY和SOME是等价的，只是两种记法。和比较运算符一起用的常见情况：<br>                1）&gt;ANY，大于子查询中某个值即可<br>                2）&gt;ALL，大于子查询中所有的值<br>                （其他比较类似，ANY要求有某个子查询的结果满足就可以视上层元组满足条件；ALL则要求子查询的所有结果都满足才行）<br>        eg：<br>            1）查询其他系中比计算机科学系所有学生年龄都小的学生姓名及年龄（比年龄最小的还小）<br>        注意：<br>            ANY和ALL可以实现的效果，也可以在带有比较运算符中运用MIN、MAX聚集函数来实现（语义上的等价，很好理解）<br>    4）带有EXISTS谓词的子查询<br>        应用场景：<br>            带有EXISTS谓词的子查询不会返回任何数据，只会返回true or false（子查询有数据 or 没有数据），作为对上层元组是否满足条件的判断；<br>            由于上述特点，所以其应用场景一般是相关子查询，要用上层查询的元组与子查询构造条件<br>        eg：<br>            1）查询所有选修了1号课程的学生姓名<br>            2）查询没有选修1号课程的学生姓名<br>            3）查询与刘晨在同一个系学习的学生<br>        注意：<br>            1）NOT EXISTS的用法和EXISTS类似，只是返回true、false的情况是反着的；<br>            2）由于使用EXISTS谓词不会关注其返回的信息，所以子查询通常用SELECT *；<br>            3）前面所有的子查询都可以用EXISTS实现</p>
<h3 id="DML语句"><a href="#DML语句" class="headerlink" title="DML语句"></a>DML语句</h3><p>对数据（元组）的操作<br>    插入数据<br>        INSERT INTO … VALUES…<br>        （省略号处是表名和属性列；VALUES后要使用对应属性列的常量）<br>        注意：<br>            1）带子查询的插入数据：对应VALUES…部分由SELECT语句替换，该语句要返回与INTO后指定的各列一致的数据<br>        eg：<br>            1）将张成名的信息插入Student表<br>            2）对于每一个系，求学生的平均年龄，插入表格中；对应属性（系名，平均年龄）<br>    修改数据<br>        UPDATE…（指定表名）<br>        SET…（设置列名对应的属性值，属性值可以是表达式）<br>        …（WHERE附加的条件）<br>        注意：<br>            1）附加的条件一般来说是必要的，否则就是对整列进行修改<br>            2）带子查询的修改，一般是将相关子查询用在WHERE中，构造较为复杂的修改判断条件<br>        eg：<br>            1）将学生200215121的年龄修改为22岁<br>            2）将计算机系全体学生成绩置0<br>    删除数据<br>        DELETE<br>        FROM…<br>        …（WHERE附加的条件）<br>        注意：<br>            1）与修改数据类似，在不附加条件的情况下会删除所有元组，但是表仍然存在<br>            2）子查询与修改不同的点，DELETE实际上是要用WHERE指定特定的删除对象的<br>            （通常是用WHERE条件指定候选码，从而删除指定的元组；毕竟是以元组为单位操作的，如果单独删除某列数据没有意义，这与UPDATE不同）<br>        eg：<br>            1）删除计算机系所有学生的选课记录<br>            2）删除计算机系所有学生的选课记录</p>
<h3 id="空值处理"><a href="#空值处理" class="headerlink" title="空值处理"></a>空值处理</h3><p>空值的产生<br>    1）插入<br>    2）修改</p>
<p>空值的判断<br>    1）IS NULL<br>    2）IS NOT NULL</p>
<p>空值的约束<br>    1）CREATE语句中若对属性列使用了NOT NULL、UNIQUE进行限制，不能取空值<br>    2）码属性不能为空值（PRIMARY KEY）</p>
<p>空值的运算<br>    1）有空值的算数运算为空值<br>    2）有空值的比较运算为UNKNOWN<br>    3）有空值的逻辑运算为True或FALSE或Unkonw：<br>        类似于：F&gt;U&gt;T(AND);T&gt;U&gt;F(AND);!U&#x3D;U</p>
<h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p>视图<br>    定义：虚表，是从一个或几个基本表（或视图）导出的表，数据库中只存放其定义，不存放相应的数据<br>    注意：<br>        如果一个视图是从一个基本表导出来的，则它是行列子集视图</p>
<p>视图定义<br>    CREATE VIEW …（不指定对应全部列 or 指定列）<br>    AS …（子查询，要与VIEW后的对应列相匹配）<br>    …<br>    （WITH CHECK OPTION，可选的，一般在子查询中存在WHERE语句的时候启用，启用后对视图的插入和修改会保证元组满足WHERE条件）<br>    注意：<br>        1）创建的时候可以基于多个表，只需在子查询中指定即可，但无论如何子查询返回的数据要与VIEW的属性列相匹配<br>        2）创建的时候也可以基于视图，子查询中对视图查询即可<br>        3）子查询中对属性列可以使用表达式；子查询中可以使用分组+聚集函数；都是为了满足视图的信息需要</p>
<p>删除视图<br>    DROP VIEW 视图名 …（是否用CASCADE）<br>    注意：<br>        1）对应删除了视图的定义<br>        2）如果该视图上导出了其他视图，要用CASCADE及联删除</p>
<p>查询视图<br>    与查询基本表相同</p>
<p>更新视图<br>    对视图使用INSERT、UPDATE、DELETE起头的语句，即视图的更新<br>    注意：<br>        1）行列子集视图可以进行更新<br>        2）常见的不能更新的视图：<br>            视图由两个以上基本表导出；<br>            视图上定义的视图不能更新；<br>            视图中的一个元组的数据对应来自基本表中的多个数据不能更新（这种情况可能由子查询有聚集函数、GROUP BY语句、DISTINCT短语…导致）</p>
<p>视图的作用：<br>    1）能够简化用户的操作<br>    2）使用户以多种视角看待同一数据<br>    3）对重构数据库提供了一定程度的逻辑独立性<br>    4）对机密数据提供安全保护<br>    5）更清晰地表达查询</p>
<h2 id="数据库安全性"><a href="#数据库安全性" class="headerlink" title="数据库安全性"></a>数据库安全性</h2><p><code>重点是数据库安全的策略、SQL授权语句</code></p>
<p>数据库安全性：数据库安全性是指保护数据库，防止不合法使用所造成的数据泄露、更改或破坏；</p>
<p>数据库安全性控制的常用方法：<br>    1）用户身份鉴别；<br>        地位：DBMS提供的最外层安全保护措施；<br>        含义：<br>            每个用户在系统中有一个用户标识，由用户名和用户标识号组成（user name 和 UID），对此标识进行鉴别，确定是否是对应用户；<br>        常用方法：<br>            静态口令，eg：密码；<br>            动态口令，eg：短信密码、动态令牌；<br>            生物特征，eg：指纹；<br>            智能卡，不可复制的硬件；<br>    2）多层存取控制；<br>        存取控制：<br>            机制组成：<br>                1）用户权限的定义；<br>                2）合法权限的检查；<br>        自主存取控制方法（DAC）；<br>            安全等级：C2，灵活<br>            实现方式：<br>                GRANT、REVOKE语句；<br>        强制存取控制方法（MAC）；<br>            安全等级：B1，严格<br>            适用于对数据由严格而固定密级分类的部分，例如军事部门、政府部门；<br>                方法：<br>                    主体：DBMS所管理的实际用户；<br>                    客体：各用户的进程；<br>                        eg：操作文件、基本表、索引、视图；<br>                    敏感度标记：<br>                        1）绝密；<br>                        2）机密；<br>                        3）可信；<br>                        4）公开；<br>                        注意：<br>                            1）主体与客体都有敏感度标记；<br>                            2）主体的称为：许可证级别；<br>                            3）客体的称为：密级；<br>                    规则：<br>                        1）读取：仅当主体许可证级别大于或等于对应客体的密级，才能让主体读取客体；<br>                        2）写入：仅当主题许可证级别等于对应客体时才能写入<br>                        3）同级读写，高级可读；<br>    3）审计；<br>        审计日志：<br>            保存用户的所有操作记录，DBA可以找到非法存取数据的人、时间、内容；<br>        用户级审计：<br>            针对自己创建的数据库表或视图进行审计；<br>        系统级审计：<br>            检测成功或失败的登陆要求；<br>            检测GRANT、REVOKE操作以及其他数据库级权限下的操作；<br>    4）视图；<br>        将要保密的数据对无权存取这些数据对用户隐藏起来，对数据提供一定程度的安全保护；<br>    5）数据加密；<br>        根据一定的算法将原始数据变换为不可直接识别的格式；<br>        存储加密、传输加密；</p>
<p>自主存取控制：<br>    GRANT语句的使用；<br>        1）一般用法；<br>        2）授权所有权限：GRANT ALL PRIVILEGES …<br>        3）授权给所有人：… TO PUBLIC；<br>        4）授权特定列：GRANT UPDATE(Sno) …<br>        5）授予人将相同权限授予出去的能力：… WITH GRANT OPTION;<br>    REVOKE语句的使用：<br>        1）一般用法；<br>        2）从所有用户收回：… FROM PUBLIC;<br>        3）级联收回：… FROM U5 CASCADE;<br>    角色：<br>        创建：<br>            CREATE ROLE &lt;角色名&gt;<br>    授予、回收权限：<br>        将角色名用在用户的位置；<br>    将角色授予其他角色或用户：<br>        将角色名用在权限的位置；<br>        可选的转授能力：<br>            [WITH ADMIN OPTION]</p>
<p>GRANT一般用法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GRANT &lt;权限 &gt;[,...]</span><br><span class="line">ON &lt;对象类型 &gt; &lt;对象名 &gt;[,...]</span><br><span class="line">TO &lt;USER &gt;[,...]</span><br><span class="line">[WITH GRANT OPTION]</span><br></pre></td></tr></table></figure>
<p>注意对象类型，因为不一定是基本表，也可以是视图等；</p>
<p>REVOKE一般用法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">REVOKE &lt;权限 &gt;[,...]</span><br><span class="line">ON &lt;对象类型 &gt; &lt;对象名 &gt;[,...]</span><br><span class="line">FROM &lt;用户 &gt;[,...];</span><br></pre></td></tr></table></figure>

<h2 id="数据库完整性"><a href="#数据库完整性" class="headerlink" title="数据库完整性"></a>数据库完整性</h2><p><code>实际上我们在前面的关系部分也有关系的完整性约束，尝试进行对比。</code></p>
<p>数据库完整性：<br>    定义：数据的正确、有效和相容；（<strong>也是数据库的一致性</strong>）；<br>        1）正确：数据要符合语义；<br>        2）有效：数据有有效期限；（eg，验证码过了时效就不能用了）；<br>        3）相容：同一关系同一元组，同一关系不同元组，不同关系不同元组，之间的数据一致性；<br>    面对的场景：<br>        1）合法用户合法操作；<br>        2）不合语义、不正确的数据；<br>    （注意与安全性的对比）；<br>    <strong>DBMS确保完整性的方法：</strong><br>        1）提供定义完整性约束条件的机制；<br>        2）提供完整性检查的方法；<br>        3）违约处理；<br>    包括：<br>        1）实体完整性约束；<br>        2）参照完整性约束；<br>        3）用户定义的完整性约束；</p>
<p>实体完整性：<br>    定义：若属性（组）是关系的主属性，则其不能为空；<br>    相关SQL语句：<br>        1）使用PRIMARY KEY进行实体完整性约束的定义；<br>        2）可以在列级别定义（创建表时直接定义在属性之后）；<br>        3）可以定义在表级别（创建表时定义在所有属性之后，定义要使用扩号）；<br>        eg：<br>            创建SC表，将Sno,Cno属性定义为码；<br>    完整性检查：<br>        1）插入或修改时检查主码值是不是唯一<br>        2）插入或修改时检查主属性是否为空；<br>    违约处理：<br>        1）如果主码不唯一则拒绝<strong>插入或修改</strong>；<br>        2）如果主属性为空则拒绝<strong>插入或修改</strong>；</p>
<p>参照完整性：<br>    外码：如果F是关系R到属性（组），但是F不是R的码，并且F与关系S到码Ks相对应，那么F就是关系R的外码；<br>        其中：<br>            1）R称为参照关系；<br>            2）S称为被参照关系；<br>    参照完整性定义：<br>        如果F是关系R的外码，并且与关系S的主码Ks相对应，那么F的取值，必须：<br>            1）或者为空值；<br>            2）或者为某个元组Ks的值；<br>    相关SQL语句：<br>        1）使用FOREIGN KEY(…) REFERENCEES 关系(…);<br>            （第一个括号中为指定为外码的属性，第二个括号中为在某关系上对应参照的属性）；<br>        2）参照完整性约束都是定义在表级的；<br>        eg：<br>            创建SC表，其中Cno参照Course(Cno)，Sno参照Student(Sno)；<br>    完整性检查：<br>        1）插入参照表的时候；<br>        2）修改参照表外码的时候；<br>        3）删除被参照表元组的时候；<br>        4）修改被参照表候选码的时候；<br>    违约处理：<br>        1）对于参照表的操作如果违反了参照完整性约束，直接拒绝操作；<br>        2）对于被参照表的操作如果违反了参照完整性约束：<br>            1）拒绝操作；<br>                eg：<br>                    1）（FOREIGN KEY(Sno) REFERENCE Student(Sno) ON UPDATE NO ACTION）；<br>            2）对被参照表级联修改&#x2F;删除；<br>                eg：<br>                    1）（FOREIGN KEY(Cno) REFERENCES Cource(Cno) ON UPDATE CASCADE;）<br>                    2）（FOREIGN KEY(Sno) REFERENCES Student(Sno) ON DELETE CASCADE;）<br>            3）对被参照表对应设置为空；<br>        涉及违约处理的SQL：<br>            FOREIGN KEY(…) REFERENCE 关系(…) ON 操作 NO ACTION&#x2F;CASCADE;<br>            （其中操作时UPDATE或DELETE）</p>
<p>用户定义的完整性约束：<br>    1）在属性上定义：<br>        1）NOT NULL 非空；<br>        2）UNIQUE 唯一；<br>        3）CHECK(…) 布尔表达式；<br>            eg：<br>                创建Student表，要求Sname唯一，Sage不能为空，Ssex只能为’男’或’女’；<br>    2）在元组上定义：<br>        使用CHECK进行定义，约束可以是一个属性的条件，或者多个属性之间的条件（取值相互约束）；<br>            eg：<br>                创建Student表，当学生Sage为’男’时，Sname不能以’Ms.’开头；<br>    违约处理：<br>        如果任何操作违反用户定义的完整性约束则拒绝；</p>
<p>完整性约束命名子句：<br>    SQL语句：<br>        CONSTRAINT &lt;完整性约束条件名&gt; &lt;完整性约束条件&gt;;<br>    其中条件可以是：<br>        NOT NULL&#x2F;UNQUE&#x2F;PRIMARY&#x2F;FROEIGN KEY&#x2F;CHECK等；<br>    （好处在于对于复杂的约束条件对构造，可以利用约束条件名对定义过的约束进行复用）</p>
<p>修改表中的完整性限制：<br>    ALTER语句（详情见前面“基本表的DDL语句，ALTER的用法，ADD的注意事项”）；</p>
<p>域的使用：<br>    创建一个DOMAIN类似创建了一个数据类型，后续创建基本表的时候属性的类型可以用域进行定义；<br>    SQL语句：<br>        CREATE DOMAIN 域名 CHECK(限制条件);<br>    优点是：使用域定义属性类型，自带约束条件；</p>
<h2 id="关系数据理论"><a href="#关系数据理论" class="headerlink" title="关系数据理论"></a>关系数据理论</h2><p>关系模式的形式化定义：<br>    R(D,DOM,U,F);<br>        1）R关系名；<br>        2）D域；<br>        3）DOM，U到D到映射；<br>        4）U，属性；<br>        5）F数据依赖；<br>    关系模式简化表示：<br>        R&lt;U,F&gt;；</p>
<p>完整性约束的表现形式；<br>    1）限定属性取值范围；<br>    2）属性值之间相互关联存在数据依赖的情况（主要是属性值相等的条件）；<br>    数据依赖：<br>        1）一个关系内部的属性之间的约束；<br>        2）不同关系之间的属性关系；<br>    数据依赖的类型：<br>        1）函数依赖；<br>        2）多值依赖；<br>        （其他，条件函数依赖等）</p>
<p>数据依赖造成的关系模式设计问题：<br>    1）问题背景：<br>        1）关系模式Student(Sno,Sname,Mname,Cno,Grade)；<br>        2）其中Mname是所在院系管理员的名字，一个院系只有一个；<br>    2）问题：<br>        1）删除异常，当某个院系的所有学生都毕业了，删除学生后，院系对应管理员也不清楚了；<br>        2）插入异常，当某个院系还没有学生的时候，但是管理员是确定的，可是不能插入；<br>        3）修改复杂，当院系的管理员更换的时候，对该院系所有学生的元组都要进行修改；<br>        4）数据冗余度大，每个学生元组中都记录了院系管理员的信息，数据冗余；<br>        注意：<br>            1）判断数据冗余的技巧是看两个条件，如果重复出现，并且对具体的元组删除一个没有影响，那就是冗余。<br>            （所以院系不是冗余，但是院系管理员是冗余）；<br>            2）修改复杂对应例子理解，并且修改复杂通常是和数据冗余一起出现的；<br>            3）删除异常、插入异常对应例子理解；<br>    3）总结：上面的Student关系不是好的关系，原因是某些不好的数据依赖，可以通过<strong>关系模式分解</strong>（后面会重点讨论，工具就是规范化理论），消除这些数据依赖；<br>    4）解决方法：规范化<br>        规范化理论是用来改造关系模式，通过分解关系模式来消除其中不合适的数据依赖，以解决插入异常、删除异常、更新异常和数据冗余问题。</p>
<p>函数依赖：<br>    基本概念：<br>        X函数确定Y；<br>        Y函数依赖X；<br>        X函数决定Y；<br>        $X \rightarrow Y$；<br>        定义：设R(U)是属性集U上的关系模式。X, Y是U的子集。若对于R(U)的任意一个可能的关系r，r中不可能存在两个元组在X上的属性值相等，而在Y上的属性值不等。<br>        注意：<br>        1）关系模式是结构，是不变的；<br>        2）关系是变化的，由具体有哪些元组确定，也就是说所有关系实例都要满足；<br>        3）函数依赖是语义范畴；<br>        4）在上面的函数依赖关系中X就是函数决定属性组（决定因素）<br>        5）X函数确定Y 且 Y函数确定X的记法（X与Y等价）；<br>        6）X不能函数确定Y的记法；<br>    平凡与非平凡：<br>        平凡函数依赖：如果Y是X的子集则函数依赖是平凡的；<br>        非平凡函数依赖：如果Y不是X的子集则函数依赖是非平凡的；<br>        注意：<br>            1）平凡的函数依赖是显然成立的；<br>            2）(Cpno)不是(Cno)的子集，属性组的集合成分是由属性来度量的，而不是属性的具体取值；<br>    完全与部分：<br>        完全函数依赖：对于属性组X的任何子集都不能函数确定Y；<br>        部分函数依赖：不是完全函数依赖；<br>        注意：<br>            相关的记法，在箭头上加F、P；<br>    传递函数依赖：<br>        1）X函数确定Y；<br>        2）Y不是X的子集；<br>        3）Y不能函数确定X；<br>        4）Y函数确定Z；<br>        5）Z不是Y的子集；<br>        （Y非平凡函数依赖于X，X不函数依赖于Y，Z非平凡函数依赖于Y）    </p>
<p>候选码：对于关系模式R(U)，U完全函数依赖于某个U的子集属性组K，则K是候选码；</p>
<p>主属性：候选码属性组中的属性都是主属性；</p>
<p>非主属性：不包含在任何候选码中的属性；</p>
<p>全码：U是候选码；</p>
<p>外码：R中属性组X并非R的码，但是是其他关系模式的码；</p>
<p>范式：<br>    定义：符合某一种级别的关系模式的集合，关系数据库的关系必须满足的要求，不同级别的范式有不同的要求；<br>    1）1NF<br>        定义：关系模式R的每个属性都是不可再分的数据项；<br>        注意：对关系模式最起码的要求，不满足不能称为关系数据库；<br>    2）2NF<br>        定义：1NF之上，每个<strong>非主属性</strong>完全函数依赖于候选码；<br>    3）3NF<br>        定义：2NF之上，不存在<strong>非主属性</strong>对候选码的传递函数依赖；<br>        （实际的定义没有2NF之上的表述，而是类似于不满足部分函数依赖的描述，但是少了一个Y是X的子集的条件，即只有部分函数依赖的四个条件，少的这个条件如果成立的话，则不满足2NF，所以应该是默认满足2NF）<br>        eg：S-L(Sno,Sdept,Sloc)，满足2NF，不满足3NF；<br>        （Sdept函数确定Sloc）<br>    4）BCNF<br>        定义：1NF之上，任何函数依赖的决定因素都必须包含码；<br>        注意：<br>            1）实际上是在3NF之上，消除了<strong>主属性</strong>对候选码的部分函数依赖和传递函数依赖；<br>        eg：<br>            1）STJ(S,T,J)满足3NF，不满足BCNF<br>                1）(S,J)-&gt;T，T-&gt;J<br>                （一个老师只能教一门课程，但是一门课程可以由不同的老师来教）<br>                2）候选码，S、J、T，<strong>没有非主属性</strong>，所以满足3NF；<br>                3）存在主属性对码的部分函数依赖(S,T)-&gt;J，所以不满足BCNF；<br>            2）SJP(S,J,P)满足BCNF；<br>                1）(S,J)-&gt;P，(J,P)-&gt;S；<br>                （一个学生一门课程有唯一一个名次，一个课程的一个名次也只能有一个学生（不考虑并列））<br>                2）候选码，S、J、P，<strong>没有非主属性</strong>，满足3NF；<br>                3）且所有函数依赖都包含码；<br>    注意<strong>这些例子对帮助理解和构造类似满足范式的关系很有帮助</strong>；<br>    判断满足四种范式的方法：<br>        1）1NF，略；<br>        2）2NF，找是否有非主属性部分函数依赖于某个码；<br>        3）3NF，找是否有非主属性传递函数依赖于某个码；<br>        4）BCNF，看是否所有的函数依赖决定因素都含有码；看是否有主属性部分&#x2F;传递函数依赖于码；<br>    3NF与BCNF的等价条件：<br>        <strong>当关系模式有且仅有一个候选码的时候，3NF与BCNF是等价的</strong>；</p>
<p>多值依赖<br>    定义：设R(U)是属性集U上的一个关系模式。X, Y, Z是U的子集，并且Z&#x3D;U-X-Y。关系模式R(U)中多值依赖 X-&gt;-&gt;Y成立，当且仅当对R(U)的任一关系r，给定一对(x, z)值，有一组Y的值，这组值仅仅决定于x值而与z值无关。<br>    <strong>针对例子理解</strong>：<br>        关系模式CTB(C,T,B)<br>        1）属性含义：C课程，T老师，B参考资料；<br>        2）条件：一门课程可以由多个老师讲授，他们必须使用相同的一套参考资料；<br>        3）注意：每个老师可以讲授不同的课程，每种参考书也可以供多门课程使用（因为这并不是重点）；<br>        存在的多值依赖：<br>            1）C-&gt;-&gt;T，对于给定一个课程，都有一组老师与其对应而与使用参考书的情况无关；<br>            （假如有一个老师使用的是和其他老师不同的参考书，那就不满足多值依赖了，因为根据参考书的情况会影响老师的情况）<br>            2）C-&gt;-&gt;B，对于给定一个课程，有一组参考书与之对应<br>    等价的定义：在R (U)的任一关系r中，如果存在元组t, s 使得t[X]&#x3D;s[X]，那么就必然存在元组w，v在r中，(w，v可以与s，t相同)，使得w[X] &#x3D; v[X] &#x3D; t[X]，而w[Y]&#x3D;t[Y]，w[Z]&#x3D;s[Z]，v[Y]&#x3D;s[Y]，v[Z]&#x3D;t[Z]（<strong>一句话：对于任意X属性组相等的元组s、t，交换s，t元组的Y值（X、Z值不改变）所得的两个新元组必在r中</strong>）；<br>        eg：<br>            1）对应到CBT到例子，对于(C,T1,B1)&#x2F;(C,T2,B2)，必然存在元组(C,T2,B1)&#x2F;(C,T1,B2)；<br>            2）但是如果有老师有用和别打老师不一样的教科书，在课程一样的时候，交换老师这一属性，得到课程-另一个老师-原老师独有的教科书，那这一元组显然是不存在的；<br>    平凡与非平凡：<br>        1）如果Z为空集，则多值依赖X-&gt;-&gt;Y是平凡的；<br>        2）否则是非平凡的；<br>    多值依赖的性质：<br>        1）对称性，X-&gt;-&gt;Y则X-&gt;-&gt;Z；<br>    4NF：对于每一个非平凡的多值依赖X-&gt;-&gt;Y，X中都包含候选码；<br>        注意：<br>            1）判断方法：在BCNF基础上，不允许有非平凡且非函数依赖的多值依赖；<br>            2）如果R满足4NF，则R满足BCNF；<br>    多值依赖的有效性与属性集的范围有关：<br>        1）如果X-&gt;-&gt;Y在U上成立，则在W上一定成立（W属性组包含X、Y属性组，且是U属性组的子集）；<br>        2）如果X-&gt;-&gt;Y在W上成立，则在U上不一定成立；<br>        （本质原因是前者减小了Z的范围，后者扩大了Z的范围，在大范围内成立在小范围内一定成立，反之不然）；<br>    多值依赖与函数依赖的区别：<br>        1）函数依赖X-&gt;Y成立，则对任何Y对子集Y’，X-&gt;Y’成立，但是换成多值依赖这是不行的；<br>        （本质上还是伴随着Y对减小，Z对范围可能扩大）<br>        2）函数依赖是多值依赖的特殊情况，若X-&gt;Y则X-&gt;-&gt;Y；<br>        （挺好理解的，对于函数依赖，X确定的时候Y的值也确定了，所以Z的值根本无所谓，因为根本没有X对应的其他Y值来体现Z的不同）；</p>
<p>从1NF、2NF、3NF、BCNF、4NF，规范化程度越来越高，但是不是规范化程度越高关系模式就越好；</p>
<p><strong>注意，BCNF、多值依赖，对应三个例子很重要：STJ&#x2F;SJP&#x2F;CTB</strong>；</p>
<p>Amstrong公理系统<br>    定义：对于满足一组函数依赖F 的关系模式R &lt;U, F&gt;，其任何一个关系r，若函数依赖X→Y都成立, (即r中任意两元组t，s，若t[X] &#x3D; s[X]，则t[Y]&#x3D;s[Y])，则称F逻辑蕴含X→Y。<br>    基本定律：<br>        1）自反律：若Y是X的子集，X是U的子集，则X-&gt;Y；<br>        2）增广律：若X-&gt;Y，Z是U的子集，则XZ-&gt;YZ<br>        （其中类似XZ的表达，可以理解为两个属性组拼成了一个大属性组）<br>        3）传递律：若X-&gt;Y，Y-&gt;Z则X-&gt;Z；<br>    推理规则：<br>        1）合并规则：若X-&gt;Y，X-&gt;Z则X-&gt;YZ；<br>        2）伪传递规则：若X-&gt;Y,WY-&gt;Z则WX-&gt;Z；<br>        3）分解规则：若X-&gt;Y且Z是Y的子集则X-&gt;Z；<br>        （三个推理规则从属性组的层面来说都很好理解）；<br>    <strong>定律与推理，得出的新函数依赖都被原来的函数依赖F所“蕴含”</strong>；<br>    Amstrong公理系统是<strong>有效的、完备的</strong>；<br>    极小函数依赖集：<br>        函数依赖集F为极小函数依赖集当且仅当：<br>            1）F中任意函数的右部只含有一个属性；<br>            2）F中不存在函数依赖X-&gt;A，使得F与F-{X-&gt;A}等价；<br>            3）F中不存在函数依赖X-&gt;A，使得X存在真子集Z，满足F-{X-&gt;A}并上{Z-&gt;A}与F等价；<br>                等价的含义：<br>                    1）函数依赖集F等价于G 等价于 F的闭包与G的闭包相等；<br>                    2）函数依赖集的闭包是函数依赖集所蕴含的函数依赖全体；<br>        （简单理解极小函数依赖集，在现有的函数依赖集中不断地去掉函数依赖，若去掉的函数依赖不能由剩下的导出，那么它就是必要的，保留所有必要的函数依赖，得到的就是极小函数依赖集）<br>        性质：<br>            1）每一个函数依赖集F均等价于一个极小函数依赖集Fm，Fm称为最小依赖集；<br>            2）F的最小依赖集Fm不是唯一的；<br>        极小化过程：<br>            找出F的最小依赖集Fm（基本上就是按照函数依赖集F的简单理解）；</p>
<p>模式分解：<br>    含义：<br>        1）将关系R分为几个关系，划分出的关系中的属性没有包含和被包含关系，且所有这些属性的并是关系R到属性；<br>        2）划分出的关系中的数据依赖，是关系R到数据依赖F在各关系所含属性上的投影；<br>    关系模式分解的标准（要求）：<br>        1）具有无损连接性：划分出的所有关系做自然连接，得到原始关系；<br>        2）保持函数依赖：F所蕴含的某个函数依赖，也一定由某个划分出的关系的数据依赖所蕴含；<br>        （典型的例如(Sno,Sname,Sdept,Mname)划分为(Sno,Sname,Sdept) (Sno,Mname)，这就丢失了Sdept-&gt;Mname）<br>        3）既具有无损连接性，又能保持函数依赖；<br>    注意：<br>        1）无损连接性可以保证信息不丢失；<br>        2）保持函数依赖可以减轻、解决异常情况；<br>        3）无损连接性和保持函数依赖是两个独立的性质，具备一个不一定具备另一个；<br>    (<em>模式分解和数据依赖带来的问题要一起考虑，融汇贯通</em>)</p>
<p>chase算法判断无损连接性：<br>    1）建立初始表；<br>        1）行对应关系，列对应属性；<br>        2）i行j列处，如果j对应属性在i对应关系中，则填aj，否则填bij；<br>    2）根据划分后的关系的函数依赖更新表格；<br>        1）“chase”操作，使用分解之前的原始函数依赖；<br>        2）对于每一个函数依赖Xi-&gt;Yi，检查决定项目Xi对应的列；<br>        3）找到Xi对应列，有相同元素的行w1 w2；<br>        4）找到Yi对应的列，这一列对应刚刚找到的行，即w1,Yi w2,Yi两个位置，更新为一样的；<br>        5）如果有一个是a?则全部更新为a?，否则全部更新为bmj，其中m取当前有的b?j，?的最小值；<br>    3）若出现a1、a2、…、an的行则具有无损连接性；<br>    <img src="/DBS/p2.png" alt="chase算法例子"></p>
<h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><p><code>视每次作业的情况而定，我可能会在这里写我最初版的作业，最终提交则是在此之上加以改进；同时会附加一些我在完成作业的过程中学习到的知识</code></p>
<h3 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h3><p>习题1，描述数据、数据库、数据库管理系统、数据库系统的概念</p>
<ol>
<li>数据是用来描述事物的符号记录，是数据库中存储的基本对象。</li>
<li>数据库是长期存储在计算机内、有组织、可共享的大量数据的集合。</li>
<li>数据库管理系统是位于用户和操作系统之间的一层数据管理软件，和操作系统一样是计算机的基础软件，是一个大型且复杂的软件系统。</li>
<li>数据库系统是指在计算机系统中引入数据库后的系统。</li>
</ol>
<p>习题2，描述文件系统和数据库系统的区别和联系</p>
<ol>
<li>区别：主要在共享性、冗余度、结构化上，文件系统共享性差，冗余度高，记录内有结构但是整体无结构；数据库系统共享性好，冗余度低，整体结构化。</li>
<li>联系：数据库系统和文件系统都属于数据管理技术，并且前者是后者的继承与发展；在硬件实现方面它们都可以使用磁盘，处理方式上都支持联机实时处理与批处理，都是系统本身作为数据的管理者等等。</li>
</ol>
<p>习题8，描述数据模型的概念，作用及其包含的三个要素</p>
<ol>
<li>概念：数据模型是数据库中用于抽象、表示和处理现实世界中的数据和信息的工具，是现实世界的模拟，满足能比较真实地模拟现实世界、容易为人所理解、便于在计算机上实现这三个条件。</li>
<li>作用：用于抽象、表示和处理现实世界中的数据和信息。</li>
<li>三个要素：数据结构、数据操作以及数据的完整性约束。</li>
</ol>
<p><code>这个概念或许需要进一步明确一下</code></p>
<p>习题14，描述数据库系统的三级模式结构，并说明这种结构的优点是什么</p>
<ol>
<li>三级模式结构：主要是指内模式，模式，外模式的三级结构，其中内模式是数据物理结构和存储方式的描述，模式是全体数据的逻辑结构和特征描述，外模式是数据库用户能看见和使用的局部数据的逻辑结构和特征的描述；内模式与模式之间由，模式&#x2F;内模式映像连接。模式与外模式之间由外模式&#x2F;模式映像连接。</li>
<li>优点：使用了映像连接，在内模式修改的时候，同时修改模式&#x2F;内模式映像，可以确保物理独立性；在模式修改的时候，同时修改外模式&#x2F;模式映像，可以确保逻辑独立性。</li>
</ol>
<p>习题15，描述数据与程序的物理独立性和逻辑独立性。为什么是数据库系统具有较强的数据与程序的独立性。</p>
<ol>
<li>物理独立性：用户的应用与存储在磁盘上的数据库中的数据是相互独立的，当数据物理存储改变了，应用程序不用改变。</li>
<li>逻辑独立性：用户的应用程序与数据库的逻辑结构是相互独立的，数据的逻辑结构改变了，用户程序可以不变。</li>
<li>较好的数据与程序的逻辑独立性，是因为应用程序依据数据的外模式进行编写，当模式改变的时候，数据库管理员通过修改外模式&#x2F;模式映像，使外模式保持不变从而让应用程序不必修改。</li>
<li>较好的数据与程序的物理独立性，是因为当数据库的存储结构改变了，数据库管理员可以修改模式&#x2F;内模式映像，让模式保持不变，从而让应用程序不受影响。</li>
</ol>
<h2 id="SQL练习（创建、修改、删除）"><a href="#SQL练习（创建、修改、删除）" class="headerlink" title="SQL练习（创建、修改、删除）"></a>SQL练习（创建、修改、删除）</h2><h3 id="创建基本表"><a href="#创建基本表" class="headerlink" title="创建基本表"></a>创建基本表</h3><p>其基本语言规范是</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">CREATE TABLE &lt;表名&gt;</span><br><span class="line">(</span><br><span class="line">    &lt;列名&gt; &lt;数据类型&gt; [列级完整性约束],</span><br><span class="line">    &lt;列名&gt; &lt;数据类型&gt; [列级完整性约束],</span><br><span class="line">    [表级完整性约束]</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="eg5-建立学生数据表"><a href="#eg5-建立学生数据表" class="headerlink" title="eg5 建立学生数据表"></a>eg5 建立学生数据表</h4><p>要求：</p>
<ol>
<li>学号是主键</li>
<li>姓名不能重复</li>
<li>性别是一个汉字（对应旧版本mysql两个字符）</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">CREATE TABLE Student</span><br><span class="line">(</span><br><span class="line">    Sno CHAR(10) PRIMARY KEY,</span><br><span class="line">    Sname CHAR(20) UNIQUE,</span><br><span class="line">    Ssex CHAR(2),</span><br><span class="line">    Sage SMALLINT,</span><br><span class="line">    Sdept CHAR(20)</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="eg6-建立课程数据表"><a href="#eg6-建立课程数据表" class="headerlink" title="eg6 建立课程数据表"></a>eg6 建立课程数据表</h4><p>要求：</p>
<ol>
<li>课程号是主键CHAR(4)</li>
<li>课程名不允许为空</li>
<li>先修课是外码，参照的是自己的课程号属性</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">CREATE TABLE Course</span><br><span class="line">(</span><br><span class="line">    Cno CHAR(4) PRIMARY KEY,</span><br><span class="line">    Cname CHAR(40) NOT NULL,</span><br><span class="line">    Cpno CHAR(4),</span><br><span class="line">    Ccredit SMALLINT,</span><br><span class="line">    FOREIGN KEY (Cpno)</span><br><span class="line">    REFERENCES Course Cno</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>错误修正</strong>：<code>REFERENCES Course Cno</code>应该是<code>REFERENCES Course(Cno)</code></p>
<h4 id="eg7-建立选课表"><a href="#eg7-建立选课表" class="headerlink" title="eg7 建立选课表"></a>eg7 建立选课表</h4><p>要求：</p>
<ol>
<li>主键由两个Sno、Cno两个属性构成</li>
<li>Sno、Cno还分别是外键，参考前面两个表中的对应属性</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">CREATE TABLE SC</span><br><span class="line">(</span><br><span class="line">    Sno CHAR(10),</span><br><span class="line">    Cno CHAR(4),</span><br><span class="line">    Grade SMALLINT,</span><br><span class="line">    PRIMARY KEY (Sno,Cno),</span><br><span class="line">    FOREIGN KEY (Sno)</span><br><span class="line">    REFERENCES Student(Sno),</span><br><span class="line">    FOREIGN KEY (Cno)</span><br><span class="line">    REFERENCES Course(Cno)</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>注意创建主键为多个属性组合时的写法：</strong><code>PRIMARY KEY (Sno,Cno)</code></p>
<h3 id="修改基本表"><a href="#修改基本表" class="headerlink" title="修改基本表"></a>修改基本表</h3><p>基本规范如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ALTER TABLE &lt;表名&gt;</span><br><span class="line">[ADD &lt;列名&gt; &lt;数据类型&gt; [完整性约束]]</span><br><span class="line">[DROP &lt;列名&gt; &lt;数据类型&gt;]</span><br><span class="line">[ALTER COLUMN &lt;列名&gt; &lt;数据类型&gt;]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="eg8-向学生表增加入学时间"><a href="#eg8-向学生表增加入学时间" class="headerlink" title="eg8 向学生表增加入学时间"></a>eg8 向学生表增加入学时间</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ALTER TABLE Student</span><br><span class="line">ADD S_entrance DATA;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>错误修正：</strong>时间的数据类型应该是<code>DATE</code>而不是<code>DATA</code></p>
<h4 id="eg9-将学生表中的年龄属性转换为INT类型"><a href="#eg9-将学生表中的年龄属性转换为INT类型" class="headerlink" title="eg9 将学生表中的年龄属性转换为INT类型"></a>eg9 将学生表中的年龄属性转换为INT类型</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ALTER TABLE Student</span><br><span class="line">ALTER COLUMN Sage INT;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>注意以下事项</strong>：</p>
<ol>
<li>COLUMN的拼写</li>
<li>在MYSQL中似乎对列的修改不是ALTER，而是MODIFY，即<code>MODIFY COLUMN Sage INT;</code></li>
</ol>
<h2 id="SQL练习（查询）"><a href="#SQL练习（查询）" class="headerlink" title="SQL练习（查询）"></a>SQL练习（查询）</h2><h3 id="单表查询-1"><a href="#单表查询-1" class="headerlink" title="单表查询"></a>单表查询</h3><ol>
<li>选择表的若干列</li>
<li>选择表的若干元组</li>
<li>ORDER BY 子句</li>
<li>聚集函数</li>
<li>GROUP BY子句</li>
</ol>
<p><strong>关于GROUP BY，我本地的mysql和教材的SQL标准存在一些偏差</strong>：做如下记录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SELECT Sno</span><br><span class="line">FROM SC</span><br><span class="line">GROUP BY Sno;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的查询语句本地的mysql显示的结果会自动去重，和我理解的按照Sno属性是否相同将对应元组放在一张表里面，而不改变元组的个数有一些不同；<strong>但是使用COUNT语句能够正确统计出各组元组的个数，和课本上一致。</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SELECT Sno,Cno</span><br><span class="line">FROM SC</span><br><span class="line">GROUP BY Sno</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>本地上是会报错的，老师说按照课本的逻辑这应该是可以执行的，并且查询的结果会是没有分组的Sno、Cno</p>
<p><strong>总是，GROUP BY语句大多数时候还是配合聚集函数使用的，直接显示结果比较少</strong>。</p>
<h4 id="查询若干列"><a href="#查询若干列" class="headerlink" title="查询若干列"></a>查询若干列</h4><p>eg1 查询全体学生的姓名和学号</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SELECT Sname,Sno</span><br><span class="line">From Student;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>eg2 查询全体学生的姓名、学号和所在系</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SELECT Sname,Sno,Sdept</span><br><span class="line">FROM Student;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>eg3 查询全体学生的详细记录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SLECT * FROM Student;</span><br></pre></td></tr></table></figure>

<p><strong>查询若干列的时候，不仅可以直接查询，还可以查询经过计算的表达式</strong>，常用的表达式如下：</p>
<ol>
<li>算术表达式，例如<code>SELECT 2024 - Sage FROM Student;</code>，结果显示Sage列，并且每一个元组下的值都是2024-对应值</li>
<li>字符串常量，例如<code>SELECT &#39;birth of date&#39;,Birth,2024 - Sage FROM Student;</code>，结果会显示两列，在Sage列前会新增一列，名为Birth，其下的值均为字符串’birth of date’，第二列名为Sage，其下的值都是2024-Sage</li>
<li>函数，例如<code>SELECT LOWER(Sdept) FROM Student;</code>，结果显示Sdept列，结果是其下对应元组值中的字符串无论大小写均使用小写</li>
<li>列别名，规范<code>SELECT &lt;列名&gt; &lt;列别名&gt;</code>，显示的时候会自然将对应的列作别名显示</li>
</ol>
<p>eg4 查询全体学生的姓名及出生年份</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SELECT Sname,<span class="string">&#x27;birth of date:&#x27;</span> BIRTH,2025-Sage BIRTHDAY</span><br><span class="line">FROM Student;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>eg5 查询学生的姓名、出生年份和所在院系，要求小写字母表示所有系名</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SELECT Sname,<span class="string">&#x27;birth of date:&#x27;</span> BIRTH,2025-Sage BIRTHDAY,LOWER(Sdept)</span><br><span class="line">FROM Student;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="选择表中的若干元组"><a href="#选择表中的若干元组" class="headerlink" title="选择表中的若干元组"></a>选择表中的若干元组</h4><p><strong>关于DISTINCT和ALL</strong>：如果没有规定DISTINCT，则默认为ALL，前者会消除重复行，后者会保留所有在原始基本表中查询到的满足条件的元组</p>
<p>eg6 查询选修了课程的学生学号</p>
<p>eg6思路：对于SC课程表查询Sno，并去重</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SELECT DISTINCT Sno</span><br><span class="line">FROM SC;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong><code>DISTINCT</code>出现的位置，不是在列名之后，否则就变成别名了</p>
<p><strong>关于选择元组常用的查询条件（比较）</strong>：</p>
<ol>
<li>比较：<code>&lt;, &gt;, =, !=, &lt;&gt;, !&gt;, !&lt;, NOT</code>，小于、大于、等于、不等于、不等于、不大于、不小于、否定布尔表达式（<code>NOT(布尔表达式)</code>常见用法）</li>
<li>确定范围：<code>BETWEEN AND, NOT BETWEEN AND</code></li>
<li>确定集合：<code>IN, NOT IN</code></li>
<li>字符匹配：<code>LIKE, NOT LIKE</code></li>
<li>空值：<code>IS NULL, IS NOT NULL</code></li>
<li>多重条件（逻辑运算）：<code>AND, OR, NOT</code></li>
</ol>
<p>eg7 查询计算机科学系全体学生的名单</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SELECT *</span><br><span class="line">FROM Student</span><br><span class="line">WHERE Sdept = <span class="string">&#x27;CS&#x27;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>eg8 查询所有年龄在20岁以下学生姓名及年龄</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SELECT Sname,Sage</span><br><span class="line">FROM Student</span><br><span class="line">WHERE Sage&lt;20;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>eg9 查询考试成绩有不及格的学生学号</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SELECT DISTINCT Sno</span><br><span class="line">FROM SC</span><br><span class="line">WHERE Grade&lt;60;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>关于选择元组常用的查询条件（确定范围）</strong>：<code>BETWEEN...AND...</code>和<code>NOT BETWEEN...AND...</code>，注意<code>BETWEEN...AND...</code>是包含边界的！</p>
<p>eg10 查询年龄在20~23岁之间的学生姓名、系别和年龄</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SELECT Sname,Sdept,Sage</span><br><span class="line">FROM Student</span><br><span class="line">WHERE Sage BETWEEN 20 AND 23;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>eg11 查询年龄不在20~23岁之间的学生姓名、系别和年龄</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SELECT Sname,Sdept,Sage</span><br><span class="line">FROM Student</span><br><span class="line">WHERE Sage NOT BETWEEN 20 AND 23;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>关于选择元组常用的查询条件（确定集合）</strong>：<code>IN &lt;值表&gt;</code>，<code>NOT IN &lt;值表&gt;</code>，例如，对于字符串的值，值表写法是<code>(&#39;1&#39;,&#39;2&#39;,&#39;3&#39;)</code></p>
<p>eg12 查询信息系IS、数学系MA和计算机科学系CS，学生姓名和系别</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SELECT Sname,Sdept</span><br><span class="line">FROM Student</span><br><span class="line">WHERE Sdept IN (<span class="string">&#x27;IS&#x27;</span>,<span class="string">&#x27;MA&#x27;</span>,<span class="string">&#x27;CS&#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>eg13 查询既不是信息系、数学系也不是计算机科学系的学生姓名和性别</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SELECT Sname,Ssex</span><br><span class="line">FROM Student</span><br><span class="line">WHERE Sdept NOT IN (<span class="string">&#x27;IS&#x27;</span>,<span class="string">&#x27;MA&#x27;</span>,<span class="string">&#x27;CS&#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>关于选择元组常用的查询条件（字符匹配）</strong>：</p>
<ol>
<li>基本的用法是<code>[NOT] LIKE &#39;&lt;匹配串&gt;&#39;</code>，值得注意的是匹配串中可以有通配符，有两种分别是：<code>%</code>和<code>_</code>，前者可以代表任意数量的任意字符，后者代表一个任意字符</li>
<li><code>ESCAPE &#39;&lt;转义字符&gt;&#39;</code>，指定的转义字符用于通配符前面，用来将通配符当作一个普通的字符，但是值得注意的是<strong>如果转义字符单独出现那么它只会被当作普通字符</strong>，这与一些常见语言的处理方式是不同的，不需要两个转义字符来表示其本身</li>
</ol>
<p>eg14 查询学号为200215121学生的详细情况</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SELECT *</span><br><span class="line">FROM Student</span><br><span class="line">WHERE Sno LIKE <span class="string">&#x27;200215121&#x27;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>eg15查询所有姓刘学生的姓名、学号和性别</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SELECT Sname,Sno,Ssex</span><br><span class="line">FROM Student</span><br><span class="line">WHERE Sname LIKE <span class="string">&#x27;刘%&#x27;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>eg16查询姓“欧阳”且全名为三个汉字的学生的姓名</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SELECT Sname</span><br><span class="line">FROM Student</span><br><span class="line">WHERE Sname LIKE <span class="string">&#x27;欧阳__&#x27;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：实际上现在经过测试，MySQL做了适配，一个下划线就可以对应一个汉字字符，从前要用两个，是因为在编码的时候汉字有内外码，一个汉字对应两个字符长度</p>
<p>eg18 查询所有不姓刘的学生姓名</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SELECT Sname</span><br><span class="line">FROM Student</span><br><span class="line">WHERE Sname NOT LIKE <span class="string">&#x27;刘%&#x27;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>eg19 查询DB_Design课程的课程号和学分</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SELECT Cno,Credit</span><br><span class="line">FROM Course</span><br><span class="line">WHERE Cname LIKE <span class="string">&#x27;DB\_Design&#x27;</span></span><br><span class="line">ESCAPE <span class="string">&#x27;\&#x27;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>eg20 查询以’DB_’开头，且倒数第3个字符为’i’的课程的详细情况</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SELECT *</span><br><span class="line">FROM Course</span><br><span class="line">WHERE Cname LIKE <span class="string">&#x27;DB\_%i__&#x27;</span></span><br><span class="line">ESCAPE <span class="string">&#x27;\&#x27;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>关于选择元组常用的查询条件（涉及空值）</strong>：使用语句<code>IS NULL</code>或<code>IS NOT NULL</code>，这里的<code>IS</code>不能够用<code>=</code>来代替，简单理解就是，<code>NULL</code>是一个对象而不是一个值</p>
<p>eg21 查询缺少成绩的学生的学号和相应的课程号</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SELECT Sno,Cno</span><br><span class="line">FROM SC</span><br><span class="line">WHERE Grade IS NULL;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>关于选择元组常用的查询条件（多重条件查询）</strong>：</p>
<ol>
<li>主要使用逻辑运算符AND和OR，用它们两个来连接布尔表达式（由各种查询条件构成的）</li>
<li>默认情况下AND的优先级高于OR的优先级，可以使用括号来改变优先级</li>
</ol>

        


        <span>
          <a class="article-read" href="/2025/09/30/DBS/"> Read more -->
          </span>
        </div>

        
    
    <div class="recent-post-item">

      <a href="/2025/09/04/csp%E4%B9%A0%E9%A2%98%E9%9B%86/" class="item-title">csp习题集</a>
      
      <time datetime="2025-09-04T06:26:27.000Z">
        2025-09-04
      </time>
      
      <!-- <div class="article-digest"> -->
        <!-- 这篇blog用来记录我练习ccf csp认证的时候做过的习题
梦境巡查 第36次 task2缓存模拟 第36次 task3大模拟题先整理信息：

有N组缓存，每组缓存中有n块
内存块k，存储在k&#x2F;n组中，n个缓存块的任意一个
操作，读、写内存块，分为两种情况：1）k&#x2F;n组中存储了数据（某行），命中；2）k&#x2F;n组中没有数据（所有行），没有命中
命中，分为两种情况：1）读，无特殊处理；2）写，修改缓存行，标记对应内存块是修改了的，实际还没有改内存块
未命中，先进行载入，再按照命中处理
载入，1）如果k&#x2F;n组有未使用的，就载入未使用的位置；2）否则，按照LRU进行替换，如果内存块修改过要写回

我的思路：

对于N组，每组维护一个队列（队列中存储实际的内存块编号，以及该内存块是否修改过），队列的长度上限设置为n
未命中的时候，1）如果进行载入，队长小于n，直接将内存块入队即可（这里进行了读内存块）；2）如果进行替换，被替换的是队首元素，检查该元素是否被修改过，如果是（这里进行写内存块），然后再将内存块入队（这里进行了读内存块）
命中的时候，1）如果是读 -->
        <!-- </div> -->

        
        <p><code>这篇blog用来记录我练习ccf csp认证的时候做过的习题</code></p>
<h2 id="梦境巡查-第36次-task2"><a href="#梦境巡查-第36次-task2" class="headerlink" title="梦境巡查 第36次 task2"></a>梦境巡查 第36次 task2</h2><h2 id="缓存模拟-第36次-task3"><a href="#缓存模拟-第36次-task3" class="headerlink" title="缓存模拟 第36次 task3"></a>缓存模拟 第36次 task3</h2><p>大模拟题先整理信息：</p>
<ol>
<li>有N组缓存，每组缓存中有n块</li>
<li>内存块k，存储在k&#x2F;n组中，n个缓存块的任意一个</li>
<li>操作，读、写内存块，分为两种情况：1）k&#x2F;n组中存储了数据（某行），命中；2）k&#x2F;n组中没有数据（所有行），没有命中</li>
<li>命中，分为两种情况：1）读，无特殊处理；2）写，修改缓存行，标记对应内存块是修改了的，实际还没有改内存块</li>
<li>未命中，先进行载入，再按照命中处理</li>
<li>载入，1）如果k&#x2F;n组有未使用的，就载入未使用的位置；2）否则，按照LRU进行替换，如果内存块修改过要写回</li>
</ol>
<p>我的思路：</p>
<ol>
<li>对于N组，每组维护一个队列（队列中存储实际的内存块编号，以及该内存块是否修改过），队列的长度上限设置为n</li>
<li>未命中的时候，1）如果进行载入，队长小于n，直接将内存块入队即可（这里进行了读内存块）；2）如果进行替换，被替换的是队首元素，检查该元素是否被修改过，如果是（这里进行写内存块），然后再将内存块入队（这里进行了读内存块）</li>
<li>命中的时候，1）如果是读，修改队列，取出命中的元素，重新入队，其它元素相对位置不变；2）如果是写，在1）的基础上还要标记对应内存块被修改过</li>
</ol>
<h2 id="字符串变换-第35次CCF认证"><a href="#字符串变换-第35次CCF认证" class="headerlink" title="字符串变换 第35次CCF认证"></a>字符串变换 第35次CCF认证</h2><p>我的思路：</p>
<p>如果直接使用1个map存储映射的话，当查询的变换次数很大的时候肯定会超时，于是我想到了用两个key（char，int）映射到一个char，代表char变换int次的时候映射到的char。</p>
<p>具体的思路：</p>
<ol>
<li>定义一个struct，里面有char、int；定义map&lt;struct, char&gt;，将struct中的char变换int次后，映射到新的char</li>
<li>初始化的情况是struct(char,0) map&lt;struct,char&gt; &#x3D;&#x3D; char本身；然后根据映射函数，处理边界struct(char,1) map&lt;struct,char&gt; &#x3D;&#x3D; char(如果有映射就是新的，没有仍然保持自己)；注意初始化的时候还要考虑，原始字符串中字符可以映射到的字符</li>
<li>处理变换，如果某次查询是变换k次，那么从1变换到k，保存一路下来的结果，之后的查询只要小于k就可以直接一次变换即可。</li>
</ol>
<p>代码实现如下（考虑了一下，把struct换成tuple了，而且0的初始化是冗余的，直接从1开始了）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">map</span>&lt;tuple&lt;<span class="type">int</span>,<span class="type">char</span>&gt;, <span class="type">char</span>&gt; mp;</span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ini</span><span class="params">()</span> &#123;</span><br><span class="line"> getline(<span class="built_in">cin</span>, s);</span><br><span class="line"> <span class="type">int</span> t; </span><br><span class="line"> <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line"> getchar();<span class="comment">//吞回车</span></span><br><span class="line"> <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">  <span class="comment">//处理函数的映射，注意没有指明的映射映射到自己</span></span><br><span class="line">  <span class="built_in">string</span> ss;</span><br><span class="line">  getline(<span class="built_in">cin</span>, ss);</span><br><span class="line">  tuple&lt;<span class="type">int</span>, <span class="type">char</span>&gt; <span class="title function_">st1</span><span class="params">(<span class="number">1</span>, ss[<span class="number">1</span>])</span>;</span><br><span class="line">  mp[st1] = ss[<span class="number">2</span>]; </span><br><span class="line"></span><br><span class="line">  tuple&lt;<span class="type">int</span>, <span class="type">char</span>&gt; <span class="title function_">st2</span><span class="params">(<span class="number">1</span>, ss[<span class="number">2</span>])</span>;</span><br><span class="line">  <span class="keyword">if</span> (mp.find(st2) == mp.end())</span><br><span class="line">   mp[st2] = ss[<span class="number">2</span>];</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; s[i] != <span class="string">&#x27;#&#x27;</span>; i++) &#123;</span><br><span class="line">  <span class="comment">//检查源字符串中是否存在函数映射没有覆盖到的，若有则映射到自己</span></span><br><span class="line">  tuple&lt;<span class="type">int</span>, <span class="type">char</span>&gt; <span class="title function_">st</span><span class="params">(<span class="number">1</span>, s[i])</span>;</span><br><span class="line">  <span class="keyword">if</span> (mp.find(st) == mp.end())</span><br><span class="line">   mp[st] = s[i];</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> <span class="title function_">f</span><span class="params">(<span class="type">char</span> c,<span class="type">int</span> k)</span> &#123;</span><br><span class="line"> <span class="comment">//将c映射k次</span></span><br><span class="line"> <span class="type">char</span> res = c;</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">  tuple&lt;<span class="type">int</span>, <span class="type">char</span>&gt; <span class="title function_">st</span><span class="params">(<span class="number">1</span>, res)</span>;<span class="comment">//不断进行一次映射，进行k次</span></span><br><span class="line">  res = mp[st];</span><br><span class="line">  <span class="keyword">if</span> (i == <span class="number">1</span>)<span class="keyword">continue</span>;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="comment">//当进行i&gt;1次的时候，保存映射结果</span></span><br><span class="line">   tuple&lt;<span class="type">int</span>, <span class="type">char</span>&gt; st1(i, c);</span><br><span class="line">   mp[st1] = res;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">search</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="type">int</span> m;</span><br><span class="line"> <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line"> <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">  <span class="type">int</span> k;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; s[i] != <span class="string">&#x27;#&#x27;</span>; i++) &#123;</span><br><span class="line">   <span class="comment">//逐个处理字符映射</span></span><br><span class="line">   tuple&lt;<span class="type">int</span>, <span class="type">char</span>&gt; <span class="title function_">st</span><span class="params">(k, s[i])</span>;</span><br><span class="line">   <span class="keyword">if</span> (mp.find(st) == mp.end()) &#123;</span><br><span class="line">    <span class="comment">//如果没有，则进行映射处理</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f(s[i],k);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//如果有则直接输出</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; mp[st];</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27;#&#x27;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"> ini();</span><br><span class="line"> search();</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="补丁应用-第35次CCF认证-task3"><a href="#补丁应用-第35次CCF认证-task3" class="headerlink" title="补丁应用 第35次CCF认证 task3"></a>补丁应用 第35次CCF认证 task3</h2><p>大模拟题，先看信息：</p>
<p>关于diff输出的补丁</p>
<ol>
<li>一个块 or 多个块；块：若干行文本；文本：对文件的一处修改；</li>
<li>关于第一行文本：1）@@开头结尾；2）NN MM nn mm是1~9字符组成的字符串；0、1或多个字符；最终表示一个整数；第NN行开始修改；修改了MM行；“这处”修改从新文件nn行开始；“这处”修改在新文件中有mm行</li>
<li>关于随后的若干行文本：1）-开头是删除该行；2）+开头被添加该行；3）空格开头，该行未变化； -与空格开头的行 &#x3D; MM；+与空格开头的行 &#x3D; mm</li>
</ol>
<p>关于patch</p>
<ol>
<li>移除#开头的</li>
<li>@开始到下一个@之间未一个块；如果没有@开头补丁损坏</li>
</ol>
<p>对于每一个块</p>
<ol>
<li>检查第一行格式，如果不正确则补丁损坏</li>
</ol>
<p>如果补丁未损坏</p>
<ol>
<li>解析NN、MM、mm</li>
<li>检查NN大于等于前一个块 NN与MM之和，否则补丁损坏</li>
</ol>
<p>如果补丁未损坏</p>
<ol>
<li>其余行，是否有+、-、空格开头的行，否则补丁损坏</li>
</ol>
<p>未损坏</p>
<ol>
<li>-、空格开头的是源文件片段</li>
<li>片段行数是否与MM一致，否则补丁损坏</li>
</ol>
<p>未损坏</p>
<ol>
<li>提取+、空格开头的，作为新文件片段</li>
<li>片段行数是否与mm一致，否则补丁损坏</li>
</ol>
<p>如果所有块都通过检查，即补丁未损坏（补丁有多个块）</p>
<p>修改源文件操作：</p>
<p>检查是否存在整数d，使得</p>
<ol>
<li>对于第一块，源文件NN+d行开始的MM行，与第一块的“源文件”片段完全匹配；</li>
<li>对于非第一块，除了1）要满足的条件之外，还要满足NN+d，不小于前一个块的NN+MM之和；否则补丁损坏</li>
<li>如果存在多个d，取绝对值最小的，如果仍存在多个，取小于0的d</li>
</ol>
<p>找到d之后（对于每个块应该要找一个d）</p>
<ol>
<li>将原文件的第NN+d行开始的MM行替换为块的新文件内容</li>
</ol>
<h2 id="通讯延迟-第35次CCF认证-task4"><a href="#通讯延迟-第35次CCF认证-task4" class="headerlink" title="通讯延迟 第35次CCF认证 task4"></a>通讯延迟 第35次CCF认证 task4</h2><p>基本思路是根据覆盖情况建图，然后跑一个dijkstra算法</p>
<ol>
<li>遍历每一个基站，检查它覆盖范围内的结点，范围内的结点互相间可以有边，完成建图</li>
<li>dijkstra算法，从结点1到结点n的最短路</li>
</ol>
<p>关于建立图的方式：</p>
<p>对每一个基站，确定其四个边界点的范围；<br>    遍历每一个点，确定其是否在该范围内；对在该范围内的所有点，两两之间添加边</p>
<p>关于dijkstra算法</p>
<ol>
<li>选定初始结点，纳入起点集合（队列）；用vis标志其距离已经确定</li>
<li>起点集合队首元素出列，作为起点，更新其到各个结点的距离；选择距离最短的结点，（检查未被vis标志）纳入起点集合，并用vis标志其距离已经确定</li>
<li>直到所有可以选择的点都被纳入过起点集合 1）所有点都被纳入过了；2）未被纳入的点距离都是INF</li>
</ol>
<p>反复处理，直到所有结点都被纳入起点集合</p>

        


        <span>
          <a class="article-read" href="/2025/09/04/csp习题集/"> Read more -->
          </span>
        </div>

        
      </div>
      


      <div id="recent-posts-paginator">
        <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"> </a>
      </div>

    </div>

<aside id="sidebar">
  
  <div class="widget-box">
  	  <div class="widget-box">
    <h3 class="widget-title-friends">friends</h3>
    <div class="widget">
      
    </div>
  </div>

  </div>
  
  <div class="widget-box">
  	

  </div>
  
  <div class="widget-box">
  	
  <div class="widget-box">
    <h3 class="widget-title-tag">tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/" rel="tag">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/unity/" rel="tag">unity</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" rel="tag">分布式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/" rel="tag">图形学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%A7%E5%AD%A6/" rel="tag">大学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" rel="tag">数据结构与算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88MTL%EF%BC%89/" rel="tag">机器学习（MTL）</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%83%E5%AD%A6%E4%B9%A0%EF%BC%89/" rel="tag">机器学习（元学习）</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%89/" rel="tag">机器学习（强化学习）</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0%EF%BC%89/" rel="tag">机器学习（联邦学习）</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E8%81%9A%E7%B1%BB%EF%BC%89/" rel="tag">机器学习（聚类）</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9D%82%E9%A1%B9/" rel="tag">杂项</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C/" rel="tag">网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" rel="tag">计算机基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%97%E6%AD%8C/" rel="tag">诗歌</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/" rel="tag">软件工程</a></li></ul>
    </div>
  </div>


  </div>
  
  <div class="widget-box">
  	
  <div class="widget-box">
    <h3 class="widget-title-archive">archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2026/01/">January 2026</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/12/">December 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/11/">November 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/10/">October 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/09/">September 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/08/">August 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/07/">July 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/05/">May 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/04/">April 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/02/">February 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/10/">October 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li></ul>
    </div>
  </div>

  </div>
  
  <div class="widget-box">
  	
  <div class="widget-box">
    <h3 class="widget-title-post">recent_posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a class="recent_posts-list-link" href="/2026/01/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/">软件工程导论</a>
          </li>
        
          <li>
            <a class="recent_posts-list-link" href="/2026/01/02/Connect6%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/">Connect6框架学习</a>
          </li>
        
          <li>
            <a class="recent_posts-list-link" href="/2025/12/15/Computer-Graphic/">Computer Graphic</a>
          </li>
        
          <li>
            <a class="recent_posts-list-link" href="/2025/12/05/Double-Cross/">Double Cross</a>
          </li>
        
          <li>
            <a class="recent_posts-list-link" href="/2025/12/01/Computer%20Network/">Computer Network</a>
          </li>
        
      </ul>
    </div>
  </div>

  </div>
  
</aside>

<!-- <div id="paginator"> -->
<!--   <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"> </a> -->
<!-- </div> -->

    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
          tex2jax: {
            inlineMath: [ ['$','$'], ["\\(","\\)"] ],
            processEscapes: true
          }
        });
      </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
            tex2jax: {
              skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
            }
          });
      </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
              var all = MathJax.Hub.getAllJax(), i;
              for(i=0; i < all.length; i += 1) {
                  all[i].SourceElement().parentNode.className += ' has-jax';
              }
          });
    </script>

    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>



			</div>
		</div>

		<div id="bottom-outer">
			<div id="bottom-inner">
				Site by 阳生 | 
				Powered by <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a> |
				theme <a target="_blank" rel="noopener" href="https://github.com/fireworks99/hexo-theme-PreciousJoy">PreciousJoy</a>
			</div>
		</div>

		
	</div>





	
	<!-- scripts list from theme config.yml -->
	
	<script src="/js/jquery-3.5.1.min.js"></script>
	
	<script src="/js/PreciousJoy.js"></script>
	
	<script src="/js/highlight.pack.js"></script>
	
	<script src="/js/jquery.fancybox.min.js"></script>
	
	<script src="/js/search.js"></script>
	
	<script src="/js/load.js"></script>
	
	<script src="/js/jquery.mCustomScrollbar.concat.min.js"></script>
	
	<script src="/js/clipboard.min.js"></script>
	
	

	<script>hljs.initHighlightingOnLoad();</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>
