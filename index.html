


<!DOCTYPE html>
<html lang="ch">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
	<title> [ 代码和诗 ]</title>
	
	
	<!-- stylesheets list from _config.yml -->
	
	<link rel="stylesheet" href="/css/PreciousJoy.css">
	
	<link rel="stylesheet" href="/css/top-bar.css">
	
	<link rel="stylesheet" href="/css/menu-outer.css">
	
	<link rel="stylesheet" href="/css/content-outer.css">
	
	<link rel="stylesheet" href="/css/bottom-outer.css">
	
	<link rel="stylesheet" href="/css/atom-one-dark.css">
	
	<link rel="stylesheet" href="/css/recent-posts-item.css">
	
	<link rel="stylesheet" href="/css/article-sidebar-toc.css">
	
	<link rel="stylesheet" href="/css/jquery.fancybox.min.css">
	
	<link rel="stylesheet" href="/css/search.css">
	
	<link rel="stylesheet" href="/css/toc.css">
	
	<link rel="stylesheet" href="/css/sidebar.css">
	
	<link rel="stylesheet" href="/css/archive.css">
	
	<link rel="stylesheet" href="/css/jquery.mCustomScrollbar.min.css">
	
	<link rel="stylesheet" href="/css/Z-last-cover-others.css">
	
	
	
<meta name="generator" content="Hexo 7.3.0"></head>




<body id="wrapper">

	<div id="">
		
		<div id="top-bar">
			
			<div id="avatar-box">
				<img 
				class="avatar"
				src="/images/my-avatar.jpg" //网站头像
				alt="avatar">
			</div>

			<div id="top-bar-text">
				<div id="top-bar-title">
					阳生。
				</div>
				<div id="top-bar-slogan">
					风毛丛劲节，只上尽头竿。
				</div>
			</div>

		</div>

		<div id="menu-outer">
			<div id="menu-inner">
				
				
				<div class="menu-item">
					<a href="/">Home</a>
				</div>
				
				<div class="menu-item">
					<a href="/about">About</a>
				</div>
				
				<div class="menu-item">
					<a href="/archives">Archives</a>
				</div>
				

				<div class="menu-item menu-item-search">
					
  <span class="local-search local-search-google local-search-plugin">
      <input type="search" placeholder="站内搜索" id="local-search-input" class="local-search-input-cls" style="">
      <div id="local-search-result" class="local-search-result-cls"></div>
  </span>
	
				</div>

			</div>
		</div>

		<div id="content-outer">
			<div id="content-inner">

				

<div id="recent-posts-box">

  
  <div id="recent-posts">
    <!-- <h1>Recent Posts</h1> -->
    
    
    <div class="recent-post-item">

      <a href="/2025/10/24/Npuzzle/" class="item-title">Npuzzle</a>
      
      <time datetime="2025-10-24T02:57:13.000Z">
        2025-10-24
      </time>
      
      <!-- <div class="article-digest"> -->
        <!-- 这篇blog用于记录我在大三春季学期，修读人工智能导论过程中，进行的一个实验项目，有关Npuzzle问题的求解
主要分工
负责问题建模，准备原始样例数据；实现从原始文本数据到问题实例化对象的过程；实现将问题实例化对象转换回原始文本数据（2个人）

负责实现具体的寻路算法，涉及多种算法的实现（2个人）（IDA，Frontier实现，基于不相交数据库模式的A）

负责可视化参考视频（袁庆康）

实验报告撰写、ppt制作，我可以主要负责，需要负责各个部分的同学提供相关视图数据


后期工作
提高工程代码质量
测试

从main函数出发解析代码core.runner.Searcher（main函数）主要功能：

异常处理
实例化EngineFeeder对象
文本文件转字符串，再由EngineFeeder对象函数将字符串转为Problem对象
给定启发函数（由问题类型和任务阶段确定）
solveProblems，参数有Problem对象，AbstractSearcher对象（由EngineFeeder对象用启发函数构造），启发函数类型；

core.solver.algorithm.search -->
        <!-- </div> -->

        
        <p><code>这篇blog用于记录我在大三春季学期，修读人工智能导论过程中，进行的一个实验项目，有关Npuzzle问题的求解</code></p>
<h2 id="主要分工"><a href="#主要分工" class="headerlink" title="主要分工"></a>主要分工</h2><ol>
<li><p>负责问题建模，准备原始样例数据；实现从原始文本数据到问题实例化对象的过程；实现将问题实例化对象转换回原始文本数据（2个人）</p>
</li>
<li><p>负责实现具体的寻路算法，涉及多种算法的实现（2个人）（IDA<em>，Frontier实现，基于不相交数据库模式的A</em>）</p>
</li>
<li><p>负责可视化<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1TievzLEG9/?spm_id_from=333.337.search-card.all.click&vd_source=80df09f481ef5f0671e5e0e35d02e33e">参考视频</a>（袁庆康）</p>
</li>
<li><p>实验报告撰写、ppt制作，我可以主要负责，需要负责各个部分的同学提供相关视图数据</p>
</li>
</ol>
<h3 id="后期工作"><a href="#后期工作" class="headerlink" title="后期工作"></a>后期工作</h3><ol>
<li>提高工程代码质量</li>
<li>测试</li>
</ol>
<h2 id="从main函数出发解析代码"><a href="#从main函数出发解析代码" class="headerlink" title="从main函数出发解析代码"></a>从main函数出发解析代码</h2><p>core.runner.Searcher（main函数）主要功能：</p>
<ol>
<li>异常处理</li>
<li>实例化EngineFeeder对象</li>
<li>文本文件转字符串，再由EngineFeeder对象函数将字符串转为Problem对象</li>
<li>给定启发函数（由问题类型和任务阶段确定）</li>
<li>solveProblems，参数有Problem对象，AbstractSearcher对象（由EngineFeeder对象用启发函数构造），启发函数类型；</li>
</ol>
<p>core.solver.algorithm.searcher.AbstractSearcher（担任求解器核心组件的对象所属类，继承的抽象类）</p>
<p>core.solver.algorithm.searcher.BestFirstSearcher（最佳优先搜索算法，继承了上面的类，在老师示例中其对象就是求解器的核心组件）</p>
<p>最佳优先搜索算法的类暂时应该不需要我们实现，但是我们需要为其对象的构造提供组件，包括：Frontier、Predictor</p>
<p>core.runner.EngineFeeder（用来提供搜索器所需组件的类，所应遵从规范的，抽象类；其中已经完成了将组件frontier、predictor拼装起来，实例化为搜索器的函数，由final修饰）</p>
<p>stud.runner.WalkerFeeder（老师示例用的类feeder类，继承了EngineFeeder，负责组件frontier、predictor的提供，为了解耦合，组件对象的具体构造来自其它类）</p>
<p>stud.queue.ListFrontier（老师实现的一个优先队列，其中包含了最佳优先搜索算法执行时所需队列操作的实现）</p>
<p>stud.problem.pathfinding.Postion（其中实现了具体的启发式函数predictor，然后通过枚举映射将估值类型映射到启发式函数；而perdictor主要是在problem中使用）</p>
<h2 id="整体代码框架"><a href="#整体代码框架" class="headerlink" title="整体代码框架"></a>整体代码框架</h2><p>老师编写整个代码框架的思路大概是：1）先确定几个必要的核心组件，以及它们连接起来进行工作的逻辑；2）为每种组件编写规范，使用抽象类或者接口；3）继承规范，为我们编写了一个示例；4）编写SearcherTest类，包含main函数，作为程序入口，对处理完成的组件进行测试的顶层代码</p>
<h3 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h3><p>算法相关</p>
<ol>
<li>搜索器Searcher，main函数中进行测试求解的核心组件，规范为：抽象类AbstarctSearcher</li>
<li>拼装器？Feeder，负责使用组件优先队列frontier，估值器predictor，完成搜索器Searcher的拼装；问题实例化，规范为：抽象类EngineFeeder</li>
<li>优先队列Frontier，对应的就是我们课程中学习的fringe，用来按优先级维护节点顺序，规范为：接口Frontier</li>
<li>估值器Predictor，这个似乎<strong>比较特别</strong>，其规范是接口：Predictor，但是没有单独实现的类，老师的示例中在State的子类Position中使用了一个枚举类型映射到函数的实现</li>
</ol>
<p>问题建模相关</p>
<ol>
<li>抽象类Problem，示例寻路问题中使用PathingFinding来继承</li>
<li>抽象类State，示例中是Position进行集成</li>
<li>抽象类Action，示例中用Move进行继承</li>
</ol>
<p>注：这里的“拼装”只是为了便于阐释，并非传统意义的拼装，实际上A+B拼装成C，就是C中包含了A、B对象，当然C也有A、B对象以外自己的一些功能</p>
<h2 id="第一次会议纪要"><a href="#第一次会议纪要" class="headerlink" title="第一次会议纪要"></a>第一次会议纪要</h2><ol>
<li>明确了整个项目框架core下定义了抽象类或接口的规范，包括1）代码组织有关：AbstrcatSearcher, EngineFeeder；2）问题定义有关：Problem, State, Action；3）算法有关：Frontier、Predictor</li>
<li>明确了老师示例的寻路问题是如何实现的，这里对应<strong>1.<strong>中的规范进行描述；1）框架中实现了BestFirstSearcher（最佳优先搜索器，对应的就是课堂上学习的搜索问题一般算法，其具体是什么算法会由Frontier如何维护来决定，</strong>因此我们无需实现自己的搜索器，使用老师的搜索器即可，当我们实现不同的frontier的时候，实际上就实现了不同的算法</strong>）；2）使用WalkerFeeder继承了AbstractSearcher，对PathFinding进行实例化，并完整状态图建立，并提供ListFrontier、Predictor的接口；3）使用PathFinding继承了Problem；4）Position继承了State；5）Move继承了Action，<strong>3）~5）完成了问题建模</strong>；6）使用ListFrontier继承了Frontier实现了优先队列，边缘节点（对应课堂里伪代码中的Fringe）；7）在Position中完成了Predictor接口的实例化（<strong>在老师的示例中，关于Predictor的创建与使用似乎均被集成到了State里</strong>）</li>
<li>明确了初步分工：1）袁庆康负责可视化的实现；2）刘静洹与汪希负责算法的实现（包括Frontier的实现（Open表优先队列）、Closed表（哈希）、IDA*的实现、基于不相交数据库模式的A*算法实现）；3）汤琦先从EngineFeeder出发，把握一下这个核心组件，尝试Problem、State、Action与EngineFeeder的解耦合；4）杨子程、蔺春名预计与汤琦一起完成核心组件EngineFeeder</li>
<li>探讨了一些后续可能的工作，包括代码审计，提高质量，以及测试等工作</li>
<li>GitHub协作开发模式，fork仓库后完成自己负责的文件，申请合并到主仓库，审计合并</li>
</ol>
<p>注意事项：1）协作开发的时候尽量不要同时写一个文件；2）当主分支更新的时候及时更新自己的本地仓库，防止自己在旧版本上做较多延申，预防冲突</p>

        


        <span>
          <a class="article-read" href="/2025/10/24/Npuzzle/"> Read more -->
          </span>
        </div>

        
    
    <div class="recent-post-item">

      <a href="/2025/10/23/OS/" class="item-title">OS</a>
      
      <time datetime="2025-10-23T11:27:33.000Z">
        2025-10-23
      </time>
      
      <!-- <div class="article-digest"> -->
        <!-- 这篇blog用来记录我于大三秋季学期，学习操作系统时，了解到的知识，以备复习以及增强自己的专业素养
操作系统的基本概念L1操作系统需要解决的问题
作为用户与计算机硬件系统之间的接口（例如上层的编程者使用系统调用完成相关工作）
对计算机系统资源进行管理（eg. 管理硬件CPU、存储器、外设，管理软件程序、数据；管理资源状态，如PCB、TCB；采取相关策略，对资源分配、回收等）
在需要的时候马上对计算机资源进行抽象（通过逻辑功能扩展物理功能，如在裸机上附加外设管理、文件管理、存储管理、处理器管理）

一些启发的问题：

直接使用计算机是很不方便的，因为计算机是一个复杂精密的仪器，而大部分人只需要计算机的部分功能，无需去了解整个计算机系统的工作原理
计算机衍生出各种不同的资源，显示器、音响、打印机，各种外设，资源多样意味着，1）资源管理复杂，那么管理应该落到谁身上？使用者？某种软件？；2）不同厂家生产的设备需要纳入计算机的体系协同工作，缺少统一标准，谁来负责与不同的接口交互？

操作系统的位置
OS是配置在硬件上的第一层软件，是对硬件系统的首次扩充
OS工作在内核态

操作系统的发展过程未配 -->
        <!-- </div> -->

        
        <p><code>这篇blog用来记录我于大三秋季学期，学习操作系统时，了解到的知识，以备复习以及增强自己的专业素养</code></p>
<h2 id="操作系统的基本概念L1"><a href="#操作系统的基本概念L1" class="headerlink" title="操作系统的基本概念L1"></a>操作系统的基本概念L1</h2><h3 id="操作系统需要解决的问题"><a href="#操作系统需要解决的问题" class="headerlink" title="操作系统需要解决的问题"></a>操作系统需要解决的问题</h3><ol>
<li>作为用户与计算机硬件系统之间的接口（例如上层的编程者使用系统调用完成相关工作）</li>
<li>对计算机系统资源进行管理（eg. 管理硬件CPU、存储器、外设，管理软件程序、数据；管理资源状态，如PCB、TCB；采取相关策略，对资源分配、回收等）</li>
<li>在需要的时候马上对计算机资源进行抽象（通过逻辑功能扩展物理功能，如在裸机上附加外设管理、文件管理、存储管理、处理器管理）</li>
</ol>
<p>一些启发的问题：</p>
<ol>
<li>直接使用计算机是很不方便的，因为计算机是一个复杂精密的仪器，而大部分人只需要计算机的部分功能，无需去了解整个计算机系统的工作原理</li>
<li>计算机衍生出各种不同的资源，显示器、音响、打印机，各种外设，资源多样意味着，1）资源管理复杂，那么管理应该落到谁身上？使用者？某种软件？；2）不同厂家生产的设备需要纳入计算机的体系协同工作，缺少统一标准，谁来负责与不同的接口交互？</li>
</ol>
<h3 id="操作系统的位置"><a href="#操作系统的位置" class="headerlink" title="操作系统的位置"></a>操作系统的位置</h3><ol>
<li>OS是配置在硬件上的第一层软件，是对硬件系统的首次扩充</li>
<li>OS工作在内核态</li>
</ol>
<h3 id="操作系统的发展过程"><a href="#操作系统的发展过程" class="headerlink" title="操作系统的发展过程"></a>操作系统的发展过程</h3><h4 id="未配置操作系统的计算机系统"><a href="#未配置操作系统的计算机系统" class="headerlink" title="未配置操作系统的计算机系统"></a>未配置操作系统的计算机系统</h4><p>工作方式：用户作为计算机专业人员，使用机器语言编程，输入输出如纸带。</p>
<p>工作特点：用户独占资源，资源不能在用户间共享；CPU等待用户手工装、卸纸带，利用率很低。</p>
<h4 id="单道批处理系统"><a href="#单道批处理系统" class="headerlink" title="单道批处理系统"></a>单道批处理系统</h4><p>动机：为充分利用计算机系统，应尽量让系统连续运行，以减少空闲时间</p>
<p>工作方式：一批作业，脱机输入道磁带，监督程序控制有序处理</p>
<p>工作特点：内存中只保持一个作业运行，先进先出（单道）；成批处理作业（批处理，或许是指一批作业同时输入）</p>
<p><strong>注</strong>：单道批处理系统是最早出现的一种OS，单严格来说只能算OS前身，并非人们现在所理解的OS</p>
<h4 id="多道批处理系统"><a href="#多道批处理系统" class="headerlink" title="多道批处理系统"></a>多道批处理系统</h4><p>动机：单道批处理系统中内存中仅有一道作业，每次处理完一个作业，程序发出I&#x2F;O请求的时候CPU都处于等待状态，无法充分利用资源</p>
<p>工作方式：作业成批进入内存，按照一定策略由程序调度，轮流使用CPU</p>
<p>工作特点：内存中维护多个作业，交替使用CPU（多道性）；作业进出顺序不定（无序性）；作业经历两次调度（作业调度、进程调度）</p>
<p><strong>注</strong>：为了完成这样的工作方式，实际上牵扯到许多问题，包括处理器争用、内存分配和保护、IO设备分配、文件组织管理、作业管理、用户与系统接口等等，<strong>所以应该增加一组软件来解决这些问题，于是这些软件构成了现代意义上的操作系统</strong></p>
<h4 id="分时系统"><a href="#分时系统" class="headerlink" title="分时系统"></a>分时系统</h4><p>动机：多个程序员围着一台批处理系统的主机，缺乏一些机制来很好地为每个用户作业分配时间、为程序员提供良好的交互体验，有时一个逗号的编译错误会浪费程序员半天的时间，他们希望自己的程序可以更快地得到响应</p>
<p>工作方式：在多道批处理系统的基础上，将系统资源在时间上进行分割，每个时间段称为一个时间片，每个用户依次轮流使用时间片</p>
<p>工作特点：多个终端共享一个主机（多路性）；各个用户独立操作，互不干扰（独立性）；请求能在很短的时间得到响应（及时性）；用户可以通过中断与系统进行人机交互（交互性）</p>
<p><strong>注</strong>：实际上分时系统已经很接近如今我们使用的操作系统了，或者说就是在其基础上加入了更多的现代化改进，而下面的实时系统则是为了应对一些特殊的场景</p>
<h4 id="实时系统（特殊，仅作了解）"><a href="#实时系统（特殊，仅作了解）" class="headerlink" title="实时系统（特殊，仅作了解）"></a>实时系统（特殊，仅作了解）</h4><p>动机：在一些场景下我们特别强调作业处理的及时响应，甚至不再是及时性，而是实时性与可靠性，例如武器装备、订票系统等场景</p>
<p>实时任务种类：硬实时任务、软实时任务，前者要求系统必须满足任务对截止日期的要求，后者可以偶尔错过截止日期</p>
<h4 id="微机操作系统（了解存在）"><a href="#微机操作系统（了解存在）" class="headerlink" title="微机操作系统（了解存在）"></a>微机操作系统（了解存在）</h4><p>略</p>
<h2 id="操作系统的特性"><a href="#操作系统的特性" class="headerlink" title="操作系统的特性"></a>操作系统的特性</h2><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>并发的含义：指处理多个同时性活动的能力</p>
<ol>
<li>针对单核CPU讨论，具体来说：宏观上是这些程序同时在执行，微观上是每个时刻实际只有一个程序在执行，程序轮流使用CPU</li>
<li>并发不同于并行，后者是不同程序同一时刻在多个硬件部件上执行，例如多核CPU</li>
</ol>
<h3 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h3><p>共享的含义：操作系统与多个用户的程序共同使用计算机中的有限资源</p>
<p>共享的分类：互斥共享（打印机）、同时共享（读文件）</p>
<h3 id="虚拟"><a href="#虚拟" class="headerlink" title="虚拟"></a>虚拟</h3><p>虚拟的含义：一个物理实体映射为若干多个对应逻辑实体</p>
<p>虚拟的实现方法：分时 分空间</p>
<p>对应的具体例子：时分CPU，在每个进程看来是一个虚拟处理机；空分存储器，每个进程拥有独立的虚拟地址空间；</p>
<h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>异步的含义：操作系统必须随时对不可预测的次序发生的事件进行响应和处理</p>
<ol>
<li>多个进程发生与运行速度的不可知，导致了在操作系统视角下，整个系统在每时每刻的状态都是难以重现的</li>
<li>操作系统需要保证，只要环境相同，进程的运行结果就要一致（进程对复杂、不可重现的整个系统是感知不到的，系统对进程是透明的）</li>
<li>更准确一点来说，异步是操作系统面对的挑战</li>
</ol>
<h2 id="操作系统的功能"><a href="#操作系统的功能" class="headerlink" title="操作系统的功能"></a>操作系统的功能</h2><p>总的来说，其需要保证多道程序，有条不紊地运行，提高系统中各种资源的利用率，并方便用户的交互。</p>
<h3 id="处理器管理"><a href="#处理器管理" class="headerlink" title="处理器管理"></a>处理器管理</h3><p>进程控制：以进程为基本单位进行处理机的分配和运行</p>
<p>具体而言：</p>
<ol>
<li>为作业创建进程</li>
<li>撤销已经结束的进程</li>
<li>控制进程在运行过程中的状态转换</li>
</ol>
<p>注：在现代OS中，进程控制除了这些以外还有关于线程的管理，后续会学习到</p>
<p>进程同步：通过<strong>进程同步机制</strong>，协调进程间的资源共享，推进并发进程执行</p>
<p>进程同步的主要方式：</p>
<ol>
<li>互斥方式，各进程在对<strong>临界资源</strong>访问的时候应该采取互斥的方式</li>
<li>同步方式，有的进程之间需要<strong>相互合作</strong>，同步机制来协调她们的次序</li>
</ol>
<p>进程通信：让多个相互协作的进程可以交换信息</p>
<p>例如：I-C-P，三个进程互相通信，I为C提供数据，C为P提供结果，P进行打印</p>
<p>进程调度：控制作业、进程的运行切换，从而高效地利用处理机资源提高系统性能</p>
<ol>
<li>作业调度：从<strong>后备队列</strong>上按照一定的算法，选择出若干个作业，为其分配必要的资源</li>
<li>进程调度：从<strong>就绪队列</strong>上，挑选出一个新进程，将处理机分配给它，并为其设置好运行现场，使其投入运行</li>
</ol>
<h3 id="存储器管理"><a href="#存储器管理" class="headerlink" title="存储器管理"></a>存储器管理</h3><p>内存分配：为多道程序分配内存，提高存储器利用率</p>
<ol>
<li>静态分配：内存空间在作业装入时确定，不允许作业再申请新的内存空间，也不允许作业在空间中移动</li>
<li>动态分配：允许作业在运行过程中申请新的内存空间，适应程序和数据的动态增长，也允许作业在内存中“移动”</li>
</ol>
<p>内存保护：确保每个进程在自己的内存空间运行，互不干扰</p>
<p>例如：设置两个界限寄存器，用来存放正在执行进程的上下界，系统对每条指令访问的地址进行检查，如果有越界行为则停止程序执行</p>
<p>地址映射：将逻辑地址分配给进程，让用户可以通过逻辑地址透明地访问物理地址</p>
<p>实际上就是一种虚拟化</p>
<p>内存扩充：借助<strong>虚拟存储技术</strong>，从逻辑上扩充内存容量，让用户感知道的内存容量比实际容量大得多</p>
<h3 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h3><p>管理计算机所有的外围设备</p>
<p>缓冲区管理：解决CPU和I&#x2F;O设备速度不匹配的问题</p>
<p>设备分配：控制设备的分配和回收</p>
<p>设备处理：实现CPU和设备控制器之间的通信</p>
<p>（设备在操作系统中同样会被映射为地址）</p>
<h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h3><p>文件存储空间管理：为每个文件分配必要的外存空间，对空间进行回收（通常采用离散分配的方式）</p>
<p>目录管理：就为了让用户能方便地在外存上找到所需文件，系统为文件建立目录项</p>
<p>读写保护：文件读写管理，以及防止文件被非法窃取、破坏</p>
<h3 id="用户接口"><a href="#用户接口" class="headerlink" title="用户接口"></a>用户接口</h3><p>联机用户接口：为联机用户提供的接口，由一组键盘命令及命令解释程序组成</p>
<p>脱机用户接口：为批处理作业的用户提供的接口（这类用户无需实时交互）</p>
<h3 id="其它功能"><a href="#其它功能" class="headerlink" title="其它功能"></a>其它功能</h3><p>系统安全、网络功能与服务、支持多媒体</p>
<p><code>写在操作系统功能的最后：实际上操作系统功能这一块可以作为一张地图使用，我们后续的学习实际上就是在这个框架上的展开，一步步去学习操作系统是怎么具体地将这些功能进行实现的</code></p>

        


        <span>
          <a class="article-read" href="/2025/10/23/OS/"> Read more -->
          </span>
        </div>

        
    
    <div class="recent-post-item">

      <a href="/2025/09/30/DBS/" class="item-title">DBS</a>
      
      <time datetime="2025-09-30T11:17:29.000Z">
        2025-09-30
      </time>
      
      <!-- <div class="article-digest"> -->
        <!-- 我在大学三年级的秋季学期选修了数据库系统导论这门课程，这篇blog用来记录：1）我对于相关知识点复习的梳理；2）一些习题；3）考试的重点
复习梳理复习梳理≠照搬原文，内容阐释点到为止，最重要的是达成两个目的1）梳理整体知识脉络，形成框架；2）标记重点，便于回到资料中复习；所以最后阶段的背诵记忆，应该用这份梳理为参考结合老师的资料进行
绪论这一章主要有4个部分，从前往后，1）在数据库系统概述中了解了与数据库有关的基本概念；2）在此基础上，为了把现实世界中的事物抽象为数据保存，我们学习了数据模型；3）有了抽象的数据模型之后，我们回到抽象的数据库系统，从整体上，探讨了数据库系统的三级模式；4）最后从细节上，了解了数据库系统的组成
数据库系统概述一些与数据库有关的基本概念
数据：定义&amp;基本对象、特点（语义）
数据库：定义（具有4个特点的集合）
数据库管理系统：定义（某位置的软件）；缩写DBMS；能力（了解）
数据库系统：定义；构成（4）
关于数据库系统定义的理解（例如使用MySQL来管理数据的基础上，开发了一个实际的应用，就可以叫做数据库系统）；
关于数据管理技术的发展，主要得注意DB -->
        <!-- </div> -->

        
        <p><code>我在大学三年级的秋季学期选修了数据库系统导论这门课程，这篇blog用来记录：1）我对于相关知识点复习的梳理；2）一些习题；3）考试的重点</code></p>
<h2 id="复习梳理"><a href="#复习梳理" class="headerlink" title="复习梳理"></a>复习梳理</h2><p><code>复习梳理≠照搬原文，内容阐释点到为止，最重要的是达成两个目的1）梳理整体知识脉络，形成框架；2）标记重点，便于回到资料中复习；所以最后阶段的背诵记忆，应该用这份梳理为参考结合老师的资料进行</code></p>
<h2 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h2><p>这一章主要有4个部分，从前往后，1）在数据库系统概述中了解了与数据库有关的基本概念；2）在此基础上，为了把现实世界中的事物抽象为数据保存，我们学习了数据模型；3）有了抽象的数据模型之后，我们回到抽象的数据库系统，从整体上，探讨了数据库系统的三级模式；4）最后从细节上，了解了数据库系统的组成</p>
<h3 id="数据库系统概述"><a href="#数据库系统概述" class="headerlink" title="数据库系统概述"></a>数据库系统概述</h3><p><code>一些与数据库有关的基本概念</code></p>
<p>数据：定义&amp;基本对象、特点（语义）</p>
<p>数据库：定义（具有4个特点的集合）</p>
<p>数据库管理系统：定义（某位置的软件）；缩写DBMS；能力（了解）</p>
<p>数据库系统：定义；构成（4）</p>
<p><em>关于数据库系统定义的理解（例如使用MySQL来管理数据的基础上，开发了一个实际的应用，就可以叫做数据库系统）</em>；</p>
<p><code>关于数据管理技术的发展，主要得注意DBS阶段和文件系统阶段的对比，以及数据库系统的特点</code></p>
<p>发展的阶段（3个阶段）</p>
<p><strong>阶段对比</strong>：</p>
<p>共享程度（无共享，很多冗余-差共享，多冗余-多共享，低冗余）；</p>
<p>独立性（不独立，依赖程序-差独立，数据逻辑结构改变需修改程序-高度物理独立性与一定的逻辑独立性）；</p>
<p>结构化情况（无结构-记录内有结构，整体无结构-整体结构化）；</p>
<p>数据控制能力（应用控制-应用控制-数据库管理系统自己控制）</p>
<p><em>讨论独立性的时候，讨论的是数据与应用程序的独立性</em>；</p>
<p><strong>数据库系统的特点（4个特点，对应前面四种对比的维度）</strong>：</p>
<p>数据结构化：主要特点之一；不局限某一个应用；最小存取单位，数据项</p>
<p>共享程度：面向整个系统，多个用户、应用</p>
<p>独立性：物理独立性（数据物理存储、应用程序）；逻辑独立性（数据库逻辑结构、应用程序）；保障（二级映像）</p>
<p>数据由DBMS统一管理：安全性、完整性、并发控制、错误恢复（稍微了解概念，每一点在后面都会作为章节展开）</p>
<h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><p>数据模型：通俗概念；工具定位</p>
<p><strong>数据模型的分类</strong>：</p>
<p>两类数据模型：概念模型（信息模型）&amp;逻辑模型和物理模型</p>
<p>概念模型的一种表示方法：实体-联系方法</p>
<p>逻辑模型包括：层次、网状、关系、面向对象、对象关系模型（逻辑模型是常用的，其中的关系模型更是我们重点学习的，因为其可以用于DBMS的实现）；<em>它们都是常用的数据模型</em></p>
<p>物理模型定位：对数据的最底层抽象，数据在系统内部或磁盘磁带上的存储方式与存取方法</p>
<p><strong>数据模型的组成要素</strong>：</p>
<p>数据结构：定义；对系统静态特性的描述</p>
<p>数据操作：定义；操作类型（查询、更新：插入、删除、修改）；对系统动态特性的描述</p>
<p>数据的完整性约束条件：定义（一组完整性规则的集合）；目的（数据正确、有效、相容）<br><em>有效对应符合规定的条件，相容对应满足数据间的一致性</em></p>
<p><strong>概念模型</strong>：</p>
<p>概念模型用途：信息世界建模</p>
<p>信息世界基本概念：实体（客观存在、可区别的事物）；属性（实体的特性）；码（<strong>唯一</strong>标识实体的<strong>属性集</strong>）；域（属性取值范围）；实体型；实体集；联系（事物内部、事物之间-属性间、实体集间）</p>
<p>联系的分类：一对一联系、一对多联系、多对多联系</p>
<p>E-R图：基本图形表示；各类联系的表示；码的表示；联系可以有属性</p>
<p><strong>层次模型</strong>：</p>
<p>数据库系统中最早出现的数据模型</p>
<p>满足的基本条件：1）有且仅有一个结点没有双亲结点，根结点；2）除根结点，其它结点有且只有一个双亲</p>
<p><strong>网状模型</strong>：</p>
<p>网状数据库系统的组织方式，网状模型；<em>层次模型是网状模型的特例</em></p>
<p>满足的基本条件：1）允许一个以上的结点无双亲；2）一个结点可以有多于一个双亲结点</p>
<p><strong>关系模型</strong>：</p>
<p>关系数据库系统的组织方式，关系模型；<em>几乎与所有计算机厂商退出的DBMS都支持关系模型，伟大无需多言~</em></p>
<p>关系模型的数据结构：关系（对应一张表，元组的集合）；元组（表中的一行）；属性（表中的一列，有名字）；码（属性组，唯一确定元组）；域；分量（元组的一个属性值）；</p>
<p>关系模型的操作：查询、插入、删除、更新；<em>集合操作，操作对象与结果都是关系，即元组的集合</em></p>
<p>关系模型的完整性约束：实体完整性（码非空且唯一）、参照完整性、用户定义的完整性</p>
<p>关系模型的存储结构：实体以及联系都用表来进行（这也是关系模型的优点，概念单一）；<em>突然出现实体、联系的描述，我的理解：概念模型完成了对信息的建模，现在使用逻辑模型中的关系模型让这些抽象的信息建模具有逻辑关系，这里的逻辑关系指的是面向计算机编程的抽象逻辑，其对立面是真实的物理情况，而非抽象信息建模之间的逻辑关系（在概念模型的阶段就完成了）</em></p>
<p>关系模型的缺点：存取路径对用户隐蔽，可能导致用户使用效率较低的查询</p>
<p>关系的描述：关系模式；</p>
<p>关系的规范化：必需确保；<em>最基本的规范条件是，关系的每一个分量是不可分的数据项，绝不允许表中有表。否则就是非规范关系</em></p>
<h3 id="数据库系统的结构"><a href="#数据库系统的结构" class="headerlink" title="数据库系统的结构"></a>数据库系统的结构</h3><p>数据库系统的结构：三级模式结构，外模式-模式-内模式，外模式&#x2F;模式映像（逻辑独立性），模式&#x2F;内模式映像（物理独立性）</p>
<p>模式：数据库中<strong>全体数据</strong>的逻辑结构和特征的描述；需要对型进行描述；相对稳定；反映数据结构和联系</p>
<p>外模式：用户能够看见的局部数据的逻辑结构和特征描述</p>
<p>内模式：数据物理结构和存储方式的描述</p>
<p>型：对数据结构及属性的说明；（类比实体型，都是类似于“类”的概念）</p>
<p>值：型的具体赋值</p>
<p>实例：将模式整体看作一个型，实例就是值；反映了数据库某一个时刻的状态</p>
<h3 id="数据库系统的组成"><a href="#数据库系统的组成" class="headerlink" title="数据库系统的组成"></a>数据库系统的组成</h3><p>组成：数据库DB、数据库管理系统（及开发工具）DBMS、应用系统、数据库管理员DBA</p>
<h3 id="小结重点"><a href="#小结重点" class="headerlink" title="小结重点"></a>小结重点</h3><p>数据库系统概述：1）数据库基本概念；2）数据管理的发展过程</p>
<p>数据模型：1）数据模型的三要素；2）概念模型，E-R模型；3）三种主要数据库模型（层次、网状、关系，当然关系最重要）</p>
<p>数据库系统的结构：1）三级模式结构；2）数据库系统两层映像系统结构</p>
<p>数据库系统的组成</p>
<h2 id="关系数据库"><a href="#关系数据库" class="headerlink" title="关系数据库"></a>关系数据库</h2><h3 id="关系数据结构及形式化定义"><a href="#关系数据结构及形式化定义" class="headerlink" title="关系数据结构及形式化定义"></a>关系数据结构及形式化定义</h3><h4 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h4><p>关系模型的数据结构：关系，<strong>在用户角度</strong>，关系是一张二维表，列对应属性，行对应元组</p>
<p>关系定义的前置知识：</p>
<ol>
<li>域（Domain）：一组具有相同数据类型的值的集合</li>
<li>笛卡尔积：给定一组域，其笛卡尔积为一个集合，其中的元素形式为(d1,d2,…,dn)，di为分量，是来自域Di的值，将所有域中的进行组合得到类似的元素，然后形成的集合就是笛卡尔积</li>
<li>元组，2.中提到的元素就是元组</li>
<li>分量，元组的分量的值，简称分量</li>
</ol>
<p>于是，笛卡尔积可以表示为一个二维表，其中的每一行对应一个元组，每一列的值来自一个域</p>
<p>关系：域D1、D2、…、Dn的笛卡尔积的子集，即在D1，D2，…，Dn上的关系，表示为R(D1,D2,…,Dn)，其中R就是关系名，而n可以叫做<strong>关系的目或度</strong>（n&#x3D;1时为单元关系，n&#x3D;2时为二元关系）</p>
<p>元组的表示：通常用t进行标识</p>
<p>关系的表示：可以将关系看作一个二维表，行对应元组，列对应域</p>
<p>属性：属性的引入是类似给域取了一个名字，毕竟域作为一个值的集合本身并没有名字，我们给它取一个名字可以反映这组值代表的含义。（这也是我们通常更关注的东西，例如对于一列元组的字符串分量值，比起关心它们都是字符串，我们更关心它们的实际含义，例如它们都代表名字）</p>
<p>码：</p>
<ol>
<li>候选码：关系中某一属性组的值能够唯一标识一个元组，则该属性组是候选码</li>
<li>全码：当一个关系的候选码是所有属性构成的属性组时，该属性组称为全码</li>
<li>主码：如果一个关系有多个候选码的时候，则选定一个作为主码（注意，候选码本身也可能是属性组）</li>
<li>主属性：候选码对应属性组中的各个属性都是主属性（主属性不是主码的属性）</li>
<li>非主属性：不包含在任何候选码中的属性，即非主属性</li>
</ol>
<h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><p><code>视每次作业的情况而定，我可能会在这里写我最初版的作业，最终提交则是在此之上加以改进；同时会附加一些我在完成作业的过程中学习到的知识</code></p>
<h3 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h3><p>习题1，描述数据、数据库、数据库管理系统、数据库系统的概念</p>
<ol>
<li>数据是用来描述事物的符号记录，是数据库中存储的基本对象。</li>
<li>数据库是长期存储在计算机内、有组织、可共享的大量数据的集合。</li>
<li>数据库管理系统是位于用户和操作系统之间的一层数据管理软件，和操作系统一样是计算机的基础软件，是一个大型且复杂的软件系统。</li>
<li>数据库系统是指在计算机系统中引入数据库后的系统。</li>
</ol>
<p>习题2，描述文件系统和数据库系统的区别和联系</p>
<ol>
<li>区别：主要在共享性、冗余度、结构化上，文件系统共享性差，冗余度高，记录内有结构但是整体无结构；数据库系统共享性好，冗余度低，整体结构化。</li>
<li>联系：数据库系统和文件系统都属于数据管理技术，并且前者是后者的继承与发展；在硬件实现方面它们都可以使用磁盘，处理方式上都支持联机实时处理与批处理，都是系统本身作为数据的管理者等等。</li>
</ol>
<p>习题8，描述数据模型的概念，作用及其包含的三个要素</p>
<ol>
<li>概念：数据模型是数据库中用于抽象、表示和处理现实世界中的数据和信息的工具，是现实世界的模拟，满足能比较真实地模拟现实世界、容易为人所理解、便于在计算机上实现这三个条件。</li>
<li>作用：用于抽象、表示和处理现实世界中的数据和信息。</li>
<li>三个要素：数据结构、数据操作以及数据的完整性约束。</li>
</ol>
<p><code>这个概念或许需要进一步明确一下</code></p>
<p>习题14，描述数据库系统的三级模式结构，并说明这种结构的优点是什么</p>
<ol>
<li>三级模式结构：主要是指内模式，模式，外模式的三级结构，其中内模式是数据物理结构和存储方式的描述，模式是全体数据的逻辑结构和特征描述，外模式是数据库用户能看见和使用的局部数据的逻辑结构和特征的描述；内模式与模式之间由，模式&#x2F;内模式映像连接。模式与外模式之间由外模式&#x2F;模式映像连接。</li>
<li>优点：使用了映像连接，在内模式修改的时候，同时修改模式&#x2F;内模式映像，可以确保物理独立性；在模式修改的时候，同时修改外模式&#x2F;模式映像，可以确保逻辑独立性。</li>
</ol>
<p>习题15，描述数据与程序的物理独立性和逻辑独立性。为什么是数据库系统具有较强的数据与程序的独立性。</p>
<ol>
<li>物理独立性：用户的应用与存储在磁盘上的数据库中的数据是相互独立的，当数据物理存储改变了，应用程序不用改变。</li>
<li>逻辑独立性：用户的应用程序与数据库的逻辑结构是相互独立的，数据的逻辑结构改变了，用户程序可以不变。</li>
<li>较好的数据与程序的逻辑独立性，是因为应用程序依据数据的外模式进行编写，当模式改变的时候，数据库管理员通过修改外模式&#x2F;模式映像，使外模式保持不变从而让应用程序不必修改。</li>
<li>较好的数据与程序的物理独立性，是因为当数据库的存储结构改变了，数据库管理员可以修改模式&#x2F;内模式映像，让模式保持不变，从而让应用程序不受影响。</li>
</ol>
<h2 id="考试"><a href="#考试" class="headerlink" title="考试"></a>考试</h2><h2 id="SQL练习（创建、修改、删除）"><a href="#SQL练习（创建、修改、删除）" class="headerlink" title="SQL练习（创建、修改、删除）"></a>SQL练习（创建、修改、删除）</h2><h3 id="创建基本表"><a href="#创建基本表" class="headerlink" title="创建基本表"></a>创建基本表</h3><p>其基本语言规范是</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">CREATE TABLE &lt;表名&gt;</span><br><span class="line">(</span><br><span class="line">    &lt;列名&gt; &lt;数据类型&gt; [列级完整性约束],</span><br><span class="line">    &lt;列名&gt; &lt;数据类型&gt; [列级完整性约束],</span><br><span class="line">    [表级完整性约束]</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="eg5-建立学生数据表"><a href="#eg5-建立学生数据表" class="headerlink" title="eg5 建立学生数据表"></a>eg5 建立学生数据表</h4><p>要求：</p>
<ol>
<li>学号是主键</li>
<li>姓名不能重复</li>
<li>性别是一个汉字（对应旧版本mysql两个字符）</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">CREATE TABLE Student</span><br><span class="line">(</span><br><span class="line">    Sno CHAR(10) PRIMARY KEY,</span><br><span class="line">    Sname CHAR(20) UNIQUE,</span><br><span class="line">    Ssex CHAR(2),</span><br><span class="line">    Sage SMALLINT,</span><br><span class="line">    Sdept CHAR(20)</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="eg6-建立课程数据表"><a href="#eg6-建立课程数据表" class="headerlink" title="eg6 建立课程数据表"></a>eg6 建立课程数据表</h4><p>要求：</p>
<ol>
<li>课程号是主键CHAR(4)</li>
<li>课程名不允许为空</li>
<li>先修课是外码，参照的是自己的课程号属性</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">CREATE TABLE Course</span><br><span class="line">(</span><br><span class="line">    Cno CHAR(4) PRIMARY KEY,</span><br><span class="line">    Cname CHAR(40) NOT NULL,</span><br><span class="line">    Cpno CHAR(4),</span><br><span class="line">    Ccredit SMALLINT,</span><br><span class="line">    FOREIGN KEY (Cpno)</span><br><span class="line">    REFERENCES Course Cno</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>错误修正</strong>：<code>REFERENCES Course Cno</code>应该是<code>REFERENCES Course(Cno)</code></p>
<h4 id="eg7-建立选课表"><a href="#eg7-建立选课表" class="headerlink" title="eg7 建立选课表"></a>eg7 建立选课表</h4><p>要求：</p>
<ol>
<li>主键由两个Sno、Cno两个属性构成</li>
<li>Sno、Cno还分别是外键，参考前面两个表中的对应属性</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">CREATE TABLE SC</span><br><span class="line">(</span><br><span class="line">    Sno CHAR(10),</span><br><span class="line">    Cno CHAR(4),</span><br><span class="line">    Grade SMALLINT,</span><br><span class="line">    PRIMARY KEY (Sno,Cno),</span><br><span class="line">    FOREIGN KEY (Sno)</span><br><span class="line">    REFERENCES Student(Sno),</span><br><span class="line">    FOREIGN KEY (Cno)</span><br><span class="line">    REFERENCES Course(Cno)</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>注意创建主键为多个属性组合时的写法：</strong><code>PRIMARY KEY (Sno,Cno)</code></p>
<h3 id="修改基本表"><a href="#修改基本表" class="headerlink" title="修改基本表"></a>修改基本表</h3><p>基本规范如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ALTER TABLE &lt;表名&gt;</span><br><span class="line">[ADD &lt;列名&gt; &lt;数据类型&gt; [完整性约束]]</span><br><span class="line">[DROP &lt;列名&gt; &lt;数据类型&gt;]</span><br><span class="line">[ALTER COLUMN &lt;列名&gt; &lt;数据类型&gt;]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="eg8-向学生表增加入学时间"><a href="#eg8-向学生表增加入学时间" class="headerlink" title="eg8 向学生表增加入学时间"></a>eg8 向学生表增加入学时间</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ALTER TABLE Student</span><br><span class="line">ADD S_entrance DATA;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>错误修正：</strong>时间的数据类型应该是<code>DATE</code>而不是<code>DATA</code></p>
<h4 id="eg9-将学生表中的年龄属性转换为INT类型"><a href="#eg9-将学生表中的年龄属性转换为INT类型" class="headerlink" title="eg9 将学生表中的年龄属性转换为INT类型"></a>eg9 将学生表中的年龄属性转换为INT类型</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ALTER TABLE Student</span><br><span class="line">ALTER COLUMN Sage INT;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>注意以下事项</strong>：</p>
<ol>
<li>COLUMN的拼写</li>
<li>在MYSQL中似乎对列的修改不是ALTER，而是MODIFY，即<code>MODIFY COLUMN Sage INT;</code></li>
</ol>
<h2 id="SQL练习（查询）"><a href="#SQL练习（查询）" class="headerlink" title="SQL练习（查询）"></a>SQL练习（查询）</h2><h3 id="单表查询"><a href="#单表查询" class="headerlink" title="单表查询"></a>单表查询</h3><ol>
<li>选择表的若干列</li>
<li>选择表的若干元组</li>
<li>ORDER BY 子句</li>
<li>聚集函数</li>
<li>GROUP BY子句</li>
</ol>
<p><strong>关于GROUP BY，我本地的mysql和教材的SQL标准存在一些偏差</strong>：做如下记录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SELECT Sno</span><br><span class="line">FROM SC</span><br><span class="line">GROUP BY Sno;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的查询语句本地的mysql显示的结果会自动去重，和我理解的按照Sno属性是否相同将对应元组放在一张表里面，而不改变元组的个数有一些不同；<strong>但是使用COUNT语句能够正确统计出各组元组的个数，和课本上一致。</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SELECT Sno,Cno</span><br><span class="line">FROM SC</span><br><span class="line">GROUP BY Sno</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>本地上是会报错的，老师说按照课本的逻辑这应该是可以执行的，并且查询的结果会是没有分组的Sno、Cno</p>
<p><strong>总是，GROUP BY语句大多数时候还是配合聚集函数使用的，直接显示结果比较少</strong>。</p>
<h4 id="查询若干列"><a href="#查询若干列" class="headerlink" title="查询若干列"></a>查询若干列</h4><p>eg1 查询全体学生的姓名和学号</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SELECT Sname,Sno</span><br><span class="line">From Student;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>eg2 查询全体学生的姓名、学号和所在系</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SELECT Sname,Sno,Sdept</span><br><span class="line">FROM Student;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>eg3 查询全体学生的详细记录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SLECT * FROM Student;</span><br></pre></td></tr></table></figure>

<p><strong>查询若干列的时候，不仅可以直接查询，还可以查询经过计算的表达式</strong>，常用的表达式如下：</p>
<ol>
<li>算术表达式，例如<code>SELECT 2024 - Sage FROM Student;</code>，结果显示Sage列，并且每一个元组下的值都是2024-对应值</li>
<li>字符串常量，例如<code>SELECT &#39;birth of date&#39;,Birth,2024 - Sage FROM Student;</code>，结果会显示两列，在Sage列前会新增一列，名为Birth，其下的值均为字符串’birth of date’，第二列名为Sage，其下的值都是2024-Sage</li>
<li>函数，例如<code>SELECT LOWER(Sdept) FROM Student;</code>，结果显示Sdept列，结果是其下对应元组值中的字符串无论大小写均使用小写</li>
<li>列别名，规范<code>SELECT &lt;列名&gt; &lt;列别名&gt;</code>，显示的时候会自然将对应的列作别名显示</li>
</ol>
<p>eg4 查询全体学生的姓名及出生年份</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SELECT Sname,<span class="string">&#x27;birth of date:&#x27;</span> BIRTH,2025-Sage BIRTHDAY</span><br><span class="line">FROM Student;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>eg5 查询学生的姓名、出生年份和所在院系，要求小写字母表示所有系名</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SELECT Sname,<span class="string">&#x27;birth of date:&#x27;</span> BIRTH,2025-Sage BIRTHDAY,LOWER(Sdept)</span><br><span class="line">FROM Student;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="选择表中的若干元组"><a href="#选择表中的若干元组" class="headerlink" title="选择表中的若干元组"></a>选择表中的若干元组</h4><p><strong>关于DISTINCT和ALL</strong>：如果没有规定DISTINCT，则默认为ALL，前者会消除重复行，后者会保留所有在原始基本表中查询到的满足条件的元组</p>
<p>eg6 查询选修了课程的学生学号</p>
<p>eg6思路：对于SC课程表查询Sno，并去重</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SELECT DISTINCT Sno</span><br><span class="line">FROM SC;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong><code>DISTINCT</code>出现的位置，不是在列名之后，否则就变成别名了</p>
<p><strong>关于选择元组常用的查询条件（比较）</strong>：</p>
<ol>
<li>比较：<code>&lt;, &gt;, =, !=, &lt;&gt;, !&gt;, !&lt;, NOT</code>，小于、大于、等于、不等于、不等于、不大于、不小于、否定布尔表达式（<code>NOT(布尔表达式)</code>常见用法）</li>
<li>确定范围：<code>BETWEEN AND, NOT BETWEEN AND</code></li>
<li>确定集合：<code>IN, NOT IN</code></li>
<li>字符匹配：<code>LIKE, NOT LIKE</code></li>
<li>空值：<code>IS NULL, IS NOT NULL</code></li>
<li>多重条件（逻辑运算）：<code>AND, OR, NOT</code></li>
</ol>
<p>eg7 查询计算机科学系全体学生的名单</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SELECT *</span><br><span class="line">FROM Student</span><br><span class="line">WHERE Sdept = <span class="string">&#x27;CS&#x27;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>eg8 查询所有年龄在20岁以下学生姓名及年龄</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SELECT Sname,Sage</span><br><span class="line">FROM Student</span><br><span class="line">WHERE Sage&lt;20;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>eg9 查询考试成绩有不及格的学生学号</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SELECT DISTINCT Sno</span><br><span class="line">FROM SC</span><br><span class="line">WHERE Grade&lt;60;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>关于选择元组常用的查询条件（确定范围）</strong>：<code>BETWEEN...AND...</code>和<code>NOT BETWEEN...AND...</code>，注意<code>BETWEEN...AND...</code>是包含边界的！</p>
<p>eg10 查询年龄在20~23岁之间的学生姓名、系别和年龄</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SELECT Sname,Sdept,Sage</span><br><span class="line">FROM Student</span><br><span class="line">WHERE Sage BETWEEN 20 AND 23;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>eg11 查询年龄不在20~23岁之间的学生姓名、系别和年龄</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SELECT Sname,Sdept,Sage</span><br><span class="line">FROM Student</span><br><span class="line">WHERE Sage NOT BETWEEN 20 AND 23;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>关于选择元组常用的查询条件（确定集合）</strong>：<code>IN &lt;值表&gt;</code>，<code>NOT IN &lt;值表&gt;</code>，例如，对于字符串的值，值表写法是<code>(&#39;1&#39;,&#39;2&#39;,&#39;3&#39;)</code></p>
<p>eg12 查询信息系IS、数学系MA和计算机科学系CS，学生姓名和系别</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SELECT Sname,Sdept</span><br><span class="line">FROM Student</span><br><span class="line">WHERE Sdept IN (<span class="string">&#x27;IS&#x27;</span>,<span class="string">&#x27;MA&#x27;</span>,<span class="string">&#x27;CS&#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>eg13 查询既不是信息系、数学系也不是计算机科学系的学生姓名和性别</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SELECT Sname,Ssex</span><br><span class="line">FROM Student</span><br><span class="line">WHERE Sdept NOT IN (<span class="string">&#x27;IS&#x27;</span>,<span class="string">&#x27;MA&#x27;</span>,<span class="string">&#x27;CS&#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>关于选择元组常用的查询条件（字符匹配）</strong>：</p>
<ol>
<li>基本的用法是<code>[NOT] LIKE &#39;&lt;匹配串&gt;&#39;</code>，值得注意的是匹配串中可以有通配符，有两种分别是：<code>%</code>和<code>_</code>，前者可以代表任意数量的任意字符，后者代表一个任意字符</li>
<li><code>ESCAPE &#39;&lt;转义字符&gt;&#39;</code>，指定的转义字符用于通配符前面，用来将通配符当作一个普通的字符，但是值得注意的是<strong>如果转义字符单独出现那么它只会被当作普通字符</strong>，这与一些常见语言的处理方式是不同的，不需要两个转义字符来表示其本身</li>
</ol>
<p>eg14 查询学号为200215121学生的详细情况</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SELECT *</span><br><span class="line">FROM Student</span><br><span class="line">WHERE Sno LIKE <span class="string">&#x27;200215121&#x27;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>eg15查询所有姓刘学生的姓名、学号和性别</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SELECT Sname,Sno,Ssex</span><br><span class="line">FROM Student</span><br><span class="line">WHERE Sname LIKE <span class="string">&#x27;刘%&#x27;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>eg16查询姓“欧阳”且全名为三个汉字的学生的姓名</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SELECT Sname</span><br><span class="line">FROM Student</span><br><span class="line">WHERE Sname LIKE <span class="string">&#x27;欧阳__&#x27;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：实际上现在经过测试，MySQL做了适配，一个下划线就可以对应一个汉字字符，从前要用两个，是因为在编码的时候汉字有内外码，一个汉字对应两个字符长度</p>
<p>eg18 查询所有不姓刘的学生姓名</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SELECT Sname</span><br><span class="line">FROM Student</span><br><span class="line">WHERE Sname NOT LIKE <span class="string">&#x27;刘%&#x27;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>eg19 查询DB_Design课程的课程号和学分</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SELECT Cno,Credit</span><br><span class="line">FROM Course</span><br><span class="line">WHERE Cname LIKE <span class="string">&#x27;DB\_Design&#x27;</span></span><br><span class="line">ESCAPE <span class="string">&#x27;\&#x27;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>eg20 查询以’DB_’开头，且倒数第3个字符为’i’的课程的详细情况</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SELECT *</span><br><span class="line">FROM Course</span><br><span class="line">WHERE Cname LIKE <span class="string">&#x27;DB\_%i__&#x27;</span></span><br><span class="line">ESCAPE <span class="string">&#x27;\&#x27;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>关于选择元组常用的查询条件（涉及空值）</strong>：使用语句<code>IS NULL</code>或<code>IS NOT NULL</code>，这里的<code>IS</code>不能够用<code>=</code>来代替，简单理解就是，<code>NULL</code>是一个对象而不是一个值</p>
<p>eg21 查询缺少成绩的学生的学号和相应的课程号</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SELECT Sno,Cno</span><br><span class="line">FROM SC</span><br><span class="line">WHERE Grade IS NULL;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>关于选择元组常用的查询条件（多重条件查询）</strong>：</p>
<ol>
<li>主要使用逻辑运算符AND和OR，用它们两个来连接布尔表达式（由各种查询条件构成的）</li>
<li>默认情况下AND的优先级高于OR的优先级，可以使用括号来改变优先级</li>
</ol>

        


        <span>
          <a class="article-read" href="/2025/09/30/DBS/"> Read more -->
          </span>
        </div>

        
    
    <div class="recent-post-item">

      <a href="/2025/09/04/csp%E4%B9%A0%E9%A2%98%E9%9B%86/" class="item-title">csp习题集</a>
      
      <time datetime="2025-09-04T06:26:27.000Z">
        2025-09-04
      </time>
      
      <!-- <div class="article-digest"> -->
        <!-- 这篇blog用来记录我练习ccf csp认证的时候做过的习题
梦境巡查 第36次 task2缓存模拟 第36次 task3大模拟题先整理信息：

有N组缓存，每组缓存中有n块
内存块k，存储在k&#x2F;n组中，n个缓存块的任意一个
操作，读、写内存块，分为两种情况：1）k&#x2F;n组中存储了数据（某行），命中；2）k&#x2F;n组中没有数据（所有行），没有命中
命中，分为两种情况：1）读，无特殊处理；2）写，修改缓存行，标记对应内存块是修改了的，实际还没有改内存块
未命中，先进行载入，再按照命中处理
载入，1）如果k&#x2F;n组有未使用的，就载入未使用的位置；2）否则，按照LRU进行替换，如果内存块修改过要写回

我的思路：

对于N组，每组维护一个队列（队列中存储实际的内存块编号，以及该内存块是否修改过），队列的长度上限设置为n
未命中的时候，1）如果进行载入，队长小于n，直接将内存块入队即可（这里进行了读内存块）；2）如果进行替换，被替换的是队首元素，检查该元素是否被修改过，如果是（这里进行写内存块），然后再将内存块入队（这里进行了读内存块）
命中的时候，1）如果是读 -->
        <!-- </div> -->

        
        <p><code>这篇blog用来记录我练习ccf csp认证的时候做过的习题</code></p>
<h2 id="梦境巡查-第36次-task2"><a href="#梦境巡查-第36次-task2" class="headerlink" title="梦境巡查 第36次 task2"></a>梦境巡查 第36次 task2</h2><h2 id="缓存模拟-第36次-task3"><a href="#缓存模拟-第36次-task3" class="headerlink" title="缓存模拟 第36次 task3"></a>缓存模拟 第36次 task3</h2><p>大模拟题先整理信息：</p>
<ol>
<li>有N组缓存，每组缓存中有n块</li>
<li>内存块k，存储在k&#x2F;n组中，n个缓存块的任意一个</li>
<li>操作，读、写内存块，分为两种情况：1）k&#x2F;n组中存储了数据（某行），命中；2）k&#x2F;n组中没有数据（所有行），没有命中</li>
<li>命中，分为两种情况：1）读，无特殊处理；2）写，修改缓存行，标记对应内存块是修改了的，实际还没有改内存块</li>
<li>未命中，先进行载入，再按照命中处理</li>
<li>载入，1）如果k&#x2F;n组有未使用的，就载入未使用的位置；2）否则，按照LRU进行替换，如果内存块修改过要写回</li>
</ol>
<p>我的思路：</p>
<ol>
<li>对于N组，每组维护一个队列（队列中存储实际的内存块编号，以及该内存块是否修改过），队列的长度上限设置为n</li>
<li>未命中的时候，1）如果进行载入，队长小于n，直接将内存块入队即可（这里进行了读内存块）；2）如果进行替换，被替换的是队首元素，检查该元素是否被修改过，如果是（这里进行写内存块），然后再将内存块入队（这里进行了读内存块）</li>
<li>命中的时候，1）如果是读，修改队列，取出命中的元素，重新入队，其它元素相对位置不变；2）如果是写，在1）的基础上还要标记对应内存块被修改过</li>
</ol>
<h2 id="字符串变换-第35次CCF认证"><a href="#字符串变换-第35次CCF认证" class="headerlink" title="字符串变换 第35次CCF认证"></a>字符串变换 第35次CCF认证</h2><p>我的思路：</p>
<p>如果直接使用1个map存储映射的话，当查询的变换次数很大的时候肯定会超时，于是我想到了用两个key（char，int）映射到一个char，代表char变换int次的时候映射到的char。</p>
<p>具体的思路：</p>
<ol>
<li>定义一个struct，里面有char、int；定义map&lt;struct, char&gt;，将struct中的char变换int次后，映射到新的char</li>
<li>初始化的情况是struct(char,0) map&lt;struct,char&gt; &#x3D;&#x3D; char本身；然后根据映射函数，处理边界struct(char,1) map&lt;struct,char&gt; &#x3D;&#x3D; char(如果有映射就是新的，没有仍然保持自己)；注意初始化的时候还要考虑，原始字符串中字符可以映射到的字符</li>
<li>处理变换，如果某次查询是变换k次，那么从1变换到k，保存一路下来的结果，之后的查询只要小于k就可以直接一次变换即可。</li>
</ol>
<p>代码实现如下（考虑了一下，把struct换成tuple了，而且0的初始化是冗余的，直接从1开始了）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">map</span>&lt;tuple&lt;<span class="type">int</span>,<span class="type">char</span>&gt;, <span class="type">char</span>&gt; mp;</span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ini</span><span class="params">()</span> &#123;</span><br><span class="line"> getline(<span class="built_in">cin</span>, s);</span><br><span class="line"> <span class="type">int</span> t; </span><br><span class="line"> <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line"> getchar();<span class="comment">//吞回车</span></span><br><span class="line"> <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">  <span class="comment">//处理函数的映射，注意没有指明的映射映射到自己</span></span><br><span class="line">  <span class="built_in">string</span> ss;</span><br><span class="line">  getline(<span class="built_in">cin</span>, ss);</span><br><span class="line">  tuple&lt;<span class="type">int</span>, <span class="type">char</span>&gt; <span class="title function_">st1</span><span class="params">(<span class="number">1</span>, ss[<span class="number">1</span>])</span>;</span><br><span class="line">  mp[st1] = ss[<span class="number">2</span>]; </span><br><span class="line"></span><br><span class="line">  tuple&lt;<span class="type">int</span>, <span class="type">char</span>&gt; <span class="title function_">st2</span><span class="params">(<span class="number">1</span>, ss[<span class="number">2</span>])</span>;</span><br><span class="line">  <span class="keyword">if</span> (mp.find(st2) == mp.end())</span><br><span class="line">   mp[st2] = ss[<span class="number">2</span>];</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; s[i] != <span class="string">&#x27;#&#x27;</span>; i++) &#123;</span><br><span class="line">  <span class="comment">//检查源字符串中是否存在函数映射没有覆盖到的，若有则映射到自己</span></span><br><span class="line">  tuple&lt;<span class="type">int</span>, <span class="type">char</span>&gt; <span class="title function_">st</span><span class="params">(<span class="number">1</span>, s[i])</span>;</span><br><span class="line">  <span class="keyword">if</span> (mp.find(st) == mp.end())</span><br><span class="line">   mp[st] = s[i];</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> <span class="title function_">f</span><span class="params">(<span class="type">char</span> c,<span class="type">int</span> k)</span> &#123;</span><br><span class="line"> <span class="comment">//将c映射k次</span></span><br><span class="line"> <span class="type">char</span> res = c;</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">  tuple&lt;<span class="type">int</span>, <span class="type">char</span>&gt; <span class="title function_">st</span><span class="params">(<span class="number">1</span>, res)</span>;<span class="comment">//不断进行一次映射，进行k次</span></span><br><span class="line">  res = mp[st];</span><br><span class="line">  <span class="keyword">if</span> (i == <span class="number">1</span>)<span class="keyword">continue</span>;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="comment">//当进行i&gt;1次的时候，保存映射结果</span></span><br><span class="line">   tuple&lt;<span class="type">int</span>, <span class="type">char</span>&gt; st1(i, c);</span><br><span class="line">   mp[st1] = res;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">search</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="type">int</span> m;</span><br><span class="line"> <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line"> <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">  <span class="type">int</span> k;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; s[i] != <span class="string">&#x27;#&#x27;</span>; i++) &#123;</span><br><span class="line">   <span class="comment">//逐个处理字符映射</span></span><br><span class="line">   tuple&lt;<span class="type">int</span>, <span class="type">char</span>&gt; <span class="title function_">st</span><span class="params">(k, s[i])</span>;</span><br><span class="line">   <span class="keyword">if</span> (mp.find(st) == mp.end()) &#123;</span><br><span class="line">    <span class="comment">//如果没有，则进行映射处理</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f(s[i],k);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//如果有则直接输出</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; mp[st];</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27;#&#x27;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"> ini();</span><br><span class="line"> search();</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="补丁应用-第35次CCF认证-task3"><a href="#补丁应用-第35次CCF认证-task3" class="headerlink" title="补丁应用 第35次CCF认证 task3"></a>补丁应用 第35次CCF认证 task3</h2><p>大模拟题，先看信息：</p>
<p>关于diff输出的补丁</p>
<ol>
<li>一个块 or 多个块；块：若干行文本；文本：对文件的一处修改；</li>
<li>关于第一行文本：1）@@开头结尾；2）NN MM nn mm是1~9字符组成的字符串；0、1或多个字符；最终表示一个整数；第NN行开始修改；修改了MM行；“这处”修改从新文件nn行开始；“这处”修改在新文件中有mm行</li>
<li>关于随后的若干行文本：1）-开头是删除该行；2）+开头被添加该行；3）空格开头，该行未变化； -与空格开头的行 &#x3D; MM；+与空格开头的行 &#x3D; mm</li>
</ol>
<p>关于patch</p>
<ol>
<li>移除#开头的</li>
<li>@开始到下一个@之间未一个块；如果没有@开头补丁损坏</li>
</ol>
<p>对于每一个块</p>
<ol>
<li>检查第一行格式，如果不正确则补丁损坏</li>
</ol>
<p>如果补丁未损坏</p>
<ol>
<li>解析NN、MM、mm</li>
<li>检查NN大于等于前一个块 NN与MM之和，否则补丁损坏</li>
</ol>
<p>如果补丁未损坏</p>
<ol>
<li>其余行，是否有+、-、空格开头的行，否则补丁损坏</li>
</ol>
<p>未损坏</p>
<ol>
<li>-、空格开头的是源文件片段</li>
<li>片段行数是否与MM一致，否则补丁损坏</li>
</ol>
<p>未损坏</p>
<ol>
<li>提取+、空格开头的，作为新文件片段</li>
<li>片段行数是否与mm一致，否则补丁损坏</li>
</ol>
<p>如果所有块都通过检查，即补丁未损坏（补丁有多个块）</p>
<p>修改源文件操作：</p>
<p>检查是否存在整数d，使得</p>
<ol>
<li>对于第一块，源文件NN+d行开始的MM行，与第一块的“源文件”片段完全匹配；</li>
<li>对于非第一块，除了1）要满足的条件之外，还要满足NN+d，不小于前一个块的NN+MM之和；否则补丁损坏</li>
<li>如果存在多个d，取绝对值最小的，如果仍存在多个，取小于0的d</li>
</ol>
<p>找到d之后（对于每个块应该要找一个d）</p>
<ol>
<li>将原文件的第NN+d行开始的MM行替换为块的新文件内容</li>
</ol>
<h2 id="通讯延迟-第35次CCF认证-task4"><a href="#通讯延迟-第35次CCF认证-task4" class="headerlink" title="通讯延迟 第35次CCF认证 task4"></a>通讯延迟 第35次CCF认证 task4</h2><p>基本思路是根据覆盖情况建图，然后跑一个dijkstra算法</p>
<ol>
<li>遍历每一个基站，检查它覆盖范围内的结点，范围内的结点互相间可以有边，完成建图</li>
<li>dijkstra算法，从结点1到结点n的最短路</li>
</ol>
<p>关于建立图的方式：</p>
<p>对每一个基站，确定其四个边界点的范围；<br>    遍历每一个点，确定其是否在该范围内；对在该范围内的所有点，两两之间添加边</p>
<p>关于dijkstra算法</p>
<ol>
<li>选定初始结点，纳入起点集合（队列）；用vis标志其距离已经确定</li>
<li>起点集合队首元素出列，作为起点，更新其到各个结点的距离；选择距离最短的结点，（检查未被vis标志）纳入起点集合，并用vis标志其距离已经确定</li>
<li>直到所有可以选择的点都被纳入过起点集合 1）所有点都被纳入过了；2）未被纳入的点距离都是INF</li>
</ol>
<p>反复处理，直到所有结点都被纳入起点集合</p>

        


        <span>
          <a class="article-read" href="/2025/09/04/csp习题集/"> Read more -->
          </span>
        </div>

        
    
    <div class="recent-post-item">

      <a href="/2025/09/01/DFS-DP%E5%88%B7%E9%A2%98%E7%BB%83%E4%B9%A0/" class="item-title">DFS&amp;DP刷题练习</a>
      
      <time datetime="2025-09-01T07:52:59.000Z">
        2025-09-01
      </time>
      
      <!-- <div class="article-digest"> -->
        <!-- 在通过网上一些资料稍微系统学习了一下DFS相关的内容，还有初步接触了一些DP的基础知识之后，我开这篇blog用来记录我刷相关的练习题的思路
打家劫舍 Ⅱ leetcode213第一版代码是错误的。
我的思路是，现在房屋形成了一个环，我可以任意枚举一个位置入手，把环剪开，此时还原成房屋是一排的情况，然后套用Ⅰ的dp模板就可以了。
这样做的问题在于，dp模板在新的一排房屋上，相当于状态树是从i+1的位置开始的，但是dp模板是套用在从0开始的。也就是说状态树结点上前后结点的值有严格的依赖，任意剪切环，形成的数组，从前往后的dp并不对应原始数据的状态树。
以下是第一版代码：
123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution &#123;public:    int ans = 0;    int rob(vector&lt;int&gt;&amp; nums) &#123;        if(nums.size() == 1)return  -->
        <!-- </div> -->

        
        <p><code>在通过网上一些资料稍微系统学习了一下DFS相关的内容，还有初步接触了一些DP的基础知识之后，我开这篇blog用来记录我刷相关的练习题的思路</code></p>
<h2 id="打家劫舍-Ⅱ-leetcode213"><a href="#打家劫舍-Ⅱ-leetcode213" class="headerlink" title="打家劫舍 Ⅱ leetcode213"></a>打家劫舍 Ⅱ leetcode213</h2><p>第一版代码是错误的。</p>
<p>我的思路是，现在房屋形成了一个环，我可以任意枚举一个位置入手，把环剪开，此时还原成房屋是一排的情况，然后套用Ⅰ的dp模板就可以了。</p>
<p>这样做的问题在于，dp模板在新的一排房屋上，相当于状态树是从i+1的位置开始的，但是dp模板是套用在从0开始的。也就是说状态树结点上前后结点的值有严格的依赖，任意剪切环，形成的数组，从前往后的dp并不对应原始数据的状态树。</p>
<p>以下是第一版代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() == <span class="number">1</span>)<span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums.size() == <span class="number">2</span>)<span class="keyword">return</span> max(nums[<span class="number">1</span>],nums[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums.size() == <span class="number">3</span>)<span class="keyword">return</span> max(nums[<span class="number">2</span>],max(nums[<span class="number">1</span>],nums[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; nums.size();i++)&#123;</span><br><span class="line">            <span class="type">int</span> cnt = nums[i];</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> b1 = i,b2 = (i<span class="number">-1</span>+nums.size())%nums.size(),b3 = (i+<span class="number">1</span>)%nums.size();</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; t;</span><br><span class="line">            t.clear();</span><br><span class="line">            <span class="comment">// for(int j = 0;j &lt; nums.size();j++)</span></span><br><span class="line">            <span class="comment">//     if(j != b1&amp;&amp;j != b2&amp;&amp;j != b3)t.push_back(nums[j]); 这样简单粗暴的构造t没有考虑到环断开之后，首位相接的情况</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i+<span class="number">2</span>;j &lt; nums.size();j++)</span><br><span class="line">                t.push_back(nums[j]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; i<span class="number">-1</span>;j++)</span><br><span class="line">                t.push_back(nums[j]);</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(t.size() == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(ans &lt; t[<span class="number">0</span>]+cnt)ans = t[<span class="number">0</span>]+cnt;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(t.size() == <span class="number">2</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(ans &lt; max(t[<span class="number">0</span>],t[<span class="number">1</span>])+cnt) ans = max(t[<span class="number">0</span>],t[<span class="number">1</span>])+cnt;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> new_f,f0 = t[<span class="number">0</span>],f1 = t[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">2</span>;j &lt; t.size();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                new_f = max(f1,f0+t[j]);</span><br><span class="line">                f0 = f1;</span><br><span class="line">                f1 = new_f;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(new_f + cnt &gt; ans)ans = new_f + cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>正确的思路是只从第一个位置把环剪开，枚举偷第一个位置，不偷第一个位置；</p>
<p>我最开始想到从任意位置剪开环，其实是相当于在选不选的子集模板中，不从第一个数开始考虑，从任意的数字开始考虑。看似是为了“考虑所有情况”，实际上打乱了状态树的状态，按照从前往后依次考虑选不选本就能够把所有状态考虑进去。而这道题只是在此基础上多了一个，第一个位置要特殊考虑，它会衍生出两种情况，就第一个位置的特殊考虑而言已经完备，分别在两种情况中直接使用“从前往后选或不选”的思想，也是完备的，综合来看可以考虑所有情况，而不会打乱状态树，可以套用dp模板。否则只会像我的第一版思路，打乱了状态树，还套用dp模板，只会造成错误（这样的错误在某种程度上来说，就是我改变了某些房屋的位置，改变了它们的相邻关系。）</p>
<p>修改后的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() == <span class="number">1</span>)<span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums.size() == <span class="number">2</span>)<span class="keyword">return</span> max(nums[<span class="number">1</span>],nums[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums.size() == <span class="number">3</span>)<span class="keyword">return</span> max(nums[<span class="number">2</span>],max(nums[<span class="number">1</span>],nums[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> new_f = <span class="number">0</span>, f1 = <span class="number">0</span>, f0 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//选第一个房屋</span></span><br><span class="line">        <span class="comment">// f0 = nums[2+0], f1 = max(nums[2+0],nums[2+1]);</span></span><br><span class="line">        <span class="comment">// if(4 == nums.size() &amp;&amp; nums[0]+f0 &gt; ans)ans = nums[0]+f0;</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// for(int j = 2+2;j &lt; nums.size() - 1;j++)</span></span><br><span class="line">        <span class="comment">// &#123;</span></span><br><span class="line">        <span class="comment">//     new_f = max(f1,f0+nums[j]);</span></span><br><span class="line">        <span class="comment">//     f0 = f1;</span></span><br><span class="line">        <span class="comment">//     f1 = new_f;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// if(new_f+nums[0] &gt; ans) ans = new_f+nums[0]; 注意选第一个房屋不一定要偷第一个房屋，我的代码就错在了这里！</span></span><br><span class="line"></span><br><span class="line">        f0 = nums[<span class="number">0</span>],f1 = max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">2</span>;j &lt; nums.size()<span class="number">-1</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            new_f = max(f1,f0+nums[j]);</span><br><span class="line">            f0 = f1;</span><br><span class="line">            f1 = new_f;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(new_f &gt; ans) ans = new_f;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//不选第一个房屋</span></span><br><span class="line">        f0 = nums[<span class="number">1</span>+<span class="number">0</span>], f1 = max(nums[<span class="number">1</span>+<span class="number">0</span>],nums[<span class="number">1</span>+<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>+<span class="number">2</span>;j &lt; nums.size();j++)</span><br><span class="line">        &#123;</span><br><span class="line">            new_f = max(f1,f0+nums[j]);</span><br><span class="line">            f0 = f1;</span><br><span class="line">            f1 = new_f;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(new_f &gt; ans) ans = new_f;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我在写这版代码开始的时候又犯了一个错误，选第一间房屋的意思是要考虑第一间，而不是一定会偷第一间；实际上选第一间与否代表着参与递推计算的索引范围不同，也是考虑的房屋范围不同。但是确定了范围之后使用递推计算的过程，对应的才是考虑实际要不要偷的问题。</p>
<h2 id="删除并获得点数"><a href="#删除并获得点数" class="headerlink" title="删除并获得点数"></a>删除并获得点数</h2><p>题干：</p>
<p>给你一个整数数组 nums ，你可以对它进行一些操作。</p>
<p>每次操作中，选择任意一个 nums[i] ，删除它并获得 nums[i] 的点数。之后，你必须删除 所有 等于 nums[i] - 1 和 nums[i] + 1 的元素。</p>
<p>开始你拥有 0 个点数。返回你能通过这些操作获得的最大点数。</p>
<p>我的思路：</p>
<p>这道题和打家劫舍有一点像，不过其取走i处的元素后不能再取的并不直接是i-1，i+1处的元素，而是元素值等于nums[i]+1和nums[i]-1处的元素。</p>
<p>首先，我想尽量还原回打家劫舍的场景，看是否能套用模板。于是我想到了<strong>排序</strong>，排完序之后，对于ban掉的位置而言，根据元素值的+1、-1会比较接近直接根据下标值的+1、-1。</p>
<p>于是我考虑直接使用dfs的模板，回溯三问：</p>
<ol>
<li>当前问题考虑能从0~i位置获取到的最大值，当前操作，是否选择位置i的元素</li>
<li>子问题，如果选择了位置i的元素，那么考虑0<del>j位置获取到的最大值，其中j是从i-1开始，第一个不满足nums[j]+1 &#x3D;&#x3D; nums[i]的元素的下标；如果没有选择位置i的元素，那么考虑0</del>i-1位置能获取到的最大元素</li>
<li>子问题的操作，如果…，是否选择位置j的元素；如果…是否选择位置i-1处的元素</li>
</ol>
<p>然而上面存在一个问题，即第2步的时候：“对于j是，第一个不满足nums[j]+1 &#x3D;&#x3D; nums[i]的元素的下标”，如果nums[i] !&#x3D; nums[i-1]的话这是正确的，换言之，如果存在相同元素，那么索引范围的缩减会出现错误，误以为已经缩减成剔除了nums[j]+1 &#x3D;&#x3D; nums[i]对应的元素nums[j]，但实际上没有剔除。</p>
<p>所以为了回溯三问对应的思路是正确的，我们要确保没有相同元素的存在；又因为我们要取得最大值，所以你如果选择了一个nums[i]，那么剩下的相同值的元素你都应该选；于是我想到了用一个哈希表，以nums[i]为key，value存储所有值为nums[i]的元素的和；然后将nums更新，使得重复的元素只保留一个，再排序；最后套用回溯三问的思路即可。</p>
<p>代码实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; mp;</span><br><span class="line">    <span class="type">int</span> cnt[<span class="number">20000</span>];</span><br><span class="line">    <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">0</span>)<span class="keyword">return</span> mp[nums[<span class="number">0</span>]];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i<span class="number">-1</span>]+<span class="number">1</span> == nums[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(cnt[i] != <span class="number">-1</span>)<span class="keyword">return</span> cnt[i];</span><br><span class="line">                cnt[i] = max(dfs(i<span class="number">-1</span>,nums),dfs(i<span class="number">-2</span>,nums)+mp[nums[i]]);</span><br><span class="line">                <span class="keyword">return</span> cnt[i];</span><br><span class="line">            &#125;   </span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(cnt[i] != <span class="number">-1</span>)<span class="keyword">return</span> cnt[i];</span><br><span class="line">                cnt[i] = dfs(i<span class="number">-1</span>,nums)+mp[nums[i]];</span><br><span class="line">                <span class="keyword">return</span> cnt[i];</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">deleteAndEarn</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; nums.size();i++)</span><br><span class="line">            mp[nums[i]]+=nums[i];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; t;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it = mp.begin();it != mp.end();it++)</span><br><span class="line">            t.push_back(it-&gt;first);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; t.size();i++)cnt[i] = <span class="number">-1</span>;</span><br><span class="line">        sort(t.begin(),t.end());</span><br><span class="line">        <span class="keyword">return</span> dfs(t.size()<span class="number">-1</span>,t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="统计构造好字符串的方案数-leetcode-2466"><a href="#统计构造好字符串的方案数-leetcode-2466" class="headerlink" title="统计构造好字符串的方案数 leetcode 2466"></a>统计构造好字符串的方案数 leetcode 2466</h2><p>题干：</p>
<p>给你整数 zero ，one ，low 和 high ，我们从空字符串开始构造一个字符串，每一步执行下面操作中的一种：</p>
<ol>
<li>将 ‘0’ 在字符串末尾添加 zero  次。</li>
<li>将 ‘1’ 在字符串末尾添加 one 次。<br>以上操作可以执行任意次。</li>
</ol>
<p>如果通过以上过程得到一个 长度 在 low 和 high 之间（包含上下边界）的字符串，那么这个字符串我们称为 好 字符串。</p>
<p>请你返回满足以上要求的 不同 好字符串数目。由于答案可能很大，请将结果对 109 + 7 取余 后返回。</p>
<p>我的第一种思路，试一试dfs，枚举每次选zero还是选one即可，时间复杂度显然是$O(2^n)$，不出所料超时了…但是正确性是有保证的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans;</span><br><span class="line">    <span class="type">int</span> low,high,zero,one;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> M = <span class="number">1000000007</span>;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> len)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(len &gt; high)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(len &gt;= low)ans = (ans+<span class="number">1</span>)%M;</span><br><span class="line"></span><br><span class="line">        dfs(len+zero);</span><br><span class="line">        dfs(len+one);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">countGoodStrings</span><span class="params">(<span class="type">int</span> low, <span class="type">int</span> high, <span class="type">int</span> zero, <span class="type">int</span> one)</span> &#123;</span><br><span class="line">        this-&gt;low = low, this-&gt;high = high, this-&gt;zero = zero, this-&gt;one = one;</span><br><span class="line">        dfs(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>改进的思路是添加记忆化。换一个视角，其实这就是爬楼梯的翻版，每次可以选择爬zero或one阶，爬到x in [low,high]，的方案总和有多少。于是可以写出如下记忆化递归：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> M = <span class="number">1000000007</span>;</span><br><span class="line">    <span class="type">int</span> zero,one;</span><br><span class="line">    <span class="type">int</span> cnt[<span class="number">100001</span>];</span><br><span class="line">    <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> len)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//得到空串的方案数是1</span></span><br><span class="line">        <span class="keyword">if</span>(len &lt; <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(cnt[len] != <span class="number">-1</span>)<span class="keyword">return</span> cnt[len];</span><br><span class="line">        <span class="keyword">else</span> cnt[len] = (dfs(len-zero)+dfs(len-one))%M;</span><br><span class="line">        <span class="keyword">return</span> cnt[len];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">countGoodStrings</span><span class="params">(<span class="type">int</span> low, <span class="type">int</span> high, <span class="type">int</span> zero, <span class="type">int</span> one)</span> &#123;</span><br><span class="line">        this-&gt;zero = zero,this-&gt;one = one;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= high;i++)cnt[i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = low;i &lt;= high;i++)</span><br><span class="line">            ans = (ans + dfs(i))%M;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>有两个关键点</p>
<ol>
<li>递归的边界条件，dfs(i)代表爬i阶的方案数，所以dfs(0) &#x3D;&#x3D; 1，可以理解成爬0阶就是一种方案，或者理解为递归从i到0的时候，0是整个下台阶尝试成功的一条分支，所以返回1；而i&lt;0的情况就是尝试失败的分支，所以返回0</li>
<li>最后的ans累加的是dfs(i)，low&lt;&#x3D; i &lt;&#x3D;high，虽然我们的dfs(i)本身代表的是爬上i阶的方案，并且在cnt中进行了记忆化，但是对于i的不同初态，能够递归到的情况是不同的；所以不能直接dfs(high)，然后ans累加cnt[i]，i in [low, high]（例如low &#x3D; 4，high &#x3D; 5，zero &#x3D; 2，one &#x3D; 2，如果从high开始，dfs(4)并不会被递归到）</li>
</ol>
<p><strong>第二个关键点是我第一次遇见</strong>，这算是一种在递归中初态会影响后续分支选择的情况，值得着重注意。</p>
<h2 id="组合总和"><a href="#组合总和" class="headerlink" title="组合总和"></a>组合总和</h2><p>题干：</p>
<p>给你一个由 不同 整数组成的数组 nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数。（元素可以重复选取）</p>
<p>题目数据保证答案符合 32 位整数范围。</p>
<p>我的思路：仍然可以看成爬楼梯的变式，这次要爬的楼梯数是固定的，但是每次的选择有nums.size()种。dfs枚举每一次每一种选，然后加一个记忆化即可。基本上就是直接套板子了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cnt[<span class="number">1001</span>];</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i &lt; <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(cnt[i] != <span class="number">-1</span>)<span class="keyword">return</span> cnt[i];</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; nums.size();j++)</span><br><span class="line">                res += dfs(i - nums[j]);</span><br><span class="line">            cnt[i] = res;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">combinationSum4</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt;= target;i++)cnt[i] = <span class="number">-1</span>;</span><br><span class="line">        this-&gt;nums = nums;</span><br><span class="line">        <span class="keyword">return</span> dfs(target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="统计打字方案数"><a href="#统计打字方案数" class="headerlink" title="统计打字方案数"></a>统计打字方案数</h2><p>爬楼梯的变式，可以看成楼梯是由数字标定的不同种类，有这样几个关键的条件限制</p>
<ol>
<li>一次只能爬一种台阶</li>
<li>对于7、9标定的台阶，一次最多爬4阶；其它数字对应的台阶一次最多爬3阶</li>
</ol>
<p>在此基础上，从dfs(-1)开始，代表还没有爬任何一阶（因为string从0开始索引就代表第一阶了）；然后开始爬楼梯，使用check()检查当前位置可以爬几阶，例如可以爬3阶的时候就是dfs(i) &#x3D; dfs(i+1)+dfs(i+2)+dfs(i+3)，向下递归即可；边界条件是i &#x3D;&#x3D; str.length()-1，即i已经索引到了最后一个字符，也就是爬上了最高的台阶。</p>
<p>最后再引入一个记忆化即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="type">int</span> cnt[<span class="number">100001</span>];</span><br><span class="line">    <span class="type">int</span> tlen[<span class="number">100001</span>];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> i)</span>&#123;<span class="comment">//确定可以上几个台阶</span></span><br><span class="line">        <span class="type">int</span> len = <span class="number">1</span>;<span class="comment">//至少上一阶，不会有上0阶的情况，因为在dfs中以到最后一阶（i == str.length()-1）为边界条件</span></span><br><span class="line">        <span class="keyword">if</span>(len + i == str.length() - <span class="number">1</span>)<span class="keyword">return</span> len;<span class="comment">//上一阶就到最后一阶了</span></span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> t = str[i + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(t == <span class="string">&#x27;7&#x27;</span> || t == <span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(;(len + i != str.length())&amp;&amp;(str[len + i] == str[i + <span class="number">1</span>]);len++);</span><br><span class="line">            <span class="keyword">return</span> min(len<span class="number">-1</span>,<span class="number">4</span>);<span class="comment">//最多上4阶</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(;(len + i != str.length())&amp;&amp;(str[len + i] == str[i + <span class="number">1</span>]);len++);</span><br><span class="line">            <span class="keyword">return</span> min(len<span class="number">-1</span>,<span class="number">3</span>);<span class="comment">//最多上3阶</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == str.length()<span class="number">-1</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i &gt;= <span class="number">0</span> &amp;&amp; cnt[i] != <span class="number">-1</span>)<span class="keyword">return</span> cnt[i];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">-1</span>)len = check(i);</span><br><span class="line">        <span class="keyword">else</span> len = tlen[i];</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= len;j++)</span><br><span class="line">            res = (res + dfs(i+j))%<span class="number">1000000007</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(i &gt;= <span class="number">0</span>)cnt[i] = res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">countTexts</span><span class="params">(<span class="built_in">string</span> pressedKeys)</span> &#123;</span><br><span class="line">        this-&gt;str = pressedKeys;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; str.length();i++)cnt[i] = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; str.length()<span class="number">-1</span>;i++)</span><br><span class="line">            tlen[i] = check(i);</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但是这样记忆化搜索会被最后几个非常庞大的样例卡住，时间大概是擦边不能过的样子…</p>
<p>参考了题解之后，这道题应该直接用dp，虽然dp和记忆化搜索在一般情况下认为时间大差不差，但是这种时间擦边不能过的情况，记忆化搜索稍微比dp多出来的一点时间就成为掣肘的关键了。</p>
<p>改dp的思路：</p>
<ol>
<li>打标计算只有一类台阶的情况，爬到第i阶的时候有多少种方案</li>
<li>再中间台阶类型变换的时候使用乘法原理处理</li>
</ol>
<p>转移方程参考爬楼梯的模板dp[i] &#x3D; dp[i-1] + dp[i-2]，不难理解。 </p>
<p>代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> dp1[<span class="number">100001</span>];<span class="comment">//dp1[i]代表在全是一类台阶的情况下，爬到i的方案数</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> dp2[<span class="number">100001</span>];<span class="comment">//dp2[i]代表在全是二类台阶的情况下，爬到i的方案数</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> M = <span class="number">1000000007</span>;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">ini</span><span class="params">()</span>&#123;</span><br><span class="line">        dp1[<span class="number">0</span>] = <span class="number">1</span>,dp1[<span class="number">1</span>] = <span class="number">1</span>,dp1[<span class="number">2</span>] = <span class="number">2</span>,dp1[<span class="number">3</span>] = <span class="number">4</span>;<span class="comment">//不爬；1；11、2；3、12、21、111；</span></span><br><span class="line">        dp2[<span class="number">0</span>] = <span class="number">1</span>,dp2[<span class="number">1</span>] = <span class="number">1</span>,dp2[<span class="number">2</span>] = <span class="number">2</span>,dp2[<span class="number">3</span>] = <span class="number">4</span>;<span class="comment">//同上</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//提前打好dp表，后续直接用</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">4</span>;i &lt; <span class="number">100001</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp1[i] = (dp1[i<span class="number">-1</span>] + dp1[i<span class="number">-2</span>] + dp1[i<span class="number">-3</span>])%M;</span><br><span class="line">            dp2[i] = (dp2[i<span class="number">-1</span>] + dp2[i<span class="number">-2</span>] + dp2[i<span class="number">-3</span>] + dp2[i<span class="number">-4</span>])%M;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">countTexts</span><span class="params">(<span class="built_in">string</span> pressedKeys)</span> &#123;</span><br><span class="line">        ini();</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">1</span>;<span class="comment">//最后的答案爬完这种楼梯的方案数，中间要用乘法处理，因为楼梯的类型会变化，乘的就是一种类型的楼梯爬了几个台阶</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; pressedKeys.length();)&#123;</span><br><span class="line">            <span class="type">int</span> j;</span><br><span class="line">            <span class="keyword">for</span>(j = i+<span class="number">1</span>;j &lt; pressedKeys.length() &amp;&amp; pressedKeys[j] == pressedKeys[i];j++);<span class="comment">//注意边界情况，最后爬到最高的台阶应该是第pressedKeys.length()阶，而不是按照索引去减1；可以想想里面具体有多少字符</span></span><br><span class="line">            <span class="keyword">if</span>(pressedKeys[i] == <span class="string">&#x27;7&#x27;</span> || pressedKeys[i] == <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">                ans = (ans * dp2[j - i])%M;</span><br><span class="line">            <span class="keyword">else</span> ans = (ans * dp1[j - i])%M;</span><br><span class="line">            i = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这道题给我最大的感受是，对于边界条件的设置，以及不同索引下dp数组的含义 or dfs递归的状态 要有清楚的认识，这样才不会乱。我被索引绕得有点晕写了好久…</p>
<h2 id="统计各位数字都不同的数字个数"><a href="#统计各位数字都不同的数字个数" class="headerlink" title="统计各位数字都不同的数字个数"></a>统计各位数字都不同的数字个数</h2><p>题干：</p>
<p>给你一个整数 n ，统计并返回各位数字都不同的数字 x 的个数，其中 0 &lt;&#x3D; x &lt; 10n 。</p>
<p>示例 1：</p>
<p>输入：n &#x3D; 2<br>输出：91<br>解释：答案应为除去 11、22、33、44、55、66、77、88、99 外，在 0 ≤ x &lt; 100 范围内的所有数字。</p>
<p>这道题换一个视角来看，就是有0<del>9，十张卡片，按照要求抽1</del>n张卡，求对应所有的排列情况之和（即抽1张卡时的排列情况+2张卡时的排列情况+…）。可以直接使用全排列；由于抽卡的数量是1~n，所以问题状态树上的每一个结点都对应增加一种情况，而不是完成抽卡之后才统计为一种情况。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">1</span>;<span class="comment">//一位的情况下可以有一个单独的0</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> r)</span>&#123;<span class="comment">//i是当前抽的第几个数字，r是当前剩余的数字数量</span></span><br><span class="line">        <span class="keyword">if</span>(i == n)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt; r;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                ans++;</span><br><span class="line">                dfs(<span class="number">1</span>,r<span class="number">-1</span>);<span class="comment">//第一个数字不能是0</span></span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; r;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                ans++;</span><br><span class="line">                dfs(i+<span class="number">1</span>,r<span class="number">-1</span>);</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">countNumbersWithUniqueDigits</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        this-&gt;n = n;</span><br><span class="line">        dfs(<span class="number">0</span>,<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意点是</p>
<ol>
<li>上面写的dfs递归不涵盖n &#x3D;&#x3D; 0的情况，所以ans初始时置为1；</li>
<li>然后n &#x3D;&#x3D; 1的时候由于n &#x3D;&#x3D; 0抽掉了1，所以只剩9张卡；而当n &gt; 1的时候，高位数字不能为0，所以第一次抽也只有9张卡，于是统一在dfs中有一个特殊处理，即i &#x3D;&#x3D; 0的情况</li>
</ol>
<h2 id="最小路径和"><a href="#最小路径和" class="headerlink" title="最小路径和"></a>最小路径和</h2><p>题干：</p>
<p>给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<p>说明：每次只能向下或者向右移动一步。</p>
<p>我的基本思路是这样的：</p>
<p>回溯三问：</p>
<ol>
<li>当前操作，是否选择要向右移动</li>
<li>当前子问题，要做k次选择，其中只能且必须选择i次向右，要求获得收益最少</li>
<li>子问题的下一个问题，情况1：如果选择了向右，那么还要做k-1次选择，只能且必须选择i-1次向右；如果没有选择向右，那么还要做k-1次选择，只能且必须选择i次向右</li>
</ol>
<p>关于边界条件：</p>
<ol>
<li>当i &#x3D;&#x3D; k的时候，剩余k次全部选择向右</li>
<li>当i &#x3D;&#x3D; 0的时候，剩余k此全部选择向下</li>
</ol>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; cnt;<span class="comment">//记录每一次的选择，1向右，0向下</span></span><br><span class="line">    <span class="type">int</span> memo[<span class="number">200</span>][<span class="number">400</span>];</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; grid;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">compute</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="number">0</span>,y = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> t = grid[x][y];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; cnt.size();i++)</span><br><span class="line">            <span class="keyword">if</span>(cnt[i] == <span class="number">1</span>)t += grid[x][++y];</span><br><span class="line">            <span class="keyword">else</span> t += grid[++x][y];</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == k)&#123;<span class="comment">//只能向右走了</span></span><br><span class="line">            <span class="keyword">if</span>(memo[i][k] != <span class="number">-1</span>)<span class="keyword">return</span> memo[i][k];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; k;j++)</span><br><span class="line">                cnt.push_back(<span class="number">1</span>);</span><br><span class="line">            <span class="type">int</span> res = compute();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; k;j++)</span><br><span class="line">                cnt.pop_back();</span><br><span class="line">            memo[i][k] = res;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;<span class="comment">//只能向下走了</span></span><br><span class="line">            <span class="keyword">if</span>(memo[i][k] != <span class="number">-1</span>)<span class="keyword">return</span> memo[i][k];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; k;j++)</span><br><span class="line">                cnt.push_back(<span class="number">0</span>);</span><br><span class="line">            <span class="type">int</span> res = compute();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; k;j++)</span><br><span class="line">                cnt.pop_back();</span><br><span class="line">            memo[i][k] = res;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(memo[i][k] != <span class="number">-1</span>)<span class="keyword">return</span> memo[i][k];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//选择向右走</span></span><br><span class="line">        cnt.push_back(<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> t1 = dfs(i<span class="number">-1</span>,k<span class="number">-1</span>);</span><br><span class="line">        cnt.pop_back();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//选择向下走</span></span><br><span class="line">        cnt.push_back(<span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> t2 = dfs(i,k<span class="number">-1</span>);</span><br><span class="line">        cnt.pop_back();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = min(t1,t2);</span><br><span class="line">        memo[i][k] = res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">minPathSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">200</span>;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; <span class="number">400</span>;j++)</span><br><span class="line">                memo[i][j] = <span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        this-&gt;grid = grid;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dfs(grid[<span class="number">0</span>].size()<span class="number">-1</span>,grid.size()+grid[<span class="number">0</span>].size()<span class="number">-2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但是这份代码出现了问题。</p>
<p>其实回溯三问的考量下的状态转移，以及递归的边界条件都没有问题，而状态是出现在记忆化上。</p>
<p><strong>来自deepseek的总结</strong>非常鞭辟入里</p>
<p>你的代码的基本思路是使用记忆化搜索（DFS + memoization），通过记录路径选择（<code>cnt</code> 向量）并在边界条件下计算完整路径和（<code>compute</code> 函数）。然而，错误的核心在于 <strong>记忆化设计不完整</strong>，导致在某些情况下错误地重用了记忆化值。具体原因如下：<br>记忆化键（memo[i][k]）不足以唯一标识状态</p>
<p>你的记忆化数组 memo[i][k] 使用两个参数：</p>
<ol>
<li>i：表示剩余需要向右走的步数。</li>
<li>k：表示总剩余步数（剩余向右步数 + 剩余向下步数）。</li>
</ol>
<p>在状态 (i, k) 下，理论上剩余路径是确定的（需要走 i 步向右和 k - i 步向下），但 (i, k) 没有捕获当前位置 (x, y) 或前缀路径的累积和。<br>问题在于，compute 函数计算的是 从起点 (0, 0) 开始的完整路径和，而不是从当前状态开始的剩余路径和。compute 使用全局 cnt 向量重建整个路径，但 cnt 包含了所有历史选择（从起点到当前点的路径）。因此：<br>相同的 (i, k) 状态可能从不同的位置 (x, y) 到达（例如，通过不同的路径前缀）。<br>由于起点到当前位置的前缀路径不同，compute 计算的完整路径和也会不同。<br>然而，你的记忆化只基于 (i, k) 存储结果，忽略了当前位置或前缀路径的影响。这会导致错误的重用：当从不同路径到达相同的 (i, k) 状态时，memo[i][k] 可能返回一个错误的完整路径和（该值依赖于之前计算时的前缀路径，而非当前路径）。</p>
<p>其实这本质上就是犯了我常犯的一个错误——<strong>将累积变量作为了参数传递</strong>，如果使用累积变量作为参数传递，通常是不能使用记忆化的；（看似我这里没有把它当作参数传递，但是本质上累积变量是到达边界的时候才进行计算的。）</p>
<p>进一步思考，我对于这个问题的考虑太过复杂了，其实没必要考虑“选择序列”是怎样的，直接将位置作为状态即可。</p>
<p>重新考虑回溯三问</p>
<ol>
<li>当前操作，在位置(x,y)，去到位置(x+1,y)还是位置(x,y+1)</li>
<li>当前子问题，在位置(x,y)，如何移动到终点，使得收益最小</li>
<li>当前子问题的下一个问题，1）在(x+1,y)如何移动到终点使得收益最小；2）在(x,y+1)如何移动到终点使得收益最小</li>
</ol>
<p>边界条件：</p>
<p>x &#x3D;&#x3D; g.size()-1 || y &#x3D;&#x3D; g.size()-1</p>
<p>状态转移：</p>
<p>dfs(x,y) &#x3D; min(dfs(x+1,y)+g[x+1][y],dfs(x,y+1)+g[x][y+1]) s.t. x !&#x3D; g.size()-1 &amp;&amp; y !&#x3D; g[0].size()-1<br>… s.t. x &#x3D;&#x3D; g.size()-1<br>… s.t. y &#x3D;&#x3D; g[0].size()-1</p>
<p>g[0][0]可以直接作为初始值，累加在答案上。</p>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> memo[<span class="number">200</span>][<span class="number">200</span>];</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; g;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == g.size() - <span class="number">1</span> &amp;&amp; y == g[<span class="number">0</span>].size() - <span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(memo[x][y] != <span class="number">-1</span>)<span class="keyword">return</span> memo[x][y];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(x == g.size() - <span class="number">1</span>)&#123;</span><br><span class="line">            memo[x][y] = dfs(x,y+<span class="number">1</span>) + g[x][y+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">return</span> memo[x][y];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(y == g[<span class="number">0</span>].size() - <span class="number">1</span>)&#123;</span><br><span class="line">            memo[x][y] = dfs(x+<span class="number">1</span>,y) + g[x+<span class="number">1</span>][y];</span><br><span class="line">            <span class="keyword">return</span> memo[x][y];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            memo[x][y] = min(dfs(x+<span class="number">1</span>,y) + g[x+<span class="number">1</span>][y],dfs(x,y+<span class="number">1</span>) + g[x][y+<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">return</span> memo[x][y];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">minPathSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">200</span>;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; <span class="number">200</span>;j++)</span><br><span class="line">                memo[i][j] = <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">        this-&gt;g =grid;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> g[<span class="number">0</span>][<span class="number">0</span>] + dfs(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样才能明显的看见，累积变量是在递归状态转移的过程中累加的，而没有作为参数处理。‘</p>
<h2 id="将石头分散到网格图的最少移动次数"><a href="#将石头分散到网格图的最少移动次数" class="headerlink" title="将石头分散到网格图的最少移动次数"></a>将石头分散到网格图的最少移动次数</h2><p>题干：</p>
<p>给你一个大小为 3 * 3 ，下标从 0 开始的二维整数矩阵 grid ，分别表示每一个格子里石头的数目。网格图中总共恰好有 9 个石头，一个格子里可能会有 多个 石头。</p>
<p>每一次操作中，你可以将一个石头从它当前所在格子移动到一个至少有一条公共边的相邻格子。</p>
<p>请你返回每个格子恰好有一个石头的 最少移动次数 。</p>
<p>我的思路：</p>
<ol>
<li>预处理，统计重叠石头的存在位置（注意是统计重叠了的石头，例如一个位置有3个石头要统计两次）；统计没有石头的位置</li>
<li>对存在石头的位置进行全排列，与没有石头的位置一一匹配，计算每一种情况的移动次数</li>
<li>保留最少的移动次数</li>
</ol>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Pos</span>&#123;</span></span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="type">int</span> y;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Pos&gt; a;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Pos&gt; b;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">100000000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;Pos&gt;&amp; cmb)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cmb.size() == b.size())&#123;</span><br><span class="line">            <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; cmb.size();i++)&#123;</span><br><span class="line">                cnt += (<span class="built_in">abs</span>(cmb[i].x - b[i].x) + <span class="built_in">abs</span>(cmb[i].y - b[i].y));</span><br><span class="line">            &#125;</span><br><span class="line">            ans = min(ans, cnt);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; a.size();i++)&#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">Pos</span> <span class="title">t</span> =</span> a[i];</span><br><span class="line">            cmb.push_back(t);</span><br><span class="line">            a.erase(a.begin()+i);</span><br><span class="line">            dfs(cmb);</span><br><span class="line">            a.insert(a.begin()+i,t);</span><br><span class="line">            cmb.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">minimumMoves</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; <span class="number">3</span>;j++)</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="class"><span class="keyword">struct</span> <span class="title">Pos</span> <span class="title">t</span>;</span></span><br><span class="line">                    t.x = i,t.y = j;</span><br><span class="line">                    b.push_back(t);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(grid[i][j] &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> k = grid[i][j]<span class="number">-1</span>;k &gt; <span class="number">0</span>;k--)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">struct</span> Pos t;</span><br><span class="line">                        t.x = i,t.y = j;</span><br><span class="line">                        a.push_back(t);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;Pos&gt; t;</span><br><span class="line">        dfs(t);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

        


        <span>
          <a class="article-read" href="/2025/09/01/DFS-DP刷题练习/"> Read more -->
          </span>
        </div>

        
    
    <div class="recent-post-item">

      <a href="/2025/08/30/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E6%95%B4%E7%90%86/" class="item-title">深度优先搜索整理</a>
      
      <time datetime="2025-08-30T03:28:38.000Z">
        2025-08-30
      </time>
      
      <!-- <div class="article-digest"> -->
        <!-- 这篇blog用来整理一些常见的可以使用深度优先搜索的问题模板
写在最前面在这篇blog中会高频地出现三个词汇，DFS、递归、回溯，实际上DFS与后二者的关联是十分密切的。
狭义上来说，DFS是在图上面做搜索的一种算法，它使用深度优先，依次处理各个结点。可以用递归函数的形式实现，也可以用循环+栈的形式实现。
但是从广义上来说，对于可以枚举状态的问题，问题的状态转移的过程本就可以抽象成一棵树，而树本质上就是一个特殊的图。当我们使用递归函数，搜索问题的各个状态的时候，就可以看作，我们是在一张“特殊的”图上，做DFS。
关于回溯与它们的联系，后面再进行补充。
基本范式DFS的模板框架如下：
1234567891011121314151617181920function dfs(now_state)&#123;    if(now_state == target_state)    &#123;        ...        return ...;    &#125;    for(... enumerate new_state)&#123;        if(new_state is  -->
        <!-- </div> -->

        
        <p><code>这篇blog用来整理一些常见的可以使用深度优先搜索的问题模板</code></p>
<h2 id="写在最前面"><a href="#写在最前面" class="headerlink" title="写在最前面"></a>写在最前面</h2><p>在这篇blog中会高频地出现三个词汇，<strong>DFS、递归、回溯</strong>，实际上DFS与后二者的关联是十分密切的。</p>
<p>狭义上来说，DFS是在图上面做搜索的一种算法，它使用深度优先，依次处理各个结点。可以用<strong>递归函数的形式</strong>实现，也可以用<strong>循环+栈</strong>的形式实现。</p>
<p>但是从广义上来说，对于可以枚举状态的问题，问题的状态转移的过程本就可以<strong>抽象成一棵树</strong>，而树本质上就是一个特殊的图。当我们使用递归函数，搜索问题的各个状态的时候，就可以看作，我们是在一张“特殊的”图上，做DFS。</p>
<p><em>关于回溯与它们的联系，后面再进行补充</em>。</p>
<h2 id="基本范式"><a href="#基本范式" class="headerlink" title="基本范式"></a>基本范式</h2><p>DFS的模板框架如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function <span class="title function_">dfs</span><span class="params">(now_state)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(now_state == target_state)</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> ...;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(... enumerate new_state)&#123;</span><br><span class="line">        <span class="keyword">if</span>(new_state is valid)&#123;</span><br><span class="line">            vis[new_state] = ...;<span class="comment">//标记新状态被访问</span></span><br><span class="line">            dfs(new_state);</span><br><span class="line">            ? vis[new_state] = ...;<span class="comment">//是否需要恢复现场</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(have considered all condition)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来的部分分几个主要的大类型，每个题目里都会附上对应的练习与解答，结合题目进行总结。</p>
<h2 id="DFS无需回溯"><a href="#DFS无需回溯" class="headerlink" title="DFS无需回溯"></a>DFS无需回溯</h2><p>DFS无需回溯的情况是少</p>
<h3 id="红与黑-AcWing-1113"><a href="#红与黑-AcWing-1113" class="headerlink" title="红与黑 AcWing 1113"></a>红与黑 AcWing 1113</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> h,w;</span><br><span class="line"><span class="type">char</span> mp[<span class="number">21</span>][<span class="number">21</span>];</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> vis[<span class="number">21</span>][<span class="number">21</span>],<span class="type">int</span> posx,<span class="type">int</span> posy)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">4</span>;i++)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="keyword">switch</span>(i)&#123;</span><br><span class="line">   <span class="keyword">case</span> <span class="number">1</span>:&#123;</span><br><span class="line">    <span class="type">int</span> x = posx,y = posy<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(y &gt;= <span class="number">0</span> &amp;&amp; !vis[x][y] &amp;&amp; mp[x][y] == <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">     vis[x][y] = <span class="number">1</span>;</span><br><span class="line">     cnt++;</span><br><span class="line">     <span class="built_in">dfs</span>(vis,x,y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">case</span> <span class="number">2</span>:&#123;</span><br><span class="line">    <span class="type">int</span> x = posx,y = posy<span class="number">+1</span>;</span><br><span class="line">    <span class="keyword">if</span>(y &lt; w &amp;&amp; !vis[x][y] &amp;&amp; mp[x][y] == <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">     vis[x][y] = <span class="number">1</span>;</span><br><span class="line">     cnt++;</span><br><span class="line">     <span class="built_in">dfs</span>(vis,x,y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">case</span> <span class="number">3</span>:&#123;</span><br><span class="line">    <span class="type">int</span> x = posx<span class="number">-1</span>,y = posy;</span><br><span class="line">    <span class="keyword">if</span>(x &gt;= <span class="number">0</span> &amp;&amp; !vis[x][y] &amp;&amp; mp[x][y] == <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">     vis[x][y] = <span class="number">1</span>;</span><br><span class="line">     cnt++;</span><br><span class="line">     <span class="built_in">dfs</span>(vis,x,y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">case</span> <span class="number">4</span>:&#123;</span><br><span class="line">    <span class="type">int</span> x = posx<span class="number">+1</span>,y = posy;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; h &amp;&amp; !vis[x][y] &amp;&amp; mp[x][y] == <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">     vis[x][y] = <span class="number">1</span>;</span><br><span class="line">     cnt++;</span><br><span class="line">     <span class="built_in">dfs</span>(vis,x,y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="type">int</span> vis[<span class="number">21</span>][<span class="number">21</span>];</span><br><span class="line"> <span class="type">int</span> posx = <span class="number">0</span>,posy = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; h;i++)</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; w;j++)</span><br><span class="line">  &#123;</span><br><span class="line">   vis[i][j] = <span class="number">0</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//寻找起点</span></span><br><span class="line">   <span class="comment">//cout&lt;&lt;&quot;mp[i][j]:&quot;&lt;&lt;mp[i][j]&lt;&lt;endl;</span></span><br><span class="line">   <span class="keyword">if</span>(mp[i][j] == <span class="string">&#x27;@&#x27;</span>)posx = i,posy = j; </span><br><span class="line">  &#125;</span><br><span class="line"> vis[posx][posy] = <span class="number">1</span>;</span><br><span class="line"> cnt = <span class="number">1</span>;</span><br><span class="line"> <span class="built_in">dfs</span>(vis,posx,posy);</span><br><span class="line"> cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> string str;</span><br><span class="line"> <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">  cin&gt;&gt;w&gt;&gt;h;</span><br><span class="line">  <span class="keyword">if</span>(w == <span class="number">0</span> &amp;&amp; h == <span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; h;i++)</span><br><span class="line">   &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; w;j++)</span><br><span class="line">     cin&gt;&gt;mp[i][j];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//输入完成 </span></span><br><span class="line">   <span class="built_in">solve</span>();</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意点：</p>
<ol>
<li>关于不需要回溯，<strong>我的一个理解</strong>：由于在每次搜索到的状态，更改的全局变量只有vis数组，而这个更改正是必须的（我们需要一个DFS分支更改的vis影响另一个DFS分支，来确定当前点是否已经到达过了），所以不需要进行回溯。<em>需要回溯的一种情况是，一个分支修改的全局变量对另一个分支没有作用，另一个分支不能直接使用，要自己修改，那么在一个分支结束的时候就应该还原自己修改的全局变量</em></li>
<li>关于不需要回溯，<strong>另一种理解</strong>：在一个分支下到达的每一个点，在这个分支结束过后就可以抛弃了，因为我们只是统计点的数量不需要再回到这个点；但是需要回溯的情况，例如走迷宫，你在尝试一种路径的时候走过一系列点，这些点不能被抛弃，你在尝试其它路径的时候可能还会来到这些点，所以在每一条路径结束的时候，要将标记访问的vis数组进行还原（具体如何还原见后面的笔记）。</li>
<li>注意io上的细节实现，由于有多轮数据，所以每轮开始要注意相关变量的初始化</li>
</ol>
<h2 id="DFS与回溯"><a href="#DFS与回溯" class="headerlink" title="DFS与回溯"></a>DFS与回溯</h2><h3 id="ACW分成互质组"><a href="#ACW分成互质组" class="headerlink" title="ACW分成互质组"></a>ACW分成互质组</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; g[<span class="number">11</span>];</span><br><span class="line"><span class="type">int</span> num[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(x%y == <span class="number">0</span>)<span class="keyword">return</span> y;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">return</span> gcd(y,x%y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line"> <span class="comment">//检查是否可以把数字i放在第j组</span></span><br><span class="line"> <span class="keyword">if</span>(g[j].empty())<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> <span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>;k &lt; g[j].size();k++)&#123;</span><br><span class="line">   <span class="keyword">if</span>(gcd(num[i],g[j][k]) != <span class="number">1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> num_g,<span class="type">int</span> now)</span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(now == n)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="type">int</span> i = now;</span><br><span class="line"> <span class="comment">//i对应当前正在处理数字的索引 </span></span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; num_g;j++)<span class="comment">//把它尝试放入各组中</span></span><br><span class="line"> &#123;</span><br><span class="line">  <span class="keyword">if</span>(check(i,j))&#123;<span class="comment">//如果可以放入第j组 </span></span><br><span class="line">   g[j].push_back(num[now]);</span><br><span class="line">   <span class="keyword">if</span>(dfs(num_g, now+<span class="number">1</span>))<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   <span class="keyword">else</span> g[j].pop_back();<span class="comment">//尝试放入失败 </span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">  <span class="built_in">cin</span>&gt;&gt;num[i];</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> num_g = <span class="number">1</span>;num_g &lt;= n;num_g++)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="keyword">if</span>(dfs(num_g,<span class="number">0</span>))&#123;</span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;num_g&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125; </span><br><span class="line">  </span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现的思路是从小到大枚举可能的组数，用DFS暴力搜索，把每个数字依次放入每个组的情况。</p>
<p>本题总结：</p>
<ol>
<li>DFS的主线是依次处理每个数字，每处理一个数字就进入到下一个状态，当n个数字处理完毕就可以结束了，当前使用的组数就是最小的组数</li>
<li>一个反思，在写DFS的时候要想清楚，每层深入的时候，对应的实际意义是什么。这里就是处理过的数字的数量增加。我开始的时候没有想清楚在dfs的for循环外面还套了一层遍历所有数字的循环，不明所以…</li>
<li>这里就要注意<strong>恢复现场</strong>，即g[j].pop_back()，也是回溯的体现，当一条分支尝试失败了要还原状态。否则当前分支存入第j组的数字，在其它分支总也会存在，显然就会有问题…</li>
</ol>
<h3 id="子集模板-子集-leetcode78"><a href="#子集模板-子集-leetcode78" class="headerlink" title="子集模板 子集 leetcode78"></a>子集模板 子集 leetcode78</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; &gt;ans;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; cmb, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == len)&#123;</span><br><span class="line">            ans.push_back(cmb);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cmb.push_back(nums[i]);</span><br><span class="line">        dfs(cmb,i+<span class="number">1</span>);</span><br><span class="line">        cmb.pop_back();</span><br><span class="line"></span><br><span class="line">        dfs(cmb,i+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; subsets(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        len = nums.size();</span><br><span class="line">        this-&gt;nums = nums;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; t;</span><br><span class="line">        dfs(t,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这道题可以完美地体现写在blog开头的那段话，问题的状态就是一棵二叉树，递归就是在其上做深搜。同样，回溯体现在还原现场。</p>
<p>上面代码的此题思路是，从<strong>每个数字</strong>的角度出发，依次考虑选与不选，当所有的数字都被考虑过一遍，我们就可以得到一种答案的组合。</p>
<p><strong>另一种思路</strong>是从<strong>答案的角度</strong>出发，依次考虑选择哪些数字，每做出一次选择本身就得到了一种答案。</p>
<p>而对于这种思路，当我们考虑过下标为i的数字选择后会从当前层向下递归产生分支；而在当前层，我们还会考虑下标大于i的数字，例如i+1对应的数字，选择它后又从当前层向下递归产生分支（记作分支1）；要避免后一条分支（记作分支2）与分支1重复。</p>
<p>即对于(1,2)的原始数组，第一层选择1后，产生分支1向下递归选择2，形成(1,2)；我们要避免第一层选择2后产生分支2向下递归形成(2,1)（这是重复的）</p>
<p><strong>规避重复</strong>的一种思路是，每层向下递归的时候 只能选择 下标 大于当前层已选数字下标 的数字 从而形成下面图片的效果：</p>
<p><img src="/../_images/Algorithm1/DFS1.png" alt="MyAlgorithm"></p>
<p><a href="!https://www.bilibili.com/video/BV1mG4y1A7Gu?spm_id_from=333.788.videopod.sections&vd_source=80df09f481ef5f0671e5e0e35d02e33e">参考视频教程</a></p>
<p>我们也可以将这两种思路概括为：</p>
<ol>
<li>选或者不选的思路</li>
<li>选哪个的思路<br>（这是常用的dfs思路，后续的组合、排列都会用到）</li>
</ol>
<h3 id="子集模板应用-分割回文串-leetcode-131"><a href="#子集模板应用-分割回文串-leetcode-131" class="headerlink" title="子集模板应用 分割回文串 leetcode 131"></a>子集模板应用 分割回文串 leetcode 131</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="title function_">check</span><span class="params">(<span class="built_in">string</span> s)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>,j = s.length()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(;i &lt; s.length() &amp;&amp; j &gt;= <span class="number">0</span>;i++,j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] != s[j])<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; ans;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; cmb, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == len<span class="number">-1</span>)&#123;<span class="comment">//当执行到应该判断最后一个位置是否要切割的时候</span></span><br><span class="line">            <span class="built_in">string</span> s = str.substr(j+<span class="number">1</span>,i-j);</span><br><span class="line">            <span class="keyword">if</span>(check(s))&#123;</span><br><span class="line">                cmb.push_back(s);</span><br><span class="line">                ans.push_back(cmb);</span><br><span class="line">                cmb.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> s = str.substr(j+<span class="number">1</span>,i-j);</span><br><span class="line">        <span class="keyword">if</span>(check(s))&#123;</span><br><span class="line">            cmb.push_back(s);</span><br><span class="line">            dfs(cmb, i+<span class="number">1</span>,i);</span><br><span class="line">            <span class="comment">//回溯</span></span><br><span class="line">            cmb.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dfs(cmb,i+<span class="number">1</span>,j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//切割是把当前位置的字符串和上一次切割位置后的字符串切出来</span></span><br><span class="line"><span class="comment">//i是当前考虑是否要切割的位置</span></span><br><span class="line"><span class="comment">//j是上一次进行切割的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; partition(<span class="built_in">string</span> s) &#123;</span><br><span class="line">        this-&gt;len = s.length();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; t;</span><br><span class="line">        this-&gt;str = s;</span><br><span class="line">        dfs(t, <span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这道题的思路是考虑所有可以切割子串的位置的状态，每个位置有两种状态，切或者不切；问题的状态就变成了一棵二叉树，DFS在树上做搜索，但是将一个位置设置为“切”的状态，需要判断得到的新子串是否是回文串，如果是才能切；最后一个位置必须切。</p>
<h3 id="组合模板-组合-leetcode-78"><a href="#组合模板-组合-leetcode-78" class="headerlink" title="组合模板 组合 leetcode 78"></a>组合模板 组合 leetcode 78</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="type">int</span> k,n;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> cnt,<span class="type">int</span> i,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; cmb)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt == k)&#123;</span><br><span class="line">            ans.push_back(cmb);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i+<span class="number">1</span>;j &lt;= n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cmb.push_back(j);</span><br><span class="line">            dfs(cnt+<span class="number">1</span>,j,cmb);</span><br><span class="line">            cmb.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; combine(<span class="type">int</span> n, <span class="type">int</span> k) &#123;</span><br><span class="line">        this-&gt;k = k;</span><br><span class="line">        this-&gt;n = n;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; t;</span><br><span class="line">        dfs(<span class="number">0</span>,<span class="number">0</span>,t);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面代码的实现思路是，在子集模板的第二种思路（站在答案的视角，考虑每个数字的选择）下加入一个已选择数字数量的判定，当选择的数字数量达到k个的时候就将答案记录下来，并停止向下递归。</p>
<h4 id="关于组合问题的剪枝"><a href="#关于组合问题的剪枝" class="headerlink" title="关于组合问题的剪枝"></a>关于组合问题的剪枝</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span>(n-i+cnt &lt; k)<span class="keyword">return</span>;<span class="comment">//剩下可选的数字+已经选择的数字 &lt; 需要选择的数字，可以直接return，因为最后必定没有结果（剪枝）</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在dfs的for循环之前加入这个判断，如果满足条件，最后一定无法选出指定数量的数字，也就没有继续递归的必要了，可以提前结束当前分支。</p>
<h3 id="组合模板应用-组合总和Ⅲ-leetcode-216"><a href="#组合模板应用-组合总和Ⅲ-leetcode-216" class="headerlink" title="组合模板应用 组合总和Ⅲ leetcode 216"></a>组合模板应用 组合总和Ⅲ leetcode 216</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> k,n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> cnt,<span class="type">int</span> i,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; cmb)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt == k &amp;&amp; accumulate(cmb.begin(),cmb.end(),<span class="number">0</span>) == n)&#123;</span><br><span class="line">            ans.push_back(cmb);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">9</span>-i+cnt &lt; k)<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i+<span class="number">1</span>;j &lt;= <span class="number">9</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cmb.push_back(j);</span><br><span class="line">            dfs(cnt+<span class="number">1</span>,j,cmb);</span><br><span class="line">            cmb.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; combinationSum3(<span class="type">int</span> k, <span class="type">int</span> n) &#123;</span><br><span class="line">        this-&gt;k = k;</span><br><span class="line">        this-&gt;n = n;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; t;</span><br><span class="line">        dfs(<span class="number">0</span>,<span class="number">0</span>,t);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="关于剪枝"><a href="#关于剪枝" class="headerlink" title="关于剪枝"></a>关于剪枝</h4><p>这道题除了和组合模板一样的剪枝，还有根据n进行的剪枝。主要是两种情况</p>
<ol>
<li>当前已经选择的数字数量不足k，但是其和已经大于n，最后递归下去其和必定大于n，剪枝</li>
<li>剩下的所有数字加上当前选择的所有数字 之和 小于n，最后递归下去其和必定小于n，剪枝</li>
</ol>
<p>为了方便剪枝的实现，可以选择维护一个当前已选数字之和的变量now_sum，具体实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> k,n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> cnt,<span class="type">int</span> i,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; cmb,<span class="type">int</span> now_sum)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt == k &amp;&amp; now_sum == n)&#123;</span><br><span class="line">            ans.push_back(cmb);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">9</span>-i+cnt &lt; k)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(now_sum &gt; n)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(now_sum+(i+<span class="number">10</span>)*(<span class="number">9</span>-i)/<span class="number">2</span> &lt; n)<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i+<span class="number">1</span>;j &lt;= <span class="number">9</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cmb.push_back(j);</span><br><span class="line">            dfs(cnt+<span class="number">1</span>,j,cmb,now_sum+j);</span><br><span class="line">            cmb.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; combinationSum3(<span class="type">int</span> k, <span class="type">int</span> n) &#123;</span><br><span class="line">        this-&gt;k = k;</span><br><span class="line">        this-&gt;n = n;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; t;</span><br><span class="line">        dfs(<span class="number">0</span>,<span class="number">0</span>,t,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>一个总结：组合模板上的剪枝是围绕要选择k个数字进行的，这一题又有了新的要求即k个数字的和要为n。这些要求都可以看作问题的约束，也就是说我们这两道题的剪枝都是围绕问题的约束展开的。所以以后在思考递归的剪枝的时候，可以考虑<strong>问题状态树上，从当前递归层的状态出发，判断之后的状态是否可以满足最终问题的各个约束，如果不能满足，那么就停止向下递归。</strong></p>
<p>而我们之所以能做出这样判断的原因，是因为问题状态具有的一些性质在转移的过程中如何发展是可以推知的。<em>就像这道题，一共9个数，你每次只选比上一次选择的数字更大的数字，当你选择了i，接下来你可以选择的数字个数一定是9-i</em>，这就是可以推知的状态。</p>
<h3 id="组合模板应用-括号生成-leetcode-22"><a href="#组合模板应用-括号生成-leetcode-22" class="headerlink" title="组合模板应用 括号生成 leetcode 22"></a>组合模板应用 括号生成 leetcode 22</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> nl,<span class="type">int</span> nr,<span class="built_in">string</span>&amp; str)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nl + nr == (n&lt;&lt;<span class="number">1</span>))&#123;</span><br><span class="line">            ans.push_back(str);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nl &lt; nr)<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nl &lt; n)&#123;</span><br><span class="line">            str += <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">            dfs(nl+<span class="number">1</span>,nr,str);</span><br><span class="line">            str.erase(str.end()<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nr &lt; n)&#123;</span><br><span class="line">            str += <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">            dfs(nl,nr+<span class="number">1</span>,str);</span><br><span class="line">            str.erase(str.end()<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title function_">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        this-&gt;n = n;</span><br><span class="line">        <span class="built_in">string</span> str;</span><br><span class="line">        dfs(<span class="number">0</span>,<span class="number">0</span>,str);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我解决这道题的思考过程：</p>
<ol>
<li>基本方法是套用子集模板，我们一共有n个左括号、n个右括号可以用，需要选择2n个括号，根据选择的顺序形成str，直接dfs到底，然后判断括号是否有效</li>
<li>考虑剪枝，约束是括号有效，考虑是否存在一些选择情况对应的状态已经无效，并且之后的状态也一定无效。存在这样的选择情况，那就是右括号比左括号先选择。只要有这种情况出现就可以剪枝</li>
</ol>
<p>关于实现</p>
<ol>
<li>剪枝的实现是可以维护nl、nr来记录已经选择的左右括号的数量，一旦nl小于nr就剪枝。</li>
<li>并且我注意到，递归的结束条件可以用nl+nr &#x3D;&#x3D; 2*n来实现；且只要nl始终大于等于nr，左括号一定可以被右括号抵消，最终的情况一定有效，也就不需要递归结束时的有效判断了</li>
<li>结合1、2两点，套用dfs的模板就可以解决问题</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> nl,<span class="type">int</span> nr,<span class="built_in">string</span>&amp; str)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nl + nr == (n&lt;&lt;<span class="number">1</span>))&#123;</span><br><span class="line">            ans.push_back(str);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nl &lt; nr)<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nl &lt; n)&#123;</span><br><span class="line">            str += <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">            dfs(nl+<span class="number">1</span>,nr,str);</span><br><span class="line">            str.erase(str.end()<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nr &lt; n)&#123;</span><br><span class="line">            str += <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">            dfs(nl,nr+<span class="number">1</span>,str);</span><br><span class="line">            str.erase(str.end()<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title function_">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        this-&gt;n = n;</span><br><span class="line">        <span class="built_in">string</span> str;</span><br><span class="line">        dfs(<span class="number">0</span>,<span class="number">0</span>,str);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="全排列模板-全排列-leetcode-46"><a href="#全排列模板-全排列-leetcode-46" class="headerlink" title="全排列模板 全排列 leetcode 46"></a>全排列模板 全排列 leetcode 46</h3><p>模板的思路基础是<strong>子集模板的第二种思路</strong>，在子集模板中，我们为了避免重复的选择，规定在选择第i个数字之后 产生的递归分支上，只能选择第i+1及以后的数字；而全排列不需要避免这种重复的选择，或者说<strong>这种重复的选择对全排列而言正是必要的</strong>，因为对于排列而言，选择的顺序不同 但 含有的元素相同 的子集是不同的。</p>
<p>于是问题的关键在于，每个分支如何知道自己当前可以选择哪些数字。</p>
<p>我的思路是用一个vis数组来记录当前分支的<strong>父状态</strong>选择过的数字，这些数字是不能选的。而其它分支选择过的数字，自己的父状态没有选择过的数字，这些分支是可以选择的。</p>
<p>按照这个思路实现的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; vis;</span><br><span class="line">    </span><br><span class="line">    <span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; cmb)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == len)&#123;</span><br><span class="line">            ans.push_back(cmb);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                cmb.push_back(nums[i]); vis[i] = <span class="number">1</span>;</span><br><span class="line">                dfs(n+<span class="number">1</span>,cmb);</span><br><span class="line">                cmb.pop_back(); vis[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; permute(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        this-&gt;len = nums.size();</span><br><span class="line">        this-&gt;nums = nums;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; len;i++)</span><br><span class="line">            vis.push_back(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; cmb;</span><br><span class="line">        dfs(<span class="number">0</span>,cmb);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>参考教程的思路是<strong>维护一个可选数字</strong>的集合，这个集合可以起到取代我上面的vis数组的作用。并且这样显然好一些，因为使用vis数组，状态树上的每一个结点都会检查初始nums中的所有数组，虽然当不满足条件的时候，不会向下产生分支，但是在当前层的循环中枚举了很多不必要的情况。</p>
<p>我按照这个思路写的代码如下，但是使用到了vector的插入和删除操作，频繁的这样操作，或许增加的时间复杂度不会比我开始使用的vis好到哪里去？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; cmb,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty())&#123;</span><br><span class="line">            ans.push_back(cmb);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> t = nums[i];</span><br><span class="line">            cmb.push_back(t); nums.erase(nums.begin()+i);</span><br><span class="line">            dfs(cmb,nums);</span><br><span class="line">            cmb.pop_back(); nums.insert(nums.begin()+i,t);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; permute(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; cmb;</span><br><span class="line">        dfs(cmb,nums);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>实际上两种思路都是常见的做法，我的第一种思路在参考的教程中后面也提到了。</p>
<p><a href="!https://www.bilibili.com/video/BV1mY411D7f6?spm_id_from=333.788.videopod.sections&vd_source=80df09f481ef5f0671e5e0e35d02e33e">参考教程</a></p>
<h3 id="DFS与回溯综合练习-n皇后"><a href="#DFS与回溯综合练习-n皇后" class="headerlink" title="DFS与回溯综合练习 n皇后"></a>DFS与回溯综合练习 n皇后</h3><p>我的基本思路是用dfs枚举每个位置放置皇后的情况，每个位置可以放、可以不放；当一个位置放置后，该位置对应的行、列、两个对角线 不能再放置；维护一个vis二维数组来判断各个位置是否可以放置皇后。</p>
<p>实现代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; vis;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; ans;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> num,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; cmb,<span class="type">int</span> posx,<span class="type">int</span> posy,<span class="type">int</span> cnt)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num == n)&#123;</span><br><span class="line">            ans.push_back(cmb);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(cnt &lt; n-num)<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = posx;i &lt; n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = posy;j &lt; n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(vis[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">                    cmb[i][j] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//ban</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>;k &lt; n;k++)</span><br><span class="line">                        vis[i][k]++,vis[k][j]++;</span><br><span class="line">                    vis[i][j]--;<span class="comment">//重复ban了一次</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> ki = i+<span class="number">1</span>,kj = j+<span class="number">1</span>;ki &lt; n&amp;&amp;kj &lt; n;ki++,kj++)</span><br><span class="line">                        vis[ki][kj]++;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> ki = i<span class="number">-1</span>,kj = j<span class="number">-1</span>;ki &gt;= <span class="number">0</span>&amp;&amp;kj &gt;= <span class="number">0</span>;ki--,kj--)</span><br><span class="line">                        vis[ki][kj]++;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> ki = i+<span class="number">1</span>,kj = j<span class="number">-1</span>;ki &lt; n&amp;&amp;kj &gt;= <span class="number">0</span>;ki++,kj--)</span><br><span class="line">                        vis[ki][kj]++;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> ki = i<span class="number">-1</span>,kj = j+<span class="number">1</span>;ki &gt;= <span class="number">0</span>&amp;&amp;kj &lt; n;ki--,kj++)</span><br><span class="line">                        vis[ki][kj]++;</span><br><span class="line">                    </span><br><span class="line">                    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> ki = <span class="number">0</span>;ki &lt; n;ki++)</span><br><span class="line">                        <span class="keyword">for</span>(<span class="type">int</span> kj = <span class="number">0</span>;kj &lt; n;kj++)</span><br><span class="line">                            <span class="keyword">if</span>(vis[ki][kj] == <span class="number">0</span>)sum++;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>(posy &lt; n)</span><br><span class="line">                        dfs(num+<span class="number">1</span>,cmb,posx,posy+<span class="number">1</span>,sum);</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(posy == n<span class="number">-1</span>)</span><br><span class="line">                        dfs(num+<span class="number">1</span>,cmb,posx+<span class="number">1</span>,<span class="number">0</span>,sum);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//recover，这样写可能会错误的恢复已经被其它皇后ban掉的位置，将修改为1改做++</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>;k &lt; n;k++)</span><br><span class="line">                        vis[i][k]--,vis[k][j]--;</span><br><span class="line">                    vis[i][j]++;<span class="comment">//重复recover了一次</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> ki = i+<span class="number">1</span>,kj = j+<span class="number">1</span>;ki &lt; n&amp;&amp;kj &lt; n;ki++,kj++)</span><br><span class="line">                        vis[ki][kj]--;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> ki = i<span class="number">-1</span>,kj = j<span class="number">-1</span>;ki &gt;= <span class="number">0</span>&amp;&amp;kj &gt;= <span class="number">0</span>;ki--,kj--)</span><br><span class="line">                        vis[ki][kj]--;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> ki = i+<span class="number">1</span>,kj = j<span class="number">-1</span>;ki &lt; n&amp;&amp;kj &gt;= <span class="number">0</span>;ki++,kj--)</span><br><span class="line">                        vis[ki][kj]--;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> ki = i<span class="number">-1</span>,kj = j+<span class="number">1</span>;ki &gt;= <span class="number">0</span>&amp;&amp;kj &lt; n;ki--,kj++)</span><br><span class="line">                        vis[ki][kj]--;</span><br><span class="line">                    cmb[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">                </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; solveNQueens(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; t;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; n;j++)</span><br><span class="line">                t.push_back(<span class="number">0</span>);</span><br><span class="line">            vis.push_back(t);</span><br><span class="line">        &#125;   </span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; cmb;</span><br><span class="line">        <span class="built_in">string</span> str;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">            str+=<span class="string">&quot;.&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">            cmb.push_back(str);</span><br><span class="line">        this-&gt;n = n;</span><br><span class="line">        dfs(<span class="number">0</span>,cmb,<span class="number">0</span>,<span class="number">0</span>,n*n);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>记录几个出现的问题：</p>
<ol>
<li>开始的时候我标记位置是否能放，能放是将vis[i][j]置为1，能放是将这个元素置为0。这样做的问题在于：一个皇后恢复现场的时候，可能把其它皇后置为不能放置的位置给恢复成能放了； <strong>解决的方法</strong>是，可以放置设置为0，每放一个皇后对应不能放置的位置+1，恢复的时候-1即可，这样每个皇后对现场的操作都被保存了下来作为是否能放的参照</li>
<li>开始的时候我写dfs中的for循环，每一层都是从i&#x3D;0，j&#x3D;0开始枚举的，这样的话每一层都会重复考虑之前已经考虑过的位置，这是错误的。<strong>解决的方法</strong>是记录好当前位置的下标，进入下一层递归的时候设置下一次开始遍历的初始位置是当前位置的下一个位置</li>
<li>解决1、2两个问题之后，代码的正确性已经得到保证了，但是现在的问题是时间复杂度太高了…，当n&#x3D;&#x3D;9的时候会TLE</li>
</ol>
<h3 id="全排列模板-n皇后"><a href="#全排列模板-n皇后" class="headerlink" title="全排列模板 n皇后"></a>全排列模板 n皇后</h3><p>对于上述dfs枚举每个格子的<strong>改进的方法</strong>，涉及n皇后的一个性质，那就是<strong>每一行、每一列一定有一个皇后</strong>。</p>
<p>这个性质不难证明，假设有一行没有皇后，那么剩下n-1行要放n个皇后，肯定有一行有两个皇后，与条件矛盾；列是同理的</p>
<p>于是我们可以考虑使用一个数组col[i]来表示第i行在哪一列放置了Q，即在第col[i]列放置了Q，<strong>理解这个数组很关键！</strong></p>
<p>于是，我们最终放置好的棋盘就可以单纯用col数组来表示。并且满足条件的情况下，其中一定有4个元素。</p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">col[<span class="number">4</span>] = &#123;<span class="number">1</span>，<span class="number">3</span>，<span class="number">0</span>，<span class="number">2</span>&#125;<span class="comment">//n==4的一种放置方案</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们现在可以把问题变成：我们要在数字0<del>n-1中，选出一种k&#x3D;n个数字的排列。由于一共就0</del>n-1个数字，所以得到排列还原回棋盘上的情况，意味着<strong>列一定不会冲突</strong>；而我们按照行来进行枚举，那么<strong>行也一定不会冲突</strong>；再者，在dfs的时候我们是从行0，枚举到行n-1，那么<strong>左下、右下的对角线一定不会冲突</strong></p>
<p>于是问题就变成了全排列模板上的变式，改变了的点是：</p>
<ol>
<li>在完成排列，退出递归的时候，我们要把得到的col数组还原回字符串向量（题意中用于表示棋盘），这是一个简单的模拟问题</li>
<li>在挑选加入排列的数字的时候，我们要进行check，考虑当前选择的数字，对应放置到棋盘上的Q，其左上、右上是否已经有Q了，如果有了就不能放置，也就是不能选择这个数字；否则可以选择</li>
</ol>
<p>具体的代码实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; ans;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//x是当前处理的行号，y是当前选择的数字，即x行希望放置Q的列号</span></span><br><span class="line">    <span class="type">bool</span> <span class="title function_">check</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp;col, <span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">        <span class="comment">//只需要检查左上和右上有没有皇后，因为按行递归，下面的行必定还没放置Q</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = x<span class="number">-1</span>,j1 = y<span class="number">-1</span>,j2 = y+<span class="number">1</span>;i &gt;= <span class="number">0</span>;i--,j1--,j2++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(col[i] == j1 || col[i] == j2)<span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; col, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(col.size() == n)&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; cmb;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">                <span class="built_in">string</span> str;</span><br><span class="line">                str.clear();</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; n;j++)</span><br><span class="line">                    <span class="keyword">if</span>(j == col[i])str+=<span class="string">&quot;Q&quot;</span>;</span><br><span class="line">                    <span class="keyword">else</span> str+=<span class="string">&quot;.&quot;</span>;</span><br><span class="line">                cmb.push_back(str);</span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(cmb);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; nums.size();j++)<span class="comment">//全排列的模板，nums中存有待选数字</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(check(col, col.size(), nums[j]))&#123;</span><br><span class="line">                <span class="type">int</span> t = nums[j];</span><br><span class="line">                col.push_back(nums[j]); nums.erase(nums.begin()+j);</span><br><span class="line">                dfs(col, nums);</span><br><span class="line">                col.pop_back(); nums.insert(nums.begin()+j,t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; solveNQueens(<span class="type">int</span> n) &#123;</span><br><span class="line">        this-&gt;n = n;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)nums.push_back(i);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; col;</span><br><span class="line">        dfs(col,nums);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>实际上check函数可以再利用棋盘上的一个性质，那就是从(i,j)出发，对于任意右上的位置(k,l)，i+j &#x3D;&#x3D; k+l恒成立；对于任意左上的位置(k,l)，i-j &#x3D;&#x3D; k-l恒成立。</p>
<p>于是可以这样写</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">check</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; col, <span class="type">int</span> x,<span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = x<span class="number">-1</span>;i &gt;= <span class="number">0</span>;i--)</span><br><span class="line">        <span class="keyword">if</span>(x+y == i+col[i] || x-y == i-col[i])<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>进一步优化对角线是否合法的检查，如果可以用i+j以及i-j来判断，那么我们不如直接使用两个bool数组，分别对应左上、右上；对于左上要使用i-j+n-1（避免索引出现负数），右上的索引可以直接使用i+j</p>
<p>这样check的O(n)就变成了O(1)，这是一种常见的哈希表优化的思想。</p>
<p>优化后的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; ans;</span><br><span class="line">    <span class="type">bool</span> diag1[<span class="number">20</span>];</span><br><span class="line">    <span class="type">bool</span> diag2[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// //x是当前处理的行号，y是当前选择的数字，即x行希望放置Q的列号</span></span><br><span class="line">    <span class="comment">// bool check(vector&lt;int&gt;&amp;col, int x,int y)&#123;</span></span><br><span class="line">    <span class="comment">//     //只需要检查左上和右上有没有皇后，因为按行递归，下面的行必定还没放置Q</span></span><br><span class="line">    <span class="comment">//     for(int i = x-1,j1 = y-1,j2 = y+1;i &gt;= 0;i--,j1--,j2++)&#123;</span></span><br><span class="line">    <span class="comment">//        if(col[i] == j1 || col[i] == j2)return false; </span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     return true;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; col, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(col.size() == n)&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; cmb;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">                <span class="built_in">string</span> str;</span><br><span class="line">                str.clear();</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; n;j++)</span><br><span class="line">                    <span class="keyword">if</span>(j == col[i])str+=<span class="string">&quot;Q&quot;</span>;</span><br><span class="line">                    <span class="keyword">else</span> str+=<span class="string">&quot;.&quot;</span>;</span><br><span class="line">                cmb.push_back(str);</span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(cmb);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; nums.size();j++)<span class="comment">//全排列的模板，nums中存有待选数字</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(diag1[nums[j]+col.size()] &amp;&amp; diag2[nums[j]-col.size()+n<span class="number">-1</span>])&#123;</span><br><span class="line">                <span class="type">int</span> t = nums[j];</span><br><span class="line">                diag1[nums[j]+col.size()] = <span class="literal">false</span>;diag2[nums[j]-col.size()+n<span class="number">-1</span>] = <span class="literal">false</span>;</span><br><span class="line">                col.push_back(nums[j]); nums.erase(nums.begin()+j);</span><br><span class="line">                dfs(col, nums);</span><br><span class="line">                col.pop_back(); nums.insert(nums.begin()+j,t);</span><br><span class="line">                diag1[nums[j]+col.size()] = <span class="literal">true</span>;diag2[nums[j]-col.size()+n<span class="number">-1</span>] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; solveNQueens(<span class="type">int</span> n) &#123;</span><br><span class="line">        this-&gt;n = n;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)nums.push_back(i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">20</span>;i++)diag1[i] = <span class="literal">true</span>,diag2[i] = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; col;</span><br><span class="line">        dfs(col,nums);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="DFS与记忆化"><a href="#DFS与记忆化" class="headerlink" title="DFS与记忆化"></a>DFS与记忆化</h2><h3 id="打家劫舍-leetcode-198"><a href="#打家劫舍-leetcode-198" class="headerlink" title="打家劫舍 leetcode 198"></a>打家劫舍 leetcode 198</h3><h4 id="打家劫舍-基础递归"><a href="#打家劫舍-基础递归" class="headerlink" title="打家劫舍 基础递归"></a>打家劫舍 基础递归</h4><p>这道题可以使用选或不选的递归思路，从后向前考虑。如果第i个房间选择了，那么第i-1个就不能选，紧接着从第i-2个继续考虑；如果第i个房间不选，紧接着从第i-1个继续考虑；于是很自然的就可以画出问题的状态树是怎样的，在此之上进行递归。</p>
<p>而我们的目标是最终的结果最大，所以考虑的时候应该是dfs(i) &#x3D; max(dfs(i-1),dfs(i-2)+nums[i])</p>
<p>在上面的思路上有了第一版代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> num)</span>&#123;<span class="comment">//从后向前考虑，i表示当前考虑的房间</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span>) <span class="keyword">return</span> num;</span><br><span class="line">        <span class="keyword">return</span> max(dfs(i<span class="number">-1</span>,num),dfs(i<span class="number">-2</span>,num+nums[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums)</span> &#123;</span><br><span class="line">        this-&gt;nums = nums;</span><br><span class="line">        <span class="keyword">return</span> dfs(nums.size()<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="打家劫舍-递归-记忆化-记忆化搜索"><a href="#打家劫舍-递归-记忆化-记忆化搜索" class="headerlink" title="打家劫舍 递归+记忆化&#x3D;记忆化搜索"></a>打家劫舍 递归+记忆化&#x3D;记忆化搜索</h4><p>遗憾的是，每层递归几乎都会展开两层，时间复杂度为$O(2^n)$，会TLE</p>
<p>我们可以注意到，在问题的状态树中，存在这样的结构：</p>
<p><img src="/../_images/Algorithm1/DFS2.png" alt="状态树"></p>
<p><a href="!https://www.bilibili.com/video/BV1Xj411K7oF?spm_id_from=333.788.videopod.sections&vd_source=80df09f481ef5f0671e5e0e35d02e33e">参考资料</a></p>
<p>这意味着我们进行了重复计算（<strong>通过观察状态树的分支情况，是我们判断是否可以进行记忆化处理的一种标注</strong>）</p>
<p>优化后的状态树是这样的，每层递归的小分支可以忽略不记，时间复杂度直接变成了O(n)<br><img src="/../_images/Algorithm1/DFS3.png" alt="优化后的状态树"></p>
<p>具体的优化方法是，我们可以使用一个数组或者一个哈希表，来保存在某分支上第一次计算dfs(i)的结果，然后在其它分支要计算dfs(i)的时候，先检查是否已经计算过了，如果计算过了可以直接调用。</p>
<p>我写的初版记忆化代码是这样的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cnt[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> num)</span>&#123;<span class="comment">//从后向前考虑，i表示当前考虑的房间</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span>) <span class="keyword">return</span> num;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(cnt[i] != <span class="number">-1</span>)<span class="keyword">return</span> cnt[i];</span><br><span class="line">        <span class="type">int</span> res = max(dfs(i<span class="number">-1</span>,num),dfs(i<span class="number">-2</span>,num+nums[i]));</span><br><span class="line">        cnt[i] = res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums)</span> &#123;</span><br><span class="line">        this-&gt;nums = nums;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">100</span>;i++)cnt[i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> dfs(nums.size()<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但是得出的结果是错误的。一个重要的原因是<strong>记忆化的依据是问题的状态</strong>，我们要把一个状态的结果保存下来，就像我们开始说的，要把dfs(i)的计算结果保存下来，这里的i就可以看作一个<strong>状态变量</strong>，来对一层递归进行唯一的标定。</p>
<p>而我代码中将累加变量num，当作参数来处理，num也变成了一个状态变量，而且它的值通常是难以估计的（随着测试输入的值有着巨大的变化），如果硬要考虑num也是一个状态，可以使用二维数组来存储记忆的结果，但是这会让空间开销变得很大（甚至超范围）。</p>
<p><strong>累加变量本身是可以作返回值处理的</strong>，不用当作参数跟着传递，修改的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cnt[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i)</span>&#123;<span class="comment">//从后向前考虑，i表示当前考虑的房间</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(cnt[i] != <span class="number">-1</span>)<span class="keyword">return</span> cnt[i];</span><br><span class="line">        <span class="type">int</span> res = max(dfs(i<span class="number">-1</span>),dfs(i<span class="number">-2</span>)+nums[i]);</span><br><span class="line">        cnt[i] = res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums)</span> &#123;</span><br><span class="line">        this-&gt;nums = nums;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">100</span>;i++)cnt[i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> dfs(nums.size()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>简单总结一下，一般情况下我习惯将dfs的累加变量当作参数处理，尤其是在退出的时候，使用最后累积的参数来更新我的答案；但是如果要实现记忆化，通常这种累积的参数应该通过返回值来进行处理，即存在明显的递归中“归”这一操作；而当累加变量当作参数处理的时候，实际上我的dfs返回通常是void，没有下层向上层的反馈，只有递归到边界的时候对全局变量的操作，所以没有“归”这一操作</p>
<h4 id="打家劫舍-自顶向下的记忆化搜索-自下向上-DP"><a href="#打家劫舍-自顶向下的记忆化搜索-自下向上-DP" class="headerlink" title="打家劫舍 自顶向下的记忆化搜索-&gt;自下向上 &#x3D; DP"></a>打家劫舍 自顶向下的记忆化搜索-&gt;自下向上 &#x3D; DP</h4><p>我们可以进一步观察状态树</p>
<p><img src="/../_images/Algorithm1/DFS4.png" alt="优化后的状态树"></p>
<p>从状态树来看，自上向下计算的过程中，我们总是在较上层提前计算了dfs(i)的结果 并存储起来 留给下层又遇到dfs(i)的时候使用的。</p>
<p>例如，在上面的状态树中，2、1、0这些右侧的分支点，是第一次调用dfs(2),dfs(1),dfs(0)的点，然后再左侧又遇到dfs(2),dfs(1),dfs(0)的时候是直接使用 较上层的 右侧分支点 第一次计算时保存的结果。</p>
<p>现在我们希望不保存这些结果，将空间复杂度从O(n)优化到O(1)，该如何做？</p>
<p>答案很显然了，我们可以自下向上计算状态结点上的值，只使用临时变量存储必要的值，并不断更新这些临时变量。站在记忆化的角度理解就是，我们是有保存dfs(i)的结果，但是没有保存全部结果，我们只存储了O(1)个对之后计算有需要的结果，并抛弃了不需要的结果；从临时变量来看，我们就是不断地用之后的计算需要的结果存入临时变量，覆盖掉了不再需要的结果。</p>
<p>从状态树上来看，我们计算dfs(2)的时候需要dfs(1),dfs(0)，计算dfs(3)的时候需要dfs(2),dfs(1)但不再需要dfs(0)，计算dfs(4)的时候需要dfs(3),dfs(2)，但不再需要dfs(1),dfs(0)。由此可以看出，计算dfs(i)的时候，实际需要的是dfs(i-1),dfs(i-2)</p>
<p>于是我们将dfs改记作dp，于是我们有了递推公式dp(i) &#x3D; max(dp(i-1),dp(i-2)+nums[i])；再结合边界条件dp(0) &#x3D; nums[0]，dp(1) &#x3D; max(nums[0],nums[1])，就可以开始递推填表了，这就是动态规划。</p>
<p>当然仅仅这样的自下向上，我们还没有完成空间复杂度的优化，因为我们使用了O(n)的递推数组。完全的优化是只使用O(1)的临时变量递推，这类似于我们在1维的dp数组上滚动处理，同样也类似于背包问题中，把二维的表格优化为一维的滚动数组（$O(n^2)$到O(n)的空间复杂度优化）。</p>
<p>在一维数组上的滚动处理，我们只需要3个临时变量f1、f2、f3。</p>
<ol>
<li>f1 &#x3D; nums[0], f2 &#x3D; max(nums[1], nums[0]) 状态0、状态1</li>
<li>f3 &#x3D; max(f2,f1+nums[2]) 状态2 &#x3D; max(状态1,状态0+nums[2])</li>
<li>f1 &#x3D; max(f3,f2+nums[3]) 状态3 &#x3D; max(状态2,状态1+nums[3])</li>
<li>f2 &#x3D; max(f1,f3+nums[4])</li>
</ol>
<p>最终结果就在f2中，上面的f1、f2、f3再反复使用的时候被赋予了不同状态的值，要注意区别。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() == <span class="number">1</span>)<span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums.size() == <span class="number">2</span>)<span class="keyword">return</span> max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> f[<span class="number">3</span>] = &#123;nums[<span class="number">0</span>],max(nums[<span class="number">1</span>],nums[<span class="number">0</span>]),<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt; nums.size();i++)</span><br><span class="line">            f[i%<span class="number">3</span>] = max(f[(i<span class="number">-1</span>)%<span class="number">3</span>],f[(i<span class="number">-2</span>)%<span class="number">3</span>]+nums[i]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> f[(nums.size()<span class="number">-1</span>)%<span class="number">3</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li>f是用来存储dfs的结果的，初始化要存储dfs(0)和dfs(1)，而dfs(1)并不是nums[1]，而是max(nums[1],nums[0])，我开始犯了这个错误</li>
<li>通过取模来实现三个临时变量不断互换位置更新的操作的这种实现方法需要留意，多多测试，想清楚怎么变化的，也是一种套路</li>
</ol>
<p>关于注意的第二点，也可以枚举nums中的数字，然后使用一种易读性更强的写法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> new_f,f0 = nums[<span class="number">0</span>],f1 = max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt; nums.size();i++)</span><br><span class="line">&#123;</span><br><span class="line">    new_f = max(f1,f0+nums[i]);</span><br><span class="line">    f0 = f1;</span><br><span class="line">    f1 = new_f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

        


        <span>
          <a class="article-read" href="/2025/08/30/深度优先搜索整理/"> Read more -->
          </span>
        </div>

        
    
    <div class="recent-post-item">

      <a href="/2025/08/30/%E5%9B%BE%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" class="item-title">图的数据结构与算法</a>
      
      <time datetime="2025-08-30T02:29:59.000Z">
        2025-08-30
      </time>
      
      <!-- <div class="article-digest"> -->
        <!-- 这篇blog用来整理图有关的数据结构与算法的知识
图的存储结构邻接矩阵邻接矩阵本质上就是一个二维数组，分为两种情况

无权图，m[i][j] &#x3D;&#x3D; 1代表vi有到vj的边；否则为0，代表不存在这样的边
有权图，元素为inf代表两点间不存在边，否则存在，且对应元素值为权重

从数据结构上来说，有向无向图没有区别，都是二维数组，且均适用于上面描述的两种情况。只是无向图有m[i][j] &#x3D;&#x3D; m[j][i]恒成立的性质
链式前向星本质上是数组实现的静态邻接表
掌握的关键在于记住三个点

使用到的数据结构即其含义
初始化的方式
加边的方式

下面分别进行描述：
数据结构：
12345678int head[]//一维数组，head[i]代表 vi 的最后一条边在edge中的索引 起一个指针的作用struct Edge&#123;    int to;//当前边指向的结点编号 对应可以用作head的索引 兼具标识结点编号和类似指针的两重作用    int next;//同一结点 当前边的 上一条边在edge中的索引 起一个指针的作用    int w;// -->
        <!-- </div> -->

        
        <p><code>这篇blog用来整理图有关的数据结构与算法的知识</code></p>
<h2 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h2><h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><p>邻接矩阵本质上就是一个二维数组，分为两种情况</p>
<ol>
<li>无权图，m[i][j] &#x3D;&#x3D; 1代表vi有到vj的边；否则为0，代表不存在这样的边</li>
<li>有权图，元素为inf代表两点间不存在边，否则存在，且对应元素值为权重</li>
</ol>
<p>从数据结构上来说，有向无向图没有区别，都是二维数组，且均适用于上面描述的两种情况。只是无向图有m[i][j] &#x3D;&#x3D; m[j][i]恒成立的性质</p>
<h3 id="链式前向星"><a href="#链式前向星" class="headerlink" title="链式前向星"></a>链式前向星</h3><p>本质上是数组实现的静态邻接表</p>
<p>掌握的关键在于记住三个点</p>
<ol>
<li>使用到的数据结构即其含义</li>
<li>初始化的方式</li>
<li>加边的方式</li>
</ol>
<p><em>下面分别进行描述</em>：</p>
<p>数据结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> head[]<span class="comment">//一维数组，head[i]代表 vi 的最后一条边在edge中的索引 起一个指针的作用</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> to;<span class="comment">//当前边指向的结点编号 对应可以用作head的索引 兼具标识结点编号和类似指针的两重作用</span></span><br><span class="line">    <span class="type">int</span> next;<span class="comment">//同一结点 当前边的 上一条边在edge中的索引 起一个指针的作用</span></span><br><span class="line">    <span class="type">int</span> w;<span class="comment">//当前边的权重</span></span><br><span class="line">&#125;edge[]<span class="comment">//一维数组，表示一条边</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这种数据结构的特点是，边本身是没有编号的；也不像邻接矩阵那样，可以直观的知道某条边介于哪两点之间。但是通过遍历点来遍历边，是能够得到这些信息的。</p>
<p>初始化与加边的方式</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> maxmn;</span><br><span class="line"><span class="type">int</span> m,n,cnt;</span><br><span class="line"><span class="type">int</span> head[maxmn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> to,next,w;</span><br><span class="line">&#125;edge[maxmn];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ini</span><span class="params">()</span>&#123;</span><br><span class="line">    cnt = <span class="number">0</span>;<span class="comment">//注意cnt用于全局管理边的索引，初始化为0</span></span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)head[i] = <span class="number">-1</span>;<span class="comment">//结点初始时都没有指向任何边 代表边索引的值初始化为-1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> from,to,w;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;from&gt;&gt;to&gt;&gt;w;</span><br><span class="line">        add_edge(from,to,w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">add_edge</span><span class="params">(<span class="type">int</span> from,<span class="type">int</span> to,<span class="type">int</span> w)</span>&#123;</span><br><span class="line">    edge[cnt].to = to;</span><br><span class="line">    edge[cnt].w = w;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这三行是理解加边操作的关键</span></span><br><span class="line">    edge[cnt].next = head[from];<span class="comment">//让新加的边指向 结点的上一条边</span></span><br><span class="line">    head[from] = cnt;<span class="comment">//让结点指向 新加的边</span></span><br><span class="line">    cnt++;<span class="comment">//全局管理边的索引</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="链式前向星的遍历"><a href="#链式前向星的遍历" class="headerlink" title="链式前向星的遍历"></a>链式前向星的遍历</h4><p>前面提到了这种存图方法在以点为基础，进行遍历的时候，是可以遍历所有的边，并得到边的完整信息（起点、终点、权重）的。下面进行展示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    ini();<span class="comment">//参考前面的代码，假设我们初始化好了一个链式前向星存储的图</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = head[i];j != <span class="number">-1</span>;j = edge[j].next)<span class="comment">//当j==-1成立时，对应遍历完了点v的所有边 前面初始化为-1的作为边界条件的作用 就是类似使用的</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;当前边在edge中的索引：&quot;</span>:j&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;from:&quot;</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;to:&quot;</span>&lt;&lt;edge[j].to&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;w:&quot;</span>&lt;&lt;edge[j].w&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//注意j的更新操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，我认为<strong>数据结构的含义是记忆的重点，记住之后其它操作根据理解是可以写出的</strong>。</p>
<h2 id="图上的DFS（判断两个点是否连通）"><a href="#图上的DFS（判断两个点是否连通）" class="headerlink" title="图上的DFS（判断两个点是否连通）"></a>图上的DFS（判断两个点是否连通）</h2><p>这里使用链式前向星实现，目的是对于输入的两个点u、v，判断是否连通（从一个点可以到达令一个点）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> maxmn = <span class="number">10000</span>;</span><br><span class="line"><span class="type">int</span> n,m,cnt = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> head[maxmn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> to,next,w;</span><br><span class="line">&#125;edge[maxmn];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ini_graph</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">        head[i] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        add_edge(u,v,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">add_edge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span>&#123;</span><br><span class="line">    edge[cnt].to = v;</span><br><span class="line">    edge[cnt].w = <span class="number">1</span>;</span><br><span class="line">    edge[cnt].next = head[u];</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> u,v;<span class="comment">//需要判断是否连通的两点</span></span><br><span class="line"><span class="type">bool</span> flag = <span class="literal">false</span>;<span class="comment">//结果标志</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>* vis, <span class="type">int</span> now_pos)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(flag) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历当前点的边，对每一条可行的边进行递归，实现dfs</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = head[now_pos];i != <span class="number">-1</span>;i = edge[i].next)&#123;</span><br><span class="line">        <span class="comment">//判断是否到达目标结点</span></span><br><span class="line">        <span class="keyword">if</span>(edge[i].to == v)&#123;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(vis[edge[i].to] == <span class="number">0</span>)&#123;</span><br><span class="line">            vis[edge[i].to] = <span class="number">1</span>;</span><br><span class="line">            dfs(vis, edge[i].to);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">solve</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> vis[maxmn];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)vis[i] = <span class="number">0</span>;<span class="comment">//初始化一个标记访问的数组</span></span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v;</span><br><span class="line">    vis[u] = <span class="number">1</span>;<span class="comment">//注意标记初始点已经被访问（来自chatgpt的纠错）</span></span><br><span class="line">    dfs(vis, u);</span><br><span class="line">    <span class="keyword">if</span>(flag)<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;u可达于v&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;不可达！&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    ini_graph();</span><br><span class="line">    solve();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h2><h2 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h2>
        


        <span>
          <a class="article-read" href="/2025/08/30/图的数据结构与算法/"> Read more -->
          </span>
        </div>

        
    
    <div class="recent-post-item">

      <a href="/2025/08/29/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E7%9A%84%E5%B0%8F%E7%AE%97%E6%B3%95/" class="item-title">杂七杂八的小算法</a>
      
      <time datetime="2025-08-29T14:08:53.000Z">
        2025-08-29
      </time>
      
      <!-- <div class="article-digest"> -->
        <!-- 在平常练习算法题的过程中，有的题目常常涉及到使用一些基本的小算法作为整个解决方案中的一部分，例如gcd、进制转换，乃至KMP等等，我用这篇blog对这些小算法。我在这篇blog中对它们做一个综合的整理。
gcd1234int gcd(int x,int y)&#123; if(x%y == 0)return y; else return gcd(y,x%y);&#125;

辗转相除法求最大公约数
进制转换lcm1234int lcm(int x,int y)&#123;    return x*y/gcd(x,y);&#125;

利用最大公约数求最小公倍数
Fibonacci这一部分从Fibonacci数列的计算出发，使用递归&amp;递归+记忆化的方式实现。
目的是展示递归改记忆化递归的基本思想。
string数字转换为int数字 -->
        <!-- </div> -->

        
        <p><code>在平常练习算法题的过程中，有的题目常常涉及到使用一些基本的小算法作为整个解决方案中的一部分，例如gcd、进制转换，乃至KMP等等，我用这篇blog对这些小算法。我在这篇blog中对它们做一个综合的整理。</code></p>
<h2 id="gcd"><a href="#gcd" class="headerlink" title="gcd"></a>gcd</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(x%y == <span class="number">0</span>)<span class="keyword">return</span> y;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">return</span> gcd(y,x%y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>辗转相除法求最大公约数</p>
<h2 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h2><h2 id="lcm"><a href="#lcm" class="headerlink" title="lcm"></a>lcm</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">lcm</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> x*y/gcd(x,y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用最大公约数求最小公倍数</p>
<h2 id="Fibonacci"><a href="#Fibonacci" class="headerlink" title="Fibonacci"></a>Fibonacci</h2><p>这一部分从Fibonacci数列的计算出发，使用递归&amp;递归+记忆化的方式实现。</p>
<p>目的是展示递归改记忆化递归的基本思想。</p>
<h2 id="string数字转换为int数字"><a href="#string数字转换为int数字" class="headerlink" title="string数字转换为int数字"></a>string数字转换为int数字</h2>
        


        <span>
          <a class="article-read" href="/2025/08/29/杂七杂八的小算法/"> Read more -->
          </span>
        </div>

        
    
    <div class="recent-post-item">

      <a href="/2025/08/29/%E7%AE%97%E6%B3%95%E9%A2%98%E5%B8%B8%E7%94%A8%E5%BA%93%E4%B8%AD%E7%9A%84%E5%B7%A5%E5%85%B7/" class="item-title">算法题常用库中的工具</a>
      
      <time datetime="2025-08-29T12:19:32.000Z">
        2025-08-29
      </time>
      
      <!-- <div class="article-digest"> -->
        <!-- 在过去的算法竞赛中，我常常接触到一些库中的工具，例如函数、容器、类等等，但是总是零零散散的，记忆也不是很牢，每次都是用到了现查。于是我用这篇blog做一个简单的整理
头文件algorithmmax()函数在 C++ 中，max 函数是一个非常实用的函数，用于比较两个或更多数值并返回其中的最大值。这个函数定义在 algorithm 头文件中。
1234567891011#include &lt;iostream&gt;#include &lt;algorithm&gt; // 引入algorithm头文件以使用max函数int main() &#123;int a = 10;int b = 20;int max_value = std::max(a, b); // 使用max函数比较a和b，并将结果存储在max_value中std::cout &lt;&lt; &quot;Max value is: &quot; &lt;&lt; max_value &lt;&lt; std::endl;return 0;&#125;

在这个例子中，std::max(a, b) 将返回 a 和 b 中 -->
        <!-- </div> -->

        
        <p><code>在过去的算法竞赛中，我常常接触到一些库中的工具，例如函数、容器、类等等，但是总是零零散散的，记忆也不是很牢，每次都是用到了现查。于是我用这篇blog做一个简单的整理</code></p>
<h2 id="头文件algorithm"><a href="#头文件algorithm" class="headerlink" title="头文件algorithm"></a>头文件algorithm</h2><h3 id="max-函数"><a href="#max-函数" class="headerlink" title="max()函数"></a>max()函数</h3><p>在 C++ 中，max 函数是一个非常实用的函数，用于比较两个或更多数值并返回其中的最大值。这个函数定义在 algorithm 头文件中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span> <span class="comment">// 引入algorithm头文件以使用max函数</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> max_value = <span class="built_in">std</span>::max(a, b); <span class="comment">// 使用max函数比较a和b，并将结果存储在max_value中</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Max value is: &quot;</span> &lt;&lt; max_value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，std::max(a, b) 将返回 a 和 b 中的较大值，并将结果存储在 max_value 中。</p>
<h3 id="sort-函数"><a href="#sort-函数" class="headerlink" title="sort()函数"></a>sort()函数</h3><h2 id="头文件cmath"><a href="#头文件cmath" class="headerlink" title="头文件cmath"></a>头文件cmath</h2><h3 id="取整函数"><a href="#取整函数" class="headerlink" title="取整函数"></a>取整函数</h3><p>round()</p>
<p>ceil()</p>
<p>floor()</p>
<h2 id="字符串相关"><a href="#字符串相关" class="headerlink" title="字符串相关"></a>字符串相关</h2><h3 id="strcpy"><a href="#strcpy" class="headerlink" title="strcpy"></a>strcpy</h3><h3 id="substr"><a href="#substr" class="headerlink" title="substr"></a>substr</h3><h3 id="getline"><a href="#getline" class="headerlink" title="getline"></a>getline</h3><p>通常的使用方式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a;</span><br><span class="line"><span class="built_in">cin</span>.ignore();<span class="comment">//处理回车</span></span><br><span class="line">getline(<span class="built_in">cin</span>,str);</span><br></pre></td></tr></table></figure>

<p>注意在使用getline读取一行信息之前，如果输入有回车，要使用cin.ignore()来处理回车</p>
<h3 id="erase"><a href="#erase" class="headerlink" title="erase"></a>erase</h3><ol>
<li>basic_string &amp; erase(size_type pos&#x3D;0, size_type n&#x3D;npos);即erase（pos，n）;从给定起始位置pos处开始删除, 删除n个字符, 返回值修改后的string对象引用。比如erase(0,1)就是删除第一个字符。</li>
<li>iterator erase(const_iterator position)即erase（positon），删除迭代器位置处的单个字符(position是个string类型的迭代器), 并返回下个元素的迭代器。<br>如果position 不是迭代器位置，则删除该位置及之后的所有字符。</li>
<li>iterator erase(const_iterator first, const_iterator last)即erase（first，last）；删除迭代器（first, last)区间的所有字符（first和last都是迭代器）,返回一个指向被删除的最后一个元素的下一个字符的迭代器.</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="built_in">string</span> str = <span class="string">&quot;hello the world!&quot;</span>;</span><br><span class="line"> <span class="built_in">string</span> str1 = <span class="string">&quot;hello the world!&quot;</span>;</span><br><span class="line"> <span class="built_in">string</span> str2 = <span class="string">&quot;hello the world!&quot;</span>;</span><br><span class="line"> <span class="built_in">string</span> str3 = <span class="string">&quot;hello the world!&quot;</span>;</span><br><span class="line"> <span class="built_in">string</span> str4 = <span class="string">&quot;hello the world!&quot;</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/****************第1种用法:earse(pos,n)**************************/</span></span><br><span class="line"> str.erase(<span class="number">6</span>, <span class="number">2</span>);   </span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;&lt;&quot;</span> &lt;&lt; str &lt;&lt; <span class="string">&quot;&gt;&quot;</span> &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// &lt;hello e world!&gt;    </span></span><br><span class="line"> <span class="comment">/****************第2种用法:earse(position)***********************/</span></span><br><span class="line"> str1.erase(<span class="number">8</span>);  <span class="comment">//如果pos不是迭代器位置，则删除该位置及之后的所有字符</span></span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;&lt;&quot;</span> &lt;&lt; str1 &lt;&lt; <span class="string">&quot;&gt;&quot;</span> &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">//  &lt;hello th&gt;</span></span><br><span class="line"> </span><br><span class="line"> str2.erase(str2.begin()); <span class="comment">//如果pos是迭代器，则</span></span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;&lt;&quot;</span> &lt;&lt; str2 &lt;&lt; <span class="string">&quot;&gt;&quot;</span> &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">//  &lt;ello the world!&gt;</span></span><br><span class="line"> <span class="comment">/****************第3种用法:earse(fist,last)**********************/</span></span><br><span class="line"> str3.erase(str3.begin() + <span class="number">3</span>, str3.end()<span class="number">-3</span>);</span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;&lt;&quot;</span> &lt;&lt; str3 &lt;&lt; <span class="string">&quot;&gt;&quot;</span> &lt;&lt; <span class="built_in">endl</span>;     <span class="comment">// &lt;helld!&gt;</span></span><br><span class="line"> str4.erase(str4.begin() + <span class="number">3</span>, str4.end());</span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;&lt;&quot;</span> &lt;&lt; str4 &lt;&lt; <span class="string">&quot;&gt;&quot;</span> &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">//  &lt;hel&gt;</span></span><br><span class="line"> system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>资料来自于：<br><a href="!https://blog.csdn.net/weixin_42258743/article/details/120751188">CSDN</a></p>
<h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><h3 id="vector在指定位置插入元素"><a href="#vector在指定位置插入元素" class="headerlink" title="vector在指定位置插入元素"></a>vector在指定位置插入元素</h3><p>使用vector类的内置方法，insert</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> it = numbers.begin() + <span class="number">3</span>; <span class="comment">// 指定插入位置</span></span><br><span class="line">    numbers.insert(it, <span class="number">4</span>); <span class="comment">// 在位置 3 插入元素 4</span></span><br><span class="line">    numbers.insert(it, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;); <span class="comment">// 在位置 3 插入多个元素 4, 5, 6</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After insertion: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> num : numbers) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="vector在指定位置删除元素"><a href="#vector在指定位置删除元素" class="headerlink" title="vector在指定位置删除元素"></a>vector在指定位置删除元素</h3><p>使用vector类的内置方法，erase</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> it = numbers.begin() + <span class="number">2</span>; <span class="comment">// 指定删除位置</span></span><br><span class="line">    numbers.erase(it); <span class="comment">// 删除位置 2 的元素</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> start = numbers.begin() + <span class="number">2</span>; <span class="comment">// 指定起始删除位置</span></span><br><span class="line">    <span class="keyword">auto</span> end = numbers.begin() + <span class="number">5</span>;   <span class="comment">// 指定结束删除位置</span></span><br><span class="line">    numbers.erase(start, end); <span class="comment">// 删除从位置 2 到位置 5 的元素</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After deletion: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> num : numbers) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>关于vector插入与删除的总结，相同点是都可以使用迭代器进行，并且在操作一个元素的时候都是使用一个迭代器来指定操作元素的位置；在操作多个元素的时候插入还是使用一个迭代器，删除使用两个迭代器来指定区间。</p>
<p>插入，是插入于指定迭代器的位置，原本位置及之后的元素，均向后挪动（挪动多少取决于你插入元素的多少）<br>删除，删除指定位置的元素，或指定区间的元素</p>
<p>注意begin()获取的迭代器对应位置是首元素，end()迭代器对应位置是尾元素的下一位</p>
<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><h2 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h2><h2 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h2><h2 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h2><p>双端队列，支持队列的基本操作。但是是用push_front, pop_back</p>
<p>另外还有push_back, pop_front</p>
<p>还支持从任意位置删除元素，与vector类似，使用erase()即可</p>
<p>并且可以使用at()方法便捷地访问元素值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 使用 at() 方法访问元素</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\n使用 at() 方法访问元素:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; dq.size(); ++i) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;dq.at(&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;) = &quot;</span> &lt;&lt; dq.at(i) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样的方法便捷地访问deque的值</p>
<h2 id="accumulate"><a href="#accumulate" class="headerlink" title="accumulate"></a>accumulate</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;numeric&gt;</span><span class="comment">//accumulate函数在numeric库中</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; b = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> sum_a = accumulate(a,a+<span class="number">10</span>,<span class="number">0</span>);</span><br><span class="line"><span class="type">int</span> sum_b = accumulate(b.begin(),b.end(),<span class="number">0</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意accumulate最后一个参数是必要的，含义是在累加指定迭代器范围的容器中的元素后，加上第三个元素，并且按照第三个元素的数据类型返回求和结果。</p>
<p>所以即使不用额外的累加，也需要使用第三个元素，int型的时候，第三个元素通常置0即可。</p>
<h2 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h2><p>元组的使用：设置值&amp;获取值</p>

        


        <span>
          <a class="article-read" href="/2025/08/29/算法题常用库中的工具/"> Read more -->
          </span>
        </div>

        
    
    <div class="recent-post-item">

      <a href="/2025/08/29/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%9F%BA%E7%A1%80/" class="item-title">动态规划基础</a>
      
      <time datetime="2025-08-29T11:24:22.000Z">
        2025-08-29
      </time>
      
      <!-- <div class="article-digest"> -->
        <!-- 之前零零散散地接触过一些动态规划的问题，用这篇blog来稍微系统性的记录一下
动态规划的基本步骤
定义数组的基本含义（模板或是灵感）
找到数组元素间的关系（dp的递推式，模板或是灵感）
找到边界的初始值（基本含义定义好了这个通常不难）
递推填表得到需要的元素（结合初始值以及递推式，考虑应该如何进行递推填表，确保新填一个元素需要用到其它元素的时候，其它元素的值已经被填过了）

背包问题01背包（二维解法）问题描述：有n种物品，每种物品只有一个。每个物品有自己的重量和价值。有一个给定容量的背包，问这个背包最多能装的最大价值是多少。
step1定义数组元素的含义
1dp[i][j]//背包容量为j时，考虑1~i种物品，所能承载的最大价值

step2于是我们可以有如下递推式
1dp[i][j] = max(dp[i-1][j], dp[i-1][j-weight[i]] + val[i])

因为从前i-1种物品考虑到第i种物品，只有两种情况：

拿第i种物品，那么前i-1种物品还剩下的可用容量是j-weight[i]，根据数组元素的意义，有dp[i][j] &#x3D; max(dp[i- -->
        <!-- </div> -->

        
        <p><code>之前零零散散地接触过一些动态规划的问题，用这篇blog来稍微系统性的记录一下</code></p>
<h2 id="动态规划的基本步骤"><a href="#动态规划的基本步骤" class="headerlink" title="动态规划的基本步骤"></a>动态规划的基本步骤</h2><ol>
<li>定义数组的基本含义（模板或是灵感）</li>
<li>找到数组元素间的关系（dp的递推式，模板或是灵感）</li>
<li>找到边界的初始值（基本含义定义好了这个通常不难）</li>
<li>递推填表得到需要的元素（结合初始值以及递推式，考虑应该如何进行递推填表，确保新填一个元素需要用到其它元素的时候，其它元素的值已经被填过了）</li>
</ol>
<h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><h3 id="01背包（二维解法）"><a href="#01背包（二维解法）" class="headerlink" title="01背包（二维解法）"></a>01背包（二维解法）</h3><p>问题描述：有n种物品，每种物品只有一个。每个物品有自己的重量和价值。有一个给定容量的背包，问这个背包最多能装的最大价值是多少。</p>
<h4 id="step1"><a href="#step1" class="headerlink" title="step1"></a>step1</h4><p>定义数组元素的含义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j]<span class="comment">//背包容量为j时，考虑1~i种物品，所能承载的最大价值</span></span><br></pre></td></tr></table></figure>

<h4 id="step2"><a href="#step2" class="headerlink" title="step2"></a>step2</h4><p>于是我们可以有如下递推式</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i<span class="number">-1</span>][j-weight[i]] + val[i])</span><br></pre></td></tr></table></figure>

<p>因为从前i-1种物品考虑到第i种物品，只有两种情况：</p>
<ol>
<li>拿第i种物品，那么前i-1种物品还剩下的可用容量是j-weight[i]，根据数组元素的意义，有dp[i][j] &#x3D; max(dp[i-1][j-weight[i]] + val[i])</li>
<li>不拿第i种物品，前i-1种物品剩下的可用容量是j，根据数组元素的意义，有dp[i][j] &#x3D; dp[i-1][j]</li>
</ol>
<p>所以取两种情况中较大的一者，就是dp[i][j]的结果。<strong>注意，第一种情况应该满足条件j&gt;&#x3D;weight[i]，这是显然成立的，于变成而言不满足这个条件数组会发生越界，于实际意义而言，你要装下物品i，意味着你的背包容量至少要大于等于w[i]</strong></p>
<h4 id="step3"><a href="#step3" class="headerlink" title="step3"></a>step3</h4><p>不难发现边界条件的初始值是</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="number">0</span>][any_j] == <span class="number">0</span> &amp;&amp; dp[any_i][j] == <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h4 id="step4"><a href="#step4" class="headerlink" title="step4"></a>step4</h4><p>根据递推关系式，我们发现在填元素dp[i][j]的时候，使用到的元素的1、2维索引一定分别小于i、j，于是按照最简单的从左往右，从上往下填表即可。</p>
<h4 id="例题与代码实现-01背包（二维解法）"><a href="#例题与代码实现-01背包（二维解法）" class="headerlink" title="例题与代码实现 01背包（二维解法）"></a>例题与代码实现 01背包（二维解法）</h4><p>洛谷：P1060 [NOIP 2006 普及组] 开心的金明</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">ll m,n;</span><br><span class="line">ll v[<span class="number">26</span>],w[<span class="number">26</span>];</span><br><span class="line">ll dp[<span class="number">26</span>][<span class="number">30001</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i++)</span><br><span class="line"> &#123;</span><br><span class="line">  ll t;</span><br><span class="line">  <span class="built_in">cin</span>&gt;&gt;v[i]&gt;&gt;t;</span><br><span class="line">  w[i] = v[i];</span><br><span class="line">  v[i]*=t;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i++)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= n;j++)</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="keyword">if</span>(j &gt;= w[i])dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i<span class="number">-1</span>][j-w[i]]+v[i]);</span><br><span class="line">   <span class="keyword">else</span> dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">cout</span>&lt;&lt;dp[m][n];</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="01背包（一维解法）"><a href="#01背包（一维解法）" class="headerlink" title="01背包（一维解法）"></a>01背包（一维解法）</h3><p>根据上面的状态转移式，我们可以发现在填表的过程中，<strong>每新的一行，仅仅依赖于上一行的数据</strong>，所以我们可以考虑使用1维表格。</p>
<p>即数组dp[j]，在二维表格的意义基础上描述对应元素的意义是：当前你正在更新行的元素数据，例如更新到第i行后，那么dp[j]对应就是dp[i][j]。当然这只是粗略的描述。</p>
<p>实际上，假设你当前正在更新第i行，并考虑更新dp[j]，在其更新之前，其对应的应该是dp[i-1][j]，更新完成后才是dp[i][j]。<strong>理解这一点很关键</strong>，有如下两点原因。</p>
<ol>
<li>dp[i][j]更新只依赖于i-1行的数据，而根据这个更新过程，i-1行的数据是可以同时被保存于这个一维表格的，那么只使用这个一维表格是可能的；</li>
<li>由于dp[i][j]的更新，从列上来看，其依赖的有1）dp[i][j-1]，在dp[j]于第i行更新中没有完成时，其代表的就是第i-1行的元素，所以dp[i-1][j]可以在需要时从表格中获取；2）dp[i-1][j-w[i]]，这就要求在dp[j]于第i行更新时，任何小于j的列k（0&lt;&#x3D; k &lt; j）没有完成更新，即dp[k]还保存的i-1行的元素，<strong>所以我们要从后往前更新表格</strong></li>
</ol>
<p>在第2点的基础上，只要我们从后往前更新1维表格，就可以确保<strong>表格中每个数据更新的时候，其需要的数据都存在于表格中（关键点）</strong>，于是使用一维数组替换二维数组是可行的。</p>
<p><em>这也是一般的dp需要考虑填表的方式的原因，你知道了递推式，你需要考虑如何递推才能满足，在求解一个元素的时候其它需要的元素一定是已经求解过了。</em></p>
<h4 id="例题与代码实现-01背包（一维解法）"><a href="#例题与代码实现-01背包（一维解法）" class="headerlink" title="例题与代码实现 01背包（一维解法）"></a>例题与代码实现 01背包（一维解法）</h4><p>洛谷：P1060 [NOIP 2006 普及组] 开心的金明</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line">ll m,n;</span><br><span class="line">ll v[<span class="number">26</span>],w[<span class="number">26</span>];</span><br><span class="line">ll dp[<span class="number">30001</span>];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i++)</span><br><span class="line"> &#123;</span><br><span class="line">  ll t;</span><br><span class="line">  <span class="built_in">cin</span>&gt;&gt;v[i]&gt;&gt;t;</span><br><span class="line">  w[i] = v[i];</span><br><span class="line">  v[i]*=t;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i++)</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> j = n;j &gt;= <span class="number">0</span>;j--)<span class="comment">//注意从后往前递推</span></span><br><span class="line">   <span class="keyword">if</span>(j &gt;= w[i])dp[j] = max(dp[j],dp[j-w[i]]+v[i]);</span><br><span class="line">   <span class="comment">//else dp[j] = dp[j]，对应的就是dp[j] = dp[j-1]，当然没有写的必要 </span></span><br><span class="line"> <span class="built_in">cout</span>&lt;&lt;dp[n];</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h3><p>01背包之所以叫01背包，是因为对于每种物品只有1个，或选或不选；而完全背包唯一区别于01背包的一点就是，每一种可以选择的物品都是无限的。</p>
<p>采用与01背包相同的dp数组定义，可以想到以下递推式</p>
<p>即考虑前i种物品时对于第i种物品，考虑选择其数量为0到正无穷的情况，对此进行枚举</p>
<p>$dp[i][j] &#x3D; max^∞_{k&#x3D;0}(dp[i - 1][j - k<em>w[i]]+ k</em>v[i])$</p>
<p>当然对于每一次枚举，我们有终止条件</p>
<p>$j&#x2F;k &gt; w[i]$</p>
<p>但是这样的算法复杂度是$n^3$，通常会TLE</p>
<p>可以考虑优化</p>
<p>$dp[i][j] &#x3D; max(dp[i-1][j],dp[i][j-w[i]]+v[i])$</p>
<p>这里涉及两个情况</p>
<ol>
<li>不拿第i种物品的时候$dp[i][j] &#x3D; dp[i-1][j]$显然成立</li>
<li>拿第i种物品的时候，拿1件物品i时的值，已经由$dp[i][j-2*w[i]]$更新过了，依次类推，拿任意件物品i（至于边界情况，拿尽可能多）对应的情况都被考虑在其中了。而$dp[i][j-w[i]]$的更新一定在$dp[i][j]$之前（直接考虑顺序递推），所以可行。</li>
</ol>
<p>上面的第二点，从朴素一点的角度，可以从你定义好数组的含义之后，填表更新的过程来理解，填$dp[i][j-w[i]]$的时候，根据状态转移方程的情况2，就需要考虑$dp[i][j-2*w[i]]$，而后者一定是比前者先填好的。</p>
<h4 id="例题与代码实现"><a href="#例题与代码实现" class="headerlink" title="例题与代码实现"></a>例题与代码实现</h4><p>第37次CCF CSP认证 Task2 机器人饲养指南</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line">ll n,m;</span><br><span class="line">ll v[<span class="number">101</span>];</span><br><span class="line">ll w[<span class="number">101</span>];</span><br><span class="line">ll dp[<span class="number">101</span>][<span class="number">100001</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i++)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="built_in">cin</span>&gt;&gt;v[i];</span><br><span class="line">  w[i] = i;</span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i++)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= n;j++)</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="keyword">if</span>(j &gt;= w[i])dp[i][j] = max(dp[i<span class="number">-1</span>][j],dp[i][j-w[i]]+v[i]);<span class="comment">//记住转移方程，其它按部就班即可</span></span><br><span class="line">   <span class="keyword">else</span> dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="built_in">cout</span>&lt;&lt;dp[m][n];</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这道题就是一个完全背包的模板，理解题意还原到完全背包，苹果的数量就是容量，投喂的数量就是物品的重量，投喂数量对应的受益就是物品的价值。</p>

        


        <span>
          <a class="article-read" href="/2025/08/29/动态规划基础/"> Read more -->
          </span>
        </div>

        
      </div>
      


      <div id="recent-posts-paginator">
        <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"> </a>
      </div>

    </div>

<aside id="sidebar">
  
  <div class="widget-box">
  	  <div class="widget-box">
    <h3 class="widget-title-friends">friends</h3>
    <div class="widget">
      
    </div>
  </div>

  </div>
  
  <div class="widget-box">
  	

  </div>
  
  <div class="widget-box">
  	
  <div class="widget-box">
    <h3 class="widget-title-tag">tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/" rel="tag">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/unity/" rel="tag">unity</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" rel="tag">分布式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%A7%E5%AD%A6/" rel="tag">大学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" rel="tag">数据结构与算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%99%BA%E8%83%BD%E7%AE%97%E6%B3%95/" rel="tag">智能算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88MTL%EF%BC%89/" rel="tag">机器学习（MTL）</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%83%E5%AD%A6%E4%B9%A0%EF%BC%89/" rel="tag">机器学习（元学习）</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%89/" rel="tag">机器学习（强化学习）</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0%EF%BC%89/" rel="tag">机器学习（联邦学习）</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E8%81%9A%E7%B1%BB%EF%BC%89/" rel="tag">机器学习（聚类）</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" rel="tag">计算机基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%97%E6%AD%8C/" rel="tag">诗歌</a></li></ul>
    </div>
  </div>


  </div>
  
  <div class="widget-box">
  	
  <div class="widget-box">
    <h3 class="widget-title-archive">archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/10/">October 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/09/">September 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/08/">August 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/07/">July 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/05/">May 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/04/">April 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/02/">February 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/10/">October 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li></ul>
    </div>
  </div>

  </div>
  
  <div class="widget-box">
  	
  <div class="widget-box">
    <h3 class="widget-title-post">recent_posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a class="recent_posts-list-link" href="/2025/10/24/Npuzzle/">Npuzzle</a>
          </li>
        
          <li>
            <a class="recent_posts-list-link" href="/2025/10/23/OS/">OS</a>
          </li>
        
          <li>
            <a class="recent_posts-list-link" href="/2025/09/30/DBS/">DBS</a>
          </li>
        
          <li>
            <a class="recent_posts-list-link" href="/2025/09/04/csp%E4%B9%A0%E9%A2%98%E9%9B%86/">csp习题集</a>
          </li>
        
          <li>
            <a class="recent_posts-list-link" href="/2025/09/01/DFS-DP%E5%88%B7%E9%A2%98%E7%BB%83%E4%B9%A0/">DFS&amp;DP刷题练习</a>
          </li>
        
      </ul>
    </div>
  </div>

  </div>
  
</aside>

<!-- <div id="paginator"> -->
<!--   <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"> </a> -->
<!-- </div> -->

    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
          tex2jax: {
            inlineMath: [ ['$','$'], ["\\(","\\)"] ],
            processEscapes: true
          }
        });
      </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
            tex2jax: {
              skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
            }
          });
      </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
              var all = MathJax.Hub.getAllJax(), i;
              for(i=0; i < all.length; i += 1) {
                  all[i].SourceElement().parentNode.className += ' has-jax';
              }
          });
    </script>

    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>



			</div>
		</div>

		<div id="bottom-outer">
			<div id="bottom-inner">
				Site by 阳生 | 
				Powered by <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a> |
				theme <a target="_blank" rel="noopener" href="https://github.com/fireworks99/hexo-theme-PreciousJoy">PreciousJoy</a>
			</div>
		</div>

		
	</div>





	
	<!-- scripts list from theme config.yml -->
	
	<script src="/js/jquery-3.5.1.min.js"></script>
	
	<script src="/js/PreciousJoy.js"></script>
	
	<script src="/js/highlight.pack.js"></script>
	
	<script src="/js/jquery.fancybox.min.js"></script>
	
	<script src="/js/search.js"></script>
	
	<script src="/js/load.js"></script>
	
	<script src="/js/jquery.mCustomScrollbar.concat.min.js"></script>
	
	<script src="/js/clipboard.min.js"></script>
	
	

	<script>hljs.initHighlightingOnLoad();</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>
