


<!DOCTYPE html>
<html lang="ch">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
	<title> [ 代码和诗 ]</title>
	
	
	<!-- stylesheets list from _config.yml -->
	
	<link rel="stylesheet" href="/css/PreciousJoy.css">
	
	<link rel="stylesheet" href="/css/top-bar.css">
	
	<link rel="stylesheet" href="/css/menu-outer.css">
	
	<link rel="stylesheet" href="/css/content-outer.css">
	
	<link rel="stylesheet" href="/css/bottom-outer.css">
	
	<link rel="stylesheet" href="/css/atom-one-dark.css">
	
	<link rel="stylesheet" href="/css/recent-posts-item.css">
	
	<link rel="stylesheet" href="/css/article-sidebar-toc.css">
	
	<link rel="stylesheet" href="/css/jquery.fancybox.min.css">
	
	<link rel="stylesheet" href="/css/search.css">
	
	<link rel="stylesheet" href="/css/toc.css">
	
	<link rel="stylesheet" href="/css/sidebar.css">
	
	<link rel="stylesheet" href="/css/archive.css">
	
	<link rel="stylesheet" href="/css/jquery.mCustomScrollbar.min.css">
	
	<link rel="stylesheet" href="/css/Z-last-cover-others.css">
	
	
	
<meta name="generator" content="Hexo 7.3.0"></head>




<body id="wrapper">

	<div id="">
		
		<div id="top-bar">
			
			<div id="avatar-box">
				<img 
				class="avatar"
				src="/images/my-avatar.jpg" //网站头像
				alt="avatar">
			</div>

			<div id="top-bar-text">
				<div id="top-bar-title">
					阳生。
				</div>
				<div id="top-bar-slogan">
					风毛丛劲节，只上尽头竿。
				</div>
			</div>

		</div>

		<div id="menu-outer">
			<div id="menu-inner">
				
				
				<div class="menu-item">
					<a href="/">Home</a>
				</div>
				
				<div class="menu-item">
					<a href="/about">About</a>
				</div>
				
				<div class="menu-item">
					<a href="/archives">Archives</a>
				</div>
				

				<div class="menu-item menu-item-search">
					
  <span class="local-search local-search-google local-search-plugin">
      <input type="search" placeholder="站内搜索" id="local-search-input" class="local-search-input-cls" style="">
      <div id="local-search-result" class="local-search-result-cls"></div>
  </span>
	
				</div>

			</div>
		</div>

		<div id="content-outer">
			<div id="content-inner">

				

<div id="recent-posts-box">

  
  <div id="recent-posts">
    <!-- <h1>Recent Posts</h1> -->
    
    
    <div class="recent-post-item">

      <a href="/2025/05/01/Py-learning/" class="item-title">Py_learning</a>
      
      <time datetime="2025-05-01T04:55:26.000Z">
        2025-05-01
      </time>
      
      <!-- <div class="article-digest"> -->
        <!-- 由于我在学习机器学习算法的时候，希望通过Python来对相关的算法进行复现。而自己在此之前其实零零散散不成体系地接触过Python语言，也了解一些基本的东西，但是对于Python中一些语言“特性”方面的东西所知甚少，例如变量的作用域与生命周期，不同模块间的访问等等；此外我对Python风格的代码写法也并不熟悉，其实写什么感觉都是C的味道......于是写下这篇blog用来记录，进一步对相关内容的学习
模块化的Python程序内置变量__name____name__是python模块当中的一个内置变量，每个模块都有。如果你选择当前模块开始执行，那么当前模块内置的__name__会被置为__main__；如果一个模块是被令一个模块import进去的，那么这个模块的__name__会被置为__模块名__，但是不会引入后缀。
模块化通过__name__我们就可以将我整个项目文件模块化的组织起来。将一个模块作为程序的执行入口，并始终自我约束地从这个模块开始启动整个项目程序。这样做的关键在于使用如下代码：
12345def main:    somethingif __name__ == __ma -->
        <!-- </div> -->

        
        <p><code>由于我在学习机器学习算法的时候，希望通过Python来对相关的算法进行复现。而自己在此之前其实零零散散不成体系地接触过Python语言，也了解一些基本的东西，但是对于Python中一些语言“特性”方面的东西所知甚少，例如变量的作用域与生命周期，不同模块间的访问等等；此外我对Python风格的代码写法也并不熟悉，其实写什么感觉都是C的味道......于是写下这篇blog用来记录，进一步对相关内容的学习</code></p>
<h2 id="模块化的Python程序"><a href="#模块化的Python程序" class="headerlink" title="模块化的Python程序"></a>模块化的Python程序</h2><h3 id="内置变量-name"><a href="#内置变量-name" class="headerlink" title="内置变量__name__"></a>内置变量__name__</h3><p>__name__是python模块当中的一个内置变量，每个模块都有。如果你选择当前模块开始执行，那么当前模块内置的__name__会被置为__main__；如果一个模块是被令一个模块import进去的，那么这个模块的__name__会被置为__模块名__，但是不会引入后缀。</p>
<h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><p>通过__name__我们就可以将我整个项目文件模块化的组织起来。将一个模块作为程序的执行入口，并始终自我约束地从这个模块开始启动整个项目程序。这样做的关键在于使用如下代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>:</span><br><span class="line">    something</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == __main__:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p><strong>关键点即，不要使用判断__name__以外的任何顶层代码</strong></p>
<h3 id="一些特性"><a href="#一些特性" class="headerlink" title="一些特性"></a>一些特性</h3><p>Python是一种解释性语言，特点就是不需要编译，而是在运行时通过解释器逐行读取、分析和执行源代码。对应的特点之一就是交互式的编程环境（可以在命令行中输入代码，并立刻看到执行的结果）</p>
<p>我联想到与这种特点相对应的就是——“顶层代码”，即相关的语句不会被封装在任何函数和类当中，点击运行，便会至上而下地逐行开始执行。</p>
<p><strong>所以一个关键的特性就是，使用import导入模块化后，该模块的顶层代码会立刻执行。</strong></p>
<p>启示：编写规范化的工程代码时，除了判断程序执行入口，不要使用顶层代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#k_means.py</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;this is k_means&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#main.py</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;this is mainn&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ == main:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<p><code>this is k_means this is main</code></p>
<h2 id="变量的作用域和生命周期"><a href="#变量的作用域和生命周期" class="headerlink" title="变量的作用域和生命周期"></a>变量的作用域和生命周期</h2><h3 id="单一模块"><a href="#单一模块" class="headerlink" title="单一模块"></a>单一模块</h3><ol>
<li><p>全局变量<br>在同一模块当中，定义于模块层的变量（顶层代码部分），对应的是<code>global varible</code>全局变量，这些变量的作用域是全局可见，生命周期是从程序开始执行开始，执行完毕结束。</p>
</li>
<li><p>局部变量<br>定义于函数中的变量是<code>local varible</code>局部变量，作用域局部可见。对于嵌套函数，外层变量对内层可见，内层对外层不可见。在Python中这种函数嵌套更加的显然。下面是一个例子：</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">outer_function</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;this is outer&quot;</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner_function</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;this is inner&quot;</span>)</span><br><span class="line">    inner_function()</span><br></pre></td></tr></table></figure>

<p>对应变量的生命周期，都是从定义自己的函数开始，到函数执行完毕结束。</p>
<p><strong>另外值得一提的是，在上面这个例子当中，inner_function不能从顶层代码调用。</strong><br>3. 内置变量<br><code>Built-in varible</code>内置变量的作用域是在任何地方都可以访问，且生命周期贯穿整个程序的运行期，最开始提到的__name__就是一个很好的例子。<br>4. 访问规则<br>python对于变量遵循<code>LEGB</code>的访问规则，即局部、嵌套、全局、内置。当发现了变量，即刻使用。</p>
<p>最后简单补充以下Python的变量定义规则，变量在“第一次赋值”时被定义。当然这意味着我们要定义一个变量必须考虑一个初始值，如果暂时没有初始值的话可以使用<code>None</code>作为初始值。随后根据需要赋予想要的初始值即可。当然，变量的类型也是根据你赋予的值来确定的。</p>
<h3 id="多模块"><a href="#多模块" class="headerlink" title="多模块"></a>多模块</h3><p>为了理解多模块情况下相关变量的作用域和生命周期，引入以下概念：</p>
<ol>
<li><p>模块对象，在导入模块的时候Python会为模块创建一个对象，这个对象的生命周期由其作用域确定</p>
</li>
<li><p>全局导入，模块对象在全局作用域中导入，此时模块变量生命周期同程序一样。作用域同全局变量。</p>
</li>
<li><p>局部导入，模块对象在局部作用域中导入，此时模块变量生命周期同导入了它的函数。作用域同相应的局部变量。</p>
</li>
<li><p>模块中的顶层代码在被导入时会立刻执行，相应的对应的全局变量会即刻创建，所以对应的全局变量生命周期、作用域，同模块对象。</p>
</li>
</ol>
<p><del>口语化的来说，模块被导入的时候也相当于一个变量（或者是一个类），如果是被主函数所在的模块作为全局变量导入，那么被导入模块的生命周期、作用域同全局变量，如果被作为局部变量导入，也同局部变量。相应的，被导入的时候，被导入模块中的“全局变量”也会即刻被创建，其生命周期同被导入的模块。</del>（毫不精准的表述…）</p>
<h2 id="名称冲突"><a href="#名称冲突" class="headerlink" title="名称冲突"></a>名称冲突</h2><p>在使用以下代码的时候，名称冲突时常发生。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> somemodule <span class="keyword">import</span> somename</span><br></pre></td></tr></table></figure>

<p>这类似是跳过了模块对象，直接导入了其中某个全局变量，自然就很可能与当前模块已有的全局变量、函数发生名称冲突。</p>
<p>常用的解决方法，也是我们使用模块化的常用方法如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> somemodule</span><br><span class="line">somemodule.somename <span class="comment">#使用模块对象名来访问相应的变量、函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> somemodule <span class="keyword">import</span> somename <span class="keyword">as</span> another_name <span class="comment">#或者是别名</span></span><br></pre></td></tr></table></figure>

        


        <span>
          <a class="article-read" href="/2025/05/01/Py-learning/"> Read more -->
          </span>
        </div>

        
    
    <div class="recent-post-item">

      <a href="/2025/04/30/Clustering-learning-route/" class="item-title">Clustering-learning-route</a>
      
      <time datetime="2025-04-30T13:35:10.000Z">
        2025-04-30
      </time>
      
      <!-- <div class="article-digest"> -->
        <!-- 我从现在开始学习聚类相关的内容，最终目标是希望发表一篇相关的论文。我以现在浅显的眼光给自己定下的学习路线如下1. 完成西瓜书聚类部分的学习，完成的标志是将书上给出的伪代码进行真实地复现2. 阅读综述论文，了解聚类对应的科研领域当前大概的情况3. 阅读聚类有关的顶会论文......我以现在的知识，无法继续制定下面的计划了，因为我并不了解3、往后的真正开始着手科研工作会是怎样的。我目前粗浅的想法是，或许我会了解到一些聚类的具体应用，然后为了完成一篇相关的论文：我也必须将聚类投入到具体的应用当中去，这个时候我不得不学习一些其它领域的知识（当然，目前我并不清楚那些会是什么）；又或许我会做一些对聚类算法进行改进的工作，但是这或许会更加艰难（因为曾经一位厉害的学长告诉我将A运用于B会比将A升级为A+简单许多）此外，我将这篇blog用作自己的学习日志与计划路线
阶段一2025.4.30

学习西瓜书上有关聚类的基础知识（概念、性能指标）
学习“k均值算法”、学习“学习向量量化算法”

 -->
        <!-- </div> -->

        
        <p><code>我从现在开始学习聚类相关的内容，最终目标是希望发表一篇相关的论文。我以现在浅显的眼光给自己定下的学习路线如下</code><br><code>1. 完成西瓜书聚类部分的学习，完成的标志是将书上给出的伪代码进行真实地复现</code><br><code>2. 阅读综述论文，了解聚类对应的科研领域当前大概的情况</code><br><code>3. 阅读聚类有关的顶会论文......</code><br><code>我以现在的知识，无法继续制定下面的计划了，因为我并不了解3、往后的真正开始着手科研工作会是怎样的。我目前粗浅的想法是，或许我会了解到一些聚类的具体应用，然后为了完成一篇相关的论文：我也必须将聚类投入到具体的应用当中去，这个时候我不得不学习一些其它领域的知识（当然，目前我并不清楚那些会是什么）；又或许我会做一些对聚类算法进行改进的工作，但是这或许会更加艰难（因为曾经一位厉害的学长告诉我将A运用于B会比将A升级为A+简单许多）</code><br><code>此外，我将这篇blog用作自己的学习日志与计划路线</code></p>
<h2 id="阶段一"><a href="#阶段一" class="headerlink" title="阶段一"></a>阶段一</h2><p>2025.4.30</p>
<ol>
<li>学习西瓜书上有关聚类的基础知识（概念、性能指标）</li>
<li>学习“k均值算法”、学习“学习向量量化算法”</li>
</ol>

        


        <span>
          <a class="article-read" href="/2025/04/30/Clustering-learning-route/"> Read more -->
          </span>
        </div>

        
    
    <div class="recent-post-item">

      <a href="/2025/04/30/Clustering-watermelon-book/" class="item-title">Clustering-watermelon-book</a>
      
      <time datetime="2025-04-30T11:58:19.000Z">
        2025-04-30
      </time>
      
      <!-- <div class="article-digest"> -->
        <!-- 聚类任务简介简单地说，就是要对一个n维向量元素的集合求一个划分，划分后的子集就是一类的（不相交的簇）。
对于数据集$D &#x3D; {x_1,x_2,…,x_m}$，划分为k个不相交的集合$C_1, C_2, …, C_k$，若$x_i \in C_j$，则$\lambda_i &#x3D; j$，对应$\lambda_i$就是$x_i$的标签。聚类任务要做的是就是求出一个聚类结果$\lambda &#x3D; (\lambda_1,\lambda_2,…,\lambda_m)$，其中$\lambda$为数据集的簇标记向量，第$i$个分量标记了$x_i$属于哪一个簇。
性能度量怎样的聚类是好的：

簇内的样本尽量相似
簇间的样本尽量不同

外部指标外部指标：将聚类结果和某个“参考模型”进行比较，称为外部指标
对于数据集$D &#x3D; {x_1,x_2,…,x_m}$，使用聚类模型A，得到簇标记向量$\lambda$，另外使用参考聚类模型B，得到簇标记向量$\lambda^{*}$。
于是我们可以根据$\lambda_i$与$\lambda_j$相同与否的关系以及$\lambda^ -->
        <!-- </div> -->

        
        <h2 id="聚类任务简介"><a href="#聚类任务简介" class="headerlink" title="聚类任务简介"></a>聚类任务简介</h2><p>简单地说，就是要对一个n维向量元素的集合求一个划分，划分后的子集就是一类的（不相交的簇）。</p>
<p>对于数据集$D &#x3D; {x_1,x_2,…,x_m}$，划分为k个不相交的集合$C_1, C_2, …, C_k$，若$x_i \in C_j$，则$\lambda_i &#x3D; j$，对应$\lambda_i$就是$x_i$的标签。聚类任务要做的是就是求出一个聚类结果$\lambda &#x3D; (\lambda_1,\lambda_2,…,\lambda_m)$，其中$\lambda$为数据集的簇标记向量，第$i$个分量标记了$x_i$属于哪一个簇。</p>
<h2 id="性能度量"><a href="#性能度量" class="headerlink" title="性能度量"></a>性能度量</h2><p>怎样的聚类是好的：</p>
<ol>
<li>簇内的样本尽量相似</li>
<li>簇间的样本尽量不同</li>
</ol>
<h3 id="外部指标"><a href="#外部指标" class="headerlink" title="外部指标"></a>外部指标</h3><p>外部指标：将聚类结果和某个“参考模型”进行比较，称为外部指标</p>
<p>对于数据集$D &#x3D; {x_1,x_2,…,x_m}$，使用聚类模型A，得到簇标记向量$\lambda$，另外使用参考聚类模型B，得到簇标记向量$\lambda^{*}$。</p>
<p>于是我们可以根据$\lambda_i$与$\lambda_j$相同与否的关系以及$\lambda^{<em>}_i$与$\lambda^{</em>}_j$是否相同的关系定义如下集合。</p>
<p>$DD,DS,SD,SS$一共四个集合，这些集合中的元素类似$(x_i,x_j)$，是一个“向量对”，分别按照如下规则界定类似的向量对是否属于相应的集合</p>
<ol>
<li>$x_i$与$x_j$在模型A、B的划分下都属于同一簇，则$(x_i,x_j) \in SS$</li>
<li>$x_i$与$x_j$在模型A、B的划分下都不属于同一簇，则$(x_i,x_j) \in DD$</li>
<li>$x_i$与$x_j$在模型A划分下属于同一簇，在B划分下不属于同一簇，则$(x_i,x_j) \in SD$</li>
<li>$x_i$与$x_j$在模型A划分下不属于同一簇，在B划分下属于同一簇，则$(x_i,x_j) \in DS$</li>
</ol>
<p><code>D即different，S即same 这样就非常容易理解了</code></p>
<p>根据上面的集合，我们可以定义如下过度变量</p>
<ol>
<li>$\lvert SS \rvert &#x3D; a$</li>
<li>$\lvert SD \rvert &#x3D; b$</li>
<li>$\lvert DS \rvert &#x3D; c$</li>
<li>$\lvert DD \rvert &#x3D; d$</li>
</ol>
<p>进一步，我们定义常用于性能度量的第一组系数</p>
<ol>
<li><strong>JC系数</strong> $JC &#x3D; \frac{a}{a+b+c}$</li>
<li><strong>FMI系数</strong> $FMI &#x3D; \sqrt{\frac{a}{a+b} \ast \frac{a}{a+c}}$</li>
<li><strong>Rand指数</strong> $RI &#x3D; \frac{2(a+b)}{m(m-1)}$</li>
</ol>
<p>这些性能指标的范围都是$[0,1]$，并且越大说明聚类效果越好<br><code>当然，前提是参考的模型是“正确”的</code></p>
<h3 id="距离计算"><a href="#距离计算" class="headerlink" title="距离计算"></a>距离计算</h3><h4 id="闵可夫斯基距离"><a href="#闵可夫斯基距离" class="headerlink" title="闵可夫斯基距离"></a>闵可夫斯基距离</h4><p>定义函数$dist(\cdot,\cdot)$，用于计算两个向量的距离。则它应该满足下述三个性质</p>
<ol>
<li>非负性</li>
<li>对称性</li>
<li>直递性</li>
</ol>
<p>常用的距离是闵可夫斯基距离</p>
<p>$dist_mk(x_i,x_j) &#x3D; (\sum_{\mu &#x3D; 1}^{n} \lvert x_i\mu - x_j\mu \rvert ^{p})^{\frac{1}{p}}$<br>显然当$p &#x3D; 2$时即我们常用的欧氏距离，$p &#x3D; 1$时为曼哈顿距离</p>
<h4 id="有序属性和无序属性"><a href="#有序属性和无序属性" class="headerlink" title="有序属性和无序属性"></a>有序属性和无序属性</h4><p>在考虑属性之间的距离的时候，序十分重要。这里通过简单的例子引入有序和无序。属性值出自于能够直接计算距离的属性称为有序属性，例如属性定义域为${1,2,3}$，而不能的就是无序属性，例如${货车,西瓜,乐乐}$。</p>
<p>显然，闵可夫斯基距离是用于衡量有序属性的距离的。</p>
<h4 id="VDM——衡量无序属性的距离"><a href="#VDM——衡量无序属性的距离" class="headerlink" title="VDM——衡量无序属性的距离"></a>VDM——衡量无序属性的距离</h4><p>假设有$k$个样本簇，$m_\mu,a$表示在属性$\mu$上取值为$a$的样本的个数，$m_\mu,a,i$表示在第i个样本簇中，属性$\mu$取值为$a$的样本个数。定义VDM如下。</p>
<p>$VDM &#x3D; \sum_{i&#x3D;1}^{k} \lvert \frac{m_\mu,a,i}{m_\mu,a} - \frac{m_\mu,b,i}{m_\mu,b}\rvert ^{p}$</p>
<p>值得注意的是，这里衡量的只是无序属性的距离，而要衡量两个无序样本$x_i$与$x_j$的距离，即其中的各个属性（类比向量的分量）都是无序属性，我们应该对各个属性的$VDM$求和。</p>
<h4 id="混合元素的距离"><a href="#混合元素的距离" class="headerlink" title="混合元素的距离"></a>混合元素的距离</h4><p>不失一般性，我们可以定义混合元素的距离如下：<br>$MinkovDM_p(x_i,x_j) &#x3D; (\sum_{\mu&#x3D;1}^{n_c} \lvert x_i\mu - x_j\mu \rvert ^{p} + \sum_{\mu&#x3D;n_c+1}^{n} VDM_p(x_i,\mu,x_j,\mu))^{\frac{1}{p}}$</p>
<p>其中$x_i,x_j$为混合属性的元素，$1到n_c$对应为有序属性，$n_c到n$对应为无序属性</p>
<h3 id="内部指标"><a href="#内部指标" class="headerlink" title="内部指标"></a>内部指标</h3><p>于是我们可以根据元素的不同（有序、无序、混合），选取我们需要的距离函数$dist(\cdot,\cdot)$，定义如下常用于刻画簇的性质的量</p>
<ol>
<li>$\mu &#x3D; \frac{1}{\lvert C \rvert} \sum_{1 \le i \le \lvert C \rvert} x_i$ 簇$C$的中心点</li>
<li>$avg(C) &#x3D; \frac{2}{\lvert C \rvert (\lvert C \rvert - 1)} \sum_{1 \le i &lt; j \le \lvert C \rvert} dist(x_i,x_j)$ 簇$C$内样本间的平均距离</li>
<li>$diam(C) &#x3D; max_{1 \le i &lt; j \le \lvert C \rvert} dist(x_i,x_j)$ 簇$C$内样本间的最远距离</li>
<li>$d_{min}(C_i,C_j) &#x3D; min_{x_i \in C_i,x_j \in C_j} dist(x_i,x_j)$ 簇$C_i$和簇$C_j$中最近样本的距离</li>
<li>$d_{cen}(C_i,C_j) &#x3D; dist(\mu_i,\mu_j)$ 簇$C_i$和簇$C_j$的中心点距离</li>
</ol>
<p>进一步我们定义一些内部指标如下。</p>
<ol>
<li>$DBI &#x3D; \frac{1}{k} \sum_{i&#x3D;1}^{k} max_{j \ne i}(\frac{avg(C_i)+avg(C_j)}{d_{cen}(\mu_i,\mu_j)})$</li>
<li>$DI &#x3D; min_{1 \le i \le k} { min_{j \ne i}(\frac{d_{min}(C_i,C_j)}{min_{1 \le l \le k} diam(C_i)}) }$</li>
</ol>
<p>DB指数越小越好，Dunn指数越大越好</p>

        


        <span>
          <a class="article-read" href="/2025/04/30/Clustering-watermelon-book/"> Read more -->
          </span>
        </div>

        
    
    <div class="recent-post-item">

      <a href="/2025/04/27/Traceroute/" class="item-title">Traceroute</a>
      
      <time datetime="2025-04-27T11:35:01.000Z">
        2025-04-27
      </time>
      
      <!-- <div class="article-digest"> -->
        <!-- 这篇blog用于记录我在学习计算机工程系统导论时，一个与网络有关的实验。
实验目的
学习Ping和Traceroute工具的使用，能够在网络开发和维护中熟练使用该工具获取网络状态和进行错误排查。
巩固课堂学习的因特网分层设计实现知识，理解因特网的分组转发网络的特性，通过分析互联网数据包因转发而产生的时延，加深理解尽力而为的因特网设计思想。
通过分析ICMP协议，学习在分层设计中进行跨层通信的设计实现方法，思考因特网网络层在错误处理上的折中设计和处理技巧。
通过Traceroute工具基于错误处理包进行路径探测功能的设计，体会在实践中体会设计方案在解决问题的同时是如何带来新的设计机会的。

实验过程与习题ping应用
用不超过200字简要概括ping命令ping命令用于向主机或网关发送请求，使用的是ICMP协议的ECHO_REQUSET数据包，并且会接收ICMP ECHO_RESPONSE作为回应。其中ECHO_REQUSET数据包包含了IP和ICMP头部，其后是一个timeval结构以及若干的填充字节。ping命令支持IPv6以及IPv4协议，其中对IPv6节点的信息查询是根据RFC4 -->
        <!-- </div> -->

        
        <p>这篇blog用于记录我在学习计算机工程系统导论时，一个与网络有关的实验。</p>
<h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><ol>
<li>学习Ping和Traceroute工具的使用，能够在网络开发和维护中熟练使用该工具获取网络状态和进行错误排查。</li>
<li>巩固课堂学习的因特网分层设计实现知识，理解因特网的分组转发网络的特性，通过分析互联网数据包因转发而产生的时延，加深理解尽力而为的因特网设计思想。</li>
<li>通过分析ICMP协议，学习在分层设计中进行跨层通信的设计实现方法，思考因特网网络层在错误处理上的折中设计和处理技巧。</li>
<li>通过Traceroute工具基于错误处理包进行路径探测功能的设计，体会在实践中体会设计方案在解决问题的同时是如何带来新的设计机会的。</li>
</ol>
<h2 id="实验过程与习题"><a href="#实验过程与习题" class="headerlink" title="实验过程与习题"></a>实验过程与习题</h2><h3 id="ping应用"><a href="#ping应用" class="headerlink" title="ping应用"></a>ping应用</h3><ol>
<li><p><strong>用不超过200字简要概括ping命令</strong><br>ping命令用于向主机或网关发送请求，使用的是ICMP协议的ECHO_REQUSET数据包，并且会接收ICMP ECHO_RESPONSE作为回应。其中ECHO_REQUSET数据包包含了IP和ICMP头部，其后是一个timeval结构以及若干的填充字节。ping命令支持IPv6以及IPv4协议，其中对IPv6节点的信息查询是根据RFC4620进行的，但是由于IPv6源路由被起用，中间跳点可能不被允许。<br><em><code>man ping</code>结果如图1所示</em></p>
</li>
<li><p><strong>说明实验现象背后的原因</strong><br>我使用ping命令，分别对<code>www.sud.edu.cn</code>和<code>www.ouc.edu.cn</code>进行了10次<code>ping</code>操作，每次都发送了56字节的数据包。从结果可以看出，到<code>www.sud.edu.cn</code>的网络连接是通畅的，每一次都成功受到了回复，没有丢包发生。但是延迟时间在10.9ms-170ms之间不等，这可能是由于网络拥塞或者其它网络干扰因素导致的。但是发送到<code>www.ouc.edu.cn</code>始终没有得到回复，可能是因为OUC的网络配置了防火墙或者其它网络安全策略，阻止了<code>ping</code>请求。<br><em>实验现象如图2所示</em></p>
</li>
<li><p><strong>通过查询资料，画出所使用ICMP数据包的结构</strong><br>其中相关部分说明如下<br>(1)Type，8bits，用于指定ICMP消息类型，例如0表示<code>Echo Reply</code>，8表示<code>Echo Requset</code><br>(2)Code，8bits，用于对消息类型进行更详细的说明，例如目的地不可达，网络不可达等等<br>(3)Checksum，16bits，用于错误检查<br>(4)Identifier，16bits，用来匹配请求和响应<br>(5)Data，可变长度，包含可选的附加数据。<br><em>ICMP数据包如图3所示</em></p>
</li>
</ol>
<h3 id="traceroute应用"><a href="#traceroute应用" class="headerlink" title="traceroute应用"></a>traceroute应用</h3><ol>
<li><p><strong>不超过200字简要概括traceroute命令</strong><br>traceroute可以用于追踪数据包从源主机到目标主机的网络路径中，它通过发送一个含有TTL字段的IP数据包进行工作，数据包每传递到一个路由器TTL就会减1，当TTL为0的时候路由器就会丢弃该数据包，并给源主机发送一个ICMP（超时响应），其中包含了当前路由器的地址。traceroute在整个工作流程中会从TTL为1开始发送数据包，每次收到ICMP响应后就增大TTL值（2、3、4…），直到收到目的主机的响应。于是根据每一次收到的ICMP响应，traceroute就可以知晓从源主机到目标主机经过的每个路由器，并且显示相应的IP地址和响应时间。<br><em><code>man traceroute</code>结果如图4所示</em></p>
</li>
<li><p><strong>确定并说明从源计算机到<code>www.baidu.com</code>的路径</strong><br>源计算机到<code>www.baidu.com</code>实现路径探测，结果如下图如下图，一共经过了30跳，其中第一跳<code>172.19.0.1</code>是源计算机ip，第三、四、五跳<code>10.149.32.1</code>和<code>10.70.7.2</code>以及<code>10.90.0.4</code>是内部网络路由器，之后经过了若干公网路由器，最终到达目标服务器。显示为<code>***</code>的，可能是由于网络设备被配置为了不响应ICMP请求，所以路径不能完全确定。<br><em><code>traceroute www.baidu.com</code>结果如图5所示</em></p>
</li>
<li><p><strong>说明输出结果每个字段的意义</strong><br>(1)<code>traceroute to www.baidu.com (182.61.200.108)</code>为traceroute命令输出说明，目标的IP地址为182.61.200.108<br>(2)<code>30 hops max</code>指最多经过30跳<br>(3)<code>60 byte packets</code>指每个数据包大小为60字节<br>往下是每一跳的详细信息，以第一跳为例<br>(4)<code>1 1(172.19.0.1) 0.647ms 1.041ms 1.285ms</code><br>第一个数字1代表第一跳，172.19.0.1代表第一跳的设备IP，后续三个时间是三个ICMP包的往返时间；后续存在<code>***</code>的输出对应没有收到该跳的ICMP回复（或者是网络拥塞导致的丢包）。</p>
</li>
</ol>
<h3 id="traceroute探索"><a href="#traceroute探索" class="headerlink" title="traceroute探索"></a>traceroute探索</h3><p><code>注：这部分实验，我先是在自己本地的电脑上进行的实验，所以后续的描述是根据本地的输出来的，实验截图也是使用的本地截图</code></p>
<ol>
<li><strong>解释traceroute 18.31.0.200的输出</strong><br>通过这条指令，我们使用traceroute追踪了一条从本地网络，通过ISP、NAT字段、跨越国际骨干网再进入教育和研究网络的传输路径，最终到达了目标IP（18.31.0.200）</li>
</ol>
<p>以下按照每一跳对路径进行分析<br>(1)（1-3跳）<br>hop1是本地网络，hop2、hop3是私有IP（10.x.x.x），可能对应内部网络路由器、防火墙等<br>(2)（4跳）<br>显示为<code>***</code>，路由器没有响应ICMP请求（或者是丢包）<br>(3)（5-12跳）<br>hop5-hop12对应的是公网地址，数据包是在ISP网络中传输的（211.64.x.x和101.4.x.x地址段对应ISP或骨干网提供商，100.64.x.x属于共享地址空间，通常用于ISP内部的网络地址转换）<br>(4)（13-30跳）<br>hop13对应<code>***</code>同样可能没有响应ICMP请求或丢包；hop14开始数据包进入国际网络，延迟有显著的增加（20ms左右，到后续数百毫秒）；hop19开始数据包进入了亚洲太平洋先进网络（APAN网络），之后进入了教育和研究网络（Internet2），可以看到最后已经显示出了较高的延迟（200~400ms左右）<br><em><code>traceroute 18.31.0.200的输出</code>结果如图6所示</em><br>2. <strong>说明从源地址到<code>www.baidu.com</code>和到<code>cn.bing.com</code>的网络路径差异</strong><br>两者的网络路径在初始几跳上有共同点（除去<code>***</code>，至少前10跳是相同的），在进入外部网络之后，路径显然会分道扬镳（除去<code>***</code>，从第14跳开始不相同）；到<code>cn.bing.com</code>后续经过了一些国际骨干网，（例如202.97.x.x的IP地址属于中国电信骨干网），而到<code>www.baidu.com</code>主要是在国内网络中传输的。<br><em><code>traceroute www.baidu.com</code>与<code>traceroute cn.bing.com</code>的结果如图7、8所示</em><br>3. <strong>如果IPv6上实现路径探测，应该使用包头的哪个字段</strong><br>在IPv6网络中进行路径探测，主要依赖IPv6包头中的Hop limit字段，这个字段是“跳限字段”，其作用和IPv4中的TTL（生存周期）字段相同，用来限制数据包在网络传输的跳数，每经过一个路由器，这个字段的值都会减1，当减为0后数据包就会被丢弃，并且通常会返回一个ICMPv6的超时消息给源地址。</p>
<h2 id="遇到的问题及解决方法"><a href="#遇到的问题及解决方法" class="headerlink" title="遇到的问题及解决方法"></a>遇到的问题及解决方法</h2><p>在实验过程中我主要遇到了问题是在<code>ping www.ouc.edu.cn</code>始终无法收到返回的结果，掉包率总是100%。经过查阅相关资料，我推测应该是我们学校的服务器配置了防火墙或者其它安全策略，拒绝向ping发送的数据包进行响应。并且我使用<code>traceroute www.ouc.edu.cn</code>尝试追踪，我发现结果从第7跳开始往后始终都只返回<code>***</code>，这间接作证了我的猜测。（因为它们都使用的ICMP数据包）<br><em>结果如图9所示</em></p>
<h2 id="课后实验与思考"><a href="#课后实验与思考" class="headerlink" title="课后实验与思考"></a>课后实验与思考</h2><h3 id="Traceroute在网络故障排查中有哪些应用场景"><a href="#Traceroute在网络故障排查中有哪些应用场景" class="headerlink" title="Traceroute在网络故障排查中有哪些应用场景"></a>Traceroute在网络故障排查中有哪些应用场景</h3><p>Traceroute的主要应用场景有路径发现（它可以用于追踪整个网络路径）、网络延迟分析（可以识别在哪一条引入了延迟，可以判断哪一条延迟较大）、故障点识别（确定数据包在哪一条丢失或无法到达，例如<code>***</code>的出现可能就是这个原因）、路由问题诊断（找到可能存在的路由环路）、网络性能评估（综合以上功能可以进行网络性能评估）等</p>
<h3 id="Traceroute中如何通过修改参数来优化网络诊断效果"><a href="#Traceroute中如何通过修改参数来优化网络诊断效果" class="headerlink" title="Traceroute中如何通过修改参数来优化网络诊断效果"></a>Traceroute中如何通过修改参数来优化网络诊断效果</h3><p>(1)修改初始TTL值<br><code>traceroute -f 5 example.com</code> 使用参数f可以完成这种操作，用来跳过已知的安全路径<br>(2)设置最大TTL值<br><code>traceorute -m 20 example.com</code> 使用参数m可以完成这种操作，用于避免弹错过长的路径<br>(3)修改探测包的数量<br><code>traceroute -q 5 example.com</code> 使用参数q可以完成这种操作，用来减少或增加探测粒度</p>
<p>其它的还有使用不同的协议、修改探测包的端口号等等</p>
<h3 id="Traceroute交换源节点和目标结点，在同一时刻探测到两条路径是相同的吗"><a href="#Traceroute交换源节点和目标结点，在同一时刻探测到两条路径是相同的吗" class="headerlink" title="Traceroute交换源节点和目标结点，在同一时刻探测到两条路径是相同的吗"></a>Traceroute交换源节点和目标结点，在同一时刻探测到两条路径是相同的吗</h3><p>由于网络路由的动态性、负载均衡、多路径路由等因素，网络路径一般是非堆成的，即A到B的路径和B返回A的路径可能会经过不同的路由器以及有不同的跳数。所以一般情况下上述两条路径不会相同</p>
<h2 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h2><p>通过本次实验我掌握了<code>ping</code>和<code>traceroute</code>命令的基础使用方法，例如<code>traceroute</code>的一些常见参数的使用（f、m、q、l等）。并且能够分析两条命令的输出信息，例如ping命令输出的掉包率、时延等等，通过这个过程，我更深刻地体会了网络的结构，以及数据包在网络上传递的整个过程。此外我还了解了两条命令的基本实现原理，例如traceroute就是不断通过增大ICMP数据包的TTL，使其能够传播得更远，并每一次都记录返回的响应，最终形成完整的路径，作为信息进行输出。最后，我掌握了ICMP数据包的结构，对数据包有了更加清晰的认识。</p>

        


        <span>
          <a class="article-read" href="/2025/04/27/Traceroute/"> Read more -->
          </span>
        </div>

        
    
    <div class="recent-post-item">

      <a href="/2025/02/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%A0%91/" class="item-title">数据结构与算法——树</a>
      
      <time datetime="2025-02-03T10:42:16.000Z">
        2025-02-03
      </time>
      
      <!-- <div class="article-digest"> -->
        <!-- 如何输入一棵树在这里记录一些算法题中常见的树的输入方法
*输入格式一第一行输入一个正整数n，代表树中结点的数量。第二行输入n个正整数w1…wn，代表i点的权重接下来n行，每行输入两个整数，其中第i行的li、ri表示i点的左儿子与右儿子，若为-1则表示不存在。
如何存储一颗树在这里记录常见的树的存储方法
*存储方式一我们可以使用一个树结点的结构体，通过将这些结构体使用指针连接起来，从而构建一棵完整的树。
struct tree_node&#123;
    int value;
    tree_node * ls;
    tree_node * rs;
&#125;

 -->
        <!-- </div> -->

        
        <h2 id="如何输入一棵树"><a href="#如何输入一棵树" class="headerlink" title="如何输入一棵树"></a>如何输入一棵树</h2><p>在这里记录一些算法题中常见的树的输入方法</p>
<p>*输入格式一<br>第一行输入一个正整数n，代表树中结点的数量。<br>第二行输入n个正整数w1…wn，代表i点的权重<br>接下来n行，每行输入两个整数，其中第i行的li、ri表示i点的左儿子与右儿子，若为-1则表示不存在。</p>
<h2 id="如何存储一颗树"><a href="#如何存储一颗树" class="headerlink" title="如何存储一颗树"></a>如何存储一颗树</h2><p>在这里记录常见的树的存储方法</p>
<p>*存储方式一<br>我们可以使用一个树结点的结构体，通过将这些结构体使用指针连接起来，从而构建一棵完整的树。</p>
<pre><code class="C++">struct tree_node&#123;
    int value;
    tree_node * ls;
    tree_node * rs;
&#125;
</code></pre>

        


        <span>
          <a class="article-read" href="/2025/02/03/数据结构与算法——树/"> Read more -->
          </span>
        </div>

        
    
    <div class="recent-post-item">

      <a href="/2025/02/03/unity%E9%94%9A%E7%82%B9/" class="item-title">unity锚点</a>
      
      <time datetime="2025-02-03T10:38:50.000Z">
        2025-02-03
      </time>
      
      <!-- <div class="article-digest"> -->
        <!-- 如下参考文章https://blog.csdn.net/Terie/article/details/111433486
透过这篇博客，我大概了解到了两个点：pviot：轴心，采用相对坐标系，(0,0)-&gt;(1,1)，位于某ui的方框内，其表征着在ui被自适应缩放的时候，以哪个位置为标准缩放
锚点：unity提供了三种模式1、四个锚点合在一起的模式该模式下，在屏幕分辨率改变的过程当中，ui相对于锚点的位置不改变，ui的宽、高也不变
2、四个锚点两两在一起的模式该模式下，ui的对应对于锚点连成的线的距离不改变，宽高比不改变，随之缩放
3、四个锚点分开的模式该模式下，ui的四个边对应锚点连线矩形的四边距离不改变，宽高随着四向距离的改变，自适应。
一般情况下，设置Canvas的UI为随屏幕缩放的模式，理解pivot，记住不同位置的ui常用的锚点模式和放置位置就好。
一下是gpt的建议：a. 确定元素的锚点对于屏幕边缘的UI元素（如按钮、面板），将其Anchors设置在父容器的相应边缘。例如：左上角的按钮：Anchors设为（0，1）到（0，1）右上角的按钮：Anchors设为（1，1）到 -->
        <!-- </div> -->

        
        <h2 id="如下"><a href="#如下" class="headerlink" title="如下"></a>如下</h2><p>参考文章<a target="_blank" rel="noopener" href="https://blog.csdn.net/Terie/article/details/111433486">https://blog.csdn.net/Terie/article/details/111433486</a></p>
<p>透过这篇博客，我大概了解到了两个点：<br>pviot：轴心，采用相对坐标系，(0,0)-&gt;(1,1)，位于某ui的方框内，其表征着在ui被自适应缩放的时候，以哪个位置为标准缩放</p>
<p>锚点：unity提供了三种模式<br>1、四个锚点合在一起的模式<br>该模式下，在屏幕分辨率改变的过程当中，ui相对于锚点的位置不改变，ui的宽、高也不变</p>
<p>2、四个锚点两两在一起的模式<br>该模式下，ui的对应对于锚点连成的线的距离不改变，宽高比不改变，随之缩放</p>
<p>3、四个锚点分开的模式<br>该模式下，ui的四个边对应锚点连线矩形的四边距离不改变，宽高随着四向距离的改变，自适应。</p>
<p>一般情况下，设置Canvas的UI为随屏幕缩放的模式，理解pivot，记住不同位置的ui常用的锚点模式和放置位置就好。</p>
<p>一下是gpt的建议：<br>a. 确定元素的锚点<br>对于屏幕边缘的UI元素（如按钮、面板），将其Anchors设置在父容器的相应边缘。例如：<br>左上角的按钮：Anchors设为（0，1）到（0，1）<br>右上角的按钮：Anchors设为（1，1）到（1，1）<br>底部中央的按钮：Anchors设为（0.5，0）到（0.5，0）<br>b. 中央对齐的元素<br>对于中心对齐的UI元素（如中心的面板），将其Anchors设置在父容器的中心。例如：<br>中央面板：Anchors设为（0.5，0.5）到（0.5，0.5）<br>c. 保持宽高比例<br>在Inspector中勾选Canvas Scaler组件的“UI Scale Mode”选项，设置为“Scale With Screen Size”，并设置参考分辨率为你设计时的分辨率（如1920x1080）。这样Unity会根据屏幕分辨率自动缩放UI元素。</p>

        


        <span>
          <a class="article-read" href="/2025/02/03/unity锚点/"> Read more -->
          </span>
        </div>

        
    
    <div class="recent-post-item">

      <a href="/2024/10/27/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%EF%BC%9A%E5%9F%BA%E4%BA%8E%E5%A4%8D%E6%9D%82%E6%B8%AF%E5%8F%A3%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E6%97%A0%E4%BA%BA%E8%88%B9%E8%87%AA%E4%B8%BB%E9%9D%A0%E6%B3%8A%E6%9C%80%E4%BC%98%E6%8E%A7%E5%88%B6%E6%96%B9%E6%A1%88%E7%A0%94%E7%A9%B6/" class="item-title">论文阅读：基于复杂港口环境下的无人船自主靠泊最优控制方案研究</a>
      
      <time datetime="2024-10-27T08:51:39.000Z">
        2024-10-27
      </time>
      
      <!-- <div class="article-digest"> -->
        <!-- 论文阅读过程当中新了解的知识1、无人船MMG模型：一种用于模拟和分析船舶在水中运动行为的数学模型。
MMG模型的基本思想是将船舶的运动分解为船体本身、推进系统（如螺旋桨）和舵等操纵装置的独立贡献，然后将这些贡献综合起来，以描述船舶的整体运动。
主要包括四个部分：船体动力学模型：描述船体在水中的基本运动特性，包括水动力、惯性力和阻力等。螺旋桨模型：描述推进装置（如螺旋桨）对船舶的推力和转矩输出，这些输出通常与螺旋桨的转速和船速等参数相关。舵模型：描述舵对船舶的横向力和转矩输出，这些输出通常与舵角和水流速度等参数有关。干扰力模型：包括环境中的风、浪、流等对船舶运动的影响。
2、横荡、纵荡和艏摇：横荡（Sway）：横荡指船舶沿着横向（即垂直于船体中心线）的运动。对于一艘在水中的船舶来说，横荡运动通常是侧向的滑动，可能由于外部作用力（如侧风、侧流或舵面调整）而发生。横荡是三自由度（3-DOF）船舶动力学模型中的一个重要运动分量。纵荡是指船舶沿着船体中心线方向的运动，即船舶的前进或后退运动。纵荡通常由船舶的推进装置（如螺旋桨）提供的推力驱动。纵荡运动决定了船舶的航速变化，在无人船中，通过调整纵荡 -->
        <!-- </div> -->

        
        <h2 id="论文阅读过程当中新了解的知识"><a href="#论文阅读过程当中新了解的知识" class="headerlink" title="论文阅读过程当中新了解的知识"></a>论文阅读过程当中新了解的知识</h2><p>1、无人船MMG模型：<br>一种用于模拟和分析船舶在水中运动行为的数学模型。</p>
<p>MMG模型的基本思想是将船舶的运动分解为船体本身、推进系统（如螺旋桨）和舵等操纵装置的独立贡献，然后将这些贡献综合起来，以描述船舶的整体运动。</p>
<p>主要包括四个部分：<br>船体动力学模型：描述船体在水中的基本运动特性，包括水动力、惯性力和阻力等。<br>螺旋桨模型：描述推进装置（如螺旋桨）对船舶的推力和转矩输出，这些输出通常与螺旋桨的转速和船速等参数相关。<br>舵模型：描述舵对船舶的横向力和转矩输出，这些输出通常与舵角和水流速度等参数有关。<br>干扰力模型：包括环境中的风、浪、流等对船舶运动的影响。</p>
<p>2、横荡、纵荡和艏摇：<br>横荡（Sway）：<br>横荡指船舶沿着横向（即垂直于船体中心线）的运动。对于一艘在水中的船舶来说，横荡运动通常是侧向的滑动，可能由于外部作用力（如侧风、侧流或舵面调整）而发生。横荡是三自由度（3-DOF）船舶动力学模型中的一个重要运动分量。<br>纵荡是指船舶沿着船体中心线方向的运动，即船舶的前进或后退运动。纵荡通常由船舶的推进装置（如螺旋桨）提供的推力驱动。纵荡运动决定了船舶的航速变化，在无人船中，通过调整纵荡速度可以实现对速度的控制和调整。<br>艏摇是指船舶围绕垂直轴的旋转运动，即船首（艏）左右摇摆的运动。艏摇角度的变化决定了船舶的航向。艏摇运动通常是由舵角调整或推进系统产生的转矩导致的，它是船舶操纵中控制航向的重要参数。无人船的自动导航系统会通过控制艏摇运动来实现精确的航向调整和路径跟踪。<br>3、航向角 艏摇角 舵角 漂流角 绝对风舷角和相对风舷角</p>
<p>4、无量纲化处理 运动参数和无量纲参数的对应关系<br>无量纲化处理的核心思想是通过适当选择基准量（如长度、时间、质量等），将物理量转换为无量纲量。这样做的目的是减少方程中的变量数量，揭示系统的内在规律，并使得不同尺度的系统可以进行比较和分析。</p>
<p>选择一组基准量，例如特征长度。无量纲变量的定义：将原始变量除以相应的基准量。</p>

        


        <span>
          <a class="article-read" href="/2024/10/27/论文阅读：基于复杂港口环境下的无人船自主靠泊最优控制方案研究/"> Read more -->
          </span>
        </div>

        
    
    <div class="recent-post-item">

      <a href="/2024/10/17/srdp/" class="item-title">srdp</a>
      
      <time datetime="2024-10-17T11:01:38.000Z">
        2024-10-17
      </time>
      
      <!-- <div class="article-digest"> -->
        <!-- 关于srdp
srpd在别校算是校级大创，国级与省级大创会在推免阶段很有优势
文章只有认可度较高的才会有影响因子，EI和会议期刊这些认可度不高，不过这些对本科生而言还是比较有难度，SCI中有影响因子
出国、企业就业一般看JCR

相关方向海洋技术；声学：声信号数据处理、算法光学：仿真、数据处理、算法遥感：遥感信息数据处理、算法
光科：光谱、光电结合（单片机）、光学设计等
电子信息：单片机、算法等
相关资料Web of Science、中国知网、ScienceDirect、小绿鲸、截屏翻译APP
刚入门的直接看SCI会比较困难，最好从硕博文章开始看，在看SCI之前最好先看三篇博士文章（600多页）
看英文文章可以用小绿鲸，不用应用软件，用官网主页。截屏翻译、小绿鲸是看SCI时用到的，前期看博士文章最好。
GPT可以用，但是写出来的东西一定要自己看得懂。
zlibrary中有很多参考书，很好用。多运用CSDN、GitHub
注意点国创、省创注意截至日期，中期的时候会有一个机会用来申请国创、省创，最好要把srdp升一个台阶，不要原原本本地交srdp。
理工科相关的公式要熟悉（明白如何推导的， -->
        <!-- </div> -->

        
        <h2 id="关于srdp"><a href="#关于srdp" class="headerlink" title="关于srdp"></a>关于srdp</h2><ol>
<li>srpd在别校算是校级大创，国级与省级大创会在推免阶段很有优势</li>
<li>文章只有认可度较高的才会有影响因子，EI和会议期刊这些认可度不高，不过这些对本科生而言还是比较有难度，SCI中有影响因子</li>
<li>出国、企业就业一般看JCR</li>
</ol>
<h2 id="相关方向"><a href="#相关方向" class="headerlink" title="相关方向"></a>相关方向</h2><p>海洋技术；<br>声学：声信号数据处理、算法<br>光学：仿真、数据处理、算法<br>遥感：遥感信息数据处理、算法</p>
<p>光科：<br>光谱、光电结合（单片机）、光学设计等</p>
<p>电子信息：<br>单片机、算法等</p>
<h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><p>Web of Science、中国知网、ScienceDirect、小绿鲸、截屏翻译APP</p>
<p>刚入门的直接看SCI会比较困难，最好从硕博文章开始看，在看SCI之前最好先看三篇博士文章（600多页）</p>
<p>看英文文章可以用小绿鲸，不用应用软件，用官网主页。截屏翻译、小绿鲸是看SCI时用到的，前期看博士文章最好。</p>
<p>GPT可以用，但是写出来的东西一定要自己看得懂。</p>
<p>zlibrary中有很多参考书，很好用。多运用CSDN、GitHub</p>
<h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><p>国创、省创注意截至日期，中期的时候会有一个机会用来申请国创、省创，最好要把srdp升一个台阶，不要原原本本地交srdp。</p>
<p>理工科相关的公式要熟悉（明白如何推导的，或者说如何产生的）</p>
<p>流程：<br>10、11月立项（撰写立项书、制作ppt、填写系统、准备立项答辩）-&gt;4、5月中期检查（省创国创立项）-&gt;10、11月结项（省创国创中期检查）-&gt;4、5月省创国创结项</p>
<p>如果目标国创、省创的话最好前期干完百分之60到百分之80，除此之外一定要干满工作量，否则会延期，得不偿失。</p>
<p>选题的话主要看指导老师。</p>
<p>制定开发计划（敏捷开发计划）、迭代开发（要先有一个成果，逐步迭代，迎接变化）、定期开会（要和老师同步）、共同开发</p>
<h2 id="相关语言"><a href="#相关语言" class="headerlink" title="相关语言"></a>相关语言</h2><p>Origin（画图好用）、Latex、MathType（打字母公式）、Office…</p>
<h2 id="选题"><a href="#选题" class="headerlink" title="选题"></a>选题</h2><p>小发明、小制作、小设计；实际教学中的综合性、设计性、创新性、应用性课题</p>

        


        <span>
          <a class="article-read" href="/2024/10/17/srdp/"> Read more -->
          </span>
        </div>

        
    
    <div class="recent-post-item">

      <a href="/2024/10/16/%E6%8C%89%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9/" class="item-title">按位运算相关内容</a>
      
      <time datetime="2024-10-16T11:56:10.000Z">
        2024-10-16
      </time>
      
      <!-- <div class="article-digest"> -->
        <!-- logs目前的打算是先更新思路，然后在有图片处空出，后续补充图片。
使用算数右移实现逻辑右移以int 32位为例
我们清楚，当进行算数右移的时候，对于符号位为1的情况下，右移之后符号位、第32位的1，被移动到31位后，32位右被补上了1
而逻辑右移与之不同的是，逻辑右移后，最高位、32位会被补0
现在要用算数右移实现逻辑右移，看代码：
x = x &gt;&gt; n;
y = ~((1 &lt;&lt; 31) &gt;&gt; n &lt;&lt; 1);  
x = x&amp;y;

1、x符号位为0，算数右移动n位后，x为 0..（n+1个0）XXXXXXX…2、x符号位为1，算数右移动n位后，x为 1..（n+1个1）XXXXXXX…而对于逻辑右移n位后，无论x符号位是0还是1，都是算数右移中1、的情况

所以我们只需要：x &#x3D; x&amp;0..（n+1个0）1111..1就可以将算数右移的结果转换为逻辑右移的结果。关键在于凑出掩码0..（n+1个0）1111..1，即y处的操作。

分治法求二进制数中1的个数分治法的思想：一个复杂的问题分解成若干个规模较小但相 -->
        <!-- </div> -->

        
        <h2 id="logs"><a href="#logs" class="headerlink" title="logs"></a>logs</h2><p>目前的打算是先更新思路，然后在有图片处空出，后续补充图片。</p>
<h2 id="使用算数右移实现逻辑右移"><a href="#使用算数右移实现逻辑右移" class="headerlink" title="使用算数右移实现逻辑右移"></a>使用算数右移实现逻辑右移</h2><p>以int 32位为例</p>
<p>我们清楚，当进行算数右移的时候，对于符号位为1的情况下，右移之后符号位、第32位的1，被移动到31位后，32位右被补上了1</p>
<p>而逻辑右移与之不同的是，逻辑右移后，最高位、32位会被补0</p>
<p>现在要用算数右移实现逻辑右移，看代码：</p>
<pre><code>x = x &gt;&gt; n;
y = ~((1 &lt;&lt; 31) &gt;&gt; n &lt;&lt; 1);  
x = x&amp;y;
</code></pre>
<p>1、x符号位为0，算数右移动n位后，x为 0..（n+1个0）XXXXXXX…<br>2、x符号位为1，算数右移动n位后，x为 1..（n+1个1）XXXXXXX…<br>而对于逻辑右移n位后，无论x符号位是0还是1，都是算数右移中1、的情况</p>
<blockquote>
<p>所以我们只需要：x &#x3D; x&amp;0..（n+1个0）1111..1就可以将算数右移的结果转换为逻辑右移的结果。<br>关键在于凑出掩码0..（n+1个0）1111..1，即y处的操作。</p>
</blockquote>
<h2 id="分治法求二进制数中1的个数"><a href="#分治法求二进制数中1的个数" class="headerlink" title="分治法求二进制数中1的个数"></a>分治法求二进制数中1的个数</h2><p>分治法的思想：一个复杂的问题分解成若干个规模较小但相似的子问题，“递归”地解决这些子问题，然后将这些子问题的解组合起来，得到原问题的解。</p>
<p>让我们先以8位二进制数为例子：</p>
<blockquote>
<p>原问题：11011110 整体这个数（或者说“一”部分）有几个1<br>分解：求 1101 1110 两部分，分别有几个1<br>分解：求 11 01 11 10 四部分，分别有几个1<br>分解：求 1 1 0 1 1 1 1 0 八部分，分别有几个1</p>
</blockquote>
<p>显然，对于上一个问题，各个部分的数字0 or 1就代表了这个部分有几个1，即八个部分时各个部分有几个1已经清楚。最小问题的答案已知，考虑如何利用将最小问题的答案合并，求解上层的问题。</p>
<p>注意：“各个部分的数字0 or 1就代表了这个部分有几个1”正是八部分时最大的特点，记住这个特点，因为我们的目标是“让‘一’部分时，该部分的数字就代表该部分有几个1。”</p>
<p>下面开始合并，使用到的关系是：上一个问题中各个部分有几个1 &#x3D; 当前问题中相邻两个部分1的个数相加</p>
<p>采用上面的关系对问题合并，我们会发现每解决一个问题后，问题中各个部分的数字，就代表原来该部分有几个1。</p>
<blockquote>
<p>合并： 四部分状况的问题的答案：10 01 10 01<br>合并： 二部分状况的问题的答案：0011 0011<br>合并： “一”部分（原问题）的答案：00000110</p>
</blockquote>
<p>根据前面的描述，00000110即原本1的个数。</p>
<p>下面是具体的实现代码</p>
<pre><code>cin&gt;&gt;x
int x1,x2,x3,x4,x5,s,m;
s = x &gt;&gt; 1;
m = ~((1 &lt;&lt; 31));
x1 = s&amp;m;
x = (x &amp; 0x55555555) + (x1 &amp; 0x55555555);
s = x &gt;&gt; 2;
m = ~((1 &lt;&lt; 31) &gt;&gt; 1);
x2 = s&amp;m;
x = (x &amp; 0x33333333) + (x2 &amp; 0x33333333);
s = x &gt;&gt; 4;
m = ~((1 &lt;&lt; 31) &gt;&gt; 3);
x3 = s&amp;m;
x = (x &amp; 0x0F0F0F0F) + (x3 &amp; 0x0F0F0F0F);
s = x &gt;&gt; 8;
m = ~((1 &lt;&lt; 31) &gt;&gt; 7);
x4 = s&amp;m;
x = (x &amp; 0x00FF00FF) + (x4 &amp; 0x00FF00FF);
s = x &gt;&gt; 16;
m = ~((1 &lt;&lt; 31) &gt;&gt; 15);
x5 = s&amp;m;
x = (x &amp; 0x0000FFFF) + (x5 &amp; 0x0000FFFF);
return x;
</code></pre>
<p>关键在于理解如何实现“上一个问题中各个部分有几个1 &#x3D; 当前问题中相邻两个部分1的个数相加”之中，相邻两部分相加。<br>不难想到，我们可以使用掩码。<br>例如：</p>
<blockquote>
<p>01010101和10101010（相邻的两位相加，结果为四部分状况答案）<br>x &#x3D; x&amp;0b01010101 + x&amp;0b10101010<br>00110011和11001100（相邻的四位相加，结果为两部分状况答案）<br>x &#x3D; x&amp;0b00110011 + x&amp;0b11001100<br>00001111和11110000（相邻的四位相加，结果为“一”部分状况、最终答案）<br>x &#x3D; x&amp;0b00001111 + x&amp;0b11110000</p>
</blockquote>
<p>当然这只是对最开始用例的解释，对于具体的计算机当中的int类型，32位可以如此类比。<br>最终我们需要合并使用当前问题的答案求解上一个问题5次（32 &#x3D; 2^5），对应代码中5处使用了掩码的位置。<br>值得一提的是，也可以在一次计算当中不更换掩码，但是要将x左或右移（逻辑右移！）对应的位数，就像我在代码中的那样。</p>
<h2 id="按位运算实现对数值变量实现逻辑Not"><a href="#按位运算实现对数值变量实现逻辑Not" class="headerlink" title="按位运算实现对数值变量实现逻辑Not"></a>按位运算实现对数值变量实现逻辑Not</h2><p>具体要求：对于数值型数据x，若x &#x3D;&#x3D; 0x00000000，则输出 0b00000000000000000000000000000001，否则输出0b00000000000000000000000000000000<br>注：上面的常数均为补码值，用于做相等的比较的时候也是用的x的补码值，而非真值。</p>
<p>思路：对于非0数，其相反数的符号位一定与原数的符号位不同。考虑原数与相反数相或后考虑符号位的情况，来判断x本身是否为0。</p>
<h2 id="7-fitsBits-判断x可否使用n位补码表示"><a href="#7-fitsBits-判断x可否使用n位补码表示" class="headerlink" title="7 fitsBits 判断x可否使用n位补码表示"></a>7 fitsBits 判断x可否使用n位补码表示</h2><p>思路：<br>1、我们知道n位补码的表示范围是-2^n~2^n-1，因此我们需要判断x是否在这个范围之内。<br>2、在当前环境下，x是由32位二进制补码储存在计算机当中的，我们不难发现：如果x只需要n位补码，那么在计算机当中前面的32-n位补码是空闲的，所以我们可以将x在计算机当中的补码，先左移32-n位，再右移动还原，通过判断这样操作之后得到的补码与x的补码是否仍然相同，来判断x是否只需要n位补码<br>3、最后加上一点补充，来更好地这个问题：<br>上面的思路对于正数来说是可以直接使用的，并且也是好理解的（因为闲置位置上的补码都是0，包括符号位也是0）</p>
<p>但是对于负数而言，最高位是1（符号位），我们或许会下意识认为，对于实际上的计算机而言，（从右往左，以下都是）第32位是没有闲置的，对于只需要n位补码的负数x，在32位的环境下，实际上被闲置的是第31位到第n位，而非和正数一样的第32位到第n+1位。进一步，我们会下意识认为，闲置的位置都是0，那么第31位是0，一旦左移符号位1就会被弃置，而再左移回来时在大多数情况下，符号位都只会是1，而认为由于32位环境最高位表示负数符号位的特殊性，导致了对于负数这样的“左移右移”无法解决问题。</p>
<p>显然，这样的理解是错误的，举个简单的反例，-1在32位中的补码是111…11（32个1），并非我们理解的闲置位置是0，所以其实对于一般的负数，我们会发现当它只需要n位补码表示的时候，在32位的环境下，其闲置的位置都是1，这样就不会出现我们认为的错误的情况，所以这个方法对于负数也是适用的。</p>
<pre><code>int l = 32 + ~n + 1; 
return !(x ^ (x &lt;&lt; l &gt;&gt; l));
</code></pre>
<h2 id="按位运算计算-x-2-n-，向0取整"><a href="#按位运算计算-x-2-n-，向0取整" class="headerlink" title="按位运算计算 x&#x2F;2^n ，向0取整"></a>按位运算计算 x&#x2F;2^n ，向0取整</h2><p>思路：<br>1、首先我们要思考为什么有取整的问题，答案很简单，从一种简化的形式来说，答案可以用“1除以2除不尽（整数范围）”来概括，于是我们要考虑，该如何处理一下，让这个算式有一个结果。处理的方法就是向下取整（1&#x2F;2 &#x3D; 0）或者向上取整(1&#x2F;2 &#x3D; 1)<br>2、为了后面描述方便，我们在此前先看看向上、下取整，在1、在二进制下的形式。<br>不妨考虑（默认二进制，十进制末尾用D表示）奇数：XXXXX11（末位为1），除以2D，即右移1。XXXXX011&#x2F;2D &#x3D; (XXXXX010&#x2F;2D)+1&#x2F;2D，这就回到了1、，且更具有一般性。<br>如果要向下取整即1&#x2F;2D &#x3D; 1，在这个过程当中实际上等效于将1，当作10使用，即对XXXXX011进行了加1操作后进行XXXXX110&gt;&gt;1 &#x3D; XXXXXX11，而不同于原来的XXXXX011&gt;&gt;1 &#x3D; XXXXXX01<br>如果要向上取整，也就是直接抛弃最低位1，仍由右移时将它弃置。<br>3、所以1、中的情况在二进制下实际上就是考虑，要不要让末尾的1在一次右移当中被抛弃，如果是的话则对应向下取整，直接右移即可，如果不是的话则应该加1，让1-&gt;10，从而在除以2D时达到1D当作2D用的效果<br>4、所以一般地，对于除以2^n，即要右移动n次，是否要将前n位可能的1直接抛弃，就对应了是否要向下取整，所以我们直接对原数在前n位分别加上1，确保它们都有“1D当2D用的效果”即可达到向上取整的目的。<br>5、题目要求向0取整，对于正数而言向0取整就是向下取整，对于负数而言是向上取整。所以对正数直接右移n位，对负数在第n位后加1，再右移动n位。</p>
<h2 id="按位操作求-x"><a href="#按位操作求-x" class="headerlink" title="按位操作求-x"></a>按位操作求-x</h2><p>思路：原数的负数对应的补码，等于原数的补码取反再加1。</p>
<h2 id="按位运算判断x是否是正数"><a href="#按位运算判断x是否是正数" class="headerlink" title="按位运算判断x是否是正数"></a>按位运算判断x是否是正数</h2><p>思路：<br>1、考虑x的相反数，正数的相反数的补码符号位一定是1，负数及0的相反数的补码一定是0。<br>2、但是注意有一个特殊的负数存在，及-2^(n-1) - 1 &#x3D; -2147483648(32位)，这个负数是在32位补码对应的表示范围之内没有对应的相反数，按照常规的求相反数的补码（按位取反再加1）之后，得到的仍然是它本身，符号位不会改变。<br>3、所以在我们求完x的相反数y之后，只需要在最后查看y的符号（1则x为正，0则x为负或0）时：(y&gt;&gt;31)&amp;1（用于查看符号），加上(y&amp;(y^x)&gt;&gt;31)&amp;1（似乎还有一点问题）即可。因为y^x，的相当于查看x与其相反数的符号位是否相同，如果相同y^x的符号位是0，否则是1，即对-2147483648进行了特判。</p>
<h2 id="按位运算判断x是否小于等于y"><a href="#按位运算判断x是否小于等于y" class="headerlink" title="按位运算判断x是否小于等于y"></a>按位运算判断x是否小于等于y</h2><p>思路：<br>1、这道题要分三种情况考虑，我最开始想到的是情况1，直接判断x-y（即x + ~y + 1）的符号位是什么，如果是0，则x &gt; y，如果是1，则x &lt; y。<br>2、显然，上面的做法存在问题，很容易发现，无法处理x &#x3D;&#x3D; y的情况，这种情况下，对应x-y的符号位是0，而不同于x &lt; y时题目种要求的1。<br>所以我考虑了第二种情况，x &#x3D;&#x3D; y时，只需要判断!(x^y)的状态，如果是0则，x、y不等，这时交给1、判断，如果是1则x、y相等，只需要将1、2、中两个式子用|连接，如果2、中得到1则会直接得出答案，如果2、中得出0，也不会影响1、中的判断结果（零一律）。<br>3、然而还有一种情况是我们没有考虑到的，那就是在x、y异号的时候，可能出现的overflow，比如-2147483648，让其减去任意的负数，在32位补码的情况下，它都会变成一个正数（符号位为0），而这种情况是只会在x、y异号的时候出现的（同号时，只要是减法，都只会向0靠近，而不会向边界靠近，出现overflow），所以我们只需要和2、中一样，在加上一种情况的式子，并用|与前两个式子连接即可。所加的式子，首先判断x、y是否异号，如果是的话，我们可以直接通过x的符号给出答案，因为负数一定小于正数，所以第三种情况对应的式子是：((x^y)&gt;&gt;31&amp;1&amp;(x&gt;&gt;31&amp;1))，其中(x^y)&gt;&gt;31&amp;1在第一位给出了x、y符号是否相异，如果是的话，为1，后者(x&gt;&gt;31&amp;1)会在第一位给出x的符号；否则为0，整个式子为0，当前的大小情况交给1、2、来判断。</p>

        


        <span>
          <a class="article-read" href="/2024/10/16/按位运算相关内容/"> Read more -->
          </span>
        </div>

        
    
    <div class="recent-post-item">

      <a href="/2024/10/15/my-first-post/" class="item-title">汇编语言学习日志</a>
      
      <time datetime="2024-10-15T15:16:55.000Z">
        2024-10-15
      </time>
      
      <!-- <div class="article-digest"> -->
        <!-- DEBUG模式下几种基本命令t 追踪执行命令a 指定内存后（回车）写入指令d 从哪段内存开始 显示多长的内存&#x2F;&#x2F;显示内存中内容e 从哪段内存开始（回车）修改内存u 从哪段内存开始&#x2F;&#x2F;显示翻译后内存中内容
mov ax,bx
add ax,bx
sub ax,bx


注意高八位、低八位，h、l注意数据溢出，加法溢出则舍去，减法不足则借位，指定了高八位、低八位就以对应的两个数字为参考标准确定是否要舍去与借位，不能修改其它数字。

常见的运算符mulmul bx

相乘的数都是八位或者都是十六位八位：一个默认放在AL中，另一个放在8位reg或内存中；结果默认放在AX中十六位：一个默认放在AX中，另一个放在16位reg或内存中；结果默认低16位放在AX中，高16位放在DX中。

8位：ALBL &#x3D; AX16位：AXBX &#x3D; DXAX

divdiv bx

除数：8位、16位（2个数字、4个数字）两种被除数：默认放在AX或DX和AX中，除数为8位则被除数为16位默认放在AX中；如果除数为16位，则被除数为32位，默认放在DX和AX中 -->
        <!-- </div> -->

        
        <h2 id="DEBUG模式下几种基本命令"><a href="#DEBUG模式下几种基本命令" class="headerlink" title="DEBUG模式下几种基本命令"></a>DEBUG模式下几种基本命令</h2><p>t 追踪执行命令<br>a 指定内存后（回车）写入指令<br>d 从哪段内存开始 显示多长的内存&#x2F;&#x2F;显示内存中内容<br>e 从哪段内存开始（回车）修改内存<br>u 从哪段内存开始&#x2F;&#x2F;显示翻译后内存中内容</p>
<pre><code>mov ax,bx
add ax,bx
sub ax,bx
</code></pre>
<blockquote>
<p>注意高八位、低八位，h、l<br>注意数据溢出，加法溢出则舍去，减法不足则借位，指定了高八位、低八位就以对应的两个数字为参考标准确定是否要舍去与借位，不能修改其它数字。</p>
</blockquote>
<h2 id="常见的运算符"><a href="#常见的运算符" class="headerlink" title="常见的运算符"></a>常见的运算符</h2><h3 id="mul"><a href="#mul" class="headerlink" title="mul"></a>mul</h3><pre><code>mul bx
</code></pre>
<p>相乘的数都是八位或者都是十六位<br>八位：一个默认放在AL中，另一个放在8位reg或内存中；结果默认放在AX中<br>十六位：一个默认放在AX中，另一个放在16位reg或内存中；结果默认低16位放在AX中，高16位放在DX中。</p>
<blockquote>
<p>8位：AL<em>BL &#x3D; AX<br>16位：AX</em>BX &#x3D; DXAX</p>
</blockquote>
<h3 id="div"><a href="#div" class="headerlink" title="div"></a>div</h3><pre><code>div bx
</code></pre>
<p>除数：8位、16位（2个数字、4个数字）两种<br>被除数：默认放在AX或DX和AX中，除数为8位则被除数为16位默认放在AX中；如果除数为16位，则被除数为32位，默认放在DX和AX中，DX存放高16位，AX存放低16位。<br>结果：如果除数为8位，则AL中存放结果，AH储存余数；如果除数为16位，则AX存储商，DX存储余数。</p>
<blockquote>
<p>除数8位:AX&#x2F;BL &#x3D; AL … AH<br>除数16位：DXAX&#x2F;BX &#x3D; AX … DX</p>
</blockquote>
<h3 id="and、or"><a href="#and、or" class="headerlink" title="and、or"></a>and、or</h3><p>以二进制为标准<br>指定8位还是16位进行运算</p>
<h3 id="shl"><a href="#shl" class="headerlink" title="shl"></a>shl</h3><pre><code>shl ax,1
</code></pre>
<p>shl、shr 左移、右移，超出的舍去，缺少的0补<br>rol、ror 循环左移、右移，超出的补到后面缺少的<br>带进位的循环左移、右移 rcl rcr（了解）<br>以二进制为标准</p>
<h3 id="inc、dec"><a href="#inc、dec" class="headerlink" title="inc、dec"></a>inc、dec</h3><pre><code>inc ax

dec ax
</code></pre>
<p>相当于ax++、ax–<br>（进位、借位与普通加减法相同）</p>
<h3 id="其它杂项"><a href="#其它杂项" class="headerlink" title="其它杂项"></a>其它杂项</h3><p>如果除法除以0会进入一个中断<br>使用int 0也可以进入这个中断<br>如果除以0是一个错误，会触发int 0的中断，会找到一个地址，代码运行的指针会指向这个地址，接下来或许可以通过在这个地址准备相应的处理方法来解决异常（了解）</p>
<p>我们需要知道的就是当代码发生错误，代码运行的指针会跳转到其它地址。</p>
<p>常见的中断编号int 0、int 9</p>
<h2 id="ds寄存器与地址"><a href="#ds寄存器与地址" class="headerlink" title="ds寄存器与地址"></a>ds寄存器与地址</h2><blockquote>
<p>物理地址 &#x3D; 段地址*16+偏移地址</p>
</blockquote>
<p>DS寄存器，数据段地址寄存器<br>    r ds<br>可编辑DS当中的内容</p>
<p>配合mov指令使用，如</p>
<pre><code>mov ax,[60]
</code></pre>
<p>效果会是将DS中的段地址结合[60]偏移地址指向的内容复制给ax<br>[]中对应的都是低位</p>
<blockquote>
<p>但是注意：在内存当中字单元的概念，即将一个字型数据（16位）的内存单元，由两个地址连续的内存单元，高地址内存单元（非起始）存放字符型高位字节，低地址内存单元（起始）存放字符型低位字节。<br>如我们将DS设置为21F0后，使用mov指令会将21F0:0060中的内容复制给ax<br>而d 21F0:0060这样显示：<br>12 34<br>则0060为低位，0061为高位<br>所以对应AXL 和 AXH，由此得到ax为3412<br>但是以上内容在使用al、ah等直接对八位操作的时候，对应的物理地址上的八位数会直接被移动到对应位置，而不需要考虑是高地址还是低地址内存</p>
</blockquote>
<p>另外</p>
<blockquote>
<p>注意：不能使用mov ds，10 00<br>但是可以<br>mov 1000，ax<br>mov ds，ax</p>
</blockquote>

        


        <span>
          <a class="article-read" href="/2024/10/15/my-first-post/"> Read more -->
          </span>
        </div>

        
      </div>
      


      <div id="recent-posts-paginator">
        <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"> </a>
      </div>

    </div>

<aside id="sidebar">
  
  <div class="widget-box">
  	  <div class="widget-box">
    <h3 class="widget-title-friends">friends</h3>
    <div class="widget">
      
    </div>
  </div>

  </div>
  
  <div class="widget-box">
  	

  </div>
  
  <div class="widget-box">
  	
  <div class="widget-box">
    <h3 class="widget-title-tag">tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/" rel="tag">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/unity/" rel="tag">unity</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%A7%E5%AD%A6/" rel="tag">大学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" rel="tag">数据结构与算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9D%82%E9%A1%B9/" rel="tag">杂项</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B1%87%E7%BC%96/" rel="tag">汇编</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C/" rel="tag">网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%81%9A%E7%B1%BB/" rel="tag">聚类</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0/" rel="tag">论文学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%97%E6%AD%8C/" rel="tag">诗歌</a></li></ul>
    </div>
  </div>


  </div>
  
  <div class="widget-box">
  	
  <div class="widget-box">
    <h3 class="widget-title-archive">archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/05/">May 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/04/">April 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/02/">February 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/10/">October 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li></ul>
    </div>
  </div>

  </div>
  
  <div class="widget-box">
  	
  <div class="widget-box">
    <h3 class="widget-title-post">recent_posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a class="recent_posts-list-link" href="/2025/05/01/Py-learning/">Py_learning</a>
          </li>
        
          <li>
            <a class="recent_posts-list-link" href="/2025/04/30/Clustering-learning-route/">Clustering-learning-route</a>
          </li>
        
          <li>
            <a class="recent_posts-list-link" href="/2025/04/30/Clustering-watermelon-book/">Clustering-watermelon-book</a>
          </li>
        
          <li>
            <a class="recent_posts-list-link" href="/2025/04/27/Traceroute/">Traceroute</a>
          </li>
        
          <li>
            <a class="recent_posts-list-link" href="/2025/02/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%A0%91/">数据结构与算法——树</a>
          </li>
        
      </ul>
    </div>
  </div>

  </div>
  
</aside>

<!-- <div id="paginator"> -->
<!--   <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"> </a> -->
<!-- </div> -->

    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
          tex2jax: {
            inlineMath: [ ['$','$'], ["\\(","\\)"] ],
            processEscapes: true
          }
        });
      </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
            tex2jax: {
              skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
            }
          });
      </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
              var all = MathJax.Hub.getAllJax(), i;
              for(i=0; i < all.length; i += 1) {
                  all[i].SourceElement().parentNode.className += ' has-jax';
              }
          });
    </script>

    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>



			</div>
		</div>

		<div id="bottom-outer">
			<div id="bottom-inner">
				Site by 阳生 | 
				Powered by <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a> |
				theme <a target="_blank" rel="noopener" href="https://github.com/fireworks99/hexo-theme-PreciousJoy">PreciousJoy</a>
			</div>
		</div>

		
	</div>





	
	<!-- scripts list from theme config.yml -->
	
	<script src="/js/jquery-3.5.1.min.js"></script>
	
	<script src="/js/PreciousJoy.js"></script>
	
	<script src="/js/highlight.pack.js"></script>
	
	<script src="/js/jquery.fancybox.min.js"></script>
	
	<script src="/js/search.js"></script>
	
	<script src="/js/load.js"></script>
	
	<script src="/js/jquery.mCustomScrollbar.concat.min.js"></script>
	
	<script src="/js/clipboard.min.js"></script>
	
	

	<script>hljs.initHighlightingOnLoad();</script>

</body>
</html>
